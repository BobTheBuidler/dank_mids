def patch_eth_utils():
    r0 :: dict
    r1, r2 :: object
    r3 :: bit
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: str
    r9 :: object
    r10 :: i32
    r11 :: bit
    r12 :: dict
    r13 :: str
    r14 :: object
    r15 :: dict
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: str
    r21 :: i32
    r22 :: bit
    r23 :: dict
    r24, r25 :: object
    r26 :: bit
    r27 :: str
    r28 :: object
    r29 :: str
    r30 :: dict
    r31 :: str
    r32 :: object
    r33 :: i32
    r34 :: bit
    r35 :: dict
    r36 :: str
    r37 :: object
    r38 :: dict
    r39 :: str
    r40 :: object
    r41 :: str
    r42 :: object
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: dict
    r47 :: str
    r48 :: object
    r49 :: dict
    r50 :: str
    r51 :: object
    r52 :: str
    r53 :: object
    r54 :: str
    r55 :: i32
    r56 :: bit
    r57 :: dict
    r58, r59 :: object
    r60 :: bit
    r61 :: str
    r62 :: object
    r63 :: str
    r64 :: dict
    r65 :: str
    r66 :: object
    r67 :: i32
    r68 :: bit
    r69 :: dict
    r70 :: str
    r71 :: object
    r72 :: dict
    r73 :: str
    r74 :: object
    r75 :: str
    r76 :: object
    r77 :: str
    r78 :: object
    r79 :: str
    r80 :: i32
    r81 :: bit
    r82 :: dict
    r83, r84 :: object
    r85 :: bit
    r86 :: str
    r87 :: object
    r88 :: str
    r89 :: dict
    r90 :: str
    r91 :: object
    r92 :: i32
    r93 :: bit
    r94 :: dict
    r95 :: str
    r96 :: object
    r97 :: dict
    r98 :: str
    r99 :: object
    r100 :: str
    r101 :: object
    r102 :: str
    r103 :: object
    r104 :: str
    r105 :: i32
    r106 :: bit
    r107 :: dict
    r108, r109 :: object
    r110 :: bit
    r111 :: str
    r112 :: object
    r113 :: str
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: i32
    r118 :: bit
    r119 :: dict
    r120 :: str
    r121 :: object
    r122 :: dict
    r123 :: str
    r124 :: object
    r125 :: str
    r126 :: object
    r127 :: str
    r128 :: object
    r129 :: str
    r130 :: i32
    r131 :: bit
    r132 :: dict
    r133 :: str
    r134 :: object
    r135 :: dict
    r136 :: str
    r137 :: object
    r138 :: str
    r139 :: object
    r140 :: str
    r141 :: object
    r142 :: str
    r143 :: i32
    r144 :: bit
    r145 :: dict
    r146, r147 :: object
    r148 :: bit
    r149 :: str
    r150 :: object
    r151 :: str
    r152 :: dict
    r153 :: str
    r154 :: object
    r155 :: i32
    r156 :: bit
    r157 :: dict
    r158 :: str
    r159 :: object
    r160 :: dict
    r161 :: str
    r162 :: object
    r163 :: str
    r164 :: object
    r165 :: str
    r166 :: object
    r167 :: str
    r168 :: i32
    r169 :: bit
    r170 :: dict
    r171 :: str
    r172 :: object
    r173 :: dict
    r174 :: str
    r175 :: object
    r176 :: str
    r177 :: object
    r178 :: str
    r179 :: object
    r180 :: str
    r181 :: i32
    r182 :: bit
    r183 :: dict
    r184, r185 :: object
    r186 :: bit
    r187 :: str
    r188 :: object
    r189 :: str
    r190 :: dict
    r191 :: str
    r192 :: object
    r193 :: i32
    r194 :: bit
    r195 :: dict
    r196 :: str
    r197 :: object
    r198 :: dict
    r199 :: str
    r200 :: object
    r201 :: str
    r202 :: object
    r203 :: str
    r204 :: object
    r205 :: str
    r206 :: i32
    r207 :: bit
    r208 :: dict
    r209 :: str
    r210 :: object
    r211 :: dict
    r212 :: str
    r213 :: object
    r214 :: str
    r215 :: object
    r216 :: str
    r217 :: object
    r218 :: str
    r219 :: i32
    r220 :: bit
    r221 :: dict
    r222, r223 :: object
    r224 :: bit
    r225 :: str
    r226 :: object
    r227 :: str
    r228 :: dict
    r229 :: str
    r230 :: object
    r231 :: i32
    r232 :: bit
    r233 :: tuple[object, object, object]
    r234 :: object
    r235 :: str
    r236 :: object
    r237, r238 :: bit
    r239 :: dict
    r240 :: str
    r241 :: object
    r242 :: dict
    r243 :: str
    r244 :: object
    r245 :: str
    r246 :: object
    r247 :: str
    r248 :: object
    r249 :: str
    r250 :: i32
    r251 :: bit
    r252 :: dict
    r253 :: str
    r254 :: object
    r255 :: dict
    r256 :: str
    r257 :: object
    r258 :: str
    r259 :: object
    r260 :: str
    r261 :: object
    r262 :: str
    r263 :: i32
    r264 :: bit
    r265 :: None
L0:
    r0 = dank_mids._eth_utils.globals :: static
    r1 = eth_utils.crypto :: module
    r2 = load_address _Py_NoneStruct
    r3 = r1 != r2
    if r3 goto L3 else goto L1 :: bool
L1:
    r4 = 'eth_utils.crypto'
    r5 = PyImport_Import(r4)
    if is_error(r5) goto L110 (error at patch_eth_utils:21) else goto L2
L2:
    eth_utils.crypto = r5 :: module
    dec_ref r5
L3:
    r6 = 'eth_utils'
    r7 = PyImport_GetModuleDict()
    r8 = 'eth_utils'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L110 (error at patch_eth_utils:21) else goto L4
L4:
    r10 = CPyDict_SetItem(r0, r6, r9)
    dec_ref r9
    r11 = r10 >= 0 :: signed
    if not r11 goto L110 (error at patch_eth_utils:21) else goto L5 :: bool
L5:
    r12 = dank_mids._eth_utils.globals :: static
    r13 = 'to_bytes'
    r14 = CPyDict_GetItem(r12, r13)
    if is_error(r14) goto L110 (error at patch_eth_utils:23) else goto L6
L6:
    r15 = dank_mids._eth_utils.globals :: static
    r16 = 'eth_utils'
    r17 = CPyDict_GetItem(r15, r16)
    if is_error(r17) goto L111 (error at patch_eth_utils:23) else goto L7
L7:
    r18 = 'crypto'
    r19 = CPyObject_GetAttr(r17, r18)
    dec_ref r17
    if is_error(r19) goto L111 (error at patch_eth_utils:23) else goto L8
L8:
    r20 = 'to_bytes'
    r21 = PyObject_SetAttr(r19, r20, r14)
    dec_ref r19
    dec_ref r14
    r22 = r21 >= 0 :: signed
    if not r22 goto L110 (error at patch_eth_utils:23) else goto L9 :: bool
L9:
    r23 = dank_mids._eth_utils.globals :: static
    r24 = web3.main :: module
    r25 = load_address _Py_NoneStruct
    r26 = r24 != r25
    if r26 goto L12 else goto L10 :: bool
L10:
    r27 = 'web3.main'
    r28 = PyImport_Import(r27)
    if is_error(r28) goto L110 (error at patch_eth_utils:25) else goto L11
L11:
    web3.main = r28 :: module
    dec_ref r28
L12:
    r29 = 'web3'
    r30 = PyImport_GetModuleDict()
    r31 = 'web3'
    r32 = CPyDict_GetItem(r30, r31)
    if is_error(r32) goto L110 (error at patch_eth_utils:25) else goto L13
L13:
    r33 = CPyDict_SetItem(r23, r29, r32)
    dec_ref r32
    r34 = r33 >= 0 :: signed
    if not r34 goto L110 (error at patch_eth_utils:25) else goto L14 :: bool
L14:
    r35 = dank_mids._eth_utils.globals :: static
    r36 = 'to_hex'
    r37 = CPyDict_GetItem(r35, r36)
    if is_error(r37) goto L110 (error at patch_eth_utils:27) else goto L15
L15:
    r38 = dank_mids._eth_utils.globals :: static
    r39 = 'web3'
    r40 = CPyDict_GetItem(r38, r39)
    if is_error(r40) goto L112 (error at patch_eth_utils:27) else goto L16
L16:
    r41 = 'main'
    r42 = CPyObject_GetAttr(r40, r41)
    dec_ref r40
    if is_error(r42) goto L112 (error at patch_eth_utils:27) else goto L17
L17:
    r43 = 'to_hex'
    r44 = PyObject_SetAttr(r42, r43, r37)
    dec_ref r42
    dec_ref r37
    r45 = r44 >= 0 :: signed
    if not r45 goto L110 (error at patch_eth_utils:27) else goto L18 :: bool
L18:
    r46 = dank_mids._eth_utils.globals :: static
    r47 = 'to_bytes'
    r48 = CPyDict_GetItem(r46, r47)
    if is_error(r48) goto L110 (error at patch_eth_utils:28) else goto L19
L19:
    r49 = dank_mids._eth_utils.globals :: static
    r50 = 'web3'
    r51 = CPyDict_GetItem(r49, r50)
    if is_error(r51) goto L113 (error at patch_eth_utils:28) else goto L20
L20:
    r52 = 'main'
    r53 = CPyObject_GetAttr(r51, r52)
    dec_ref r51
    if is_error(r53) goto L113 (error at patch_eth_utils:28) else goto L21
L21:
    r54 = 'to_bytes'
    r55 = PyObject_SetAttr(r53, r54, r48)
    dec_ref r53
    dec_ref r48
    r56 = r55 >= 0 :: signed
    if not r56 goto L110 (error at patch_eth_utils:28) else goto L22 :: bool
L22:
    r57 = dank_mids._eth_utils.globals :: static
    r58 = web3.middleware.filter :: module
    r59 = load_address _Py_NoneStruct
    r60 = r58 != r59
    if r60 goto L25 else goto L23 :: bool
L23:
    r61 = 'web3.middleware.filter'
    r62 = PyImport_Import(r61)
    if is_error(r62) goto L110 (error at patch_eth_utils:30) else goto L24
L24:
    web3.middleware.filter = r62 :: module
    dec_ref r62
L25:
    r63 = 'web3'
    r64 = PyImport_GetModuleDict()
    r65 = 'web3'
    r66 = CPyDict_GetItem(r64, r65)
    if is_error(r66) goto L110 (error at patch_eth_utils:30) else goto L26
L26:
    r67 = CPyDict_SetItem(r57, r63, r66)
    dec_ref r66
    r68 = r67 >= 0 :: signed
    if not r68 goto L110 (error at patch_eth_utils:30) else goto L27 :: bool
L27:
    r69 = dank_mids._eth_utils.globals :: static
    r70 = 'to_hex'
    r71 = CPyDict_GetItem(r69, r70)
    if is_error(r71) goto L110 (error at patch_eth_utils:32) else goto L28
L28:
    r72 = dank_mids._eth_utils.globals :: static
    r73 = 'web3'
    r74 = CPyDict_GetItem(r72, r73)
    if is_error(r74) goto L114 (error at patch_eth_utils:32) else goto L29
L29:
    r75 = 'middleware'
    r76 = CPyObject_GetAttr(r74, r75)
    dec_ref r74
    if is_error(r76) goto L114 (error at patch_eth_utils:32) else goto L30
L30:
    r77 = 'filter'
    r78 = CPyObject_GetAttr(r76, r77)
    dec_ref r76
    if is_error(r78) goto L114 (error at patch_eth_utils:32) else goto L31
L31:
    r79 = 'to_hex'
    r80 = PyObject_SetAttr(r78, r79, r71)
    dec_ref r78
    dec_ref r71
    r81 = r80 >= 0 :: signed
    if not r81 goto L110 (error at patch_eth_utils:32) else goto L32 :: bool
L32:
    r82 = dank_mids._eth_utils.globals :: static
    r83 = web3.providers.base :: module
    r84 = load_address _Py_NoneStruct
    r85 = r83 != r84
    if r85 goto L35 else goto L33 :: bool
L33:
    r86 = 'web3.providers.base'
    r87 = PyImport_Import(r86)
    if is_error(r87) goto L110 (error at patch_eth_utils:34) else goto L34
L34:
    web3.providers.base = r87 :: module
    dec_ref r87
L35:
    r88 = 'web3'
    r89 = PyImport_GetModuleDict()
    r90 = 'web3'
    r91 = CPyDict_GetItem(r89, r90)
    if is_error(r91) goto L110 (error at patch_eth_utils:34) else goto L36
L36:
    r92 = CPyDict_SetItem(r82, r88, r91)
    dec_ref r91
    r93 = r92 >= 0 :: signed
    if not r93 goto L110 (error at patch_eth_utils:34) else goto L37 :: bool
L37:
    r94 = dank_mids._eth_utils.globals :: static
    r95 = 'to_bytes'
    r96 = CPyDict_GetItem(r94, r95)
    if is_error(r96) goto L110 (error at patch_eth_utils:36) else goto L38
L38:
    r97 = dank_mids._eth_utils.globals :: static
    r98 = 'web3'
    r99 = CPyDict_GetItem(r97, r98)
    if is_error(r99) goto L115 (error at patch_eth_utils:36) else goto L39
L39:
    r100 = 'providers'
    r101 = CPyObject_GetAttr(r99, r100)
    dec_ref r99
    if is_error(r101) goto L115 (error at patch_eth_utils:36) else goto L40
L40:
    r102 = 'base'
    r103 = CPyObject_GetAttr(r101, r102)
    dec_ref r101
    if is_error(r103) goto L115 (error at patch_eth_utils:36) else goto L41
L41:
    r104 = 'to_bytes'
    r105 = PyObject_SetAttr(r103, r104, r96)
    dec_ref r103
    dec_ref r96
    r106 = r105 >= 0 :: signed
    if not r106 goto L110 (error at patch_eth_utils:36) else goto L42 :: bool
L42:
    r107 = dank_mids._eth_utils.globals :: static
    r108 = web3._utils.encoding :: module
    r109 = load_address _Py_NoneStruct
    r110 = r108 != r109
    if r110 goto L45 else goto L43 :: bool
L43:
    r111 = 'web3._utils.encoding'
    r112 = PyImport_Import(r111)
    if is_error(r112) goto L110 (error at patch_eth_utils:38) else goto L44
L44:
    web3._utils.encoding = r112 :: module
    dec_ref r112
L45:
    r113 = 'web3'
    r114 = PyImport_GetModuleDict()
    r115 = 'web3'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L110 (error at patch_eth_utils:38) else goto L46
L46:
    r117 = CPyDict_SetItem(r107, r113, r116)
    dec_ref r116
    r118 = r117 >= 0 :: signed
    if not r118 goto L110 (error at patch_eth_utils:38) else goto L47 :: bool
L47:
    r119 = dank_mids._eth_utils.globals :: static
    r120 = 'to_hex'
    r121 = CPyDict_GetItem(r119, r120)
    if is_error(r121) goto L110 (error at patch_eth_utils:40) else goto L48
L48:
    r122 = dank_mids._eth_utils.globals :: static
    r123 = 'web3'
    r124 = CPyDict_GetItem(r122, r123)
    if is_error(r124) goto L116 (error at patch_eth_utils:40) else goto L49
L49:
    r125 = '_utils'
    r126 = CPyObject_GetAttr(r124, r125)
    dec_ref r124
    if is_error(r126) goto L116 (error at patch_eth_utils:40) else goto L50
L50:
    r127 = 'encoding'
    r128 = CPyObject_GetAttr(r126, r127)
    dec_ref r126
    if is_error(r128) goto L116 (error at patch_eth_utils:40) else goto L51
L51:
    r129 = 'to_hex'
    r130 = PyObject_SetAttr(r128, r129, r121)
    dec_ref r128
    dec_ref r121
    r131 = r130 >= 0 :: signed
    if not r131 goto L110 (error at patch_eth_utils:40) else goto L52 :: bool
L52:
    r132 = dank_mids._eth_utils.globals :: static
    r133 = 'to_bytes'
    r134 = CPyDict_GetItem(r132, r133)
    if is_error(r134) goto L110 (error at patch_eth_utils:41) else goto L53
L53:
    r135 = dank_mids._eth_utils.globals :: static
    r136 = 'web3'
    r137 = CPyDict_GetItem(r135, r136)
    if is_error(r137) goto L117 (error at patch_eth_utils:41) else goto L54
L54:
    r138 = '_utils'
    r139 = CPyObject_GetAttr(r137, r138)
    dec_ref r137
    if is_error(r139) goto L117 (error at patch_eth_utils:41) else goto L55
L55:
    r140 = 'encoding'
    r141 = CPyObject_GetAttr(r139, r140)
    dec_ref r139
    if is_error(r141) goto L117 (error at patch_eth_utils:41) else goto L56
L56:
    r142 = 'to_bytes'
    r143 = PyObject_SetAttr(r141, r142, r134)
    dec_ref r141
    dec_ref r134
    r144 = r143 >= 0 :: signed
    if not r144 goto L110 (error at patch_eth_utils:41) else goto L57 :: bool
L57:
    r145 = dank_mids._eth_utils.globals :: static
    r146 = web3._utils.events :: module
    r147 = load_address _Py_NoneStruct
    r148 = r146 != r147
    if r148 goto L60 else goto L58 :: bool
L58:
    r149 = 'web3._utils.events'
    r150 = PyImport_Import(r149)
    if is_error(r150) goto L110 (error at patch_eth_utils:43) else goto L59
L59:
    web3._utils.events = r150 :: module
    dec_ref r150
L60:
    r151 = 'web3'
    r152 = PyImport_GetModuleDict()
    r153 = 'web3'
    r154 = CPyDict_GetItem(r152, r153)
    if is_error(r154) goto L110 (error at patch_eth_utils:43) else goto L61
L61:
    r155 = CPyDict_SetItem(r145, r151, r154)
    dec_ref r154
    r156 = r155 >= 0 :: signed
    if not r156 goto L110 (error at patch_eth_utils:43) else goto L62 :: bool
L62:
    r157 = dank_mids._eth_utils.globals :: static
    r158 = 'to_hex'
    r159 = CPyDict_GetItem(r157, r158)
    if is_error(r159) goto L110 (error at patch_eth_utils:45) else goto L63
L63:
    r160 = dank_mids._eth_utils.globals :: static
    r161 = 'web3'
    r162 = CPyDict_GetItem(r160, r161)
    if is_error(r162) goto L118 (error at patch_eth_utils:45) else goto L64
L64:
    r163 = '_utils'
    r164 = CPyObject_GetAttr(r162, r163)
    dec_ref r162
    if is_error(r164) goto L118 (error at patch_eth_utils:45) else goto L65
L65:
    r165 = 'events'
    r166 = CPyObject_GetAttr(r164, r165)
    dec_ref r164
    if is_error(r166) goto L118 (error at patch_eth_utils:45) else goto L66
L66:
    r167 = 'to_hex'
    r168 = PyObject_SetAttr(r166, r167, r159)
    dec_ref r166
    dec_ref r159
    r169 = r168 >= 0 :: signed
    if not r169 goto L110 (error at patch_eth_utils:45) else goto L67 :: bool
L67:
    r170 = dank_mids._eth_utils.globals :: static
    r171 = 'to_bytes'
    r172 = CPyDict_GetItem(r170, r171)
    if is_error(r172) goto L110 (error at patch_eth_utils:46) else goto L68
L68:
    r173 = dank_mids._eth_utils.globals :: static
    r174 = 'web3'
    r175 = CPyDict_GetItem(r173, r174)
    if is_error(r175) goto L119 (error at patch_eth_utils:46) else goto L69
L69:
    r176 = '_utils'
    r177 = CPyObject_GetAttr(r175, r176)
    dec_ref r175
    if is_error(r177) goto L119 (error at patch_eth_utils:46) else goto L70
L70:
    r178 = 'events'
    r179 = CPyObject_GetAttr(r177, r178)
    dec_ref r177
    if is_error(r179) goto L119 (error at patch_eth_utils:46) else goto L71
L71:
    r180 = 'to_bytes'
    r181 = PyObject_SetAttr(r179, r180, r172)
    dec_ref r179
    dec_ref r172
    r182 = r181 >= 0 :: signed
    if not r182 goto L110 (error at patch_eth_utils:46) else goto L72 :: bool
L72:
    r183 = dank_mids._eth_utils.globals :: static
    r184 = web3._utils.normalizers :: module
    r185 = load_address _Py_NoneStruct
    r186 = r184 != r185
    if r186 goto L75 else goto L73 :: bool
L73:
    r187 = 'web3._utils.normalizers'
    r188 = PyImport_Import(r187)
    if is_error(r188) goto L110 (error at patch_eth_utils:48) else goto L74
L74:
    web3._utils.normalizers = r188 :: module
    dec_ref r188
L75:
    r189 = 'web3'
    r190 = PyImport_GetModuleDict()
    r191 = 'web3'
    r192 = CPyDict_GetItem(r190, r191)
    if is_error(r192) goto L110 (error at patch_eth_utils:48) else goto L76
L76:
    r193 = CPyDict_SetItem(r183, r189, r192)
    dec_ref r192
    r194 = r193 >= 0 :: signed
    if not r194 goto L110 (error at patch_eth_utils:48) else goto L77 :: bool
L77:
    r195 = dank_mids._eth_utils.globals :: static
    r196 = 'to_hex'
    r197 = CPyDict_GetItem(r195, r196)
    if is_error(r197) goto L110 (error at patch_eth_utils:50) else goto L78
L78:
    r198 = dank_mids._eth_utils.globals :: static
    r199 = 'web3'
    r200 = CPyDict_GetItem(r198, r199)
    if is_error(r200) goto L120 (error at patch_eth_utils:50) else goto L79
L79:
    r201 = '_utils'
    r202 = CPyObject_GetAttr(r200, r201)
    dec_ref r200
    if is_error(r202) goto L120 (error at patch_eth_utils:50) else goto L80
L80:
    r203 = 'normalizers'
    r204 = CPyObject_GetAttr(r202, r203)
    dec_ref r202
    if is_error(r204) goto L120 (error at patch_eth_utils:50) else goto L81
L81:
    r205 = 'to_hex'
    r206 = PyObject_SetAttr(r204, r205, r197)
    dec_ref r204
    dec_ref r197
    r207 = r206 >= 0 :: signed
    if not r207 goto L110 (error at patch_eth_utils:50) else goto L82 :: bool
L82:
    r208 = dank_mids._eth_utils.globals :: static
    r209 = 'to_bytes'
    r210 = CPyDict_GetItem(r208, r209)
    if is_error(r210) goto L110 (error at patch_eth_utils:51) else goto L83
L83:
    r211 = dank_mids._eth_utils.globals :: static
    r212 = 'web3'
    r213 = CPyDict_GetItem(r211, r212)
    if is_error(r213) goto L121 (error at patch_eth_utils:51) else goto L84
L84:
    r214 = '_utils'
    r215 = CPyObject_GetAttr(r213, r214)
    dec_ref r213
    if is_error(r215) goto L121 (error at patch_eth_utils:51) else goto L85
L85:
    r216 = 'normalizers'
    r217 = CPyObject_GetAttr(r215, r216)
    dec_ref r215
    if is_error(r217) goto L121 (error at patch_eth_utils:51) else goto L86
L86:
    r218 = 'to_bytes'
    r219 = PyObject_SetAttr(r217, r218, r210)
    dec_ref r217
    dec_ref r210
    r220 = r219 >= 0 :: signed
    if not r220 goto L110 (error at patch_eth_utils:51) else goto L87 :: bool
L87:
    r221 = dank_mids._eth_utils.globals :: static
    r222 = web3._utils.type_conversion :: module
    r223 = load_address _Py_NoneStruct
    r224 = r222 != r223
    if r224 goto L90 else goto L88 :: bool
L88:
    r225 = 'web3._utils.type_conversion'
    r226 = PyImport_Import(r225)
    if is_error(r226) goto L92 (error at patch_eth_utils:55) else goto L89
L89:
    web3._utils.type_conversion = r226 :: module
    dec_ref r226
L90:
    r227 = 'web3'
    r228 = PyImport_GetModuleDict()
    r229 = 'web3'
    r230 = CPyDict_GetItem(r228, r229)
    if is_error(r230) goto L92 (error at patch_eth_utils:55) else goto L91
L91:
    r231 = CPyDict_SetItem(r221, r227, r230)
    dec_ref r230
    r232 = r231 >= 0 :: signed
    if not r232 goto L92 (error at patch_eth_utils:55) else goto L99 :: bool
L92:
    r233 = CPy_CatchError()
    r234 = builtins :: module
    r235 = 'ModuleNotFoundError'
    r236 = CPyObject_GetAttr(r234, r235)
    if is_error(r236) goto L97 (error at patch_eth_utils:56) else goto L93
L93:
    r237 = CPy_ExceptionMatches(r236)
    dec_ref r236
    if r237 goto L96 else goto L94 :: bool
L94:
    CPy_Reraise()
    if not 0 goto L97 else goto L122 :: bool
L95:
    unreachable
L96:
    CPy_RestoreExcInfo(r233)
    dec_ref r233
    goto L109
L97:
    CPy_RestoreExcInfo(r233)
    dec_ref r233
    r238 = CPy_KeepPropagating()
    if not r238 goto L110 else goto L98 :: bool
L98:
    unreachable
L99:
    r239 = dank_mids._eth_utils.globals :: static
    r240 = 'to_hex'
    r241 = CPyDict_GetItem(r239, r240)
    if is_error(r241) goto L110 (error at patch_eth_utils:59) else goto L100
L100:
    r242 = dank_mids._eth_utils.globals :: static
    r243 = 'web3'
    r244 = CPyDict_GetItem(r242, r243)
    if is_error(r244) goto L123 (error at patch_eth_utils:59) else goto L101
L101:
    r245 = '_utils'
    r246 = CPyObject_GetAttr(r244, r245)
    dec_ref r244
    if is_error(r246) goto L123 (error at patch_eth_utils:59) else goto L102
L102:
    r247 = 'type_conversion'
    r248 = CPyObject_GetAttr(r246, r247)
    dec_ref r246
    if is_error(r248) goto L123 (error at patch_eth_utils:59) else goto L103
L103:
    r249 = 'to_hex'
    r250 = PyObject_SetAttr(r248, r249, r241)
    dec_ref r248
    dec_ref r241
    r251 = r250 >= 0 :: signed
    if not r251 goto L110 (error at patch_eth_utils:59) else goto L104 :: bool
L104:
    r252 = dank_mids._eth_utils.globals :: static
    r253 = 'to_bytes'
    r254 = CPyDict_GetItem(r252, r253)
    if is_error(r254) goto L110 (error at patch_eth_utils:60) else goto L105
L105:
    r255 = dank_mids._eth_utils.globals :: static
    r256 = 'web3'
    r257 = CPyDict_GetItem(r255, r256)
    if is_error(r257) goto L124 (error at patch_eth_utils:60) else goto L106
L106:
    r258 = '_utils'
    r259 = CPyObject_GetAttr(r257, r258)
    dec_ref r257
    if is_error(r259) goto L124 (error at patch_eth_utils:60) else goto L107
L107:
    r260 = 'type_conversion'
    r261 = CPyObject_GetAttr(r259, r260)
    dec_ref r259
    if is_error(r261) goto L124 (error at patch_eth_utils:60) else goto L108
L108:
    r262 = 'to_bytes'
    r263 = PyObject_SetAttr(r261, r262, r254)
    dec_ref r261
    dec_ref r254
    r264 = r263 >= 0 :: signed
    if not r264 goto L110 (error at patch_eth_utils:60) else goto L109 :: bool
L109:
    return 1
L110:
    r265 = <error> :: None
    return r265
L111:
    dec_ref r14
    goto L110
L112:
    dec_ref r37
    goto L110
L113:
    dec_ref r48
    goto L110
L114:
    dec_ref r71
    goto L110
L115:
    dec_ref r96
    goto L110
L116:
    dec_ref r121
    goto L110
L117:
    dec_ref r134
    goto L110
L118:
    dec_ref r159
    goto L110
L119:
    dec_ref r172
    goto L110
L120:
    dec_ref r197
    goto L110
L121:
    dec_ref r210
    goto L110
L122:
    dec_ref r233
    goto L95
L123:
    dec_ref r241
    goto L110
L124:
    dec_ref r254
    goto L110

def to_hex(primitive, hexstr, text):
    primitive, hexstr :: union[object, None]
    text :: union[str, None]
    r0, r1, r2, r3 :: object
    r4 :: bit
    r5 :: object
    r6 :: str
    r7 :: object[1]
    r8 :: object_ptr
    r9, r10, r11 :: object
    r12 :: bit
    r13 :: str
    r14 :: bytes
    r15, r16 :: object
    r17 :: i32
    r18 :: bit
    r19, r20 :: bool
    r21, r22, r23 :: str
    r24, r25 :: object
    r26 :: str
    r27 :: object
    r28 :: tuple[object, object]
    r29 :: object
    r30 :: i32
    r31 :: bit
    r32 :: bool
    r33, r34 :: object
    r35 :: str
    r36 :: object
    r37 :: i32
    r38 :: bit
    r39 :: bool
    r40 :: object
    r41 :: object[1]
    r42 :: object_ptr
    r43 :: object
    r44 :: bytes
    r45, r46 :: object
    r47 :: i32
    r48 :: bit
    r49 :: bool
    r50 :: str
    r51 :: object
    r52 :: str
    r53 :: object
    r54 :: object[1]
    r55 :: object_ptr
    r56, r57 :: object
    r58 :: i32
    r59 :: bit
    r60 :: bool
    r61 :: int
    r62 :: object
    r63 :: str
    r64, r65 :: object
    r66 :: object[1]
    r67 :: object_ptr
    r68 :: object
    r69, r70 :: str
    r71, r72 :: object
    r73 :: str
    r74 :: object
    r75 :: object[1]
    r76 :: object_ptr
    r77 :: object
    r78, r79, r80 :: str
    r81 :: object
    r82 :: str
    r83 :: object
    r84 :: object[1]
    r85 :: object_ptr
    r86, r87 :: object
L0:
    if is_error(primitive) goto L1 else goto L57
L1:
    r0 = box(None, 1)
    inc_ref r0
    primitive = r0
L2:
    if is_error(hexstr) goto L3 else goto L58
L3:
    r1 = box(None, 1)
    inc_ref r1
    hexstr = r1
L4:
    if is_error(text) goto L5 else goto L59
L5:
    r2 = box(None, 1)
    inc_ref r2
    text = r2
L6:
    r3 = load_address _Py_NoneStruct
    r4 = hexstr != r3
    if r4 goto L60 else goto L61 :: bool
L7:
    r5 = hexstr
    r6 = 'lower'
    r7 = [r5]
    r8 = load_address r7
    r9 = PyObject_VectorcallMethod(r6, r8, 9223372036854775809, 0)
    if is_error(r9) goto L62 (error at to_hex:74) else goto L8
L8:
    dec_ref r5
L9:
    r10 = add_0x_prefix(r9)
    dec_ref r9
    if is_error(r10) goto L56 (error at to_hex:74) else goto L10
L10:
    return r10
L11:
    r11 = load_address _Py_NoneStruct
    r12 = text != r11
    if r12 goto L63 else goto L64 :: bool
L12:
    r13 = cast(str, text)
    if is_error(r13) goto L56 (error at to_hex:77) else goto L13
L13:
    r14 = PyUnicode_AsUTF8String(r13)
    dec_ref r13
    if is_error(r14) goto L56 (error at to_hex:77) else goto L14
L14:
    r15 = encode_hex(r14)
    dec_ref r14
    if is_error(r15) goto L56 (error at to_hex:77) else goto L15
L15:
    return r15
L16:
    r16 = load_address PyBool_Type
    r17 = PyObject_IsInstance(primitive, r16)
    r18 = r17 >= 0 :: signed
    if not r18 goto L65 (error at to_hex:79) else goto L17 :: bool
L17:
    r19 = truncate r17: i32 to builtins.bool
    if r19 goto L18 else goto L23 :: bool
L18:
    r20 = unbox(bool, primitive)
    dec_ref primitive
    if is_error(r20) goto L56 (error at to_hex:80) else goto L19
L19:
    if r20 goto L20 else goto L21 :: bool
L20:
    r21 = '0x1'
    inc_ref r21
    r22 = r21
    goto L22
L21:
    r23 = '0x0'
    inc_ref r23
    r22 = r23
L22:
    return r22
L23:
    r24 = load_address PyBytes_Type
    r25 = builtins :: module
    r26 = 'bytearray'
    r27 = CPyObject_GetAttr(r25, r26)
    if is_error(r27) goto L65 (error at to_hex:82) else goto L24
L24:
    inc_ref r24
    r28 = (r24, r27)
    r29 = box(tuple[object, object], r28)
    r30 = PyObject_IsInstance(primitive, r29)
    dec_ref r29
    r31 = r30 >= 0 :: signed
    if not r31 goto L65 (error at to_hex:82) else goto L25 :: bool
L25:
    r32 = truncate r30: i32 to builtins.bool
    if r32 goto L26 else goto L28 :: bool
L26:
    r33 = encode_hex(primitive)
    dec_ref primitive
    if is_error(r33) goto L56 (error at to_hex:83) else goto L27
L27:
    return r33
L28:
    r34 = builtins :: module
    r35 = 'memoryview'
    r36 = CPyObject_GetAttr(r34, r35)
    if is_error(r36) goto L65 (error at to_hex:85) else goto L29
L29:
    r37 = PyObject_IsInstance(primitive, r36)
    dec_ref r36
    r38 = r37 >= 0 :: signed
    if not r38 goto L65 (error at to_hex:85) else goto L30 :: bool
L30:
    r39 = truncate r37: i32 to builtins.bool
    if r39 goto L31 else goto L35 :: bool
L31:
    r40 = load_address PyBytes_Type
    r41 = [primitive]
    r42 = load_address r41
    r43 = _PyObject_Vectorcall(r40, r42, 1, 0)
    if is_error(r43) goto L65 (error at to_hex:86) else goto L32
L32:
    dec_ref primitive
    r44 = cast(bytes, r43)
    if is_error(r44) goto L56 (error at to_hex:86) else goto L33
L33:
    r45 = encode_hex(r44)
    dec_ref r44
    if is_error(r45) goto L56 (error at to_hex:86) else goto L34
L34:
    return r45
L35:
    r46 = load_address PyUnicode_Type
    r47 = PyObject_IsInstance(primitive, r46)
    r48 = r47 >= 0 :: signed
    if not r48 goto L65 (error at to_hex:88) else goto L36 :: bool
L36:
    r49 = truncate r47: i32 to builtins.bool
    if r49 goto L66 else goto L41 :: bool
L37:
    r50 = 'Unsupported type: The primitive argument must be one of: bytes,bytearray, int or bool and not str'
    r51 = builtins :: module
    r52 = 'TypeError'
    r53 = CPyObject_GetAttr(r51, r52)
    if is_error(r53) goto L56 (error at to_hex:89) else goto L38
L38:
    r54 = [r50]
    r55 = load_address r54
    r56 = _PyObject_Vectorcall(r53, r55, 1, 0)
    dec_ref r53
    if is_error(r56) goto L56 (error at to_hex:89) else goto L39
L39:
    CPy_Raise(r56)
    dec_ref r56
    if not 0 goto L56 (error at to_hex:89) else goto L40 :: bool
L40:
    unreachable
L41:
    r57 = load_address PyLong_Type
    r58 = PyObject_IsInstance(primitive, r57)
    r59 = r58 >= 0 :: signed
    if not r59 goto L65 (error at to_hex:94) else goto L42 :: bool
L42:
    r60 = truncate r58: i32 to builtins.bool
    if r60 goto L43 else goto L48 :: bool
L43:
    r61 = unbox(int, primitive)
    dec_ref primitive
    if is_error(r61) goto L56 (error at to_hex:95) else goto L44
L44:
    r62 = builtins :: module
    r63 = 'hex'
    r64 = CPyObject_GetAttr(r62, r63)
    if is_error(r64) goto L67 (error at to_hex:95) else goto L45
L45:
    r65 = box(int, r61)
    r66 = [r65]
    r67 = load_address r66
    r68 = _PyObject_Vectorcall(r64, r67, 1, 0)
    dec_ref r64
    if is_error(r68) goto L68 (error at to_hex:95) else goto L46
L46:
    dec_ref r65
    r69 = cast(str, r68)
    if is_error(r69) goto L56 (error at to_hex:95) else goto L47
L47:
    return r69
L48:
    r70 = "Unsupported type: '"
    r71 = PyObject_Type(primitive)
    dec_ref primitive
    r72 = builtins :: module
    r73 = 'repr'
    r74 = CPyObject_GetAttr(r72, r73)
    if is_error(r74) goto L69 (error at to_hex:98) else goto L49
L49:
    r75 = [r71]
    r76 = load_address r75
    r77 = _PyObject_Vectorcall(r74, r76, 1, 0)
    dec_ref r74
    if is_error(r77) goto L69 (error at to_hex:98) else goto L50
L50:
    dec_ref r71
    r78 = cast(str, r77)
    if is_error(r78) goto L56 (error at to_hex:98) else goto L51
L51:
    r79 = "'. Must be one of: bool, str, bytes, bytearray or int."
    r80 = CPyStr_Build(3, r70, r78, r79)
    dec_ref r78
    if is_error(r80) goto L56 (error at to_hex:98) else goto L52
L52:
    r81 = builtins :: module
    r82 = 'TypeError'
    r83 = CPyObject_GetAttr(r81, r82)
    if is_error(r83) goto L70 (error at to_hex:97) else goto L53
L53:
    r84 = [r80]
    r85 = load_address r84
    r86 = _PyObject_Vectorcall(r83, r85, 1, 0)
    dec_ref r83
    if is_error(r86) goto L70 (error at to_hex:97) else goto L54
L54:
    dec_ref r80
    CPy_Raise(r86)
    dec_ref r86
    if not 0 goto L56 (error at to_hex:97) else goto L55 :: bool
L55:
    unreachable
L56:
    r87 = <error> :: object
    return r87
L57:
    inc_ref primitive
    goto L2
L58:
    inc_ref hexstr
    goto L4
L59:
    inc_ref text
    goto L6
L60:
    dec_ref primitive
    dec_ref text
    goto L7
L61:
    dec_ref hexstr
    goto L11
L62:
    dec_ref r5
    goto L56
L63:
    dec_ref primitive
    goto L12
L64:
    dec_ref text
    goto L16
L65:
    dec_ref primitive
    goto L56
L66:
    dec_ref primitive
    goto L37
L67:
    dec_ref r61 :: int
    goto L56
L68:
    dec_ref r65
    goto L56
L69:
    dec_ref r71
    goto L56
L70:
    dec_ref r80
    goto L56

def to_bytes(primitive, hexstr, text):
    primitive, hexstr :: union[object, None]
    text :: union[str, None]
    r0, r1, r2, r3 :: object
    r4 :: i32
    r5 :: bit
    r6, r7 :: bool
    r8, r9, r10 :: bytes
    r11 :: object
    r12 :: str
    r13, r14 :: object
    r15 :: str
    r16 :: object
    r17 :: tuple[object, object]
    r18 :: object
    r19 :: i32
    r20 :: bit
    r21 :: bool
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: bytes
    r27 :: object
    r28 :: i32
    r29 :: bit
    r30 :: bool
    r31 :: bytes
    r32 :: object
    r33 :: i32
    r34 :: bit
    r35 :: bool
    r36 :: int
    r37 :: object
    r38 :: union[object, None]
    r39 :: union[str, None]
    r40 :: object
    r41 :: union[object, None]
    r42 :: union[str, None]
    r43 :: bytes
    r44 :: object
    r45 :: bit
    r46, r47 :: int
    r48 :: bit
    r49 :: str
    r50 :: object
    r51, r52 :: str
    r53 :: union[str, object]
    r54 :: str
    r55 :: bytes
    r56 :: object
    r57 :: bit
    r58 :: str
    r59 :: bytes
    r60 :: str
    r61 :: object
    r62 :: str
    r63 :: object
    r64 :: object[1]
    r65 :: object_ptr
    r66 :: object
    r67 :: bytes
L0:
    if is_error(primitive) goto L1 else goto L51
L1:
    r0 = box(None, 1)
    inc_ref r0
    primitive = r0
L2:
    if is_error(hexstr) goto L3 else goto L52
L3:
    r1 = box(None, 1)
    inc_ref r1
    hexstr = r1
L4:
    if is_error(text) goto L5 else goto L53
L5:
    r2 = box(None, 1)
    inc_ref r2
    text = r2
L6:
    r3 = load_address PyBool_Type
    r4 = PyObject_IsInstance(primitive, r3)
    r5 = r4 >= 0 :: signed
    if not r5 goto L54 (error at to_bytes:108) else goto L7 :: bool
L7:
    r6 = truncate r4: i32 to builtins.bool
    if r6 goto L55 else goto L13 :: bool
L8:
    r7 = unbox(bool, primitive)
    dec_ref primitive
    if is_error(r7) goto L50 (error at to_bytes:109) else goto L9
L9:
    if r7 goto L10 else goto L11 :: bool
L10:
    r8 = b'\x01'
    inc_ref r8
    r9 = r8
    goto L12
L11:
    r10 = b'\x00'
    inc_ref r10
    r9 = r10
L12:
    return r9
L13:
    r11 = builtins :: module
    r12 = 'bytearray'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L54 (error at to_bytes:110) else goto L14
L14:
    r14 = builtins :: module
    r15 = 'memoryview'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L56 (error at to_bytes:110) else goto L15
L15:
    r17 = (r13, r16)
    r18 = box(tuple[object, object], r17)
    r19 = PyObject_IsInstance(primitive, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L54 (error at to_bytes:110) else goto L16 :: bool
L16:
    r21 = truncate r19: i32 to builtins.bool
    if r21 goto L57 else goto L20 :: bool
L17:
    r22 = load_address PyBytes_Type
    r23 = [primitive]
    r24 = load_address r23
    r25 = _PyObject_Vectorcall(r22, r24, 1, 0)
    if is_error(r25) goto L58 (error at to_bytes:111) else goto L18
L18:
    dec_ref primitive
    r26 = cast(bytes, r25)
    if is_error(r26) goto L50 (error at to_bytes:111) else goto L19
L19:
    return r26
L20:
    r27 = load_address PyBytes_Type
    r28 = PyObject_IsInstance(primitive, r27)
    r29 = r28 >= 0 :: signed
    if not r29 goto L54 (error at to_bytes:112) else goto L21 :: bool
L21:
    r30 = truncate r28: i32 to builtins.bool
    if r30 goto L59 else goto L24 :: bool
L22:
    r31 = cast(bytes, primitive)
    if is_error(r31) goto L50 (error at to_bytes:113) else goto L23
L23:
    return r31
L24:
    r32 = load_address PyLong_Type
    r33 = PyObject_IsInstance(primitive, r32)
    r34 = r33 >= 0 :: signed
    if not r34 goto L54 (error at to_bytes:114) else goto L25 :: bool
L25:
    r35 = truncate r33: i32 to builtins.bool
    if r35 goto L60 else goto L61 :: bool
L26:
    r36 = unbox(int, primitive)
    dec_ref primitive
    if is_error(r36) goto L50 (error at to_bytes:115) else goto L27
L27:
    r37 = box(int, r36)
    r38 = <error> :: union[object, None]
    r39 = <error> :: union[str, None]
    r40 = to_hex(r37, r38, r39)
    dec_ref r37
    if is_error(r40) goto L50 (error at to_bytes:115) else goto L28
L28:
    r41 = <error> :: union[object, None]
    r42 = <error> :: union[str, None]
    r43 = to_bytes(r41, r40, r42)
    dec_ref r40
    if is_error(r43) goto L50 (error at to_bytes:115) else goto L29
L29:
    return r43
L30:
    r44 = load_address _Py_NoneStruct
    r45 = hexstr != r44
    if r45 goto L62 else goto L63 :: bool
L31:
    r46 = CPyObject_Size(hexstr)
    if is_error(r46) goto L64 (error at to_bytes:117) else goto L32
L32:
    r47 = CPyTagged_Remainder(r46, 4)
    dec_ref r46 :: int
    if is_error(r47) goto L64 (error at to_bytes:117) else goto L33
L33:
    r48 = r47 != 0
    dec_ref r47 :: int
    if r48 goto L34 else goto L38 :: bool
L34:
    r49 = '0x0'
    r50 = remove_0x_prefix(hexstr)
    dec_ref hexstr
    if is_error(r50) goto L50 (error at to_bytes:117) else goto L35
L35:
    r51 = PyObject_Str(r50)
    dec_ref r50
    if is_error(r51) goto L50 (error at to_bytes:117) else goto L36
L36:
    r52 = CPyStr_Build(2, r49, r51)
    dec_ref r51
    if is_error(r52) goto L50 (error at to_bytes:117) else goto L37
L37:
    r53 = r52
    goto L39
L38:
    r53 = hexstr
L39:
    r54 = cast(str, r53)
    if is_error(r54) goto L50 (error at to_bytes:117) else goto L40
L40:
    r55 = decode_hex(r54)
    dec_ref r54
    if is_error(r55) goto L50 (error at to_bytes:117) else goto L41
L41:
    return r55
L42:
    r56 = load_address _Py_NoneStruct
    r57 = text != r56
    if r57 goto L43 else goto L65 :: bool
L43:
    r58 = cast(str, text)
    if is_error(r58) goto L50 (error at to_bytes:119) else goto L44
L44:
    r59 = PyUnicode_AsUTF8String(r58)
    dec_ref r58
    if is_error(r59) goto L50 (error at to_bytes:119) else goto L45
L45:
    return r59
L46:
    r60 = 'expected a bool, int, byte or bytearray in first arg, or keyword of hexstr or text'
    r61 = builtins :: module
    r62 = 'TypeError'
    r63 = CPyObject_GetAttr(r61, r62)
    if is_error(r63) goto L50 (error at to_bytes:120) else goto L47
L47:
    r64 = [r60]
    r65 = load_address r64
    r66 = _PyObject_Vectorcall(r63, r65, 1, 0)
    dec_ref r63
    if is_error(r66) goto L50 (error at to_bytes:120) else goto L48
L48:
    CPy_Raise(r66)
    dec_ref r66
    if not 0 goto L50 (error at to_bytes:120) else goto L49 :: bool
L49:
    unreachable
L50:
    r67 = <error> :: bytes
    return r67
L51:
    inc_ref primitive
    goto L2
L52:
    inc_ref hexstr
    goto L4
L53:
    inc_ref text
    goto L6
L54:
    dec_ref primitive
    dec_ref hexstr
    dec_ref text
    goto L50
L55:
    dec_ref hexstr
    dec_ref text
    goto L8
L56:
    dec_ref primitive
    dec_ref hexstr
    dec_ref text
    dec_ref r13
    goto L50
L57:
    dec_ref hexstr
    dec_ref text
    goto L17
L58:
    dec_ref primitive
    goto L50
L59:
    dec_ref hexstr
    dec_ref text
    goto L22
L60:
    dec_ref hexstr
    dec_ref text
    goto L26
L61:
    dec_ref primitive
    goto L30
L62:
    dec_ref text
    goto L31
L63:
    dec_ref hexstr
    goto L42
L64:
    dec_ref hexstr
    goto L50
L65:
    dec_ref text
    goto L46

def decode_hex(value):
    value :: str
    r0 :: object
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10, r11 :: object
    r12, r13 :: str
    r14 :: object[2]
    r15 :: object_ptr
    r16 :: object
    r17 :: dict
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23, r24 :: bytes
L0:
    r0 = load_address PyUnicode_Type
    r1 = PyObject_IsInstance(value, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L12 (error at decode_hex:126) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L6 else goto L2 :: bool
L2:
    r4 = 'Value must be an instance of str'
    r5 = builtins :: module
    r6 = 'TypeError'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L12 (error at decode_hex:127) else goto L3
L3:
    r8 = [r4]
    r9 = load_address r8
    r10 = _PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L12 (error at decode_hex:127) else goto L4
L4:
    CPy_Raise(r10)
    dec_ref r10
    if not 0 goto L12 (error at decode_hex:127) else goto L5 :: bool
L5:
    unreachable
L6:
    r11 = remove_0x_prefix(value)
    if is_error(r11) goto L12 (error at decode_hex:128) else goto L7
L7:
    r12 = 'ascii'
    r13 = 'encode'
    r14 = [r11, r12]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r13, r15, 9223372036854775810, 0)
    if is_error(r16) goto L13 (error at decode_hex:130) else goto L8
L8:
    dec_ref r11
    r17 = dank_mids._eth_utils.globals :: static
    r18 = 'unhexlify'
    r19 = CPyDict_GetItem(r17, r18)
    if is_error(r19) goto L14 (error at decode_hex:131) else goto L9
L9:
    r20 = [r16]
    r21 = load_address r20
    r22 = _PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L14 (error at decode_hex:131) else goto L10
L10:
    dec_ref r16
    r23 = cast(bytes, r22)
    if is_error(r23) goto L12 (error at decode_hex:131) else goto L11
L11:
    return r23
L12:
    r24 = <error> :: bytes
    return r24
L13:
    dec_ref r11
    goto L12
L14:
    dec_ref r16
    goto L12

def encode_hex(value):
    value, r0, r1 :: object
    r2 :: str
    r3 :: object
    r4 :: tuple[object, object]
    r5 :: object
    r6 :: i32
    r7 :: bit
    r8 :: bool
    ascii_bytes :: union[bytes, object]
    r9 :: object
    r10 :: i32
    r11 :: bit
    r12 :: bool
    r13 :: str
    r14 :: bytes
    r15 :: str
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: object[1]
    r20 :: object_ptr
    r21 :: object
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: object[1]
    r26 :: object_ptr
    r27 :: object
    r28 :: bytes
    r29, r30 :: str
    r31, r32 :: object
L0:
    r0 = load_address PyBytes_Type
    r1 = builtins :: module
    r2 = 'bytearray'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L19 (error at encode_hex:135) else goto L1
L1:
    inc_ref r0
    r4 = (r0, r3)
    r5 = box(tuple[object, object], r4)
    r6 = PyObject_IsInstance(value, r5)
    dec_ref r5
    r7 = r6 >= 0 :: signed
    if not r7 goto L19 (error at encode_hex:135) else goto L2 :: bool
L2:
    r8 = truncate r6: i32 to builtins.bool
    if r8 goto L3 else goto L4 :: bool
L3:
    inc_ref value
    ascii_bytes = value
    goto L13
L4:
    r9 = load_address PyUnicode_Type
    r10 = PyObject_IsInstance(value, r9)
    r11 = r10 >= 0 :: signed
    if not r11 goto L19 (error at encode_hex:137) else goto L5 :: bool
L5:
    r12 = truncate r10: i32 to builtins.bool
    if r12 goto L6 else goto L9 :: bool
L6:
    inc_ref value
    r13 = cast(str, value)
    if is_error(r13) goto L19 (error at encode_hex:138) else goto L7
L7:
    r14 = PyUnicode_AsASCIIString(r13)
    dec_ref r13
    if is_error(r14) goto L19 (error at encode_hex:138) else goto L8
L8:
    ascii_bytes = r14
    goto L13
L9:
    r15 = 'Value must be an instance of str or unicode'
    r16 = builtins :: module
    r17 = 'TypeError'
    r18 = CPyObject_GetAttr(r16, r17)
    if is_error(r18) goto L19 (error at encode_hex:140) else goto L10
L10:
    r19 = [r15]
    r20 = load_address r19
    r21 = _PyObject_Vectorcall(r18, r20, 1, 0)
    dec_ref r18
    if is_error(r21) goto L19 (error at encode_hex:140) else goto L11
L11:
    CPy_Raise(r21)
    dec_ref r21
    if not 0 goto L19 (error at encode_hex:140) else goto L12 :: bool
L12:
    unreachable
L13:
    r22 = dank_mids._eth_utils.globals :: static
    r23 = 'hexlify'
    r24 = CPyDict_GetItem(r22, r23)
    if is_error(r24) goto L20 (error at encode_hex:141) else goto L14
L14:
    r25 = [ascii_bytes]
    r26 = load_address r25
    r27 = _PyObject_Vectorcall(r24, r26, 1, 0)
    dec_ref r24
    if is_error(r27) goto L20 (error at encode_hex:141) else goto L15
L15:
    dec_ref ascii_bytes
    r28 = cast(bytes, r27)
    if is_error(r28) goto L19 (error at encode_hex:141) else goto L16
L16:
    r29 = 'ascii'
    r30 = CPy_Decode(r28, r29, 0)
    dec_ref r28
    if is_error(r30) goto L19 (error at encode_hex:141) else goto L17
L17:
    r31 = add_0x_prefix(r30)
    dec_ref r30
    if is_error(r31) goto L19 (error at encode_hex:141) else goto L18
L18:
    return r31
L19:
    r32 = <error> :: object
    return r32
L20:
    dec_ref ascii_bytes
    goto L19

def is_0x_prefixed(value):
    value :: str
    r0 :: object
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4, r5, r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13, r14 :: str
    r15 :: object[3]
    r16 :: object_ptr
    r17 :: object
    r18 :: list
    r19, r20, r21 :: ptr
    r22 :: str
    r23 :: object
    r24 :: str
    r25 :: object
    r26 :: object[1]
    r27 :: object_ptr
    r28 :: object
    r29, r30 :: str
    r31 :: tuple[str, str]
    r32 :: str
    r33 :: object
    r34 :: object[2]
    r35 :: object_ptr
    r36 :: object
    r37, r38 :: bool
L0:
    r0 = load_address PyUnicode_Type
    r1 = PyObject_IsInstance(value, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L14 (error at is_0x_prefixed:145) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L11 else goto L2 :: bool
L2:
    r4 = ''
    r5 = 'is_0x_prefixed requires text typed arguments. Got: '
    r6 = '{:{}}'
    r7 = builtins :: module
    r8 = 'repr'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L14 (error at is_0x_prefixed:146) else goto L3
L3:
    r10 = [value]
    r11 = load_address r10
    r12 = _PyObject_Vectorcall(r9, r11, 1, 0)
    dec_ref r9
    if is_error(r12) goto L14 (error at is_0x_prefixed:146) else goto L4
L4:
    r13 = ''
    r14 = 'format'
    r15 = [r6, r12, r13]
    r16 = load_address r15
    r17 = PyObject_VectorcallMethod(r14, r16, 9223372036854775811, 0)
    if is_error(r17) goto L15 (error at is_0x_prefixed:146) else goto L5
L5:
    dec_ref r12
    r18 = PyList_New(2)
    if is_error(r18) goto L16 (error at is_0x_prefixed:146) else goto L6
L6:
    r19 = get_element_ptr r18 ob_item :: PyListObject
    r20 = load_mem r19 :: ptr*
    inc_ref r5
    set_mem r20, r5 :: builtins.object*
    r21 = r20 + 8
    set_mem r21, r17 :: builtins.object*
    r22 = PyUnicode_Join(r4, r18)
    dec_ref r18
    if is_error(r22) goto L14 (error at is_0x_prefixed:146) else goto L7
L7:
    r23 = builtins :: module
    r24 = 'TypeError'
    r25 = CPyObject_GetAttr(r23, r24)
    if is_error(r25) goto L17 (error at is_0x_prefixed:146) else goto L8
L8:
    r26 = [r22]
    r27 = load_address r26
    r28 = _PyObject_Vectorcall(r25, r27, 1, 0)
    dec_ref r25
    if is_error(r28) goto L17 (error at is_0x_prefixed:146) else goto L9
L9:
    dec_ref r22
    CPy_Raise(r28)
    dec_ref r28
    if not 0 goto L14 (error at is_0x_prefixed:146) else goto L10 :: bool
L10:
    unreachable
L11:
    r29 = '0x'
    r30 = '0X'
    inc_ref r29
    inc_ref r30
    r31 = (r29, r30)
    r32 = 'startswith'
    r33 = box(tuple[str, str], r31)
    r34 = [value, r33]
    r35 = load_address r34
    r36 = PyObject_VectorcallMethod(r32, r35, 9223372036854775810, 0)
    if is_error(r36) goto L18 (error at is_0x_prefixed:147) else goto L12
L12:
    dec_ref r33
    r37 = unbox(bool, r36)
    dec_ref r36
    if is_error(r37) goto L14 (error at is_0x_prefixed:147) else goto L13
L13:
    return r37
L14:
    r38 = <error> :: bool
    return r38
L15:
    dec_ref r12
    goto L14
L16:
    dec_ref r17
    goto L14
L17:
    dec_ref r22
    goto L14
L18:
    dec_ref r33
    goto L14

def remove_0x_prefix(value):
    value :: object
    r0 :: str
    r1 :: bool
    r2, r3, r4, r5, r6, r7 :: object
L0:
    inc_ref value
    r0 = cast(str, value)
    if is_error(r0) goto L7 (error at remove_0x_prefix:152) else goto L1
L1:
    r1 = is_0x_prefixed(r0)
    dec_ref r0
    if is_error(r1) goto L7 (error at remove_0x_prefix:152) else goto L2
L2:
    if r1 goto L3 else goto L6 :: bool
L3:
    r2 = load_address _Py_NoneStruct
    r3 = load_address _Py_NoneStruct
    r4 = object 2
    r5 = PySlice_New(r4, r2, r3)
    if is_error(r5) goto L7 (error at remove_0x_prefix:153) else goto L4
L4:
    r6 = PyObject_GetItem(value, r5)
    dec_ref r5
    if is_error(r6) goto L7 (error at remove_0x_prefix:153) else goto L5
L5:
    return r6
L6:
    inc_ref value
    return value
L7:
    r7 = <error> :: object
    return r7

def add_0x_prefix(value):
    value :: object
    r0 :: str
    r1 :: bool
    r2, r3, r4 :: str
    r5 :: object
L0:
    inc_ref value
    r0 = cast(str, value)
    if is_error(r0) goto L7 (error at add_0x_prefix:159) else goto L1
L1:
    r1 = is_0x_prefixed(r0)
    dec_ref r0
    if is_error(r1) goto L7 (error at add_0x_prefix:159) else goto L2
L2:
    if r1 goto L3 else goto L4 :: bool
L3:
    inc_ref value
    return value
L4:
    r2 = '0x'
    r3 = PyObject_Str(value)
    if is_error(r3) goto L7 (error at add_0x_prefix:161) else goto L5
L5:
    r4 = CPyStr_Build(2, r2, r3)
    dec_ref r3
    if is_error(r4) goto L7 (error at add_0x_prefix:161) else goto L6
L6:
    return r4
L7:
    r5 = <error> :: object
    return r5

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L7 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('hexlify', 'unhexlify')
    r6 = 'binascii'
    r7 = dank_mids._eth_utils.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L7 (error at <module>:8) else goto L4
L4:
    binascii = r8 :: module
    dec_ref r8
    r9 = ('Any', 'AnyStr', 'Optional')
    r10 = 'typing'
    r11 = dank_mids._eth_utils.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L7 (error at <module>:9) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = ('HexStr',)
    r14 = 'eth_typing'
    r15 = dank_mids._eth_utils.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L7 (error at <module>:11) else goto L6
L6:
    eth_typing = r16 :: module
    dec_ref r16
    return 1
L7:
    r17 = <error> :: None
    return r17

def FunctionABI.__init__(self, abi):
    self :: dank_mids.brownie_patch._abi.FunctionABI
    abi, r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: dict
    r7 :: str
    r8 :: object
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    r12 :: None
L0:
    inc_ref abi
    self.abi = abi
    r0 = dank_mids.brownie_patch._abi.globals :: static
    r1 = 'build_function_signature'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L5 (error at __init__:30) else goto L1
L1:
    r3 = [abi]
    r4 = load_address r3
    r5 = _PyObject_Vectorcall(r2, r4, 1, 0)
    dec_ref r2
    if is_error(r5) goto L5 (error at __init__:30) else goto L2
L2:
    self.input_sig = r5
    r6 = dank_mids.brownie_patch._abi.globals :: static
    r7 = 'build_function_selector'
    r8 = CPyDict_GetItem(r6, r7)
    if is_error(r8) goto L5 (error at __init__:36) else goto L3
L3:
    r9 = [abi]
    r10 = load_address r9
    r11 = _PyObject_Vectorcall(r8, r10, 1, 0)
    dec_ref r8
    if is_error(r11) goto L5 (error at __init__:36) else goto L4
L4:
    self.signature = r11
    return 1
L5:
    r12 = <error> :: None
    return r12

def FunctionABI.singleton(abi):
    abi :: dict
    r0 :: object
    r1 :: dict
    r2 :: i32
    r3 :: bit
    r4 :: tuple
    r5 :: object
    r6, r7 :: dank_mids.brownie_patch._abi.FunctionABI
L0:
    r0 = dank_mids.brownie_patch._abi.FunctionABI :: type
    r1 = PyDict_New()
    if is_error(r1) goto L6 (error at singleton:51) else goto L1
L1:
    r2 = CPyDict_UpdateInDisplay(r1, abi)
    r3 = r2 >= 0 :: signed
    if not r3 goto L7 (error at singleton:51) else goto L2 :: bool
L2:
    r4 = PyTuple_Pack(0)
    if is_error(r4) goto L7 (error at singleton:51) else goto L3
L3:
    r5 = PyObject_Call(r0, r4, r1)
    dec_ref r4
    dec_ref r1
    if is_error(r5) goto L6 (error at singleton:51) else goto L4
L4:
    r6 = cast(dank_mids.brownie_patch._abi.FunctionABI, r5)
    if is_error(r6) goto L6 (error at singleton:51) else goto L5
L5:
    return r6
L6:
    r7 = <error> :: dank_mids.brownie_patch._abi.FunctionABI
    return r7
L7:
    dec_ref r1
    goto L6

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25, r26 :: object
    r27 :: bool
    r28, r29, r30, r31 :: str
    r32 :: tuple
    r33 :: i32
    r34 :: bit
    r35 :: dict
    r36 :: str
    r37 :: i32
    r38 :: bit
    r39 :: object
    r40 :: str
    r41, r42 :: object
    r43 :: str
    r44, r45 :: object
    r46 :: object[1]
    r47 :: object_ptr
    r48, r49 :: object
    r50 :: object[1]
    r51 :: object_ptr
    r52 :: object
    r53 :: str
    r54 :: i32
    r55 :: bit
    r56 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L17 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address functools :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('functools', 'functools', 'functools'),)
    r11 = dank_mids.brownie_patch._abi.globals :: static
    r12 = 'dank_mids/brownie_patch/_abi.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L17 else goto L4 :: bool
L4:
    r15 = ('Any', 'final')
    r16 = 'typing'
    r17 = dank_mids.brownie_patch._abi.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L17 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = ('build_function_selector', 'build_function_signature')
    r20 = 'brownie.convert.utils'
    r21 = dank_mids.brownie_patch._abi.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L17 (error at <module>:4) else goto L6
L6:
    brownie.convert.utils = r22 :: module
    dec_ref r22
    r23 = <error> :: object
    r24 = 'dank_mids.brownie_patch._abi'
    r25 = dank_mids.brownie_patch._abi.FunctionABI_template :: type
    r26 = CPyType_FromTemplate(r25, r23, r24)
    if is_error(r26) goto L17 (error at <module>:8) else goto L7
L7:
    r27 = FunctionABI_trait_vtable_setup()
    if is_error(r27) goto L18 (error at <module>:-1) else goto L8
L8:
    r28 = '__mypyc_attrs__'
    r29 = 'abi'
    r30 = 'input_sig'
    r31 = 'signature'
    r32 = PyTuple_Pack(3, r29, r30, r31)
    if is_error(r32) goto L18 (error at <module>:8) else goto L9
L9:
    r33 = PyObject_SetAttr(r26, r28, r32)
    dec_ref r32
    r34 = r33 >= 0 :: signed
    if not r34 goto L18 (error at <module>:8) else goto L10 :: bool
L10:
    dank_mids.brownie_patch._abi.FunctionABI = r26 :: type
    r35 = dank_mids.brownie_patch._abi.globals :: static
    r36 = 'FunctionABI'
    r37 = CPyDict_SetItem(r35, r36, r26)
    dec_ref r26
    r38 = r37 >= 0 :: signed
    if not r38 goto L17 (error at <module>:8) else goto L11 :: bool
L11:
    r39 = dank_mids.brownie_patch._abi.FunctionABI :: type
    r40 = 'singleton'
    r41 = CPyObject_GetAttr(r39, r40)
    if is_error(r41) goto L17 (error at <module>:44) else goto L12
L12:
    r42 = functools :: module
    r43 = 'lru_cache'
    r44 = CPyObject_GetAttr(r42, r43)
    if is_error(r44) goto L19 (error at <module>:43) else goto L13
L13:
    r45 = box(None, 1)
    r46 = [r45]
    r47 = load_address r46
    r48 = ('maxsize',)
    r49 = _PyObject_Vectorcall(r44, r47, 0, r48)
    dec_ref r44
    if is_error(r49) goto L19 (error at <module>:43) else goto L14
L14:
    r50 = [r41]
    r51 = load_address r50
    r52 = _PyObject_Vectorcall(r49, r51, 1, 0)
    dec_ref r49
    if is_error(r52) goto L19 (error at <module>:44) else goto L15
L15:
    dec_ref r41
    r53 = 'singleton'
    r54 = PyObject_SetAttr(r39, r53, r52)
    dec_ref r52
    r55 = r54 >= 0 :: signed
    if not r55 goto L17 (error at <module>:44) else goto L16 :: bool
L16:
    return 1
L17:
    r56 = <error> :: None
    return r56
L18:
    dec_ref r26
    goto L17
L19:
    dec_ref r41
    goto L17

def __mypyc_lambda__0_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__0_obj.__call__(__mypyc_self__, self, args):
    __mypyc_self__ :: dank_mids.brownie_patch.call.__mypyc_lambda__0_obj
    self, args, r0 :: object
    r1 :: bool
    r2 :: str
    r3 :: object
    r4 :: dict
    r5 :: str
    r6 :: object
    r7 :: str
    r8 :: object
    r9 :: str
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: list
    r14, r15, r16, r17 :: ptr
    r18 :: object
    r19 :: tuple
    r20 :: dict
    r21, r22 :: object
L0:
    r0 = dank_mids.brownie_patch.call.ENVS :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "ENVS" was not set')
    if not r1 goto L14 (error at <lambda>:78) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = 'BROWNIE_ENCODER_PROCESSES'
    r3 = CPyObject_GetAttr(r0, r2)
    if is_error(r3) goto L14 (error at <lambda>:78) else goto L4
L4:
    r4 = dank_mids.brownie_patch.call.globals :: static
    r5 = '__encode_input'
    r6 = CPyDict_GetItem(r4, r5)
    if is_error(r6) goto L15 (error at <lambda>:78) else goto L5
L5:
    r7 = 'abi'
    r8 = CPyObject_GetAttr(self, r7)
    if is_error(r8) goto L16 (error at <lambda>:78) else goto L6
L6:
    r9 = 'signature'
    r10 = CPyObject_GetAttr(self, r9)
    if is_error(r10) goto L17 (error at <lambda>:78) else goto L7
L7:
    r11 = 'run'
    r12 = CPyObject_GetAttr(r3, r11)
    dec_ref r3
    if is_error(r12) goto L18 (error at <lambda>:78) else goto L8
L8:
    r13 = PyList_New(3)
    if is_error(r13) goto L19 (error at <lambda>:78) else goto L9
L9:
    r14 = get_element_ptr r13 ob_item :: PyListObject
    r15 = load_mem r14 :: ptr*
    set_mem r15, r6 :: builtins.object*
    r16 = r15 + 8
    set_mem r16, r8 :: builtins.object*
    r17 = r15 + 16
    set_mem r17, r10 :: builtins.object*
    r18 = CPyList_Extend(r13, args)
    if is_error(r18) goto L20 (error at <lambda>:78) else goto L21
L10:
    r19 = PyList_AsTuple(r13)
    dec_ref r13
    if is_error(r19) goto L22 (error at <lambda>:78) else goto L11
L11:
    r20 = PyDict_New()
    if is_error(r20) goto L23 (error at <lambda>:78) else goto L12
L12:
    r21 = PyObject_Call(r12, r19, r20)
    dec_ref r12
    dec_ref r19
    dec_ref r20
    if is_error(r21) goto L14 (error at <lambda>:78) else goto L13
L13:
    return r21
L14:
    r22 = <error> :: object
    return r22
L15:
    dec_ref r3
    goto L14
L16:
    dec_ref r3
    dec_ref r6
    goto L14
L17:
    dec_ref r3
    dec_ref r6
    dec_ref r8
    goto L14
L18:
    dec_ref r6
    dec_ref r8
    dec_ref r10
    goto L14
L19:
    dec_ref r6
    dec_ref r8
    dec_ref r10
    dec_ref r12
    goto L14
L20:
    dec_ref r12
    dec_ref r13
    goto L14
L21:
    dec_ref r18
    goto L10
L22:
    dec_ref r12
    goto L14
L23:
    dec_ref r12
    dec_ref r19
    goto L14

def __mypyc_lambda__1_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__1_obj.__call__(__mypyc_self__, self, data):
    __mypyc_self__ :: dank_mids.brownie_patch.call.__mypyc_lambda__1_obj
    self :: object
    data :: bytes
    r0 :: object
    r1 :: bool
    r2 :: str
    r3 :: object
    r4 :: dict
    r5 :: str
    r6 :: object
    r7 :: str
    r8 :: object
    r9 :: str
    r10 :: object[4]
    r11 :: object_ptr
    r12, r13 :: object
L0:
    r0 = dank_mids.brownie_patch.call.ENVS :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "ENVS" was not set')
    if not r1 goto L8 (error at <lambda>:97) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = 'BROWNIE_DECODER_PROCESSES'
    r3 = CPyObject_GetAttr(r0, r2)
    if is_error(r3) goto L8 (error at <lambda>:97) else goto L4
L4:
    r4 = dank_mids.brownie_patch.call.globals :: static
    r5 = '__decode_output'
    r6 = CPyDict_GetItem(r4, r5)
    if is_error(r6) goto L9 (error at <lambda>:97) else goto L5
L5:
    r7 = 'abi'
    r8 = CPyObject_GetAttr(self, r7)
    if is_error(r8) goto L10 (error at <lambda>:97) else goto L6
L6:
    r9 = 'run'
    r10 = [r3, r6, data, r8]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775812, 0)
    if is_error(r12) goto L11 (error at <lambda>:97) else goto L7
L7:
    dec_ref r3
    dec_ref r6
    dec_ref r8
    return r12
L8:
    r13 = <error> :: object
    return r13
L9:
    dec_ref r3
    goto L8
L10:
    dec_ref r3
    dec_ref r6
    goto L8
L11:
    dec_ref r3
    dec_ref r6
    dec_ref r8
    goto L8

def _patch_call(call, w3):
    call, w3 :: object
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: set
    r6 :: i32
    r7 :: bit
    r8 :: bool
    r9 :: str
    r10 :: object
    r11 :: i32
    r12 :: bit
    r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: int
    r18 :: dict
    r19 :: str
    r20, r21 :: object
    r22 :: object[2]
    r23 :: object_ptr
    r24 :: object
    r25 :: dict
    r26 :: str
    r27 :: object
    r28 :: object[2]
    r29 :: object_ptr
    r30 :: object
    r31 :: str
    r32 :: i32
    r33 :: bit
    r34 :: dict
    r35 :: str
    r36 :: object
    r37 :: dict
    r38 :: str
    r39 :: object
    r40 :: object[2]
    r41 :: object_ptr
    r42 :: object
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: None
L0:
    r0 = '_address'
    r1 = CPyObject_GetAttr(call, r0)
    if is_error(r1) goto L18 (error at _patch_call:131) else goto L1
L1:
    r2 = dank_mids.brownie_patch.call.globals :: static
    r3 = '_skip_proc_pool'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L19 (error at _patch_call:131) else goto L2
L2:
    r5 = cast(set, r4)
    if is_error(r5) goto L19 (error at _patch_call:131) else goto L3
L3:
    r6 = PySet_Contains(r5, r1)
    dec_ref r5
    dec_ref r1
    r7 = r6 >= 0 :: signed
    if not r7 goto L18 (error at _patch_call:131) else goto L4 :: bool
L4:
    r8 = truncate r6: i32 to builtins.bool
    r9 = '_skip_decoder_proc_pool'
    r10 = box(bool, r8)
    r11 = PyObject_SetAttr(call, r9, r10)
    r12 = r11 >= 0 :: signed
    if not r12 goto L18 (error at _patch_call:131) else goto L5 :: bool
L5:
    r13 = 'abi'
    r14 = CPyObject_GetAttr(call, r13)
    if is_error(r14) goto L18 (error at _patch_call:132) else goto L6
L6:
    r15 = 'inputs'
    r16 = PyObject_GetItem(r14, r15)
    dec_ref r14
    if is_error(r16) goto L18 (error at _patch_call:132) else goto L7
L7:
    r17 = CPyObject_Size(r16)
    dec_ref r16
    if is_error(r17) goto L18 (error at _patch_call:132) else goto L8
L8:
    r18 = dank_mids.brownie_patch.call.globals :: static
    r19 = '_get_coroutine_fn'
    r20 = CPyDict_GetItem(r18, r19)
    if is_error(r20) goto L20 (error at _patch_call:132) else goto L9
L9:
    r21 = box(int, r17)
    r22 = [w3, r21]
    r23 = load_address r22
    r24 = _PyObject_Vectorcall(r20, r23, 2, 0)
    dec_ref r20
    if is_error(r24) goto L21 (error at _patch_call:132) else goto L10
L10:
    dec_ref r21
    r25 = dank_mids.brownie_patch.call.globals :: static
    r26 = 'MethodType'
    r27 = CPyDict_GetItem(r25, r26)
    if is_error(r27) goto L22 (error at _patch_call:132) else goto L11
L11:
    r28 = [r24, call]
    r29 = load_address r28
    r30 = _PyObject_Vectorcall(r27, r29, 2, 0)
    dec_ref r27
    if is_error(r30) goto L22 (error at _patch_call:132) else goto L12
L12:
    dec_ref r24
    r31 = 'coroutine'
    r32 = PyObject_SetAttr(call, r31, r30)
    dec_ref r30
    r33 = r32 >= 0 :: signed
    if not r33 goto L18 (error at _patch_call:132) else goto L13 :: bool
L13:
    r34 = dank_mids.brownie_patch.call.globals :: static
    r35 = '_call_no_args'
    r36 = CPyDict_GetItem(r34, r35)
    if is_error(r36) goto L18 (error at _patch_call:133) else goto L14
L14:
    r37 = dank_mids.brownie_patch.call.globals :: static
    r38 = 'MethodType'
    r39 = CPyDict_GetItem(r37, r38)
    if is_error(r39) goto L23 (error at _patch_call:133) else goto L15
L15:
    r40 = [r36, call]
    r41 = load_address r40
    r42 = _PyObject_Vectorcall(r39, r41, 2, 0)
    dec_ref r39
    if is_error(r42) goto L23 (error at _patch_call:133) else goto L16
L16:
    dec_ref r36
    r43 = '__await__'
    r44 = PyObject_SetAttr(call, r43, r42)
    dec_ref r42
    r45 = r44 >= 0 :: signed
    if not r45 goto L18 (error at _patch_call:133) else goto L17 :: bool
L17:
    return 1
L18:
    r46 = <error> :: None
    return r46
L19:
    dec_ref r1
    goto L18
L20:
    dec_ref r17 :: int
    goto L18
L21:
    dec_ref r21
    goto L18
L22:
    dec_ref r24
    goto L18
L23:
    dec_ref r36
    goto L18

def coroutine__get_coroutine_fn_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def coroutine__get_coroutine_fn_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    type, value, traceback, arg, r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11 :: object
    r12, r13 :: tuple[object, object, object]
    r14, r15, r16, r17 :: object
    r18, r19 :: tuple[object, object, object]
    r20, r21 :: object
    r22 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_env
    r23 :: int
    r24 :: dank_mids.brownie_patch.call._get_coroutine_fn_env
    r25 :: object
    r26 :: bit
    r27 :: union[dict, None]
    r28 :: object
    r29 :: bit
    r30 :: dict
    r31 :: native_int
    r32 :: short_int
    r33 :: bit
    r34 :: str
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: object[1]
    r39 :: object_ptr
    r40, r41 :: object
    r42 :: bool
    r43 :: str
    r44 :: object
    r45 :: union[object, None]
    r46, r47 :: object
    r48 :: str
    r49 :: object
    r50 :: bool
    r51 :: str
    r52 :: object
    r53 :: object[1]
    r54 :: object_ptr
    r55 :: object
    r56, r57 :: bool
    r58 :: object
    r59 :: bool
    r60, r61, r62, r63, r64 :: object
    r65 :: bool
    r66 :: object
    r67 :: bit
    r68 :: tuple[object, object, object]
    r69 :: bool
    r70 :: object_ptr
    r71 :: object
    r72, r73 :: bool
    r74 :: tuple[object, object, object]
    r75 :: bool
    r76, r77 :: tuple[object, object, object]
    r78 :: bit
    r79, r80, r81, r82 :: object
    r83 :: int
    r84 :: object
    r85 :: tuple
    r86 :: dict
    r87 :: str
    r88 :: object
    r89 :: list
    r90 :: object
    r91, r92, r93, r94 :: ptr
    r95 :: object
    r96 :: tuple
    r97 :: dict
    r98, r99 :: object
    r100 :: bool
    r101, r102, r103, r104, r105 :: object
    r106 :: bool
    r107 :: object
    r108 :: bit
    r109 :: tuple[object, object, object]
    r110 :: bool
    r111 :: object_ptr
    r112 :: object
    r113, r114 :: bool
    r115 :: tuple[object, object, object]
    r116 :: bool
    r117, r118 :: tuple[object, object, object]
    r119 :: bit
    r120, r121, r122 :: object
    r123 :: bool
    r124 :: object
    r125 :: bool
    r126 :: str
    r127 :: object
    r128 :: union[object, None]
    r129, r130 :: object
    r131 :: str
    r132 :: object
    r133 :: bool
    r134 :: str
    r135 :: object
    r136 :: object[1]
    r137 :: object_ptr
    r138 :: object
    r139, r140 :: bool
    r141 :: object
    r142 :: bool
    r143, r144, r145, r146, r147 :: object
    r148 :: bool
    r149 :: object
    r150 :: bit
    r151 :: tuple[object, object, object]
    r152 :: bool
    r153 :: object_ptr
    r154 :: object
    r155, r156 :: bool
    r157 :: tuple[object, object, object]
    r158 :: bool
    r159, r160 :: tuple[object, object, object]
    r161 :: bit
    r162, r163, r164, r165 :: object
    r166 :: str
    r167 :: object
    r168 :: str
    r169 :: object
    r170 :: str
    r171 :: object
    r172 :: str
    r173 :: object
    r174 :: dict
    r175 :: union[object, None]
    r176 :: str
    r177 :: object[3]
    r178 :: object_ptr
    r179, r180 :: object
    r181 :: bool
    r182, r183, r184, r185, r186 :: object
    r187 :: bool
    r188 :: object
    r189 :: bit
    r190 :: tuple[object, object, object]
    r191 :: bool
    r192 :: object_ptr
    r193 :: object
    r194, r195 :: bool
    r196 :: tuple[object, object, object]
    r197 :: bool
    r198, r199 :: tuple[object, object, object]
    r200 :: bit
    r201, r202, r203 :: object
    r204 :: bool
    r205 :: tuple[object, object, object]
    r206, r207 :: bool
    r208 :: tuple[object, object, object]
    r209, r210, r211, r212, r213 :: object
    r214 :: object[4]
    r215 :: object_ptr
    r216, r217 :: object
    r218 :: bool
    r219, r220, r221, r222, r223 :: object
    r224 :: bool
    r225 :: object
    r226 :: bit
    r227 :: tuple[object, object, object]
    r228 :: bool
    r229 :: object_ptr
    r230 :: object
    r231, r232 :: bool
    r233 :: tuple[object, object, object]
    r234 :: bool
    r235, r236 :: tuple[object, object, object]
    r237 :: bit
    r238, r239, r240 :: object
    r241 :: i32
    r242 :: bit
    r243 :: bool
    r244, r245 :: tuple[object, object, object]
    r246 :: bit
    r247, r248 :: tuple[object, object, object]
    r249 :: bool
    r250, r251, r252 :: object
    r253 :: object[4]
    r254 :: object_ptr
    r255, r256 :: object
    r257 :: bool
    r258, r259, r260, r261, r262 :: object
    r263 :: bool
    r264 :: object
    r265 :: bit
    r266 :: tuple[object, object, object]
    r267 :: bool
    r268 :: object_ptr
    r269 :: object
    r270, r271 :: bool
    r272 :: tuple[object, object, object]
    r273 :: bool
    r274, r275 :: tuple[object, object, object]
    r276 :: bit
    r277, r278, r279 :: object
    r280 :: bool
    r281 :: bit
    r282 :: tuple[object, object, object]
    r283, r284 :: bool
    r285 :: tuple[object, object, object]
    r286, r287, r288, r289, r290 :: object
    r291 :: object[4]
    r292 :: object_ptr
    r293, r294 :: object
    r295 :: bool
    r296, r297, r298, r299, r300 :: object
    r301 :: bool
    r302 :: object
    r303 :: bit
    r304 :: tuple[object, object, object]
    r305 :: bool
    r306 :: object_ptr
    r307 :: object
    r308, r309 :: bool
    r310 :: tuple[object, object, object]
    r311 :: bool
    r312, r313 :: tuple[object, object, object]
    r314 :: bit
    r315, r316, r317 :: object
    r318 :: i32
    r319 :: bit
    r320 :: bool
    r321, r322 :: tuple[object, object, object]
    r323 :: bit
    r324, r325 :: tuple[object, object, object]
    r326 :: bool
    r327, r328, r329 :: object
    r330 :: object[4]
    r331 :: object_ptr
    r332, r333 :: object
    r334 :: bool
    r335, r336, r337, r338, r339 :: object
    r340 :: bool
    r341 :: object
    r342 :: bit
    r343 :: tuple[object, object, object]
    r344 :: bool
    r345 :: object_ptr
    r346 :: object
    r347, r348 :: bool
    r349 :: tuple[object, object, object]
    r350 :: bool
    r351, r352 :: tuple[object, object, object]
    r353 :: bit
    r354, r355, r356 :: object
    r357 :: bool
    r358 :: bit
    r359, r360 :: object
    r361 :: bytes
    r362, r363 :: object
    r364 :: bool
    r365, r366, r367, r368, r369 :: object
    r370 :: bool
    r371 :: object
    r372 :: bit
    r373 :: tuple[object, object, object]
    r374 :: bool
    r375 :: object_ptr
    r376 :: object
    r377, r378 :: bool
    r379 :: tuple[object, object, object]
    r380 :: bool
    r381, r382 :: tuple[object, object, object]
    r383 :: bit
    r384, r385, r386 :: object
    r387 :: bool
    r388 :: tuple[object, object, object]
    r389 :: bool
    r390 :: dict
    r391 :: str
    r392 :: object
    r393 :: bit
    r394 :: object
    r395 :: bool
    r396 :: object
    r397 :: str
    r398, r399 :: object
    r400 :: str
    r401, r402 :: object
    r403 :: dict
    r404 :: str
    r405 :: object
    r406 :: object[4]
    r407 :: object_ptr
    r408 :: object
    r409 :: tuple[object, object, object]
    r410 :: bit
    r411 :: union[int, None]
    r412 :: object
    r413 :: bit
    r414, r415, r416 :: object
    r417 :: union[int, None]
    r418 :: int
    r419 :: object
    r420 :: bool
    r421 :: object
    r422 :: object[1]
    r423 :: object_ptr
    r424, r425, r426, r427 :: object
    r428 :: bool
    r429, r430, r431, r432, r433, r434, r435, r436, r437, r438 :: bit
    r439 :: bool
    r440 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = <error> :: object
    r5 = r4
    r6 = <error> :: object
    r7 = r6
    r8 = <error> :: object
    r9 = r8
    r10 = <error> :: object
    r11 = r10
    r12 = <error> :: tuple[object, object, object]
    r13 = r12
    r14 = <error> :: object
    r15 = r14
    r16 = <error> :: object
    r17 = r16
    r18 = <error> :: tuple[object, object, object]
    r19 = r18
    r20 = <error> :: object
    r21 = r20
    r22 = __mypyc_self__.__mypyc_env__
    if is_error(r22) goto L489 (error at coroutine:143) else goto L1
L1:
    r23 = r22.__mypyc_next_label__
    if is_error(r23) goto L490 (error at coroutine:143) else goto L2
L2:
    r24 = r22.__mypyc_env__
    if is_error(r24) goto L491 (error at coroutine:143) else goto L476
L3:
    r25 = load_address _Py_NoneStruct
    r26 = type != r25
    if r26 goto L492 else goto L6 :: bool
L4:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L488 (error at coroutine:143) else goto L5 :: bool
L5:
    unreachable
L6:
    r27 = r22.override
    if is_error(r27) goto L493 (error at coroutine:150) else goto L7
L7:
    r28 = load_address _Py_NoneStruct
    r29 = r27 != r28
    if r29 goto L8 else goto L494 :: bool
L8:
    r30 = cast(dict, r27)
    if is_error(r30) goto L493 (error at coroutine:150) else goto L9
L9:
    r31 = PyDict_Size(r30)
    dec_ref r30
    r32 = r31 << 1
    r33 = r32 != 0
    if r33 goto L495 else goto L14 :: bool
L10:
    r34 = 'Cannot use state override with `coroutine`.'
    r35 = builtins :: module
    r36 = 'ValueError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L488 (error at coroutine:151) else goto L11
L11:
    r38 = [r34]
    r39 = load_address r38
    r40 = _PyObject_Vectorcall(r37, r39, 1, 0)
    dec_ref r37
    if is_error(r40) goto L488 (error at coroutine:151) else goto L12
L12:
    CPy_Raise(r40)
    dec_ref r40
    if not 0 goto L488 (error at coroutine:151) else goto L13 :: bool
L13:
    unreachable
L14:
    r41 = dank_mids.brownie_patch.call.ENVS :: static
    if is_error(r41) goto L496 else goto L17
L15:
    r42 = raise NameError('value for final name "ENVS" was not set')
    if not r42 goto L488 (error at coroutine:152) else goto L16 :: bool
L16:
    unreachable
L17:
    r43 = 'BROWNIE_ENCODER_SEMAPHORE'
    r44 = CPyObject_GetAttr(r41, r43)
    if is_error(r44) goto L493 (error at coroutine:152) else goto L18
L18:
    r45 = r22.block_identifier
    if is_error(r45) goto L497 (error at coroutine:152) else goto L19
L19:
    r46 = PyObject_GetItem(r44, r45)
    dec_ref r44
    dec_ref r45
    if is_error(r46) goto L493 (error at coroutine:152) else goto L20
L20:
    r47 = PyObject_Type(r46)
    r48 = '__aexit__'
    r49 = CPyObject_GetAttr(r47, r48)
    if is_error(r49) goto L498 (error at coroutine:152) else goto L21
L21:
    r22.__mypyc_temp__0 = r49; r50 = is_error
    if not r50 goto L498 (error at coroutine:-1) else goto L22 :: bool
L22:
    r51 = '__aenter__'
    r52 = CPyObject_GetAttr(r47, r51)
    dec_ref r47
    if is_error(r52) goto L499 (error at coroutine:152) else goto L23
L23:
    r53 = [r46]
    r54 = load_address r53
    r55 = _PyObject_Vectorcall(r52, r54, 1, 0)
    dec_ref r52
    if is_error(r55) goto L499 (error at coroutine:152) else goto L24
L24:
    r22.__mypyc_temp__1 = r46; r56 = is_error
    if not r56 goto L500 (error at coroutine:-1) else goto L25 :: bool
L25:
    r22.__mypyc_temp__2 = 1; r57 = is_error
    if not r57 goto L500 (error at coroutine:-1) else goto L26 :: bool
L26:
    r58 = CPy_GetCoro(r55)
    dec_ref r55
    if is_error(r58) goto L493 (error at coroutine:152) else goto L27
L27:
    r22.__mypyc_temp__3 = r58; r59 = is_error
    if not r59 goto L493 (error at coroutine:-1) else goto L28 :: bool
L28:
    r60 = r22.__mypyc_temp__3
    if is_error(r60) goto L493 (error at coroutine:-1) else goto L29
L29:
    r61 = CPyIter_Next(r60)
    dec_ref r60
    if is_error(r61) goto L501 else goto L32
L30:
    r62 = CPy_FetchStopIterationValue()
    if is_error(r62) goto L502 (error at coroutine:152) else goto L31
L31:
    r63 = r62
    dec_ref r63
    goto L61
L32:
    r64 = r61
L33:
    r22.__mypyc_next_label__ = 2; r65 = is_error
    if not r65 goto L503 (error at coroutine:152) else goto L504 :: bool
L34:
    return r64
L35:
    r66 = load_address _Py_NoneStruct
    r67 = type != r66
    if r67 goto L36 else goto L38 :: bool
L36:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L39 (error at coroutine:152) else goto L505 :: bool
L37:
    unreachable
L38:
    inc_ref arg
    goto L56
L39:
    r68 = CPy_CatchError()
    r22.__mypyc_temp__4 = r68; r69 = is_error
    if not r69 goto L506 (error at coroutine:-1) else goto L40 :: bool
L40:
    r70 = load_address r1
    r71 = r22.__mypyc_temp__3
    if is_error(r71) goto L506 (error at coroutine:-1) else goto L41
L41:
    r72 = CPy_YieldFromErrorHandle(r71, r70)
    dec_ref r71
    if is_error(r72) goto L506 (error at coroutine:152) else goto L42
L42:
    if r72 goto L48 else goto L43 :: bool
L43:
    if is_error(r1) goto L507 else goto L46
L44:
    r73 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r73 goto L53 (error at coroutine:-1) else goto L508 :: bool
L45:
    unreachable
L46:
    inc_ref r1
    r64 = r1
    r74 = r22.__mypyc_temp__4
    if is_error(r74) goto L509 (error at coroutine:-1) else goto L47
L47:
    CPy_RestoreExcInfo(r74)
    dec_ref r74
    goto L33
L48:
    if is_error(r1) goto L510 else goto L51
L49:
    r75 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r75 goto L53 (error at coroutine:-1) else goto L511 :: bool
L50:
    unreachable
L51:
    r63 = r1
    dec_ref r63
    r76 = r22.__mypyc_temp__4
    if is_error(r76) goto L512 (error at coroutine:-1) else goto L52
L52:
    CPy_RestoreExcInfo(r76)
    dec_ref r76
    goto L61
L53:
    r77 = r22.__mypyc_temp__4
    dec_ref r22
    if is_error(r77) goto L488 (error at coroutine:-1) else goto L54
L54:
    CPy_RestoreExcInfo(r77)
    dec_ref r77
    r78 = CPy_KeepPropagating()
    if not r78 goto L488 else goto L55 :: bool
L55:
    unreachable
L56:
    r79 = r22.__mypyc_temp__3
    if is_error(r79) goto L513 (error at coroutine:-1) else goto L57
L57:
    r80 = CPyIter_Send(r79, arg)
    dec_ref r79
    dec_ref arg
    if is_error(r80) goto L514 else goto L58
L58:
    r64 = r80
    goto L33
L59:
    r81 = CPy_FetchStopIterationValue()
    if is_error(r81) goto L502 (error at coroutine:152) else goto L60
L60:
    r63 = r81
    dec_ref r63
L61:
    r82 = r22.self
    if is_error(r82) goto L515 (error at coroutine:153) else goto L62
L62:
    r83 = r24.len_inputs
    if is_error(r83) goto L516 (error at coroutine:153) else goto L63
L63:
    r84 = r24.get_request_data
    if is_error(r84) goto L517 (error at coroutine:153) else goto L64
L64:
    r85 = r22.args
    if is_error(r85) goto L518 (error at coroutine:153) else goto L65
L65:
    r86 = dank_mids.brownie_patch.call.globals :: static
    r87 = 'encode_input'
    r88 = CPyDict_GetItem(r86, r87)
    if is_error(r88) goto L519 (error at coroutine:153) else goto L66
L66:
    r89 = PyList_New(3)
    if is_error(r89) goto L520 (error at coroutine:153) else goto L67
L67:
    r90 = box(int, r83)
    r91 = get_element_ptr r89 ob_item :: PyListObject
    r92 = load_mem r91 :: ptr*
    set_mem r92, r82 :: builtins.object*
    r93 = r92 + 8
    set_mem r93, r90 :: builtins.object*
    r94 = r92 + 16
    set_mem r94, r84 :: builtins.object*
    r95 = CPyList_Extend(r89, r85)
    dec_ref r85
    if is_error(r95) goto L521 (error at coroutine:153) else goto L522
L68:
    r96 = PyList_AsTuple(r89)
    dec_ref r89
    if is_error(r96) goto L523 (error at coroutine:153) else goto L69
L69:
    r97 = PyDict_New()
    if is_error(r97) goto L524 (error at coroutine:153) else goto L70
L70:
    r98 = PyObject_Call(r88, r96, r97)
    dec_ref r88
    dec_ref r96
    dec_ref r97
    if is_error(r98) goto L515 (error at coroutine:153) else goto L71
L71:
    r99 = CPy_GetCoro(r98)
    dec_ref r98
    if is_error(r99) goto L515 (error at coroutine:153) else goto L72
L72:
    r22.__mypyc_temp__5 = r99; r100 = is_error
    if not r100 goto L515 (error at coroutine:-1) else goto L73 :: bool
L73:
    r101 = r22.__mypyc_temp__5
    if is_error(r101) goto L515 (error at coroutine:-1) else goto L74
L74:
    r102 = CPyIter_Next(r101)
    dec_ref r101
    if is_error(r102) goto L525 else goto L77
L75:
    r103 = CPy_FetchStopIterationValue()
    if is_error(r103) goto L526 (error at coroutine:153) else goto L76
L76:
    r104 = r103
    goto L106
L77:
    r105 = r102
L78:
    r22.__mypyc_next_label__ = 4; r106 = is_error
    if not r106 goto L527 (error at coroutine:153) else goto L528 :: bool
L79:
    return r105
L80:
    r107 = load_address _Py_NoneStruct
    r108 = type != r107
    if r108 goto L81 else goto L83 :: bool
L81:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L84 (error at coroutine:153) else goto L529 :: bool
L82:
    unreachable
L83:
    inc_ref arg
    goto L101
L84:
    r109 = CPy_CatchError()
    r22.__mypyc_temp__6 = r109; r110 = is_error
    if not r110 goto L530 (error at coroutine:-1) else goto L85 :: bool
L85:
    r111 = load_address r3
    r112 = r22.__mypyc_temp__5
    if is_error(r112) goto L530 (error at coroutine:-1) else goto L86
L86:
    r113 = CPy_YieldFromErrorHandle(r112, r111)
    dec_ref r112
    if is_error(r113) goto L530 (error at coroutine:153) else goto L87
L87:
    if r113 goto L93 else goto L88 :: bool
L88:
    if is_error(r3) goto L531 else goto L91
L89:
    r114 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r114 goto L98 (error at coroutine:-1) else goto L532 :: bool
L90:
    unreachable
L91:
    inc_ref r3
    r105 = r3
    r115 = r22.__mypyc_temp__6
    if is_error(r115) goto L533 (error at coroutine:-1) else goto L92
L92:
    CPy_RestoreExcInfo(r115)
    dec_ref r115
    goto L78
L93:
    if is_error(r3) goto L534 else goto L96
L94:
    r116 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r116 goto L98 (error at coroutine:-1) else goto L535 :: bool
L95:
    unreachable
L96:
    r104 = r3
    r117 = r22.__mypyc_temp__6
    if is_error(r117) goto L536 (error at coroutine:-1) else goto L97
L97:
    CPy_RestoreExcInfo(r117)
    dec_ref r117
    goto L106
L98:
    r118 = r22.__mypyc_temp__6
    if is_error(r118) goto L299 (error at coroutine:-1) else goto L99
L99:
    CPy_RestoreExcInfo(r118)
    dec_ref r118
    r119 = CPy_KeepPropagating()
    if not r119 goto L299 else goto L537 :: bool
L100:
    unreachable
L101:
    r120 = r22.__mypyc_temp__5
    if is_error(r120) goto L538 (error at coroutine:-1) else goto L102
L102:
    r121 = CPyIter_Send(r120, arg)
    dec_ref r120
    dec_ref arg
    if is_error(r121) goto L539 else goto L103
L103:
    r105 = r121
    goto L78
L104:
    r122 = CPy_FetchStopIterationValue()
    if is_error(r122) goto L526 (error at coroutine:153) else goto L105
L105:
    r104 = r122
L106:
    r22.data = r104; r123 = is_error
    if not r123 goto L526 (error at coroutine:153) else goto L107 :: bool
L107:
    r124 = dank_mids.brownie_patch.call.ENVS :: static
    if is_error(r124) goto L540 else goto L110
L108:
    r125 = raise NameError('value for final name "ENVS" was not set')
    if not r125 goto L299 (error at coroutine:154) else goto L541 :: bool
L109:
    unreachable
L110:
    r126 = 'BROWNIE_CALL_SEMAPHORE'
    r127 = CPyObject_GetAttr(r124, r126)
    if is_error(r127) goto L526 (error at coroutine:154) else goto L111
L111:
    r128 = r22.block_identifier
    if is_error(r128) goto L542 (error at coroutine:154) else goto L112
L112:
    r129 = PyObject_GetItem(r127, r128)
    dec_ref r127
    dec_ref r128
    if is_error(r129) goto L526 (error at coroutine:154) else goto L113
L113:
    r130 = PyObject_Type(r129)
    r131 = '__aexit__'
    r132 = CPyObject_GetAttr(r130, r131)
    if is_error(r132) goto L543 (error at coroutine:154) else goto L114
L114:
    r22.__mypyc_temp__7 = r132; r133 = is_error
    if not r133 goto L543 (error at coroutine:-1) else goto L115 :: bool
L115:
    r134 = '__aenter__'
    r135 = CPyObject_GetAttr(r130, r134)
    dec_ref r130
    if is_error(r135) goto L544 (error at coroutine:154) else goto L116
L116:
    r136 = [r129]
    r137 = load_address r136
    r138 = _PyObject_Vectorcall(r135, r137, 1, 0)
    dec_ref r135
    if is_error(r138) goto L544 (error at coroutine:154) else goto L117
L117:
    r22.__mypyc_temp__8 = r129; r139 = is_error
    if not r139 goto L545 (error at coroutine:-1) else goto L118 :: bool
L118:
    r22.__mypyc_temp__9 = 1; r140 = is_error
    if not r140 goto L545 (error at coroutine:-1) else goto L119 :: bool
L119:
    r141 = CPy_GetCoro(r138)
    dec_ref r138
    if is_error(r141) goto L526 (error at coroutine:154) else goto L120
L120:
    r22.__mypyc_temp__10 = r141; r142 = is_error
    if not r142 goto L526 (error at coroutine:-1) else goto L121 :: bool
L121:
    r143 = r22.__mypyc_temp__10
    if is_error(r143) goto L526 (error at coroutine:-1) else goto L122
L122:
    r144 = CPyIter_Next(r143)
    dec_ref r143
    if is_error(r144) goto L546 else goto L125
L123:
    r145 = CPy_FetchStopIterationValue()
    if is_error(r145) goto L547 (error at coroutine:154) else goto L124
L124:
    r146 = r145
    dec_ref r146
    goto L154
L125:
    r147 = r144
L126:
    r22.__mypyc_next_label__ = 6; r148 = is_error
    if not r148 goto L548 (error at coroutine:154) else goto L549 :: bool
L127:
    return r147
L128:
    r149 = load_address _Py_NoneStruct
    r150 = type != r149
    if r150 goto L129 else goto L131 :: bool
L129:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L132 (error at coroutine:154) else goto L550 :: bool
L130:
    unreachable
L131:
    inc_ref arg
    goto L149
L132:
    r151 = CPy_CatchError()
    r22.__mypyc_temp__11 = r151; r152 = is_error
    if not r152 goto L551 (error at coroutine:-1) else goto L133 :: bool
L133:
    r153 = load_address r5
    r154 = r22.__mypyc_temp__10
    if is_error(r154) goto L551 (error at coroutine:-1) else goto L134
L134:
    r155 = CPy_YieldFromErrorHandle(r154, r153)
    dec_ref r154
    if is_error(r155) goto L551 (error at coroutine:154) else goto L135
L135:
    if r155 goto L141 else goto L136 :: bool
L136:
    if is_error(r5) goto L552 else goto L139
L137:
    r156 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r156 goto L146 (error at coroutine:-1) else goto L553 :: bool
L138:
    unreachable
L139:
    inc_ref r5
    r147 = r5
    r157 = r22.__mypyc_temp__11
    if is_error(r157) goto L554 (error at coroutine:-1) else goto L140
L140:
    CPy_RestoreExcInfo(r157)
    dec_ref r157
    goto L126
L141:
    if is_error(r5) goto L555 else goto L144
L142:
    r158 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r158 goto L146 (error at coroutine:-1) else goto L556 :: bool
L143:
    unreachable
L144:
    r146 = r5
    dec_ref r146
    r159 = r22.__mypyc_temp__11
    if is_error(r159) goto L557 (error at coroutine:-1) else goto L145
L145:
    CPy_RestoreExcInfo(r159)
    dec_ref r159
    goto L154
L146:
    r160 = r22.__mypyc_temp__11
    if is_error(r160) goto L299 (error at coroutine:-1) else goto L147
L147:
    CPy_RestoreExcInfo(r160)
    dec_ref r160
    r161 = CPy_KeepPropagating()
    if not r161 goto L299 else goto L558 :: bool
L148:
    unreachable
L149:
    r162 = r22.__mypyc_temp__10
    if is_error(r162) goto L559 (error at coroutine:-1) else goto L150
L150:
    r163 = CPyIter_Send(r162, arg)
    dec_ref r162
    dec_ref arg
    if is_error(r163) goto L560 else goto L151
L151:
    r147 = r163
    goto L126
L152:
    r164 = CPy_FetchStopIterationValue()
    if is_error(r164) goto L547 (error at coroutine:154) else goto L153
L153:
    r146 = r164
    dec_ref r146
L154:
    r165 = r24.w3
    dec_ref r24
    if is_error(r165) goto L561 (error at coroutine:155) else goto L155
L155:
    r166 = 'eth'
    r167 = CPyObject_GetAttr(r165, r166)
    dec_ref r165
    if is_error(r167) goto L561 (error at coroutine:155) else goto L156
L156:
    r168 = 'to'
    r169 = r22.self
    if is_error(r169) goto L562 (error at coroutine:155) else goto L157
L157:
    r170 = '_address'
    r171 = CPyObject_GetAttr(r169, r170)
    dec_ref r169
    if is_error(r171) goto L562 (error at coroutine:155) else goto L158
L158:
    r172 = 'data'
    r173 = r22.data
    if is_error(r173) goto L563 (error at coroutine:155) else goto L159
L159:
    r174 = CPyDict_Build(2, r168, r171, r172, r173)
    dec_ref r171
    dec_ref r173
    if is_error(r174) goto L562 (error at coroutine:155) else goto L160
L160:
    r175 = r22.block_identifier
    if is_error(r175) goto L564 (error at coroutine:155) else goto L161
L161:
    r176 = 'call'
    r177 = [r167, r174, r175]
    r178 = load_address r177
    r179 = PyObject_VectorcallMethod(r176, r178, 9223372036854775811, 0)
    if is_error(r179) goto L565 (error at coroutine:155) else goto L162
L162:
    dec_ref r167
    dec_ref r174
    dec_ref r175
    r180 = CPy_GetCoro(r179)
    dec_ref r179
    if is_error(r180) goto L561 (error at coroutine:155) else goto L163
L163:
    r22.__mypyc_temp__12 = r180; r181 = is_error
    if not r181 goto L561 (error at coroutine:-1) else goto L164 :: bool
L164:
    r182 = r22.__mypyc_temp__12
    if is_error(r182) goto L561 (error at coroutine:-1) else goto L165
L165:
    r183 = CPyIter_Next(r182)
    dec_ref r182
    if is_error(r183) goto L566 else goto L168
L166:
    r184 = CPy_FetchStopIterationValue()
    if is_error(r184) goto L198 (error at coroutine:155) else goto L167
L167:
    r185 = r184
    goto L197
L168:
    r186 = r183
L169:
    r22.__mypyc_next_label__ = 8; r187 = is_error
    if not r187 goto L567 (error at coroutine:155) else goto L568 :: bool
L170:
    return r186
L171:
    r188 = load_address _Py_NoneStruct
    r189 = type != r188
    if r189 goto L172 else goto L174 :: bool
L172:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L175 (error at coroutine:155) else goto L569 :: bool
L173:
    unreachable
L174:
    inc_ref arg
    goto L192
L175:
    r190 = CPy_CatchError()
    r22.__mypyc_temp__13 = r190; r191 = is_error
    if not r191 goto L570 (error at coroutine:-1) else goto L176 :: bool
L176:
    r192 = load_address r7
    r193 = r22.__mypyc_temp__12
    if is_error(r193) goto L570 (error at coroutine:-1) else goto L177
L177:
    r194 = CPy_YieldFromErrorHandle(r193, r192)
    dec_ref r193
    if is_error(r194) goto L570 (error at coroutine:155) else goto L178
L178:
    if r194 goto L184 else goto L179 :: bool
L179:
    if is_error(r7) goto L180 else goto L182
L180:
    r195 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r195 goto L189 (error at coroutine:-1) else goto L571 :: bool
L181:
    unreachable
L182:
    inc_ref r7
    r186 = r7
    r196 = r22.__mypyc_temp__13
    if is_error(r196) goto L572 (error at coroutine:-1) else goto L183
L183:
    CPy_RestoreExcInfo(r196)
    dec_ref r196
    goto L169
L184:
    if is_error(r7) goto L185 else goto L187
L185:
    r197 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r197 goto L189 (error at coroutine:-1) else goto L573 :: bool
L186:
    unreachable
L187:
    r185 = r7
    r198 = r22.__mypyc_temp__13
    if is_error(r198) goto L574 (error at coroutine:-1) else goto L188
L188:
    CPy_RestoreExcInfo(r198)
    dec_ref r198
    goto L197
L189:
    r199 = r22.__mypyc_temp__13
    if is_error(r199) goto L198 (error at coroutine:-1) else goto L190
L190:
    CPy_RestoreExcInfo(r199)
    dec_ref r199
    r200 = CPy_KeepPropagating()
    if not r200 goto L198 else goto L575 :: bool
L191:
    unreachable
L192:
    r201 = r22.__mypyc_temp__12
    if is_error(r201) goto L576 (error at coroutine:-1) else goto L193
L193:
    r202 = CPyIter_Send(r201, arg)
    dec_ref r201
    dec_ref arg
    if is_error(r202) goto L577 else goto L194
L194:
    r186 = r202
    goto L169
L195:
    r203 = CPy_FetchStopIterationValue()
    if is_error(r203) goto L198 (error at coroutine:155) else goto L196
L196:
    r185 = r203
L197:
    r22.output = r185; r204 = is_error
    if not r204 goto L198 (error at coroutine:155) else goto L578 :: bool
L198:
    r205 = CPy_CatchError()
    r22.__mypyc_temp__14 = r205; r206 = is_error
    if not r206 goto L579 (error at coroutine:-1) else goto L199 :: bool
L199:
    r22.__mypyc_temp__9 = 0; r207 = is_error
    if not r207 goto L579 (error at coroutine:154) else goto L200 :: bool
L200:
    r208 = CPy_GetExcInfo()
    r209 = r208[0]
    r210 = r208[1]
    r211 = r208[2]
    dec_ref r208
    r212 = r22.__mypyc_temp__7
    if is_error(r212) goto L580 (error at coroutine:-1) else goto L201
L201:
    r213 = r22.__mypyc_temp__8
    if is_error(r213) goto L581 (error at coroutine:-1) else goto L202
L202:
    r214 = [r213, r209, r210, r211]
    r215 = load_address r214
    r216 = _PyObject_Vectorcall(r212, r215, 4, 0)
    dec_ref r212
    if is_error(r216) goto L582 (error at coroutine:154) else goto L203
L203:
    dec_ref r213
    dec_ref r209
    dec_ref r210
    dec_ref r211
    r217 = CPy_GetCoro(r216)
    dec_ref r216
    if is_error(r217) goto L579 (error at coroutine:154) else goto L204
L204:
    r22.__mypyc_temp__15 = r217; r218 = is_error
    if not r218 goto L579 (error at coroutine:-1) else goto L205 :: bool
L205:
    r219 = r22.__mypyc_temp__15
    if is_error(r219) goto L579 (error at coroutine:-1) else goto L206
L206:
    r220 = CPyIter_Next(r219)
    dec_ref r219
    if is_error(r220) goto L583 else goto L209
L207:
    r221 = CPy_FetchStopIterationValue()
    if is_error(r221) goto L244 (error at coroutine:154) else goto L208
L208:
    r222 = r221
    goto L238
L209:
    r223 = r220
L210:
    r22.__mypyc_next_label__ = 10; r224 = is_error
    if not r224 goto L584 (error at coroutine:154) else goto L585 :: bool
L211:
    return r223
L212:
    r225 = load_address _Py_NoneStruct
    r226 = type != r225
    if r226 goto L213 else goto L215 :: bool
L213:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L216 (error at coroutine:154) else goto L586 :: bool
L214:
    unreachable
L215:
    inc_ref arg
    goto L233
L216:
    r227 = CPy_CatchError()
    r22.__mypyc_temp__16 = r227; r228 = is_error
    if not r228 goto L587 (error at coroutine:-1) else goto L217 :: bool
L217:
    r229 = load_address r9
    r230 = r22.__mypyc_temp__15
    if is_error(r230) goto L587 (error at coroutine:-1) else goto L218
L218:
    r231 = CPy_YieldFromErrorHandle(r230, r229)
    dec_ref r230
    if is_error(r231) goto L587 (error at coroutine:154) else goto L219
L219:
    if r231 goto L225 else goto L220 :: bool
L220:
    if is_error(r9) goto L221 else goto L223
L221:
    r232 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r232 goto L230 (error at coroutine:-1) else goto L588 :: bool
L222:
    unreachable
L223:
    inc_ref r9
    r223 = r9
    r233 = r22.__mypyc_temp__16
    if is_error(r233) goto L589 (error at coroutine:-1) else goto L224
L224:
    CPy_RestoreExcInfo(r233)
    dec_ref r233
    goto L210
L225:
    if is_error(r9) goto L226 else goto L228
L226:
    r234 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r234 goto L230 (error at coroutine:-1) else goto L590 :: bool
L227:
    unreachable
L228:
    r222 = r9
    r235 = r22.__mypyc_temp__16
    if is_error(r235) goto L591 (error at coroutine:-1) else goto L229
L229:
    CPy_RestoreExcInfo(r235)
    dec_ref r235
    goto L238
L230:
    r236 = r22.__mypyc_temp__16
    if is_error(r236) goto L244 (error at coroutine:-1) else goto L231
L231:
    CPy_RestoreExcInfo(r236)
    dec_ref r236
    r237 = CPy_KeepPropagating()
    if not r237 goto L244 else goto L592 :: bool
L232:
    unreachable
L233:
    r238 = r22.__mypyc_temp__15
    if is_error(r238) goto L593 (error at coroutine:-1) else goto L234
L234:
    r239 = CPyIter_Send(r238, arg)
    dec_ref r238
    dec_ref arg
    if is_error(r239) goto L594 else goto L235
L235:
    r223 = r239
    goto L210
L236:
    r240 = CPy_FetchStopIterationValue()
    if is_error(r240) goto L244 (error at coroutine:154) else goto L237
L237:
    r222 = r240
L238:
    r241 = PyObject_IsTrue(r222)
    dec_ref r222
    r242 = r241 >= 0 :: signed
    if not r242 goto L244 (error at coroutine:-1) else goto L239 :: bool
L239:
    r243 = truncate r241: i32 to builtins.bool
    if r243 goto L242 else goto L240 :: bool
L240:
    CPy_Reraise()
    if not 0 goto L244 else goto L595 :: bool
L241:
    unreachable
L242:
    r244 = r22.__mypyc_temp__14
    if is_error(r244) goto L248 (error at coroutine:-1) else goto L243
L243:
    CPy_RestoreExcInfo(r244)
    dec_ref r244
    goto L247
L244:
    r245 = r22.__mypyc_temp__14
    if is_error(r245) goto L248 (error at coroutine:-1) else goto L245
L245:
    CPy_RestoreExcInfo(r245)
    dec_ref r245
    r246 = CPy_KeepPropagating()
    if not r246 goto L248 else goto L596 :: bool
L246:
    unreachable
L247:
    r247 = <error> :: tuple[object, object, object]
    r13 = r247
    goto L249
L248:
    r248 = CPy_CatchError()
    r13 = r248
L249:
    r249 = r22.__mypyc_temp__9
    if is_error(r249) goto L597 (error at coroutine:-1) else goto L250
L250:
    if r249 goto L251 else goto L598 :: bool
L251:
    r250 = load_address _Py_NoneStruct
    r251 = r22.__mypyc_temp__7
    if is_error(r251) goto L597 (error at coroutine:-1) else goto L252
L252:
    r252 = r22.__mypyc_temp__8
    if is_error(r252) goto L599 (error at coroutine:-1) else goto L253
L253:
    r253 = [r252, r250, r250, r250]
    r254 = load_address r253
    r255 = _PyObject_Vectorcall(r251, r254, 4, 0)
    dec_ref r251
    if is_error(r255) goto L600 (error at coroutine:154) else goto L254
L254:
    dec_ref r252
    r256 = CPy_GetCoro(r255)
    dec_ref r255
    if is_error(r256) goto L597 (error at coroutine:154) else goto L255
L255:
    r22.__mypyc_temp__17 = r256; r257 = is_error
    if not r257 goto L597 (error at coroutine:-1) else goto L256 :: bool
L256:
    r258 = r22.__mypyc_temp__17
    if is_error(r258) goto L597 (error at coroutine:-1) else goto L257
L257:
    r259 = CPyIter_Next(r258)
    dec_ref r258
    if is_error(r259) goto L601 else goto L260
L258:
    r260 = CPy_FetchStopIterationValue()
    if is_error(r260) goto L292 (error at coroutine:154) else goto L259
L259:
    r261 = r260
    dec_ref r261
    goto L289
L260:
    r262 = r259
L261:
    r22.__mypyc_next_label__ = 12; r263 = is_error
    if not r263 goto L602 (error at coroutine:154) else goto L603 :: bool
L262:
    return r262
L263:
    r264 = load_address _Py_NoneStruct
    r265 = type != r264
    if r265 goto L264 else goto L266 :: bool
L264:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L267 (error at coroutine:154) else goto L604 :: bool
L265:
    unreachable
L266:
    inc_ref arg
    goto L284
L267:
    r266 = CPy_CatchError()
    r22.__mypyc_temp__18 = r266; r267 = is_error
    if not r267 goto L605 (error at coroutine:-1) else goto L268 :: bool
L268:
    r268 = load_address r11
    r269 = r22.__mypyc_temp__17
    if is_error(r269) goto L605 (error at coroutine:-1) else goto L269
L269:
    r270 = CPy_YieldFromErrorHandle(r269, r268)
    dec_ref r269
    if is_error(r270) goto L605 (error at coroutine:154) else goto L270
L270:
    if r270 goto L276 else goto L271 :: bool
L271:
    if is_error(r11) goto L272 else goto L274
L272:
    r271 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r271 goto L281 (error at coroutine:-1) else goto L606 :: bool
L273:
    unreachable
L274:
    inc_ref r11
    r262 = r11
    r272 = r22.__mypyc_temp__18
    if is_error(r272) goto L607 (error at coroutine:-1) else goto L275
L275:
    CPy_RestoreExcInfo(r272)
    dec_ref r272
    goto L261
L276:
    if is_error(r11) goto L277 else goto L279
L277:
    r273 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r273 goto L281 (error at coroutine:-1) else goto L608 :: bool
L278:
    unreachable
L279:
    r261 = r11
    dec_ref r261
    r274 = r22.__mypyc_temp__18
    if is_error(r274) goto L281 (error at coroutine:-1) else goto L280
L280:
    CPy_RestoreExcInfo(r274)
    dec_ref r274
    goto L289
L281:
    r275 = r22.__mypyc_temp__18
    if is_error(r275) goto L292 (error at coroutine:-1) else goto L282
L282:
    CPy_RestoreExcInfo(r275)
    dec_ref r275
    r276 = CPy_KeepPropagating()
    if not r276 goto L292 else goto L609 :: bool
L283:
    unreachable
L284:
    r277 = r22.__mypyc_temp__17
    if is_error(r277) goto L610 (error at coroutine:-1) else goto L285
L285:
    r278 = CPyIter_Send(r277, arg)
    dec_ref r277
    dec_ref arg
    if is_error(r278) goto L611 else goto L286
L286:
    r262 = r278
    goto L261
L287:
    r279 = CPy_FetchStopIterationValue()
    if is_error(r279) goto L292 (error at coroutine:154) else goto L288
L288:
    r261 = r279
    dec_ref r261
L289:
    if is_error(r13) goto L612 else goto L290
L290:
    CPy_Reraise()
    if not 0 goto L292 else goto L613 :: bool
L291:
    unreachable
L292:
    if is_error(r13) goto L297 else goto L293
L293:
    if is_error(r13) goto L294 else goto L296
L294:
    r280 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r280 goto L299 (error at coroutine:-1) else goto L614 :: bool
L295:
    unreachable
L296:
    CPy_RestoreExcInfo(r13)
    xdec_ref r13
L297:
    r281 = CPy_KeepPropagating()
    if not r281 goto L299 else goto L615 :: bool
L298:
    unreachable
L299:
    r282 = CPy_CatchError()
    r22.__mypyc_temp__19 = r282; r283 = is_error
    if not r283 goto L616 (error at coroutine:-1) else goto L300 :: bool
L300:
    r22.__mypyc_temp__2 = 0; r284 = is_error
    if not r284 goto L616 (error at coroutine:152) else goto L301 :: bool
L301:
    r285 = CPy_GetExcInfo()
    r286 = r285[0]
    r287 = r285[1]
    r288 = r285[2]
    dec_ref r285
    r289 = r22.__mypyc_temp__0
    if is_error(r289) goto L617 (error at coroutine:-1) else goto L302
L302:
    r290 = r22.__mypyc_temp__1
    if is_error(r290) goto L618 (error at coroutine:-1) else goto L303
L303:
    r291 = [r290, r286, r287, r288]
    r292 = load_address r291
    r293 = _PyObject_Vectorcall(r289, r292, 4, 0)
    dec_ref r289
    if is_error(r293) goto L619 (error at coroutine:152) else goto L304
L304:
    dec_ref r290
    dec_ref r286
    dec_ref r287
    dec_ref r288
    r294 = CPy_GetCoro(r293)
    dec_ref r293
    if is_error(r294) goto L616 (error at coroutine:152) else goto L305
L305:
    r22.__mypyc_temp__20 = r294; r295 = is_error
    if not r295 goto L616 (error at coroutine:-1) else goto L306 :: bool
L306:
    r296 = r22.__mypyc_temp__20
    if is_error(r296) goto L616 (error at coroutine:-1) else goto L307
L307:
    r297 = CPyIter_Next(r296)
    dec_ref r296
    if is_error(r297) goto L620 else goto L310
L308:
    r298 = CPy_FetchStopIterationValue()
    if is_error(r298) goto L345 (error at coroutine:152) else goto L309
L309:
    r299 = r298
    goto L339
L310:
    r300 = r297
L311:
    r22.__mypyc_next_label__ = 14; r301 = is_error
    if not r301 goto L621 (error at coroutine:152) else goto L622 :: bool
L312:
    return r300
L313:
    r302 = load_address _Py_NoneStruct
    r303 = type != r302
    if r303 goto L314 else goto L316 :: bool
L314:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L317 (error at coroutine:152) else goto L623 :: bool
L315:
    unreachable
L316:
    inc_ref arg
    goto L334
L317:
    r304 = CPy_CatchError()
    r22.__mypyc_temp__21 = r304; r305 = is_error
    if not r305 goto L624 (error at coroutine:-1) else goto L318 :: bool
L318:
    r306 = load_address r15
    r307 = r22.__mypyc_temp__20
    if is_error(r307) goto L624 (error at coroutine:-1) else goto L319
L319:
    r308 = CPy_YieldFromErrorHandle(r307, r306)
    dec_ref r307
    if is_error(r308) goto L624 (error at coroutine:152) else goto L320
L320:
    if r308 goto L326 else goto L321 :: bool
L321:
    if is_error(r15) goto L322 else goto L324
L322:
    r309 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r309 goto L331 (error at coroutine:-1) else goto L625 :: bool
L323:
    unreachable
L324:
    inc_ref r15
    r300 = r15
    r310 = r22.__mypyc_temp__21
    if is_error(r310) goto L626 (error at coroutine:-1) else goto L325
L325:
    CPy_RestoreExcInfo(r310)
    dec_ref r310
    goto L311
L326:
    if is_error(r15) goto L327 else goto L329
L327:
    r311 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r311 goto L331 (error at coroutine:-1) else goto L627 :: bool
L328:
    unreachable
L329:
    r299 = r15
    r312 = r22.__mypyc_temp__21
    if is_error(r312) goto L628 (error at coroutine:-1) else goto L330
L330:
    CPy_RestoreExcInfo(r312)
    dec_ref r312
    goto L339
L331:
    r313 = r22.__mypyc_temp__21
    if is_error(r313) goto L345 (error at coroutine:-1) else goto L332
L332:
    CPy_RestoreExcInfo(r313)
    dec_ref r313
    r314 = CPy_KeepPropagating()
    if not r314 goto L345 else goto L629 :: bool
L333:
    unreachable
L334:
    r315 = r22.__mypyc_temp__20
    if is_error(r315) goto L630 (error at coroutine:-1) else goto L335
L335:
    r316 = CPyIter_Send(r315, arg)
    dec_ref r315
    dec_ref arg
    if is_error(r316) goto L631 else goto L336
L336:
    r300 = r316
    goto L311
L337:
    r317 = CPy_FetchStopIterationValue()
    if is_error(r317) goto L345 (error at coroutine:152) else goto L338
L338:
    r299 = r317
L339:
    r318 = PyObject_IsTrue(r299)
    dec_ref r299
    r319 = r318 >= 0 :: signed
    if not r319 goto L345 (error at coroutine:-1) else goto L340 :: bool
L340:
    r320 = truncate r318: i32 to builtins.bool
    if r320 goto L343 else goto L341 :: bool
L341:
    CPy_Reraise()
    if not 0 goto L345 else goto L632 :: bool
L342:
    unreachable
L343:
    r321 = r22.__mypyc_temp__19
    if is_error(r321) goto L349 (error at coroutine:-1) else goto L344
L344:
    CPy_RestoreExcInfo(r321)
    dec_ref r321
    goto L348
L345:
    r322 = r22.__mypyc_temp__19
    if is_error(r322) goto L349 (error at coroutine:-1) else goto L346
L346:
    CPy_RestoreExcInfo(r322)
    dec_ref r322
    r323 = CPy_KeepPropagating()
    if not r323 goto L349 else goto L633 :: bool
L347:
    unreachable
L348:
    r324 = <error> :: tuple[object, object, object]
    r19 = r324
    goto L350
L349:
    r325 = CPy_CatchError()
    r19 = r325
L350:
    r326 = r22.__mypyc_temp__2
    if is_error(r326) goto L634 (error at coroutine:-1) else goto L351
L351:
    if r326 goto L352 else goto L635 :: bool
L352:
    r327 = load_address _Py_NoneStruct
    r328 = r22.__mypyc_temp__0
    if is_error(r328) goto L634 (error at coroutine:-1) else goto L353
L353:
    r329 = r22.__mypyc_temp__1
    if is_error(r329) goto L636 (error at coroutine:-1) else goto L354
L354:
    r330 = [r329, r327, r327, r327]
    r331 = load_address r330
    r332 = _PyObject_Vectorcall(r328, r331, 4, 0)
    dec_ref r328
    if is_error(r332) goto L637 (error at coroutine:152) else goto L355
L355:
    dec_ref r329
    r333 = CPy_GetCoro(r332)
    dec_ref r332
    if is_error(r333) goto L634 (error at coroutine:152) else goto L356
L356:
    r22.__mypyc_temp__22 = r333; r334 = is_error
    if not r334 goto L634 (error at coroutine:-1) else goto L357 :: bool
L357:
    r335 = r22.__mypyc_temp__22
    if is_error(r335) goto L634 (error at coroutine:-1) else goto L358
L358:
    r336 = CPyIter_Next(r335)
    dec_ref r335
    if is_error(r336) goto L638 else goto L361
L359:
    r337 = CPy_FetchStopIterationValue()
    if is_error(r337) goto L639 (error at coroutine:152) else goto L360
L360:
    r338 = r337
    dec_ref r338
    goto L390
L361:
    r339 = r336
L362:
    r22.__mypyc_next_label__ = 16; r340 = is_error
    if not r340 goto L640 (error at coroutine:152) else goto L641 :: bool
L363:
    return r339
L364:
    r341 = load_address _Py_NoneStruct
    r342 = type != r341
    if r342 goto L365 else goto L367 :: bool
L365:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L368 (error at coroutine:152) else goto L642 :: bool
L366:
    unreachable
L367:
    inc_ref arg
    goto L385
L368:
    r343 = CPy_CatchError()
    r22.__mypyc_temp__23 = r343; r344 = is_error
    if not r344 goto L643 (error at coroutine:-1) else goto L369 :: bool
L369:
    r345 = load_address r17
    r346 = r22.__mypyc_temp__22
    if is_error(r346) goto L643 (error at coroutine:-1) else goto L370
L370:
    r347 = CPy_YieldFromErrorHandle(r346, r345)
    dec_ref r346
    if is_error(r347) goto L643 (error at coroutine:152) else goto L371
L371:
    if r347 goto L377 else goto L372 :: bool
L372:
    if is_error(r17) goto L644 else goto L375
L373:
    r348 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r348 goto L382 (error at coroutine:-1) else goto L645 :: bool
L374:
    unreachable
L375:
    inc_ref r17
    r339 = r17
    r349 = r22.__mypyc_temp__23
    if is_error(r349) goto L646 (error at coroutine:-1) else goto L376
L376:
    CPy_RestoreExcInfo(r349)
    dec_ref r349
    goto L362
L377:
    if is_error(r17) goto L647 else goto L380
L378:
    r350 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r350 goto L382 (error at coroutine:-1) else goto L648 :: bool
L379:
    unreachable
L380:
    r338 = r17
    dec_ref r338
    r351 = r22.__mypyc_temp__23
    if is_error(r351) goto L649 (error at coroutine:-1) else goto L381
L381:
    CPy_RestoreExcInfo(r351)
    dec_ref r351
    goto L390
L382:
    r352 = r22.__mypyc_temp__23
    dec_ref r22
    if is_error(r352) goto L393 (error at coroutine:-1) else goto L383
L383:
    CPy_RestoreExcInfo(r352)
    dec_ref r352
    r353 = CPy_KeepPropagating()
    if not r353 goto L393 else goto L650 :: bool
L384:
    unreachable
L385:
    r354 = r22.__mypyc_temp__22
    if is_error(r354) goto L651 (error at coroutine:-1) else goto L386
L386:
    r355 = CPyIter_Send(r354, arg)
    dec_ref r354
    dec_ref arg
    if is_error(r355) goto L652 else goto L387
L387:
    r339 = r355
    goto L362
L388:
    r356 = CPy_FetchStopIterationValue()
    if is_error(r356) goto L639 (error at coroutine:152) else goto L389
L389:
    r338 = r356
    dec_ref r338
L390:
    if is_error(r19) goto L400 else goto L653
L391:
    CPy_Reraise()
    if not 0 goto L393 else goto L654 :: bool
L392:
    unreachable
L393:
    if is_error(r19) goto L398 else goto L394
L394:
    if is_error(r19) goto L395 else goto L397
L395:
    r357 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r357 goto L488 (error at coroutine:-1) else goto L396 :: bool
L396:
    unreachable
L397:
    CPy_RestoreExcInfo(r19)
    xdec_ref r19
L398:
    r358 = CPy_KeepPropagating()
    if not r358 goto L488 else goto L399 :: bool
L399:
    unreachable
L400:
    r359 = r22.self
    if is_error(r359) goto L655 (error at coroutine:157) else goto L401
L401:
    r360 = r22.output
    if is_error(r360) goto L656 (error at coroutine:157) else goto L402
L402:
    r361 = cast(bytes, r360)
    if is_error(r361) goto L656 (error at coroutine:157) else goto L403
L403:
    r362 = decode_output(r359, r361)
    dec_ref r359
    dec_ref r361
    if is_error(r362) goto L655 (error at coroutine:157) else goto L404
L404:
    r363 = CPy_GetCoro(r362)
    dec_ref r362
    if is_error(r363) goto L655 (error at coroutine:157) else goto L405
L405:
    r22.__mypyc_temp__24 = r363; r364 = is_error
    if not r364 goto L655 (error at coroutine:-1) else goto L406 :: bool
L406:
    r365 = r22.__mypyc_temp__24
    if is_error(r365) goto L655 (error at coroutine:-1) else goto L407
L407:
    r366 = CPyIter_Next(r365)
    dec_ref r365
    if is_error(r366) goto L657 else goto L410
L408:
    r367 = CPy_FetchStopIterationValue()
    if is_error(r367) goto L440 (error at coroutine:157) else goto L409
L409:
    r368 = r367
    goto L439
L410:
    r369 = r366
L411:
    r22.__mypyc_next_label__ = 18; r370 = is_error
    if not r370 goto L658 (error at coroutine:157) else goto L659 :: bool
L412:
    return r369
L413:
    r371 = load_address _Py_NoneStruct
    r372 = type != r371
    if r372 goto L414 else goto L416 :: bool
L414:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L417 (error at coroutine:157) else goto L660 :: bool
L415:
    unreachable
L416:
    inc_ref arg
    goto L434
L417:
    r373 = CPy_CatchError()
    r22.__mypyc_temp__25 = r373; r374 = is_error
    if not r374 goto L661 (error at coroutine:-1) else goto L418 :: bool
L418:
    r375 = load_address r21
    r376 = r22.__mypyc_temp__24
    if is_error(r376) goto L661 (error at coroutine:-1) else goto L419
L419:
    r377 = CPy_YieldFromErrorHandle(r376, r375)
    dec_ref r376
    if is_error(r377) goto L661 (error at coroutine:157) else goto L420
L420:
    if r377 goto L426 else goto L421 :: bool
L421:
    if is_error(r21) goto L422 else goto L424
L422:
    r378 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r378 goto L431 (error at coroutine:-1) else goto L662 :: bool
L423:
    unreachable
L424:
    inc_ref r21
    r369 = r21
    r379 = r22.__mypyc_temp__25
    if is_error(r379) goto L663 (error at coroutine:-1) else goto L425
L425:
    CPy_RestoreExcInfo(r379)
    dec_ref r379
    goto L411
L426:
    if is_error(r21) goto L427 else goto L429
L427:
    r380 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r380 goto L431 (error at coroutine:-1) else goto L664 :: bool
L428:
    unreachable
L429:
    r368 = r21
    r381 = r22.__mypyc_temp__25
    if is_error(r381) goto L665 (error at coroutine:-1) else goto L430
L430:
    CPy_RestoreExcInfo(r381)
    dec_ref r381
    goto L439
L431:
    r382 = r22.__mypyc_temp__25
    if is_error(r382) goto L440 (error at coroutine:-1) else goto L432
L432:
    CPy_RestoreExcInfo(r382)
    dec_ref r382
    r383 = CPy_KeepPropagating()
    if not r383 goto L440 else goto L666 :: bool
L433:
    unreachable
L434:
    r384 = r22.__mypyc_temp__24
    if is_error(r384) goto L667 (error at coroutine:-1) else goto L435
L435:
    r385 = CPyIter_Send(r384, arg)
    dec_ref r384
    dec_ref arg
    if is_error(r385) goto L668 else goto L436
L436:
    r369 = r385
    goto L411
L437:
    r386 = CPy_FetchStopIterationValue()
    if is_error(r386) goto L440 (error at coroutine:157) else goto L438
L438:
    r368 = r386
L439:
    r22.decoded = r368; r387 = is_error
    if not r387 goto L440 (error at coroutine:157) else goto L459 :: bool
L440:
    r388 = CPy_CatchError()
    r22.__mypyc_temp__26 = r388; r389 = is_error
    if not r389 goto L456 (error at coroutine:-1) else goto L441 :: bool
L441:
    r390 = dank_mids.brownie_patch.call.globals :: static
    r391 = 'InsufficientDataBytes'
    r392 = CPyDict_GetItem(r390, r391)
    if is_error(r392) goto L456 (error at coroutine:158) else goto L442
L442:
    r393 = CPy_ExceptionMatches(r392)
    dec_ref r392
    if r393 goto L443 else goto L454 :: bool
L443:
    r394 = CPy_GetExcValue()
    r22.e = r394; r395 = is_error
    if not r395 goto L456 (error at coroutine:158) else goto L444 :: bool
L444:
    r396 = r22.e
    if is_error(r396) goto L456 (error at coroutine:159) else goto L445
L445:
    r397 = PyObject_Str(r396)
    dec_ref r396
    if is_error(r397) goto L456 (error at coroutine:159) else goto L446
L446:
    r398 = r22.self
    if is_error(r398) goto L669 (error at coroutine:159) else goto L447
L447:
    r399 = r22.self
    if is_error(r399) goto L670 (error at coroutine:159) else goto L448
L448:
    r400 = '_address'
    r401 = CPyObject_GetAttr(r399, r400)
    dec_ref r399
    if is_error(r401) goto L670 (error at coroutine:159) else goto L449
L449:
    r402 = r22.output
    if is_error(r402) goto L671 (error at coroutine:159) else goto L450
L450:
    r403 = dank_mids.brownie_patch.call.globals :: static
    r404 = 'InsufficientDataBytes'
    r405 = CPyDict_GetItem(r403, r404)
    if is_error(r405) goto L672 (error at coroutine:159) else goto L451
L451:
    r406 = [r397, r398, r401, r402]
    r407 = load_address r406
    r408 = _PyObject_Vectorcall(r405, r407, 4, 0)
    dec_ref r405
    if is_error(r408) goto L672 (error at coroutine:159) else goto L452
L452:
    dec_ref r397
    dec_ref r398
    dec_ref r401
    dec_ref r402
    CPy_Raise(r408)
    dec_ref r408
    if not 0 goto L456 (error at coroutine:159) else goto L673 :: bool
L453:
    unreachable
L454:
    CPy_Reraise()
    if not 0 goto L456 else goto L674 :: bool
L455:
    unreachable
L456:
    r409 = r22.__mypyc_temp__26
    dec_ref r22
    if is_error(r409) goto L488 (error at coroutine:-1) else goto L457
L457:
    CPy_RestoreExcInfo(r409)
    dec_ref r409
    r410 = CPy_KeepPropagating()
    if not r410 goto L488 else goto L458 :: bool
L458:
    unreachable
L459:
    r411 = r22.decimals
    if is_error(r411) goto L675 (error at coroutine:161) else goto L460
L460:
    r412 = load_address _Py_NoneStruct
    r413 = r411 == r412
    dec_ref r411
    if r413 goto L461 else goto L463 :: bool
L461:
    r414 = r22.decoded
    if is_error(r414) goto L675 (error at coroutine:161) else goto L462
L462:
    r415 = r414
    goto L473
L463:
    r416 = r22.decoded
    if is_error(r416) goto L675 (error at coroutine:161) else goto L464
L464:
    r417 = r22.decimals
    if is_error(r417) goto L676 (error at coroutine:161) else goto L465
L465:
    r418 = unbox(int, r417)
    dec_ref r417
    if is_error(r418) goto L676 (error at coroutine:161) else goto L466
L466:
    r419 = dank_mids.brownie_patch.call.Decimal :: static
    if is_error(r419) goto L677 else goto L469
L467:
    r420 = raise NameError('value for final name "Decimal" was not set')
    if not r420 goto L488 (error at coroutine:161) else goto L468 :: bool
L468:
    unreachable
L469:
    r421 = box(int, r418)
    r422 = [r421]
    r423 = load_address r422
    r424 = _PyObject_Vectorcall(r419, r423, 1, 0)
    if is_error(r424) goto L678 (error at coroutine:161) else goto L470
L470:
    dec_ref r421
    r425 = object 10
    r426 = CPyNumber_Power(r425, r424)
    dec_ref r424
    if is_error(r426) goto L676 (error at coroutine:161) else goto L471
L471:
    r427 = PyNumber_TrueDivide(r416, r426)
    dec_ref r416
    dec_ref r426
    if is_error(r427) goto L675 (error at coroutine:161) else goto L472
L472:
    r415 = r427
L473:
    r22.__mypyc_next_label__ = -2; r428 = is_error
    dec_ref r22
    if not r428 goto L679 (error at coroutine:161) else goto L474 :: bool
L474:
    CPyGen_SetStopIterationValue(r415)
    dec_ref r415
    if not 0 goto L488 else goto L475 :: bool
L475:
    unreachable
L476:
    r429 = r23 == 0
    if r429 goto L680 else goto L477 :: bool
L477:
    r430 = r23 == 2
    if r430 goto L681 else goto L682 :: bool
L478:
    r431 = r23 == 4
    if r431 goto L683 else goto L684 :: bool
L479:
    r432 = r23 == 6
    if r432 goto L685 else goto L686 :: bool
L480:
    r433 = r23 == 8
    if r433 goto L687 else goto L688 :: bool
L481:
    r434 = r23 == 10
    if r434 goto L689 else goto L690 :: bool
L482:
    r435 = r23 == 12
    if r435 goto L691 else goto L692 :: bool
L483:
    r436 = r23 == 14
    if r436 goto L693 else goto L694 :: bool
L484:
    r437 = r23 == 16
    if r437 goto L695 else goto L696 :: bool
L485:
    r438 = r23 == 18
    dec_ref r23 :: int
    if r438 goto L413 else goto L697 :: bool
L486:
    r439 = raise StopIteration
    if not r439 goto L488 (error at coroutine:143) else goto L487 :: bool
L487:
    unreachable
L488:
    r440 = <error> :: object
    return r440
L489:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    goto L488
L490:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    dec_ref r22
    goto L488
L491:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    dec_ref r22
    dec_ref r23 :: int
    goto L488
L492:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L4
L493:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L488
L494:
    dec_ref r27
    goto L14
L495:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L10
L496:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L15
L497:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    dec_ref r44
    goto L488
L498:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    dec_ref r46
    dec_ref r47
    goto L488
L499:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    dec_ref r46
    goto L488
L500:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    dec_ref r55
    goto L488
L501:
    xdec_ref r1
    goto L30
L502:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L488
L503:
    dec_ref r64
    goto L39
L504:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L34
L505:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L37
L506:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r24
    goto L53
L507:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r24
    goto L44
L508:
    dec_ref r22
    goto L45
L509:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r24
    dec_ref r64
    goto L53
L510:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r24
    goto L49
L511:
    dec_ref r22
    goto L50
L512:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r24
    goto L53
L513:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    dec_ref arg
    goto L488
L514:
    xdec_ref r1
    goto L59
L515:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L299
L516:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r82
    goto L299
L517:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r82
    dec_ref r83 :: int
    goto L299
L518:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r82
    dec_ref r83 :: int
    dec_ref r84
    goto L299
L519:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r82
    dec_ref r83 :: int
    dec_ref r84
    dec_ref r85
    goto L299
L520:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r82
    dec_ref r83 :: int
    dec_ref r84
    dec_ref r85
    dec_ref r88
    goto L299
L521:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r88
    dec_ref r89
    goto L299
L522:
    dec_ref r95
    goto L68
L523:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r88
    goto L299
L524:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r88
    dec_ref r96
    goto L299
L525:
    xdec_ref r3
    goto L75
L526:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L299
L527:
    dec_ref r105
    goto L84
L528:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L79
L529:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L82
L530:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L98
L531:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L89
L532:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L90
L533:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r105
    goto L98
L534:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L94
L535:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L95
L536:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r104
    goto L98
L537:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L100
L538:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref arg
    goto L299
L539:
    xdec_ref r3
    goto L104
L540:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L108
L541:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L109
L542:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r127
    goto L299
L543:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r129
    dec_ref r130
    goto L299
L544:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r129
    goto L299
L545:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r138
    goto L299
L546:
    xdec_ref r5
    goto L123
L547:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L299
L548:
    dec_ref r147
    goto L132
L549:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L127
L550:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L130
L551:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L146
L552:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L137
L553:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L138
L554:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r147
    goto L146
L555:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L142
L556:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L143
L557:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L146
L558:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L148
L559:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref arg
    goto L299
L560:
    xdec_ref r5
    goto L152
L561:
    xdec_ref r7
    goto L198
L562:
    xdec_ref r7
    dec_ref r167
    goto L198
L563:
    xdec_ref r7
    dec_ref r167
    dec_ref r171
    goto L198
L564:
    xdec_ref r7
    dec_ref r167
    dec_ref r174
    goto L198
L565:
    xdec_ref r7
    dec_ref r167
    dec_ref r174
    dec_ref r175
    goto L198
L566:
    xdec_ref r7
    goto L166
L567:
    dec_ref r186
    goto L175
L568:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L170
L569:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L173
L570:
    xdec_ref r7
    goto L189
L571:
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L181
L572:
    xdec_ref r7
    dec_ref r186
    goto L189
L573:
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L186
L574:
    dec_ref r185
    goto L189
L575:
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L191
L576:
    xdec_ref r7
    dec_ref arg
    goto L198
L577:
    xdec_ref r7
    goto L195
L578:
    xdec_ref r9
    goto L247
L579:
    xdec_ref r9
    goto L244
L580:
    xdec_ref r9
    dec_ref r209
    dec_ref r210
    dec_ref r211
    goto L244
L581:
    xdec_ref r9
    dec_ref r209
    dec_ref r210
    dec_ref r211
    dec_ref r212
    goto L244
L582:
    xdec_ref r9
    dec_ref r209
    dec_ref r210
    dec_ref r211
    dec_ref r213
    goto L244
L583:
    xdec_ref r9
    goto L207
L584:
    dec_ref r223
    goto L216
L585:
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L211
L586:
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L214
L587:
    xdec_ref r9
    goto L230
L588:
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L222
L589:
    xdec_ref r9
    dec_ref r223
    goto L230
L590:
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L227
L591:
    dec_ref r222
    goto L230
L592:
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L232
L593:
    xdec_ref r9
    dec_ref arg
    goto L244
L594:
    xdec_ref r9
    goto L236
L595:
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L241
L596:
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L246
L597:
    xdec_ref r11
    goto L292
L598:
    xdec_ref r11
    goto L289
L599:
    xdec_ref r11
    dec_ref r251
    goto L292
L600:
    xdec_ref r11
    dec_ref r252
    goto L292
L601:
    xdec_ref r11
    goto L258
L602:
    dec_ref r262
    goto L267
L603:
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L262
L604:
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L265
L605:
    xdec_ref r11
    goto L281
L606:
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L273
L607:
    xdec_ref r11
    dec_ref r262
    goto L281
L608:
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L278
L609:
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L283
L610:
    xdec_ref r11
    dec_ref arg
    goto L292
L611:
    xdec_ref r11
    goto L287
L612:
    xdec_ref r15
    goto L348
L613:
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L291
L614:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L295
L615:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L298
L616:
    xdec_ref r15
    goto L345
L617:
    xdec_ref r15
    dec_ref r286
    dec_ref r287
    dec_ref r288
    goto L345
L618:
    xdec_ref r15
    dec_ref r286
    dec_ref r287
    dec_ref r288
    dec_ref r289
    goto L345
L619:
    xdec_ref r15
    dec_ref r286
    dec_ref r287
    dec_ref r288
    dec_ref r290
    goto L345
L620:
    xdec_ref r15
    goto L308
L621:
    dec_ref r300
    goto L317
L622:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L312
L623:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L315
L624:
    xdec_ref r15
    goto L331
L625:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L323
L626:
    xdec_ref r15
    dec_ref r300
    goto L331
L627:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L328
L628:
    dec_ref r299
    goto L331
L629:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L333
L630:
    xdec_ref r15
    dec_ref arg
    goto L345
L631:
    xdec_ref r15
    goto L337
L632:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L342
L633:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L347
L634:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L393
L635:
    xdec_ref r17
    goto L390
L636:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r328
    goto L393
L637:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r329
    goto L393
L638:
    xdec_ref r17
    goto L359
L639:
    xdec_ref r21
    dec_ref r22
    goto L393
L640:
    dec_ref r339
    goto L368
L641:
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    dec_ref r22
    goto L363
L642:
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    dec_ref r22
    goto L366
L643:
    xdec_ref r17
    xdec_ref r21
    goto L382
L644:
    xdec_ref r21
    goto L373
L645:
    xdec_ref r19
    dec_ref r22
    goto L374
L646:
    xdec_ref r17
    xdec_ref r21
    dec_ref r339
    goto L382
L647:
    xdec_ref r21
    goto L378
L648:
    xdec_ref r19
    dec_ref r22
    goto L379
L649:
    xdec_ref r21
    goto L382
L650:
    xdec_ref r19
    goto L384
L651:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref arg
    goto L393
L652:
    xdec_ref r17
    goto L388
L653:
    xdec_ref r21
    dec_ref r22
    goto L391
L654:
    xdec_ref r19
    goto L392
L655:
    xdec_ref r21
    goto L440
L656:
    xdec_ref r21
    dec_ref r359
    goto L440
L657:
    xdec_ref r21
    goto L408
L658:
    dec_ref r369
    goto L417
L659:
    xdec_ref r21
    dec_ref r22
    goto L412
L660:
    xdec_ref r21
    dec_ref r22
    goto L415
L661:
    xdec_ref r21
    goto L431
L662:
    dec_ref r22
    goto L423
L663:
    xdec_ref r21
    dec_ref r369
    goto L431
L664:
    dec_ref r22
    goto L428
L665:
    dec_ref r368
    goto L431
L666:
    dec_ref r22
    goto L433
L667:
    xdec_ref r21
    dec_ref arg
    goto L440
L668:
    xdec_ref r21
    goto L437
L669:
    dec_ref r397
    goto L456
L670:
    dec_ref r397
    dec_ref r398
    goto L456
L671:
    dec_ref r397
    dec_ref r398
    dec_ref r401
    goto L456
L672:
    dec_ref r397
    dec_ref r398
    dec_ref r401
    dec_ref r402
    goto L456
L673:
    dec_ref r22
    goto L453
L674:
    dec_ref r22
    goto L455
L675:
    dec_ref r22
    goto L488
L676:
    dec_ref r22
    dec_ref r416
    goto L488
L677:
    dec_ref r22
    dec_ref r416
    dec_ref r418 :: int
    goto L467
L678:
    dec_ref r22
    dec_ref r416
    dec_ref r421
    goto L488
L679:
    dec_ref r415
    goto L488
L680:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L3
L681:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L35
L682:
    xdec_ref r1
    goto L478
L683:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L80
L684:
    xdec_ref r3
    goto L479
L685:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L128
L686:
    xdec_ref r5
    dec_ref r24
    goto L480
L687:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L171
L688:
    xdec_ref r7
    goto L481
L689:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L212
L690:
    xdec_ref r9
    goto L482
L691:
    xdec_ref r19
    dec_ref r23 :: int
    goto L263
L692:
    xdec_ref r11
    xdec_ref r13
    goto L483
L693:
    xdec_ref r19
    dec_ref r23 :: int
    goto L313
L694:
    xdec_ref r15
    goto L484
L695:
    dec_ref r23 :: int
    goto L364
L696:
    xdec_ref r17
    xdec_ref r19
    goto L485
L697:
    xdec_ref r21
    dec_ref r22
    goto L486

def coroutine__get_coroutine_fn_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine__get_coroutine_fn_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine__get_coroutine_fn_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine__get_coroutine_fn_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine__get_coroutine_fn_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine__get_coroutine_fn_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutine__get_coroutine_fn_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutine__get_coroutine_fn_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def coroutine__get_coroutine_fn_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine__get_coroutine_fn_obj.__call__(__mypyc_self__, self, args, block_identifier, decimals, override):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_obj
    self :: object
    args :: tuple
    block_identifier :: union[object, None]
    decimals :: union[int, None]
    override :: union[dict, None]
    r0 :: dank_mids.brownie_patch.call._get_coroutine_fn_env
    r1, r2, r3 :: object
    r4 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_env
    r5, r6, r7, r8, r9, r10 :: bool
    r11 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    r12, r13 :: bool
    r14 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L18 (error at coroutine:143) else goto L1
L1:
    if is_error(block_identifier) goto L2 else goto L19
L2:
    r1 = box(None, 1)
    inc_ref r1
    block_identifier = r1
L3:
    if is_error(decimals) goto L4 else goto L20
L4:
    r2 = box(None, 1)
    inc_ref r2
    decimals = r2
L5:
    if is_error(override) goto L6 else goto L21
L6:
    r3 = box(None, 1)
    inc_ref r3
    override = r3
L7:
    r4 = coroutine__get_coroutine_fn_env()
    if is_error(r4) goto L22 (error at coroutine:143) else goto L8
L8:
    r4.__mypyc_env__ = r0; r5 = is_error
    if not r5 goto L23 (error at coroutine:143) else goto L9 :: bool
L9:
    inc_ref self
    r4.self = self; r6 = is_error
    if not r6 goto L23 (error at coroutine:143) else goto L10 :: bool
L10:
    inc_ref args
    r4.args = args; r7 = is_error
    if not r7 goto L23 (error at coroutine:143) else goto L11 :: bool
L11:
    r4.block_identifier = block_identifier; r8 = is_error
    if not r8 goto L24 (error at coroutine:143) else goto L12 :: bool
L12:
    r4.decimals = decimals; r9 = is_error
    if not r9 goto L25 (error at coroutine:143) else goto L13 :: bool
L13:
    r4.override = override; r10 = is_error
    if not r10 goto L26 (error at coroutine:143) else goto L14 :: bool
L14:
    r11 = coroutine__get_coroutine_fn_gen()
    if is_error(r11) goto L26 (error at coroutine:143) else goto L15
L15:
    inc_ref r4
    r11.__mypyc_env__ = r4; r12 = is_error
    if not r12 goto L27 (error at coroutine:143) else goto L16 :: bool
L16:
    r4.__mypyc_next_label__ = 0; r13 = is_error
    dec_ref r4
    if not r13 goto L28 (error at coroutine:143) else goto L17 :: bool
L17:
    return r11
L18:
    r14 = <error> :: object
    return r14
L19:
    inc_ref block_identifier
    goto L3
L20:
    inc_ref decimals
    goto L5
L21:
    inc_ref override
    goto L7
L22:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r0
    goto L18
L23:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L18
L24:
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L18
L25:
    dec_ref override
    dec_ref r4
    goto L18
L26:
    dec_ref r4
    goto L18
L27:
    dec_ref r4
    dec_ref r11
    goto L18
L28:
    dec_ref r11
    goto L18

def _get_coroutine_fn(w3, len_inputs):
    w3 :: object
    len_inputs :: int
    r0 :: dank_mids.brownie_patch.call._get_coroutine_fn_env
    r1, r2, r3, r4 :: bool
    r5 :: int
    r6 :: bit
    r7 :: object
    r8, r9 :: bool
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: bool
    r14 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_obj
    r15 :: bool
    coroutine, r16 :: object
L0:
    r0 = _get_coroutine_fn_env()
    if is_error(r0) goto L18 (error at _get_coroutine_fn:137) else goto L1
L1:
    inc_ref w3
    r0.w3 = w3; r1 = is_error
    if not r1 goto L19 (error at _get_coroutine_fn:137) else goto L2 :: bool
L2:
    inc_ref len_inputs :: int
    r0.len_inputs = len_inputs; r2 = is_error
    if not r2 goto L19 (error at _get_coroutine_fn:137) else goto L3 :: bool
L3:
    r3 = dank_mids.brownie_patch.call.APPLICATION_MODE :: static
    if is_error(r3) goto L20 else goto L6
L4:
    r4 = raise NameError('value for final name "APPLICATION_MODE" was not set')
    if not r4 goto L18 (error at _get_coroutine_fn:138) else goto L5 :: bool
L5:
    unreachable
L6:
    if r3 goto L9 else goto L7 :: bool
L7:
    r5 = r0.len_inputs
    if is_error(r5) goto L19 (error at _get_coroutine_fn:138) else goto L8
L8:
    r6 = r5 != 0
    dec_ref r5 :: int
    if r6 goto L9 else goto L13 :: bool
L9:
    r7 = dank_mids.brownie_patch.call.encode :: static
    if is_error(r7) goto L21 else goto L12
L10:
    r8 = raise NameError('value for final name "encode" was not set')
    if not r8 goto L18 (error at _get_coroutine_fn:139) else goto L11 :: bool
L11:
    unreachable
L12:
    inc_ref r7
    r0.get_request_data = r7; r9 = is_error
    if not r9 goto L19 (error at _get_coroutine_fn:139) else goto L15 :: bool
L13:
    r10 = dank_mids.brownie_patch.call.globals :: static
    r11 = '_request_data_no_args'
    r12 = CPyDict_GetItem(r10, r11)
    if is_error(r12) goto L19 (error at _get_coroutine_fn:141) else goto L14
L14:
    r0.get_request_data = r12; r13 = is_error
    if not r13 goto L19 (error at _get_coroutine_fn:141) else goto L15 :: bool
L15:
    r14 = coroutine__get_coroutine_fn_obj()
    if is_error(r14) goto L19 (error at _get_coroutine_fn:143) else goto L16
L16:
    r14.__mypyc_env__ = r0; r15 = is_error
    if not r15 goto L22 (error at _get_coroutine_fn:143) else goto L17 :: bool
L17:
    coroutine = r14
    return coroutine
L18:
    r16 = <error> :: object
    return r16
L19:
    dec_ref r0
    goto L18
L20:
    dec_ref r0
    goto L4
L21:
    dec_ref r0
    goto L10
L22:
    dec_ref r14
    goto L18

def _call_no_args(self):
    self :: object
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4 :: str
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
L0:
    r0 = 'coroutine'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L3 (error at _call_no_args:168) else goto L1
L1:
    r4 = '__await__'
    r5 = [r3]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r4, r6, 9223372036854775809, 0)
    if is_error(r7) goto L4 (error at _call_no_args:168) else goto L2
L2:
    dec_ref r3
    return r7
L3:
    r8 = <error> :: object
    return r8
L4:
    dec_ref r3
    goto L3

def encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    type, value, traceback, arg, r0, r1 :: object
    r2 :: dank_mids.brownie_patch.call.encode_input_env
    r3 :: int
    r4 :: object
    r5 :: bit
    r6 :: bool
    r7 :: tuple
    r8, r9 :: bool
    r10 :: tuple
    r11 :: ptr
    r12 :: native_int
    r13, r14 :: short_int
    r15 :: bit
    r16 :: tuple
    r17 :: short_int
    r18 :: object
    r19 :: bool
    r20, r21 :: object
    r22 :: bool
    r23 :: i32
    r24 :: bit
    r25 :: bool
    r26 :: object
    r27 :: str
    r28 :: bool
    r29, r30 :: short_int
    r31 :: bool
    r32 :: object
    r33 :: str
    r34, r35 :: object
    r36 :: str
    r37 :: object
    r38 :: tuple
    r39 :: dict
    r40 :: str
    r41 :: object
    r42 :: list
    r43, r44, r45 :: ptr
    r46 :: object
    r47 :: tuple
    r48 :: dict
    r49 :: object
    r50 :: bool
    r51 :: object
    r52 :: tuple
    r53 :: object
    r54 :: list
    r55, r56 :: ptr
    r57 :: object
    r58 :: tuple
    r59 :: dict
    r60, r61 :: object
    r62 :: bool
    r63, r64, r65, r66, r67 :: object
    r68 :: bool
    r69 :: object
    r70 :: bit
    r71 :: tuple[object, object, object]
    r72 :: bool
    r73 :: object_ptr
    r74 :: object
    r75, r76 :: bool
    r77 :: tuple[object, object, object]
    r78 :: bool
    r79, r80 :: tuple[object, object, object]
    r81 :: bit
    r82, r83, r84 :: object
    r85 :: bool
    r86 :: tuple[object, object, object]
    r87 :: bool
    r88 :: object
    r89 :: str
    r90, r91 :: object
    r92 :: str
    r93 :: object
    r94 :: tuple[object, object]
    r95 :: object
    r96 :: bit
    r97 :: object
    r98 :: str
    r99, r100 :: object
    r101 :: str
    r102 :: object
    r103 :: tuple
    r104 :: dict
    r105 :: str
    r106 :: object
    r107 :: list
    r108, r109, r110 :: ptr
    r111 :: object
    r112 :: tuple
    r113 :: dict
    r114 :: object
    r115 :: bool
    r116 :: dict
    r117 :: str
    r118 :: object
    r119 :: bit
    r120 :: object
    r121 :: bool
    r122 :: str
    r123 :: object
    r124 :: bool
    r125 :: str
    r126, r127, r128 :: object
    r129 :: str
    r130 :: object
    r131 :: str
    r132 :: object[5]
    r133 :: object_ptr
    r134, r135 :: object
    r136 :: bool
    r137 :: str
    r138 :: object
    r139 :: str
    r140 :: object
    r141 :: dict
    r142 :: str
    r143 :: object
    r144 :: object[1]
    r145 :: object_ptr
    r146, r147 :: object
    r148 :: bool
    r149 :: str
    r150 :: i32
    r151 :: bit
    r152 :: int
    r153 :: bit
    r154 :: object
    r155 :: str
    r156, r157 :: object
    r158 :: str
    r159 :: object
    r160 :: tuple
    r161 :: dict
    r162 :: str
    r163 :: object
    r164 :: list
    r165, r166, r167 :: ptr
    r168 :: object
    r169 :: tuple
    r170 :: dict
    r171, r172, r173 :: object
    r174 :: str
    r175 :: object
    r176 :: bool
    r177 :: dict
    r178 :: str
    r179 :: object
    r180 :: bit
    r181 :: int
    r182 :: bit
    r183 :: object
    r184 :: str
    r185, r186 :: object
    r187 :: str
    r188 :: object
    r189 :: tuple
    r190 :: dict
    r191 :: str
    r192 :: object
    r193 :: list
    r194, r195, r196 :: ptr
    r197 :: object
    r198 :: tuple
    r199 :: dict
    r200, r201, r202 :: object
    r203 :: str
    r204 :: object
    r205 :: bool
    r206, r207 :: tuple[object, object, object]
    r208 :: bit
    r209, r210 :: object
    r211 :: str
    r212 :: object
    r213 :: i32
    r214 :: bit
    r215 :: bool
    r216, r217 :: object
    r218 :: bool
    r219, r220 :: bit
    r221 :: bool
    r222 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_env__
    if is_error(r2) goto L185 (error at encode_input:171) else goto L1
L1:
    r3 = r2.__mypyc_next_label__
    if is_error(r3) goto L186 (error at encode_input:171) else goto L180
L2:
    r4 = load_address _Py_NoneStruct
    r5 = type != r4
    if r5 goto L187 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L184 (error at encode_input:171) else goto L4 :: bool
L4:
    unreachable
L5:
    r6 = 0
    r7 = r2.args
    if is_error(r7) goto L186 (error at encode_input:173) else goto L6
L6:
    r2.__mypyc_temp__27 = r7; r8 = is_error
    if not r8 goto L186 (error at encode_input:-1) else goto L7 :: bool
L7:
    r2.__mypyc_temp__28 = 0; r9 = is_error
    if not r9 goto L186 (error at encode_input:-1) else goto L8 :: bool
L8:
    r10 = r2.__mypyc_temp__27
    if is_error(r10) goto L186 (error at encode_input:173) else goto L9
L9:
    r11 = get_element_ptr r10 ob_size :: PyVarObject
    r12 = load_mem r11 :: native_int*
    dec_ref r10
    r13 = r12 << 1
    r14 = r2.__mypyc_temp__28
    if is_error(r14) goto L186 (error at encode_input:173) else goto L10
L10:
    r15 = r14 < r13 :: signed
    if r15 goto L11 else goto L27 :: bool
L11:
    r16 = r2.__mypyc_temp__27
    if is_error(r16) goto L186 (error at encode_input:173) else goto L12
L12:
    r17 = r2.__mypyc_temp__28
    if is_error(r17) goto L188 (error at encode_input:173) else goto L13
L13:
    r18 = CPySequenceTuple_GetItem(r16, r17)
    dec_ref r16
    if is_error(r18) goto L186 (error at encode_input:173) else goto L14
L14:
    r2.arg = r18; r19 = is_error
    if not r19 goto L186 (error at encode_input:173) else goto L15 :: bool
L15:
    r20 = r2.arg
    if is_error(r20) goto L186 (error at encode_input:173) else goto L16
L16:
    r21 = dank_mids.brownie_patch.call.Contract :: static
    if is_error(r21) goto L189 else goto L19
L17:
    r22 = raise NameError('value for final name "Contract" was not set')
    if not r22 goto L184 (error at encode_input:173) else goto L18 :: bool
L18:
    unreachable
L19:
    r23 = PyObject_IsInstance(r20, r21)
    dec_ref r20
    r24 = r23 >= 0 :: signed
    if not r24 goto L186 (error at encode_input:173) else goto L20 :: bool
L20:
    r25 = truncate r23: i32 to builtins.bool
    if r25 goto L21 else goto L22 :: bool
L21:
    if r25 goto L24 else goto L25 :: bool
L22:
    r26 = r2.arg
    if is_error(r26) goto L186 (error at encode_input:173) else goto L23
L23:
    r27 = '__contains__'
    r28 = PyObject_HasAttr(r26, r27)
    dec_ref r26
    if r28 goto L24 else goto L25 :: bool
L24:
    r6 = 1
    goto L27
L25:
    r29 = r2.__mypyc_temp__28
    if is_error(r29) goto L186 (error at encode_input:173) else goto L26
L26:
    r30 = r29 + 2
    r2.__mypyc_temp__28 = r30; r31 = is_error
    if not r31 goto L186 (error at encode_input:173) else goto L8 :: bool
L27:
    if r6 goto L190 else goto L40 :: bool
L28:
    r32 = r2.call
    if is_error(r32) goto L191 (error at encode_input:175) else goto L29
L29:
    r33 = 'abi'
    r34 = CPyObject_GetAttr(r32, r33)
    dec_ref r32
    if is_error(r34) goto L191 (error at encode_input:175) else goto L30
L30:
    r35 = r2.call
    if is_error(r35) goto L192 (error at encode_input:175) else goto L31
L31:
    r36 = 'signature'
    r37 = CPyObject_GetAttr(r35, r36)
    dec_ref r35
    if is_error(r37) goto L192 (error at encode_input:175) else goto L32
L32:
    r38 = r2.args
    if is_error(r38) goto L193 (error at encode_input:175) else goto L33
L33:
    r39 = dank_mids.brownie_patch.call.globals :: static
    r40 = '__encode_input'
    r41 = CPyDict_GetItem(r39, r40)
    if is_error(r41) goto L194 (error at encode_input:175) else goto L34
L34:
    r42 = PyList_New(2)
    if is_error(r42) goto L195 (error at encode_input:175) else goto L35
L35:
    r43 = get_element_ptr r42 ob_item :: PyListObject
    r44 = load_mem r43 :: ptr*
    set_mem r44, r34 :: builtins.object*
    r45 = r44 + 8
    set_mem r45, r37 :: builtins.object*
    r46 = CPyList_Extend(r42, r38)
    dec_ref r38
    if is_error(r46) goto L196 (error at encode_input:175) else goto L197
L36:
    r47 = PyList_AsTuple(r42)
    dec_ref r42
    if is_error(r47) goto L198 (error at encode_input:175) else goto L37
L37:
    r48 = PyDict_New()
    if is_error(r48) goto L199 (error at encode_input:175) else goto L38
L38:
    r49 = PyObject_Call(r41, r47, r48)
    dec_ref r41
    dec_ref r47
    dec_ref r48
    if is_error(r49) goto L191 (error at encode_input:175) else goto L39
L39:
    r2.data = r49; r50 = is_error
    if not r50 goto L191 (error at encode_input:175) else goto L169 :: bool
L40:
    r51 = r2.call
    if is_error(r51) goto L200 (error at encode_input:178) else goto L41
L41:
    r52 = r2.args
    if is_error(r52) goto L201 (error at encode_input:178) else goto L42
L42:
    r53 = r2.get_request_data
    if is_error(r53) goto L202 (error at encode_input:178) else goto L43
L43:
    r54 = PyList_New(1)
    if is_error(r54) goto L203 (error at encode_input:178) else goto L44
L44:
    r55 = get_element_ptr r54 ob_item :: PyListObject
    r56 = load_mem r55 :: ptr*
    set_mem r56, r51 :: builtins.object*
    r57 = CPyList_Extend(r54, r52)
    dec_ref r52
    if is_error(r57) goto L204 (error at encode_input:178) else goto L205
L45:
    r58 = PyList_AsTuple(r54)
    dec_ref r54
    if is_error(r58) goto L206 (error at encode_input:178) else goto L46
L46:
    r59 = PyDict_New()
    if is_error(r59) goto L207 (error at encode_input:178) else goto L47
L47:
    r60 = PyObject_Call(r53, r58, r59)
    dec_ref r53
    dec_ref r58
    dec_ref r59
    if is_error(r60) goto L200 (error at encode_input:178) else goto L48
L48:
    r61 = CPy_GetCoro(r60)
    dec_ref r60
    if is_error(r61) goto L200 (error at encode_input:178) else goto L49
L49:
    r2.__mypyc_temp__29 = r61; r62 = is_error
    if not r62 goto L200 (error at encode_input:-1) else goto L50 :: bool
L50:
    r63 = r2.__mypyc_temp__29
    if is_error(r63) goto L200 (error at encode_input:-1) else goto L51
L51:
    r64 = CPyIter_Next(r63)
    dec_ref r63
    if is_error(r64) goto L208 else goto L54
L52:
    r65 = CPy_FetchStopIterationValue()
    if is_error(r65) goto L84 (error at encode_input:178) else goto L53
L53:
    r66 = r65
    goto L83
L54:
    r67 = r64
L55:
    r2.__mypyc_next_label__ = 2; r68 = is_error
    if not r68 goto L209 (error at encode_input:178) else goto L210 :: bool
L56:
    return r67
L57:
    r69 = load_address _Py_NoneStruct
    r70 = type != r69
    if r70 goto L58 else goto L60 :: bool
L58:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L61 (error at encode_input:178) else goto L211 :: bool
L59:
    unreachable
L60:
    inc_ref arg
    goto L78
L61:
    r71 = CPy_CatchError()
    r2.__mypyc_temp__30 = r71; r72 = is_error
    if not r72 goto L212 (error at encode_input:-1) else goto L62 :: bool
L62:
    r73 = load_address r1
    r74 = r2.__mypyc_temp__29
    if is_error(r74) goto L212 (error at encode_input:-1) else goto L63
L63:
    r75 = CPy_YieldFromErrorHandle(r74, r73)
    dec_ref r74
    if is_error(r75) goto L212 (error at encode_input:178) else goto L64
L64:
    if r75 goto L70 else goto L65 :: bool
L65:
    if is_error(r1) goto L66 else goto L68
L66:
    r76 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r76 goto L75 (error at encode_input:-1) else goto L213 :: bool
L67:
    unreachable
L68:
    inc_ref r1
    r67 = r1
    r77 = r2.__mypyc_temp__30
    if is_error(r77) goto L214 (error at encode_input:-1) else goto L69
L69:
    CPy_RestoreExcInfo(r77)
    dec_ref r77
    goto L55
L70:
    if is_error(r1) goto L71 else goto L73
L71:
    r78 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r78 goto L75 (error at encode_input:-1) else goto L215 :: bool
L72:
    unreachable
L73:
    r66 = r1
    r79 = r2.__mypyc_temp__30
    if is_error(r79) goto L216 (error at encode_input:-1) else goto L74
L74:
    CPy_RestoreExcInfo(r79)
    dec_ref r79
    goto L83
L75:
    r80 = r2.__mypyc_temp__30
    if is_error(r80) goto L84 (error at encode_input:-1) else goto L76
L76:
    CPy_RestoreExcInfo(r80)
    dec_ref r80
    r81 = CPy_KeepPropagating()
    if not r81 goto L84 else goto L217 :: bool
L77:
    unreachable
L78:
    r82 = r2.__mypyc_temp__29
    if is_error(r82) goto L218 (error at encode_input:-1) else goto L79
L79:
    r83 = CPyIter_Send(r82, arg)
    dec_ref r82
    dec_ref arg
    if is_error(r83) goto L219 else goto L80
L80:
    r67 = r83
    goto L55
L81:
    r84 = CPy_FetchStopIterationValue()
    if is_error(r84) goto L84 (error at encode_input:178) else goto L82
L82:
    r66 = r84
L83:
    r2.data = r66; r85 = is_error
    if not r85 goto L84 (error at encode_input:178) else goto L169 :: bool
L84:
    r86 = CPy_CatchError()
    r2.__mypyc_temp__31 = r86; r87 = is_error
    if not r87 goto L166 (error at encode_input:-1) else goto L85 :: bool
L85:
    r88 = builtins :: module
    r89 = 'AttributeError'
    r90 = CPyObject_GetAttr(r88, r89)
    if is_error(r90) goto L166 (error at encode_input:179) else goto L86
L86:
    r91 = builtins :: module
    r92 = 'TypeError'
    r93 = CPyObject_GetAttr(r91, r92)
    if is_error(r93) goto L220 (error at encode_input:179) else goto L87
L87:
    r94 = (r90, r93)
    r95 = box(tuple[object, object], r94)
    r96 = CPy_ExceptionMatches(r95)
    dec_ref r95
    if r96 goto L88 else goto L100 :: bool
L88:
    r97 = r2.call
    if is_error(r97) goto L166 (error at encode_input:181) else goto L89
L89:
    r98 = 'abi'
    r99 = CPyObject_GetAttr(r97, r98)
    dec_ref r97
    if is_error(r99) goto L166 (error at encode_input:181) else goto L90
L90:
    r100 = r2.call
    if is_error(r100) goto L221 (error at encode_input:181) else goto L91
L91:
    r101 = 'signature'
    r102 = CPyObject_GetAttr(r100, r101)
    dec_ref r100
    if is_error(r102) goto L221 (error at encode_input:181) else goto L92
L92:
    r103 = r2.args
    if is_error(r103) goto L222 (error at encode_input:181) else goto L93
L93:
    r104 = dank_mids.brownie_patch.call.globals :: static
    r105 = '__encode_input'
    r106 = CPyDict_GetItem(r104, r105)
    if is_error(r106) goto L223 (error at encode_input:181) else goto L94
L94:
    r107 = PyList_New(2)
    if is_error(r107) goto L224 (error at encode_input:181) else goto L95
L95:
    r108 = get_element_ptr r107 ob_item :: PyListObject
    r109 = load_mem r108 :: ptr*
    set_mem r109, r99 :: builtins.object*
    r110 = r109 + 8
    set_mem r110, r102 :: builtins.object*
    r111 = CPyList_Extend(r107, r103)
    dec_ref r103
    if is_error(r111) goto L225 (error at encode_input:181) else goto L226
L96:
    r112 = PyList_AsTuple(r107)
    dec_ref r107
    if is_error(r112) goto L227 (error at encode_input:181) else goto L97
L97:
    r113 = PyDict_New()
    if is_error(r113) goto L228 (error at encode_input:181) else goto L98
L98:
    r114 = PyObject_Call(r106, r112, r113)
    dec_ref r106
    dec_ref r112
    dec_ref r113
    if is_error(r114) goto L166 (error at encode_input:181) else goto L99
L99:
    r2.data = r114; r115 = is_error
    if not r115 goto L166 (error at encode_input:181) else goto L164 :: bool
L100:
    r116 = dank_mids.brownie_patch.call.globals :: static
    r117 = 'BrokenProcessPool'
    r118 = CPyDict_GetItem(r116, r117)
    if is_error(r118) goto L166 (error at encode_input:183) else goto L101
L101:
    r119 = CPy_ExceptionMatches(r118)
    dec_ref r118
    if r119 goto L102 else goto L142 :: bool
L102:
    r120 = dank_mids.brownie_patch.call.logger :: static
    if is_error(r120) goto L103 else goto L105
L103:
    r121 = raise NameError('value for final name "logger" was not set')
    if not r121 goto L166 (error at encode_input:184) else goto L229 :: bool
L104:
    unreachable
L105:
    r122 = 'Oh fuck, you broke the %s while decoding %s with abi %s'
    r123 = dank_mids.brownie_patch.call.ENVS :: static
    if is_error(r123) goto L106 else goto L108
L106:
    r124 = raise NameError('value for final name "ENVS" was not set')
    if not r124 goto L166 (error at encode_input:184) else goto L230 :: bool
L107:
    unreachable
L108:
    r125 = 'BROWNIE_ENCODER_PROCESSES'
    r126 = CPyObject_GetAttr(r123, r125)
    if is_error(r126) goto L166 (error at encode_input:184) else goto L109
L109:
    r127 = r2.data
    if is_error(r127) goto L231 (error at encode_input:184) else goto L110
L110:
    r128 = r2.call
    if is_error(r128) goto L232 (error at encode_input:184) else goto L111
L111:
    r129 = 'abi'
    r130 = CPyObject_GetAttr(r128, r129)
    dec_ref r128
    if is_error(r130) goto L232 (error at encode_input:184) else goto L112
L112:
    r131 = 'critical'
    r132 = [r120, r122, r126, r127, r130]
    r133 = load_address r132
    r134 = PyObject_VectorcallMethod(r131, r133, 9223372036854775813, 0)
    if is_error(r134) goto L233 (error at encode_input:184) else goto L234
L113:
    dec_ref r126
    dec_ref r127
    dec_ref r130
    r135 = dank_mids.brownie_patch.call.ENVS :: static
    if is_error(r135) goto L114 else goto L116
L114:
    r136 = raise NameError('value for final name "ENVS" was not set')
    if not r136 goto L166 (error at encode_input:186) else goto L235 :: bool
L115:
    unreachable
L116:
    r137 = 'BROWNIE_ENCODER_PROCESSES'
    r138 = CPyObject_GetAttr(r135, r137)
    if is_error(r138) goto L166 (error at encode_input:186) else goto L117
L117:
    r139 = '_max_workers'
    r140 = CPyObject_GetAttr(r138, r139)
    dec_ref r138
    if is_error(r140) goto L166 (error at encode_input:186) else goto L118
L118:
    r141 = dank_mids.brownie_patch.call.globals :: static
    r142 = 'AsyncProcessPoolExecutor'
    r143 = CPyDict_GetItem(r141, r142)
    if is_error(r143) goto L236 (error at encode_input:186) else goto L119
L119:
    r144 = [r140]
    r145 = load_address r144
    r146 = _PyObject_Vectorcall(r143, r145, 1, 0)
    dec_ref r143
    if is_error(r146) goto L236 (error at encode_input:186) else goto L120
L120:
    dec_ref r140
    r147 = dank_mids.brownie_patch.call.ENVS :: static
    if is_error(r147) goto L237 else goto L123
L121:
    r148 = raise NameError('value for final name "ENVS" was not set')
    if not r148 goto L166 (error at encode_input:186) else goto L238 :: bool
L122:
    unreachable
L123:
    r149 = 'BROWNIE_ENCODER_PROCESSES'
    r150 = PyObject_SetAttr(r147, r149, r146)
    dec_ref r146
    r151 = r150 >= 0 :: signed
    if not r151 goto L166 (error at encode_input:186) else goto L124 :: bool
L124:
    r152 = r2.len_inputs
    if is_error(r152) goto L166 (error at encode_input:187) else goto L125
L125:
    r153 = r152 != 0
    dec_ref r152 :: int
    if r153 goto L126 else goto L138 :: bool
L126:
    r154 = r2.call
    if is_error(r154) goto L166 (error at encode_input:187) else goto L127
L127:
    r155 = 'abi'
    r156 = CPyObject_GetAttr(r154, r155)
    dec_ref r154
    if is_error(r156) goto L166 (error at encode_input:187) else goto L128
L128:
    r157 = r2.call
    if is_error(r157) goto L239 (error at encode_input:187) else goto L129
L129:
    r158 = 'signature'
    r159 = CPyObject_GetAttr(r157, r158)
    dec_ref r157
    if is_error(r159) goto L239 (error at encode_input:187) else goto L130
L130:
    r160 = r2.args
    if is_error(r160) goto L240 (error at encode_input:187) else goto L131
L131:
    r161 = dank_mids.brownie_patch.call.globals :: static
    r162 = '__encode_input'
    r163 = CPyDict_GetItem(r161, r162)
    if is_error(r163) goto L241 (error at encode_input:187) else goto L132
L132:
    r164 = PyList_New(2)
    if is_error(r164) goto L242 (error at encode_input:187) else goto L133
L133:
    r165 = get_element_ptr r164 ob_item :: PyListObject
    r166 = load_mem r165 :: ptr*
    set_mem r166, r156 :: builtins.object*
    r167 = r166 + 8
    set_mem r167, r159 :: builtins.object*
    r168 = CPyList_Extend(r164, r160)
    dec_ref r160
    if is_error(r168) goto L243 (error at encode_input:187) else goto L244
L134:
    r169 = PyList_AsTuple(r164)
    dec_ref r164
    if is_error(r169) goto L245 (error at encode_input:187) else goto L135
L135:
    r170 = PyDict_New()
    if is_error(r170) goto L246 (error at encode_input:187) else goto L136
L136:
    r171 = PyObject_Call(r163, r169, r170)
    dec_ref r163
    dec_ref r169
    dec_ref r170
    if is_error(r171) goto L166 (error at encode_input:187) else goto L137
L137:
    r172 = r171
    goto L141
L138:
    r173 = r2.call
    if is_error(r173) goto L166 (error at encode_input:187) else goto L139
L139:
    r174 = 'signature'
    r175 = CPyObject_GetAttr(r173, r174)
    dec_ref r173
    if is_error(r175) goto L166 (error at encode_input:187) else goto L140
L140:
    r172 = r175
L141:
    r2.data = r172; r176 = is_error
    if not r176 goto L166 (error at encode_input:187) else goto L164 :: bool
L142:
    r177 = dank_mids.brownie_patch.call.globals :: static
    r178 = 'PicklingError'
    r179 = CPyDict_GetItem(r177, r178)
    if is_error(r179) goto L166 (error at encode_input:188) else goto L143
L143:
    r180 = CPy_ExceptionMatches(r179)
    dec_ref r179
    if r180 goto L144 else goto L162 :: bool
L144:
    r181 = r2.len_inputs
    if is_error(r181) goto L166 (error at encode_input:189) else goto L145
L145:
    r182 = r181 != 0
    dec_ref r181 :: int
    if r182 goto L146 else goto L158 :: bool
L146:
    r183 = r2.call
    if is_error(r183) goto L166 (error at encode_input:189) else goto L147
L147:
    r184 = 'abi'
    r185 = CPyObject_GetAttr(r183, r184)
    dec_ref r183
    if is_error(r185) goto L166 (error at encode_input:189) else goto L148
L148:
    r186 = r2.call
    if is_error(r186) goto L247 (error at encode_input:189) else goto L149
L149:
    r187 = 'signature'
    r188 = CPyObject_GetAttr(r186, r187)
    dec_ref r186
    if is_error(r188) goto L247 (error at encode_input:189) else goto L150
L150:
    r189 = r2.args
    if is_error(r189) goto L248 (error at encode_input:189) else goto L151
L151:
    r190 = dank_mids.brownie_patch.call.globals :: static
    r191 = '__encode_input'
    r192 = CPyDict_GetItem(r190, r191)
    if is_error(r192) goto L249 (error at encode_input:189) else goto L152
L152:
    r193 = PyList_New(2)
    if is_error(r193) goto L250 (error at encode_input:189) else goto L153
L153:
    r194 = get_element_ptr r193 ob_item :: PyListObject
    r195 = load_mem r194 :: ptr*
    set_mem r195, r185 :: builtins.object*
    r196 = r195 + 8
    set_mem r196, r188 :: builtins.object*
    r197 = CPyList_Extend(r193, r189)
    dec_ref r189
    if is_error(r197) goto L251 (error at encode_input:189) else goto L252
L154:
    r198 = PyList_AsTuple(r193)
    dec_ref r193
    if is_error(r198) goto L253 (error at encode_input:189) else goto L155
L155:
    r199 = PyDict_New()
    if is_error(r199) goto L254 (error at encode_input:189) else goto L156
L156:
    r200 = PyObject_Call(r192, r198, r199)
    dec_ref r192
    dec_ref r198
    dec_ref r199
    if is_error(r200) goto L166 (error at encode_input:189) else goto L157
L157:
    r201 = r200
    goto L161
L158:
    r202 = r2.call
    if is_error(r202) goto L166 (error at encode_input:189) else goto L159
L159:
    r203 = 'signature'
    r204 = CPyObject_GetAttr(r202, r203)
    dec_ref r202
    if is_error(r204) goto L166 (error at encode_input:189) else goto L160
L160:
    r201 = r204
L161:
    r2.data = r201; r205 = is_error
    if not r205 goto L166 (error at encode_input:189) else goto L164 :: bool
L162:
    CPy_Reraise()
    if not 0 goto L166 else goto L255 :: bool
L163:
    unreachable
L164:
    r206 = r2.__mypyc_temp__31
    if is_error(r206) goto L191 (error at encode_input:-1) else goto L165
L165:
    CPy_RestoreExcInfo(r206)
    dec_ref r206
    goto L169
L166:
    r207 = r2.__mypyc_temp__31
    dec_ref r2
    if is_error(r207) goto L184 (error at encode_input:-1) else goto L167
L167:
    CPy_RestoreExcInfo(r207)
    dec_ref r207
    r208 = CPy_KeepPropagating()
    if not r208 goto L184 else goto L168 :: bool
L168:
    unreachable
L169:
    r209 = r2.data
    if is_error(r209) goto L191 (error at encode_input:191) else goto L170
L170:
    r210 = builtins :: module
    r211 = 'Exception'
    r212 = CPyObject_GetAttr(r210, r211)
    if is_error(r212) goto L256 (error at encode_input:191) else goto L171
L171:
    r213 = PyObject_IsInstance(r209, r212)
    dec_ref r209
    dec_ref r212
    r214 = r213 >= 0 :: signed
    if not r214 goto L191 (error at encode_input:191) else goto L172 :: bool
L172:
    r215 = truncate r213: i32 to builtins.bool
    if r215 goto L173 else goto L176 :: bool
L173:
    r216 = r2.data
    dec_ref r2
    if is_error(r216) goto L184 (error at encode_input:192) else goto L174
L174:
    CPy_Raise(r216)
    dec_ref r216
    if not 0 goto L184 (error at encode_input:192) else goto L175 :: bool
L175:
    unreachable
L176:
    r217 = r2.data
    if is_error(r217) goto L191 (error at encode_input:193) else goto L177
L177:
    r2.__mypyc_next_label__ = -2; r218 = is_error
    dec_ref r2
    if not r218 goto L257 (error at encode_input:193) else goto L178 :: bool
L178:
    CPyGen_SetStopIterationValue(r217)
    dec_ref r217
    if not 0 goto L184 else goto L179 :: bool
L179:
    unreachable
L180:
    r219 = r3 == 0
    if r219 goto L258 else goto L181 :: bool
L181:
    r220 = r3 == 2
    dec_ref r3 :: int
    if r220 goto L57 else goto L259 :: bool
L182:
    r221 = raise StopIteration
    if not r221 goto L184 (error at encode_input:171) else goto L183 :: bool
L183:
    unreachable
L184:
    r222 = <error> :: object
    return r222
L185:
    xdec_ref r1
    goto L184
L186:
    xdec_ref r1
    dec_ref r2
    goto L184
L187:
    xdec_ref r1
    dec_ref r2
    goto L3
L188:
    xdec_ref r1
    dec_ref r2
    dec_ref r16
    goto L184
L189:
    xdec_ref r1
    dec_ref r2
    dec_ref r20
    goto L17
L190:
    xdec_ref r1
    goto L28
L191:
    dec_ref r2
    goto L184
L192:
    dec_ref r2
    dec_ref r34
    goto L184
L193:
    dec_ref r2
    dec_ref r34
    dec_ref r37
    goto L184
L194:
    dec_ref r2
    dec_ref r34
    dec_ref r37
    dec_ref r38
    goto L184
L195:
    dec_ref r2
    dec_ref r34
    dec_ref r37
    dec_ref r38
    dec_ref r41
    goto L184
L196:
    dec_ref r2
    dec_ref r41
    dec_ref r42
    goto L184
L197:
    dec_ref r46
    goto L36
L198:
    dec_ref r2
    dec_ref r41
    goto L184
L199:
    dec_ref r2
    dec_ref r41
    dec_ref r47
    goto L184
L200:
    xdec_ref r1
    goto L84
L201:
    xdec_ref r1
    dec_ref r51
    goto L84
L202:
    xdec_ref r1
    dec_ref r51
    dec_ref r52
    goto L84
L203:
    xdec_ref r1
    dec_ref r51
    dec_ref r52
    dec_ref r53
    goto L84
L204:
    xdec_ref r1
    dec_ref r53
    dec_ref r54
    goto L84
L205:
    dec_ref r57
    goto L45
L206:
    xdec_ref r1
    dec_ref r53
    goto L84
L207:
    xdec_ref r1
    dec_ref r53
    dec_ref r58
    goto L84
L208:
    xdec_ref r1
    goto L52
L209:
    dec_ref r67
    goto L61
L210:
    xdec_ref r1
    dec_ref r2
    goto L56
L211:
    xdec_ref r1
    dec_ref r2
    goto L59
L212:
    xdec_ref r1
    goto L75
L213:
    dec_ref r2
    goto L67
L214:
    xdec_ref r1
    dec_ref r67
    goto L75
L215:
    dec_ref r2
    goto L72
L216:
    dec_ref r66
    goto L75
L217:
    dec_ref r2
    goto L77
L218:
    xdec_ref r1
    dec_ref arg
    goto L84
L219:
    xdec_ref r1
    goto L81
L220:
    dec_ref r90
    goto L166
L221:
    dec_ref r99
    goto L166
L222:
    dec_ref r99
    dec_ref r102
    goto L166
L223:
    dec_ref r99
    dec_ref r102
    dec_ref r103
    goto L166
L224:
    dec_ref r99
    dec_ref r102
    dec_ref r103
    dec_ref r106
    goto L166
L225:
    dec_ref r106
    dec_ref r107
    goto L166
L226:
    dec_ref r111
    goto L96
L227:
    dec_ref r106
    goto L166
L228:
    dec_ref r106
    dec_ref r112
    goto L166
L229:
    dec_ref r2
    goto L104
L230:
    dec_ref r2
    goto L107
L231:
    dec_ref r126
    goto L166
L232:
    dec_ref r126
    dec_ref r127
    goto L166
L233:
    dec_ref r126
    dec_ref r127
    dec_ref r130
    goto L166
L234:
    dec_ref r134
    goto L113
L235:
    dec_ref r2
    goto L115
L236:
    dec_ref r140
    goto L166
L237:
    dec_ref r146
    goto L121
L238:
    dec_ref r2
    goto L122
L239:
    dec_ref r156
    goto L166
L240:
    dec_ref r156
    dec_ref r159
    goto L166
L241:
    dec_ref r156
    dec_ref r159
    dec_ref r160
    goto L166
L242:
    dec_ref r156
    dec_ref r159
    dec_ref r160
    dec_ref r163
    goto L166
L243:
    dec_ref r163
    dec_ref r164
    goto L166
L244:
    dec_ref r168
    goto L134
L245:
    dec_ref r163
    goto L166
L246:
    dec_ref r163
    dec_ref r169
    goto L166
L247:
    dec_ref r185
    goto L166
L248:
    dec_ref r185
    dec_ref r188
    goto L166
L249:
    dec_ref r185
    dec_ref r188
    dec_ref r189
    goto L166
L250:
    dec_ref r185
    dec_ref r188
    dec_ref r189
    dec_ref r192
    goto L166
L251:
    dec_ref r192
    dec_ref r193
    goto L166
L252:
    dec_ref r197
    goto L154
L253:
    dec_ref r192
    goto L166
L254:
    dec_ref r192
    dec_ref r198
    goto L166
L255:
    dec_ref r2
    goto L163
L256:
    dec_ref r2
    dec_ref r209
    goto L184
L257:
    dec_ref r217
    goto L184
L258:
    dec_ref r3 :: int
    goto L2
L259:
    xdec_ref r1
    dec_ref r2
    goto L182

def encode_input_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def encode_input_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def encode_input_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def encode_input_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def encode_input_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def encode_input_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def encode_input(call, len_inputs, get_request_data, args):
    call :: object
    len_inputs :: int
    get_request_data :: object
    args :: tuple
    r0 :: dank_mids.brownie_patch.call.encode_input_env
    r1, r2, r3, r4 :: bool
    r5 :: dank_mids.brownie_patch.call.encode_input_gen
    r6, r7 :: bool
    r8 :: object
L0:
    r0 = encode_input_env()
    if is_error(r0) goto L9 (error at encode_input:171) else goto L1
L1:
    inc_ref call
    r0.call = call; r1 = is_error
    if not r1 goto L10 (error at encode_input:171) else goto L2 :: bool
L2:
    inc_ref len_inputs :: int
    r0.len_inputs = len_inputs; r2 = is_error
    if not r2 goto L10 (error at encode_input:171) else goto L3 :: bool
L3:
    inc_ref get_request_data
    r0.get_request_data = get_request_data; r3 = is_error
    if not r3 goto L10 (error at encode_input:171) else goto L4 :: bool
L4:
    inc_ref args
    r0.args = args; r4 = is_error
    if not r4 goto L10 (error at encode_input:171) else goto L5 :: bool
L5:
    r5 = encode_input_gen()
    if is_error(r5) goto L10 (error at encode_input:171) else goto L6
L6:
    inc_ref r0
    r5.__mypyc_env__ = r0; r6 = is_error
    if not r6 goto L11 (error at encode_input:171) else goto L7 :: bool
L7:
    r0.__mypyc_next_label__ = 0; r7 = is_error
    dec_ref r0
    if not r7 goto L12 (error at encode_input:171) else goto L8 :: bool
L8:
    return r5
L9:
    r8 = <error> :: object
    return r8
L10:
    dec_ref r0
    goto L9
L11:
    dec_ref r0
    dec_ref r5
    goto L9
L12:
    dec_ref r5
    goto L9

def decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    type, value, traceback, arg, r0, r1, r2, r3 :: object
    r4 :: dank_mids.brownie_patch.call.decode_output_env
    r5 :: int
    r6 :: object
    r7 :: bit
    r8 :: object
    r9 :: str
    r10 :: object
    r11 :: bytes
    r12 :: dict
    r13 :: None
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: i32
    r18 :: bit
    r19 :: bool
    r20, r21 :: bytes
    r22 :: i32
    r23 :: bit
    r24 :: bool
    r25 :: bytes
    r26 :: object
    r27 :: str
    r28 :: object
    r29 :: dict
    r30 :: object
    r31 :: bool
    r32 :: object
    r33 :: bytes
    r34 :: object
    r35 :: bool
    r36 :: object[2]
    r37 :: object_ptr
    r38, r39 :: object
    r40 :: bool
    r41, r42, r43, r44, r45 :: object
    r46 :: bool
    r47 :: object
    r48 :: bit
    r49 :: tuple[object, object, object]
    r50 :: bool
    r51 :: object_ptr
    r52 :: object
    r53, r54 :: bool
    r55 :: tuple[object, object, object]
    r56 :: bool
    r57, r58 :: tuple[object, object, object]
    r59 :: bit
    r60, r61, r62 :: object
    r63 :: bool
    r64 :: tuple[object, object, object]
    r65 :: bool
    r66 :: dict
    r67 :: str
    r68 :: object
    r69 :: bit
    r70 :: object
    r71 :: bool
    r72 :: str
    r73 :: object
    r74 :: bool
    r75 :: str
    r76 :: object
    r77 :: bytes
    r78 :: object
    r79 :: str
    r80 :: object
    r81 :: str
    r82 :: object[5]
    r83 :: object_ptr
    r84, r85 :: object
    r86 :: bool
    r87 :: str
    r88 :: object
    r89 :: str
    r90 :: object
    r91 :: dict
    r92 :: str
    r93 :: object
    r94 :: object[1]
    r95 :: object_ptr
    r96, r97 :: object
    r98 :: bool
    r99 :: str
    r100 :: i32
    r101 :: bit
    r102 :: bytes
    r103 :: object
    r104 :: str
    r105 :: object
    r106 :: dict
    r107 :: object
    r108 :: bool
    r109, r110 :: tuple[object, object, object]
    r111 :: bit
    r112, r113 :: object
    r114 :: str
    r115 :: object
    r116 :: i32
    r117 :: bit
    r118 :: bool
    r119, r120 :: object
    r121 :: bool
    r122 :: tuple[object, object, object]
    r123 :: bool
    r124 :: dict
    r125 :: str
    r126 :: object
    r127 :: bit
    r128 :: object
    r129 :: bool
    r130 :: object
    r131 :: str
    r132, r133, r134 :: object
    r135 :: str
    r136 :: object
    r137 :: bytes
    r138 :: list
    r139 :: object
    r140 :: i32
    r141 :: bit
    r142 :: i32
    r143 :: bit
    r144 :: i32
    r145 :: bit
    r146 :: tuple
    r147 :: object
    r148 :: str
    r149 :: i32
    r150 :: bit
    r151 :: object
    r152 :: str
    r153 :: object
    r154 :: bit
    r155 :: object
    r156 :: bool
    r157 :: object
    r158, r159 :: str
    r160 :: bool
    r161 :: object
    r162 :: bool
    r163 :: str
    r164 :: object
    r165 :: str
    r166 :: object[3]
    r167 :: object_ptr
    r168, r169 :: object
    r170 :: str
    r171 :: object
    r172 :: dict
    r173 :: str
    r174 :: object
    r175 :: set
    r176 :: i32
    r177 :: bit
    r178 :: bool
    r179 :: object
    r180 :: str
    r181 :: object
    r182 :: i32
    r183 :: bit
    r184 :: object
    r185 :: bytes
    r186, r187 :: object
    r188 :: bool
    r189, r190, r191, r192, r193 :: object
    r194 :: bool
    r195 :: object
    r196 :: bit
    r197 :: tuple[object, object, object]
    r198 :: bool
    r199 :: object_ptr
    r200 :: object
    r201, r202 :: bool
    r203 :: tuple[object, object, object]
    r204 :: bool
    r205, r206 :: tuple[object, object, object]
    r207 :: bit
    r208, r209, r210 :: object
    r211 :: tuple[object, object, object]
    r212 :: bool
    r213 :: tuple[object, object, object]
    r214, r215, r216, r217 :: bit
    r218 :: bool
    r219 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = __mypyc_self__.__mypyc_env__
    if is_error(r4) goto L207 (error at decode_output:196) else goto L1
L1:
    r5 = r4.__mypyc_next_label__
    if is_error(r5) goto L208 (error at decode_output:196) else goto L201
L2:
    r6 = load_address _Py_NoneStruct
    r7 = type != r6
    if r7 goto L209 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L206 (error at decode_output:196) else goto L4 :: bool
L4:
    unreachable
L5:
    r8 = r4.call
    if is_error(r8) goto L208 (error at decode_output:197) else goto L6
L6:
    r9 = 'abi'
    r10 = CPyObject_GetAttr(r8, r9)
    dec_ref r8
    if is_error(r10) goto L208 (error at decode_output:197) else goto L7
L7:
    r11 = r4.data
    if is_error(r11) goto L210 (error at decode_output:197) else goto L8
L8:
    r12 = cast(dict, r10)
    if is_error(r12) goto L211 (error at decode_output:197) else goto L9
L9:
    r13 = __validate_output(r12, r11)
    dec_ref r12
    dec_ref r11
    if is_error(r13) goto L208 (error at decode_output:197) else goto L10
L10:
    r14 = r4.call
    if is_error(r14) goto L212 (error at decode_output:199) else goto L11
L11:
    r15 = '_skip_decoder_proc_pool'
    r16 = CPyObject_GetAttr(r14, r15)
    dec_ref r14
    if is_error(r16) goto L212 (error at decode_output:199) else goto L12
L12:
    r17 = PyObject_IsTrue(r16)
    dec_ref r16
    r18 = r17 >= 0 :: signed
    if not r18 goto L212 (error at decode_output:199) else goto L13 :: bool
L13:
    r19 = truncate r17: i32 to builtins.bool
    if r19 goto L213 else goto L14 :: bool
L14:
    r20 = b'Unexpected error'
    r21 = r4.data
    if is_error(r21) goto L212 (error at decode_output:199) else goto L15
L15:
    r22 = PySequence_Contains(r21, r20)
    dec_ref r21
    r23 = r22 >= 0 :: signed
    if not r23 goto L212 (error at decode_output:199) else goto L16 :: bool
L16:
    r24 = truncate r22: i32 to builtins.bool
    if r24 goto L213 else goto L23 :: bool
L17:
    r25 = r4.data
    if is_error(r25) goto L114 (error at decode_output:201) else goto L18
L18:
    r26 = r4.call
    if is_error(r26) goto L214 (error at decode_output:201) else goto L19
L19:
    r27 = 'abi'
    r28 = CPyObject_GetAttr(r26, r27)
    dec_ref r26
    if is_error(r28) goto L214 (error at decode_output:201) else goto L20
L20:
    r29 = cast(dict, r28)
    if is_error(r29) goto L214 (error at decode_output:201) else goto L21
L21:
    r30 = __decode_output(r25, r29)
    dec_ref r25
    dec_ref r29
    if is_error(r30) goto L114 (error at decode_output:201) else goto L22
L22:
    r4.decoded = r30; r31 = is_error
    if not r31 goto L114 (error at decode_output:201) else goto L103 :: bool
L23:
    r32 = r4.call
    if is_error(r32) goto L215 (error at decode_output:204) else goto L24
L24:
    r33 = r4.data
    if is_error(r33) goto L216 (error at decode_output:204) else goto L25
L25:
    r34 = dank_mids.brownie_patch.call.decode :: static
    if is_error(r34) goto L217 else goto L28
L26:
    r35 = raise NameError('value for final name "decode" was not set')
    if not r35 goto L65 (error at decode_output:204) else goto L218 :: bool
L27:
    unreachable
L28:
    r36 = [r32, r33]
    r37 = load_address r36
    r38 = _PyObject_Vectorcall(r34, r37, 2, 0)
    if is_error(r38) goto L219 (error at decode_output:204) else goto L29
L29:
    dec_ref r32
    dec_ref r33
    r39 = CPy_GetCoro(r38)
    dec_ref r38
    if is_error(r39) goto L215 (error at decode_output:204) else goto L30
L30:
    r4.__mypyc_temp__32 = r39; r40 = is_error
    if not r40 goto L215 (error at decode_output:-1) else goto L31 :: bool
L31:
    r41 = r4.__mypyc_temp__32
    if is_error(r41) goto L215 (error at decode_output:-1) else goto L32
L32:
    r42 = CPyIter_Next(r41)
    dec_ref r41
    if is_error(r42) goto L220 else goto L35
L33:
    r43 = CPy_FetchStopIterationValue()
    if is_error(r43) goto L65 (error at decode_output:204) else goto L34
L34:
    r44 = r43
    goto L64
L35:
    r45 = r42
L36:
    r4.__mypyc_next_label__ = 2; r46 = is_error
    if not r46 goto L221 (error at decode_output:204) else goto L222 :: bool
L37:
    return r45
L38:
    r47 = load_address _Py_NoneStruct
    r48 = type != r47
    if r48 goto L39 else goto L41 :: bool
L39:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L42 (error at decode_output:204) else goto L223 :: bool
L40:
    unreachable
L41:
    inc_ref arg
    goto L59
L42:
    r49 = CPy_CatchError()
    r4.__mypyc_temp__33 = r49; r50 = is_error
    if not r50 goto L224 (error at decode_output:-1) else goto L43 :: bool
L43:
    r51 = load_address r1
    r52 = r4.__mypyc_temp__32
    if is_error(r52) goto L224 (error at decode_output:-1) else goto L44
L44:
    r53 = CPy_YieldFromErrorHandle(r52, r51)
    dec_ref r52
    if is_error(r53) goto L224 (error at decode_output:204) else goto L45
L45:
    if r53 goto L51 else goto L46 :: bool
L46:
    if is_error(r1) goto L47 else goto L49
L47:
    r54 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r54 goto L56 (error at decode_output:-1) else goto L225 :: bool
L48:
    unreachable
L49:
    inc_ref r1
    r45 = r1
    r55 = r4.__mypyc_temp__33
    if is_error(r55) goto L226 (error at decode_output:-1) else goto L50
L50:
    CPy_RestoreExcInfo(r55)
    dec_ref r55
    goto L36
L51:
    if is_error(r1) goto L52 else goto L54
L52:
    r56 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r56 goto L56 (error at decode_output:-1) else goto L227 :: bool
L53:
    unreachable
L54:
    r44 = r1
    r57 = r4.__mypyc_temp__33
    if is_error(r57) goto L228 (error at decode_output:-1) else goto L55
L55:
    CPy_RestoreExcInfo(r57)
    dec_ref r57
    goto L64
L56:
    r58 = r4.__mypyc_temp__33
    if is_error(r58) goto L65 (error at decode_output:-1) else goto L57
L57:
    CPy_RestoreExcInfo(r58)
    dec_ref r58
    r59 = CPy_KeepPropagating()
    if not r59 goto L65 else goto L229 :: bool
L58:
    unreachable
L59:
    r60 = r4.__mypyc_temp__32
    if is_error(r60) goto L230 (error at decode_output:-1) else goto L60
L60:
    r61 = CPyIter_Send(r60, arg)
    dec_ref r60
    dec_ref arg
    if is_error(r61) goto L231 else goto L61
L61:
    r45 = r61
    goto L36
L62:
    r62 = CPy_FetchStopIterationValue()
    if is_error(r62) goto L65 (error at decode_output:204) else goto L63
L63:
    r44 = r62
L64:
    r4.decoded = r44; r63 = is_error
    if not r63 goto L65 (error at decode_output:204) else goto L103 :: bool
L65:
    r64 = CPy_CatchError()
    r4.__mypyc_temp__34 = r64; r65 = is_error
    if not r65 goto L100 (error at decode_output:-1) else goto L66 :: bool
L66:
    r66 = dank_mids.brownie_patch.call.globals :: static
    r67 = 'BrokenProcessPool'
    r68 = CPyDict_GetItem(r66, r67)
    if is_error(r68) goto L100 (error at decode_output:206) else goto L67
L67:
    r69 = CPy_ExceptionMatches(r68)
    dec_ref r68
    if r69 goto L68 else goto L96 :: bool
L68:
    r70 = dank_mids.brownie_patch.call.logger :: static
    if is_error(r70) goto L69 else goto L71
L69:
    r71 = raise NameError('value for final name "logger" was not set')
    if not r71 goto L100 (error at decode_output:208) else goto L232 :: bool
L70:
    unreachable
L71:
    r72 = 'Oh fuck, you broke the %s while decoding %s with abi %s'
    r73 = dank_mids.brownie_patch.call.ENVS :: static
    if is_error(r73) goto L72 else goto L74
L72:
    r74 = raise NameError('value for final name "ENVS" was not set')
    if not r74 goto L100 (error at decode_output:208) else goto L233 :: bool
L73:
    unreachable
L74:
    r75 = 'BROWNIE_DECODER_PROCESSES'
    r76 = CPyObject_GetAttr(r73, r75)
    if is_error(r76) goto L100 (error at decode_output:208) else goto L75
L75:
    r77 = r4.data
    if is_error(r77) goto L234 (error at decode_output:208) else goto L76
L76:
    r78 = r4.call
    if is_error(r78) goto L235 (error at decode_output:208) else goto L77
L77:
    r79 = 'abi'
    r80 = CPyObject_GetAttr(r78, r79)
    dec_ref r78
    if is_error(r80) goto L235 (error at decode_output:208) else goto L78
L78:
    r81 = 'critical'
    r82 = [r70, r72, r76, r77, r80]
    r83 = load_address r82
    r84 = PyObject_VectorcallMethod(r81, r83, 9223372036854775813, 0)
    if is_error(r84) goto L236 (error at decode_output:208) else goto L237
L79:
    dec_ref r76
    dec_ref r77
    dec_ref r80
    r85 = dank_mids.brownie_patch.call.ENVS :: static
    if is_error(r85) goto L80 else goto L82
L80:
    r86 = raise NameError('value for final name "ENVS" was not set')
    if not r86 goto L100 (error at decode_output:209) else goto L238 :: bool
L81:
    unreachable
L82:
    r87 = 'BROWNIE_DECODER_PROCESSES'
    r88 = CPyObject_GetAttr(r85, r87)
    if is_error(r88) goto L100 (error at decode_output:209) else goto L83
L83:
    r89 = '_max_workers'
    r90 = CPyObject_GetAttr(r88, r89)
    dec_ref r88
    if is_error(r90) goto L100 (error at decode_output:209) else goto L84
L84:
    r91 = dank_mids.brownie_patch.call.globals :: static
    r92 = 'AsyncProcessPoolExecutor'
    r93 = CPyDict_GetItem(r91, r92)
    if is_error(r93) goto L239 (error at decode_output:209) else goto L85
L85:
    r94 = [r90]
    r95 = load_address r94
    r96 = _PyObject_Vectorcall(r93, r95, 1, 0)
    dec_ref r93
    if is_error(r96) goto L239 (error at decode_output:209) else goto L86
L86:
    dec_ref r90
    r97 = dank_mids.brownie_patch.call.ENVS :: static
    if is_error(r97) goto L240 else goto L89
L87:
    r98 = raise NameError('value for final name "ENVS" was not set')
    if not r98 goto L100 (error at decode_output:209) else goto L241 :: bool
L88:
    unreachable
L89:
    r99 = 'BROWNIE_DECODER_PROCESSES'
    r100 = PyObject_SetAttr(r97, r99, r96)
    dec_ref r96
    r101 = r100 >= 0 :: signed
    if not r101 goto L100 (error at decode_output:209) else goto L90 :: bool
L90:
    r102 = r4.data
    if is_error(r102) goto L100 (error at decode_output:210) else goto L91
L91:
    r103 = r4.call
    if is_error(r103) goto L242 (error at decode_output:210) else goto L92
L92:
    r104 = 'abi'
    r105 = CPyObject_GetAttr(r103, r104)
    dec_ref r103
    if is_error(r105) goto L242 (error at decode_output:210) else goto L93
L93:
    r106 = cast(dict, r105)
    if is_error(r106) goto L242 (error at decode_output:210) else goto L94
L94:
    r107 = __decode_output(r102, r106)
    dec_ref r102
    dec_ref r106
    if is_error(r107) goto L100 (error at decode_output:210) else goto L95
L95:
    r4.decoded = r107; r108 = is_error
    if not r108 goto L100 (error at decode_output:210) else goto L98 :: bool
L96:
    CPy_Reraise()
    if not 0 goto L100 else goto L243 :: bool
L97:
    unreachable
L98:
    r109 = r4.__mypyc_temp__34
    if is_error(r109) goto L114 (error at decode_output:-1) else goto L99
L99:
    CPy_RestoreExcInfo(r109)
    dec_ref r109
    goto L103
L100:
    r110 = r4.__mypyc_temp__34
    if is_error(r110) goto L114 (error at decode_output:-1) else goto L101
L101:
    CPy_RestoreExcInfo(r110)
    dec_ref r110
    r111 = CPy_KeepPropagating()
    if not r111 goto L114 else goto L244 :: bool
L102:
    unreachable
L103:
    r112 = r4.decoded
    if is_error(r112) goto L114 (error at decode_output:212) else goto L104
L104:
    r113 = builtins :: module
    r114 = 'Exception'
    r115 = CPyObject_GetAttr(r113, r114)
    if is_error(r115) goto L245 (error at decode_output:212) else goto L105
L105:
    r116 = PyObject_IsInstance(r112, r115)
    dec_ref r112
    dec_ref r115
    r117 = r116 >= 0 :: signed
    if not r117 goto L114 (error at decode_output:212) else goto L106 :: bool
L106:
    r118 = truncate r116: i32 to builtins.bool
    if r118 goto L107 else goto L110 :: bool
L107:
    r119 = r4.decoded
    if is_error(r119) goto L114 (error at decode_output:213) else goto L108
L108:
    CPy_Raise(r119)
    dec_ref r119
    if not 0 goto L114 (error at decode_output:213) else goto L246 :: bool
L109:
    unreachable
L110:
    r120 = r4.decoded
    if is_error(r120) goto L114 (error at decode_output:214) else goto L111
L111:
    r4.__mypyc_next_label__ = -2; r121 = is_error
    if not r121 goto L247 (error at decode_output:214) else goto L248 :: bool
L112:
    CPyGen_SetStopIterationValue(r120)
    dec_ref r120
    if not 0 goto L206 else goto L113 :: bool
L113:
    unreachable
L114:
    r122 = CPy_CatchError()
    r4.__mypyc_temp__35 = r122; r123 = is_error
    if not r123 goto L249 (error at decode_output:-1) else goto L115 :: bool
L115:
    r124 = dank_mids.brownie_patch.call.globals :: static
    r125 = 'InsufficientDataBytes'
    r126 = CPyDict_GetItem(r124, r125)
    if is_error(r126) goto L249 (error at decode_output:215) else goto L116
L116:
    r127 = CPy_ExceptionMatches(r126)
    dec_ref r126
    if r127 goto L250 else goto L134 :: bool
L117:
    r128 = CPy_GetExcValue()
    r4.e = r128; r129 = is_error
    if not r129 goto L198 (error at decode_output:215) else goto L118 :: bool
L118:
    r130 = r4.e
    if is_error(r130) goto L198 (error at decode_output:217) else goto L119
L119:
    r131 = 'args'
    r132 = CPyObject_GetAttr(r130, r131)
    dec_ref r130
    if is_error(r132) goto L198 (error at decode_output:217) else goto L120
L120:
    r133 = r4.call
    if is_error(r133) goto L251 (error at decode_output:217) else goto L121
L121:
    r134 = r4.call
    if is_error(r134) goto L252 (error at decode_output:217) else goto L122
L122:
    r135 = '_address'
    r136 = CPyObject_GetAttr(r134, r135)
    dec_ref r134
    if is_error(r136) goto L252 (error at decode_output:217) else goto L123
L123:
    r137 = r4.data
    if is_error(r137) goto L253 (error at decode_output:217) else goto L124
L124:
    r138 = PyList_New(0)
    if is_error(r138) goto L254 (error at decode_output:217) else goto L125
L125:
    r139 = CPyList_Extend(r138, r132)
    dec_ref r132
    if is_error(r139) goto L255 (error at decode_output:217) else goto L256
L126:
    r140 = PyList_Append(r138, r133)
    dec_ref r133
    r141 = r140 >= 0 :: signed
    if not r141 goto L257 (error at decode_output:217) else goto L127 :: bool
L127:
    r142 = PyList_Append(r138, r136)
    dec_ref r136
    r143 = r142 >= 0 :: signed
    if not r143 goto L258 (error at decode_output:217) else goto L128 :: bool
L128:
    r144 = PyList_Append(r138, r137)
    dec_ref r137
    r145 = r144 >= 0 :: signed
    if not r145 goto L259 (error at decode_output:217) else goto L129 :: bool
L129:
    r146 = PyList_AsTuple(r138)
    dec_ref r138
    if is_error(r146) goto L198 (error at decode_output:217) else goto L130
L130:
    r147 = r4.e
    if is_error(r147) goto L260 (error at decode_output:217) else goto L131
L131:
    r148 = 'args'
    r149 = PyObject_SetAttr(r147, r148, r146)
    dec_ref r147
    dec_ref r146
    r150 = r149 >= 0 :: signed
    if not r150 goto L198 (error at decode_output:217) else goto L132 :: bool
L132:
    CPy_Reraise()
    if not 0 goto L198 else goto L261 :: bool
L133:
    unreachable
L134:
    r151 = builtins :: module
    r152 = 'AttributeError'
    r153 = CPyObject_GetAttr(r151, r152)
    if is_error(r153) goto L249 (error at decode_output:219) else goto L135
L135:
    r154 = CPy_ExceptionMatches(r153)
    dec_ref r153
    if r154 goto L136 else goto L262 :: bool
L136:
    r155 = CPy_GetExcValue()
    r4.e = r155; r156 = is_error
    if not r156 goto L249 (error at decode_output:219) else goto L137 :: bool
L137:
    r157 = r4.e
    if is_error(r157) goto L249 (error at decode_output:221) else goto L138
L138:
    r158 = PyObject_Str(r157)
    dec_ref r157
    if is_error(r158) goto L249 (error at decode_output:221) else goto L139
L139:
    r159 = " object has no attribute '_skip_decoder_proc_pool'"
    r160 = CPyStr_Endswith(r158, r159)
    dec_ref r158
    if r160 goto L142 else goto L263 :: bool
L140:
    CPy_Reraise()
    if not 0 goto L198 else goto L264 :: bool
L141:
    unreachable
L142:
    r161 = dank_mids.brownie_patch.call.logger :: static
    if is_error(r161) goto L265 else goto L145
L143:
    r162 = raise NameError('value for final name "logger" was not set')
    if not r162 goto L198 (error at decode_output:223) else goto L266 :: bool
L144:
    unreachable
L145:
    r163 = 'DEBUG ME BRO: %s'
    r164 = r4.e
    if is_error(r164) goto L249 (error at decode_output:223) else goto L146
L146:
    r165 = 'debug'
    r166 = [r161, r163, r164]
    r167 = load_address r166
    r168 = PyObject_VectorcallMethod(r165, r167, 9223372036854775811, 0)
    if is_error(r168) goto L267 (error at decode_output:223) else goto L268
L147:
    dec_ref r164
    r169 = r4.call
    if is_error(r169) goto L249 (error at decode_output:224) else goto L148
L148:
    r170 = '_address'
    r171 = CPyObject_GetAttr(r169, r170)
    dec_ref r169
    if is_error(r171) goto L249 (error at decode_output:224) else goto L149
L149:
    r172 = dank_mids.brownie_patch.call.globals :: static
    r173 = '_skip_proc_pool'
    r174 = CPyDict_GetItem(r172, r173)
    if is_error(r174) goto L269 (error at decode_output:224) else goto L150
L150:
    r175 = cast(set, r174)
    if is_error(r175) goto L269 (error at decode_output:224) else goto L151
L151:
    r176 = PySet_Contains(r175, r171)
    dec_ref r175
    dec_ref r171
    r177 = r176 >= 0 :: signed
    if not r177 goto L249 (error at decode_output:224) else goto L152 :: bool
L152:
    r178 = truncate r176: i32 to builtins.bool
    r179 = r4.call
    if is_error(r179) goto L249 (error at decode_output:224) else goto L153
L153:
    r180 = '_skip_decoder_proc_pool'
    r181 = box(bool, r178)
    r182 = PyObject_SetAttr(r179, r180, r181)
    dec_ref r179
    r183 = r182 >= 0 :: signed
    if not r183 goto L249 (error at decode_output:224) else goto L154 :: bool
L154:
    r184 = r4.call
    if is_error(r184) goto L249 (error at decode_output:225) else goto L155
L155:
    r185 = r4.data
    if is_error(r185) goto L270 (error at decode_output:225) else goto L156
L156:
    r186 = decode_output(r184, r185)
    dec_ref r184
    dec_ref r185
    if is_error(r186) goto L249 (error at decode_output:225) else goto L157
L157:
    r187 = CPy_GetCoro(r186)
    dec_ref r186
    if is_error(r187) goto L249 (error at decode_output:225) else goto L158
L158:
    r4.__mypyc_temp__36 = r187; r188 = is_error
    if not r188 goto L249 (error at decode_output:-1) else goto L159 :: bool
L159:
    r189 = r4.__mypyc_temp__36
    if is_error(r189) goto L249 (error at decode_output:-1) else goto L160
L160:
    r190 = CPyIter_Next(r189)
    dec_ref r189
    if is_error(r190) goto L271 else goto L163
L161:
    r191 = CPy_FetchStopIterationValue()
    if is_error(r191) goto L198 (error at decode_output:225) else goto L162
L162:
    r192 = r191
    goto L192
L163:
    r193 = r190
L164:
    r4.__mypyc_next_label__ = 4; r194 = is_error
    if not r194 goto L272 (error at decode_output:225) else goto L273 :: bool
L165:
    return r193
L166:
    r195 = load_address _Py_NoneStruct
    r196 = type != r195
    if r196 goto L167 else goto L169 :: bool
L167:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L170 (error at decode_output:225) else goto L274 :: bool
L168:
    unreachable
L169:
    inc_ref arg
    goto L187
L170:
    r197 = CPy_CatchError()
    r4.__mypyc_temp__37 = r197; r198 = is_error
    if not r198 goto L275 (error at decode_output:-1) else goto L171 :: bool
L171:
    r199 = load_address r3
    r200 = r4.__mypyc_temp__36
    if is_error(r200) goto L275 (error at decode_output:-1) else goto L172
L172:
    r201 = CPy_YieldFromErrorHandle(r200, r199)
    dec_ref r200
    if is_error(r201) goto L275 (error at decode_output:225) else goto L173
L173:
    if r201 goto L179 else goto L174 :: bool
L174:
    if is_error(r3) goto L175 else goto L177
L175:
    r202 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r202 goto L184 (error at decode_output:-1) else goto L276 :: bool
L176:
    unreachable
L177:
    inc_ref r3
    r193 = r3
    r203 = r4.__mypyc_temp__37
    if is_error(r203) goto L277 (error at decode_output:-1) else goto L178
L178:
    CPy_RestoreExcInfo(r203)
    dec_ref r203
    goto L164
L179:
    if is_error(r3) goto L180 else goto L182
L180:
    r204 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r204 goto L184 (error at decode_output:-1) else goto L278 :: bool
L181:
    unreachable
L182:
    r192 = r3
    r205 = r4.__mypyc_temp__37
    if is_error(r205) goto L279 (error at decode_output:-1) else goto L183
L183:
    CPy_RestoreExcInfo(r205)
    dec_ref r205
    goto L192
L184:
    r206 = r4.__mypyc_temp__37
    if is_error(r206) goto L198 (error at decode_output:-1) else goto L185
L185:
    CPy_RestoreExcInfo(r206)
    dec_ref r206
    r207 = CPy_KeepPropagating()
    if not r207 goto L198 else goto L280 :: bool
L186:
    unreachable
L187:
    r208 = r4.__mypyc_temp__36
    if is_error(r208) goto L281 (error at decode_output:-1) else goto L188
L188:
    r209 = CPyIter_Send(r208, arg)
    dec_ref r208
    dec_ref arg
    if is_error(r209) goto L282 else goto L189
L189:
    r193 = r209
    goto L164
L190:
    r210 = CPy_FetchStopIterationValue()
    if is_error(r210) goto L198 (error at decode_output:225) else goto L191
L191:
    r192 = r210
L192:
    r211 = r4.__mypyc_temp__35
    if is_error(r211) goto L283 (error at decode_output:-1) else goto L193
L193:
    CPy_RestoreExcInfo(r211)
    dec_ref r211
    r4.__mypyc_next_label__ = -2; r212 = is_error
    if not r212 goto L283 (error at decode_output:225) else goto L284 :: bool
L194:
    CPyGen_SetStopIterationValue(r192)
    dec_ref r192
    if not 0 goto L206 else goto L195 :: bool
L195:
    unreachable
L196:
    CPy_Reraise()
    if not 0 goto L198 else goto L285 :: bool
L197:
    unreachable
L198:
    r213 = r4.__mypyc_temp__35
    dec_ref r4
    if is_error(r213) goto L206 (error at decode_output:-1) else goto L199
L199:
    CPy_RestoreExcInfo(r213)
    dec_ref r213
    r214 = CPy_KeepPropagating()
    if not r214 goto L206 else goto L200 :: bool
L200:
    unreachable
L201:
    r215 = r5 == 0
    if r215 goto L286 else goto L202 :: bool
L202:
    r216 = r5 == 2
    if r216 goto L287 else goto L288 :: bool
L203:
    r217 = r5 == 4
    dec_ref r5 :: int
    if r217 goto L166 else goto L289 :: bool
L204:
    r218 = raise StopIteration
    if not r218 goto L206 (error at decode_output:196) else goto L205 :: bool
L205:
    unreachable
L206:
    r219 = <error> :: object
    return r219
L207:
    xdec_ref r1
    xdec_ref r3
    goto L206
L208:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L206
L209:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L3
L210:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r10
    goto L206
L211:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r11
    goto L206
L212:
    xdec_ref r1
    goto L114
L213:
    xdec_ref r1
    goto L17
L214:
    dec_ref r25
    goto L114
L215:
    xdec_ref r1
    goto L65
L216:
    xdec_ref r1
    dec_ref r32
    goto L65
L217:
    xdec_ref r1
    dec_ref r32
    dec_ref r33
    goto L26
L218:
    xdec_ref r3
    dec_ref r4
    goto L27
L219:
    xdec_ref r1
    dec_ref r32
    dec_ref r33
    goto L65
L220:
    xdec_ref r1
    goto L33
L221:
    dec_ref r45
    goto L42
L222:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L37
L223:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L40
L224:
    xdec_ref r1
    goto L56
L225:
    xdec_ref r3
    dec_ref r4
    goto L48
L226:
    xdec_ref r1
    dec_ref r45
    goto L56
L227:
    xdec_ref r3
    dec_ref r4
    goto L53
L228:
    dec_ref r44
    goto L56
L229:
    xdec_ref r3
    dec_ref r4
    goto L58
L230:
    xdec_ref r1
    dec_ref arg
    goto L65
L231:
    xdec_ref r1
    goto L62
L232:
    xdec_ref r3
    dec_ref r4
    goto L70
L233:
    xdec_ref r3
    dec_ref r4
    goto L73
L234:
    dec_ref r76
    goto L100
L235:
    dec_ref r76
    dec_ref r77
    goto L100
L236:
    dec_ref r76
    dec_ref r77
    dec_ref r80
    goto L100
L237:
    dec_ref r84
    goto L79
L238:
    xdec_ref r3
    dec_ref r4
    goto L81
L239:
    dec_ref r90
    goto L100
L240:
    dec_ref r96
    goto L87
L241:
    xdec_ref r3
    dec_ref r4
    goto L88
L242:
    dec_ref r102
    goto L100
L243:
    xdec_ref r3
    dec_ref r4
    goto L97
L244:
    xdec_ref r3
    dec_ref r4
    goto L102
L245:
    dec_ref r112
    goto L114
L246:
    xdec_ref r3
    dec_ref r4
    goto L109
L247:
    dec_ref r120
    goto L114
L248:
    xdec_ref r3
    dec_ref r4
    goto L112
L249:
    xdec_ref r3
    goto L198
L250:
    xdec_ref r3
    goto L117
L251:
    dec_ref r132
    goto L198
L252:
    dec_ref r132
    dec_ref r133
    goto L198
L253:
    dec_ref r132
    dec_ref r133
    dec_ref r136
    goto L198
L254:
    dec_ref r132
    dec_ref r133
    dec_ref r136
    dec_ref r137
    goto L198
L255:
    dec_ref r133
    dec_ref r136
    dec_ref r137
    dec_ref r138
    goto L198
L256:
    dec_ref r139
    goto L126
L257:
    dec_ref r136
    dec_ref r137
    dec_ref r138
    goto L198
L258:
    dec_ref r137
    dec_ref r138
    goto L198
L259:
    dec_ref r138
    goto L198
L260:
    dec_ref r146
    goto L198
L261:
    dec_ref r4
    goto L133
L262:
    xdec_ref r3
    goto L196
L263:
    xdec_ref r3
    goto L140
L264:
    dec_ref r4
    goto L141
L265:
    xdec_ref r3
    goto L143
L266:
    dec_ref r4
    goto L144
L267:
    xdec_ref r3
    dec_ref r164
    goto L198
L268:
    dec_ref r168
    goto L147
L269:
    xdec_ref r3
    dec_ref r171
    goto L198
L270:
    xdec_ref r3
    dec_ref r184
    goto L198
L271:
    xdec_ref r3
    goto L161
L272:
    dec_ref r193
    goto L170
L273:
    xdec_ref r3
    dec_ref r4
    goto L165
L274:
    xdec_ref r3
    dec_ref r4
    goto L168
L275:
    xdec_ref r3
    goto L184
L276:
    dec_ref r4
    goto L176
L277:
    xdec_ref r3
    dec_ref r193
    goto L184
L278:
    dec_ref r4
    goto L181
L279:
    dec_ref r192
    goto L184
L280:
    dec_ref r4
    goto L186
L281:
    xdec_ref r3
    dec_ref arg
    goto L198
L282:
    xdec_ref r3
    goto L190
L283:
    dec_ref r192
    goto L198
L284:
    dec_ref r4
    goto L194
L285:
    dec_ref r4
    goto L197
L286:
    dec_ref r5 :: int
    goto L2
L287:
    dec_ref r5 :: int
    goto L38
L288:
    xdec_ref r1
    goto L203
L289:
    xdec_ref r3
    dec_ref r4
    goto L204

def decode_output_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def decode_output_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def decode_output_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def decode_output_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def decode_output_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def decode_output_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def decode_output(call, data):
    call :: object
    data :: bytes
    r0 :: dank_mids.brownie_patch.call.decode_output_env
    r1, r2 :: bool
    r3 :: dank_mids.brownie_patch.call.decode_output_gen
    r4, r5 :: bool
    r6 :: object
L0:
    r0 = decode_output_env()
    if is_error(r0) goto L7 (error at decode_output:196) else goto L1
L1:
    inc_ref call
    r0.call = call; r1 = is_error
    if not r1 goto L8 (error at decode_output:196) else goto L2 :: bool
L2:
    inc_ref data
    r0.data = data; r2 = is_error
    if not r2 goto L8 (error at decode_output:196) else goto L3 :: bool
L3:
    r3 = decode_output_gen()
    if is_error(r3) goto L8 (error at decode_output:196) else goto L4
L4:
    inc_ref r0
    r3.__mypyc_env__ = r0; r4 = is_error
    if not r4 goto L9 (error at decode_output:196) else goto L5 :: bool
L5:
    r0.__mypyc_next_label__ = 0; r5 = is_error
    dec_ref r0
    if not r5 goto L10 (error at decode_output:196) else goto L6 :: bool
L6:
    return r3
L7:
    r6 = <error> :: object
    return r6
L8:
    dec_ref r0
    goto L7
L9:
    dec_ref r0
    dec_ref r3
    goto L7
L10:
    dec_ref r3
    goto L7

def _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    type, value, traceback, arg :: object
    r0 :: dank_mids.brownie_patch.call._request_data_no_args_env
    r1 :: int
    r2 :: object
    r3 :: bit
    r4 :: object
    r5 :: str
    r6 :: object
    r7 :: bool
    r8 :: bit
    r9 :: bool
    r10 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L13 (error at _request_data_no_args:228) else goto L1
L1:
    r1 = r0.__mypyc_next_label__
    if is_error(r1) goto L14 (error at _request_data_no_args:228) else goto L10
L2:
    r2 = load_address _Py_NoneStruct
    r3 = type != r2
    if r3 goto L15 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L13 (error at _request_data_no_args:228) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = r0.call
    if is_error(r4) goto L14 (error at _request_data_no_args:229) else goto L6
L6:
    r5 = 'signature'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L14 (error at _request_data_no_args:229) else goto L7
L7:
    r0.__mypyc_next_label__ = -2; r7 = is_error
    dec_ref r0
    if not r7 goto L16 (error at _request_data_no_args:229) else goto L8 :: bool
L8:
    CPyGen_SetStopIterationValue(r6)
    dec_ref r6
    if not 0 goto L13 else goto L9 :: bool
L9:
    unreachable
L10:
    r8 = r1 == 0
    dec_ref r1 :: int
    if r8 goto L2 else goto L17 :: bool
L11:
    r9 = raise StopIteration
    if not r9 goto L13 (error at _request_data_no_args:228) else goto L12 :: bool
L12:
    unreachable
L13:
    r10 = <error> :: object
    return r10
L14:
    dec_ref r0
    goto L13
L15:
    dec_ref r0
    goto L3
L16:
    dec_ref r6
    goto L13
L17:
    dec_ref r0
    goto L11

def _request_data_no_args_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _request_data_no_args_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _request_data_no_args_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _request_data_no_args_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def _request_data_no_args_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def _request_data_no_args_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _request_data_no_args(call):
    call :: object
    r0 :: dank_mids.brownie_patch.call._request_data_no_args_env
    r1 :: bool
    r2 :: dank_mids.brownie_patch.call._request_data_no_args_gen
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = _request_data_no_args_env()
    if is_error(r0) goto L6 (error at _request_data_no_args:228) else goto L1
L1:
    inc_ref call
    r0.call = call; r1 = is_error
    if not r1 goto L7 (error at _request_data_no_args:228) else goto L2 :: bool
L2:
    r2 = _request_data_no_args_gen()
    if is_error(r2) goto L7 (error at _request_data_no_args:228) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L8 (error at _request_data_no_args:228) else goto L4 :: bool
L4:
    r0.__mypyc_next_label__ = 0; r4 = is_error
    dec_ref r0
    if not r4 goto L9 (error at _request_data_no_args:228) else goto L5 :: bool
L5:
    return r2
L6:
    r5 = <error> :: object
    return r5
L7:
    dec_ref r0
    goto L6
L8:
    dec_ref r0
    dec_ref r2
    goto L6
L9:
    dec_ref r2
    goto L6

def __encode_input(abi, signature, args):
    abi :: dict
    signature :: str
    args :: tuple
    r0 :: list
    r1 :: str
    r2 :: object
    r3 :: dict
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8, r9 :: object
    r10 :: bool
    r11 :: object[2]
    r12 :: object_ptr
    r13 :: object
    r14 :: bytes
    r15 :: str
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19, r20 :: str
    r21 :: tuple[object, object, object]
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: bit
    r26 :: object
    r27 :: bit
    r28 :: object
L0:
L1:
    r0 = format_input_but_cache_checksums(abi, args)
    if is_error(r0) goto L14 (error at __encode_input:243) else goto L2
L2:
    r1 = 'inputs'
    r2 = CPyDict_GetItem(abi, r1)
    if is_error(r2) goto L22 (error at __encode_input:244) else goto L3
L3:
    r3 = dank_mids.brownie_patch.call.globals :: static
    r4 = 'get_type_strings'
    r5 = CPyDict_GetItem(r3, r4)
    if is_error(r5) goto L23 (error at __encode_input:244) else goto L4
L4:
    r6 = [r2]
    r7 = load_address r6
    r8 = _PyObject_Vectorcall(r5, r7, 1, 0)
    dec_ref r5
    if is_error(r8) goto L23 (error at __encode_input:244) else goto L5
L5:
    dec_ref r2
    r9 = dank_mids.brownie_patch.call.__eth_abi_encode :: static
    if is_error(r9) goto L24 else goto L8
L6:
    r10 = raise NameError('value for final name "__eth_abi_encode" was not set')
    if not r10 goto L14 (error at __encode_input:245) else goto L7 :: bool
L7:
    unreachable
L8:
    r11 = [r8, r0]
    r12 = load_address r11
    r13 = _PyObject_Vectorcall(r9, r12, 2, 0)
    if is_error(r13) goto L25 (error at __encode_input:245) else goto L9
L9:
    dec_ref r8
    dec_ref r0
    r14 = cast(bytes, r13)
    if is_error(r14) goto L14 (error at __encode_input:245) else goto L10
L10:
    r15 = 'hex'
    r16 = [r14]
    r17 = load_address r16
    r18 = PyObject_VectorcallMethod(r15, r17, 9223372036854775809, 0)
    if is_error(r18) goto L26 (error at __encode_input:245) else goto L11
L11:
    dec_ref r14
    r19 = cast(str, r18)
    if is_error(r19) goto L14 (error at __encode_input:245) else goto L12
L12:
    r20 = PyUnicode_Concat(signature, r19)
    dec_ref r19
    if is_error(r20) goto L14 (error at __encode_input:245) else goto L13
L13:
    return r20
L14:
    r21 = CPy_CatchError()
    r22 = builtins :: module
    r23 = 'Exception'
    r24 = CPyObject_GetAttr(r22, r23)
    if is_error(r24) goto L19 (error at __encode_input:246) else goto L15
L15:
    r25 = CPy_ExceptionMatches(r24)
    dec_ref r24
    if r25 goto L16 else goto L17 :: bool
L16:
    r26 = CPy_GetExcValue()
    CPy_RestoreExcInfo(r21)
    dec_ref r21
    return r26
L17:
    CPy_Reraise()
    if not 0 goto L19 else goto L27 :: bool
L18:
    unreachable
L19:
    CPy_RestoreExcInfo(r21)
    dec_ref r21
    r27 = CPy_KeepPropagating()
    if not r27 goto L21 else goto L20 :: bool
L20:
    unreachable
L21:
    r28 = <error> :: object
    return r28
L22:
    dec_ref r0
    goto L14
L23:
    dec_ref r0
    dec_ref r2
    goto L14
L24:
    dec_ref r0
    dec_ref r8
    goto L6
L25:
    dec_ref r0
    dec_ref r8
    goto L14
L26:
    dec_ref r14
    goto L14
L27:
    dec_ref r21
    goto L18

def __decode_output(hexstr, abi):
    hexstr :: object
    abi :: dict
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
    r9 :: bool
    r10 :: object[1]
    r11 :: object_ptr
    r12, r13 :: object
    r14 :: bool
    r15 :: object[2]
    r16 :: object_ptr
    r17 :: object
    r18, result :: tuple
    r19 :: object
    r20 :: tuple
    r21 :: ptr
    r22 :: native_int
    r23 :: short_int
    r24 :: bit
    r25 :: tuple[object]
    r26 :: object
    r27 :: union[object, tuple]
    r28 :: tuple[object, object, object]
    r29 :: object
    r30 :: str
    r31 :: object
    r32 :: bit
    r33 :: object
    r34 :: bit
    r35 :: object
L0:
L1:
    r0 = 'outputs'
    r1 = CPyDict_GetItem(abi, r0)
    if is_error(r1) goto L20 (error at __decode_output:265) else goto L2
L2:
    r2 = dank_mids.brownie_patch.call.globals :: static
    r3 = 'get_type_strings'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L28 (error at __decode_output:265) else goto L3
L3:
    r5 = [r1]
    r6 = load_address r5
    r7 = _PyObject_Vectorcall(r4, r6, 1, 0)
    dec_ref r4
    if is_error(r7) goto L28 (error at __decode_output:265) else goto L4
L4:
    dec_ref r1
    r8 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r8) goto L29 else goto L7
L5:
    r9 = raise NameError('value for final name "HexBytes" was not set')
    if not r9 goto L20 (error at __decode_output:266) else goto L6 :: bool
L6:
    unreachable
L7:
    r10 = [hexstr]
    r11 = load_address r10
    r12 = _PyObject_Vectorcall(r8, r11, 1, 0)
    if is_error(r12) goto L30 (error at __decode_output:266) else goto L8
L8:
    r13 = dank_mids.brownie_patch.call.__eth_abi_decode :: static
    if is_error(r13) goto L31 else goto L11
L9:
    r14 = raise NameError('value for final name "__eth_abi_decode" was not set')
    if not r14 goto L20 (error at __decode_output:266) else goto L10 :: bool
L10:
    unreachable
L11:
    r15 = [r7, r12]
    r16 = load_address r15
    r17 = _PyObject_Vectorcall(r13, r16, 2, 0)
    if is_error(r17) goto L32 (error at __decode_output:266) else goto L12
L12:
    dec_ref r7
    dec_ref r12
    r18 = cast(tuple, r17)
    if is_error(r18) goto L20 (error at __decode_output:266) else goto L13
L13:
    result = r18
    r19 = format_output_but_cache_checksums(abi, result)
    dec_ref result
    if is_error(r19) goto L20 (error at __decode_output:267) else goto L14
L14:
    r20 = cast(tuple, r19)
    if is_error(r20) goto L20 (error at __decode_output:267) else goto L15
L15:
    result = r20
    r21 = get_element_ptr result ob_size :: PyVarObject
    r22 = load_mem r21 :: native_int*
    r23 = r22 << 1
    r24 = r23 == 2
    if r24 goto L16 else goto L18 :: bool
L16:
    r25 = unbox(tuple[object], result)
    dec_ref result
    if is_error(r25) goto L20 (error at __decode_output:268) else goto L17
L17:
    r26 = r25[0]
    dec_ref r25
    r27 = r26
    goto L19
L18:
    r27 = result
L19:
    return r27
L20:
    r28 = CPy_CatchError()
    r29 = builtins :: module
    r30 = 'Exception'
    r31 = CPyObject_GetAttr(r29, r30)
    if is_error(r31) goto L25 (error at __decode_output:269) else goto L21
L21:
    r32 = CPy_ExceptionMatches(r31)
    dec_ref r31
    if r32 goto L22 else goto L23 :: bool
L22:
    r33 = CPy_GetExcValue()
    CPy_RestoreExcInfo(r28)
    dec_ref r28
    return r33
L23:
    CPy_Reraise()
    if not 0 goto L25 else goto L33 :: bool
L24:
    unreachable
L25:
    CPy_RestoreExcInfo(r28)
    dec_ref r28
    r34 = CPy_KeepPropagating()
    if not r34 goto L27 else goto L26 :: bool
L26:
    unreachable
L27:
    r35 = <error> :: object
    return r35
L28:
    dec_ref r1
    goto L20
L29:
    dec_ref r7
    goto L5
L30:
    dec_ref r7
    goto L20
L31:
    dec_ref r7
    dec_ref r12
    goto L9
L32:
    dec_ref r7
    dec_ref r12
    goto L20
L33:
    dec_ref r28
    goto L24

def __validate_output(abi, hexstr):
    abi :: dict
    hexstr, r0 :: object
    r1 :: bool
    r2 :: object[1]
    r3 :: object_ptr
    r4, r5, r6, r7, r8, r9 :: object
    r10 :: str
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: i32
    r17 :: bit
    r18 :: bool
    r19 :: dict
    r20 :: str
    r21 :: object
    r22 :: str
    r23 :: list
    r24, r25 :: ptr
    r26 :: object
    r27 :: bool
    r28 :: object[1]
    r29 :: object_ptr
    r30, r31, r32, r33, r34, r35 :: object
    r36 :: str
    r37 :: object[3]
    r38 :: object_ptr
    r39, r40, r41, revert_str :: object
    r42, r43, r44 :: str
    r45 :: object
    r46 :: bool
    r47 :: object[1]
    r48 :: object_ptr
    r49 :: object
    r50 :: str
    r51 :: object
    r52 :: i32
    r53 :: bit
    r54 :: bool
    r55 :: object
    r56 :: bool
    r57 :: object[1]
    r58 :: object_ptr
    r59, r60, r61, r62, r63, r64 :: object
    r65 :: str
    r66 :: object[1]
    r67 :: object_ptr
    r68, r69, r70 :: object
    r71 :: object[2]
    r72 :: object_ptr
    r73 :: object
    r74 :: int
    r75 :: dict
    r76 :: str
    r77, r78 :: object
    r79 :: i32
    r80 :: bit
    r81 :: bool
    r82 :: dict
    r83 :: str
    r84, r85, r86 :: object
    r87, r88, r89, r90, r91, r92, r93 :: str
    r94 :: object
    r95 :: bool
    r96 :: object[1]
    r97 :: object_ptr
    r98 :: object
    r99 :: str
    r100 :: object
    r101 :: i32
    r102 :: bit
    r103 :: bool
    r104 :: str
    r105 :: object
    r106 :: bool
    r107 :: object[1]
    r108 :: object_ptr
    r109 :: object
    r110 :: str
    r111 :: object
    r112 :: i32
    r113 :: bit
    r114 :: bool
    r115 :: i32
    r116 :: bit
    r117 :: bool
    r118 :: str
    r119 :: object
    r120 :: bool
    r121 :: object[1]
    r122 :: object_ptr
    r123 :: object
    r124 :: tuple[object, object, object]
    r125 :: object
    r126 :: str
    r127 :: object
    r128 :: bit
    r129 :: object
    r130 :: dict
    r131 :: str
    r132 :: object
    r133 :: object[1]
    r134 :: object_ptr
    r135 :: object
    r136 :: tuple[object, object, object]
    r137, r138 :: bit
    r139 :: None
L0:
L1:
    r0 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r0) goto L2 else goto L4
L2:
    r1 = raise NameError('value for final name "HexBytes" was not set')
    if not r1 goto L78 (error at __validate_output:275) else goto L3 :: bool
L3:
    unreachable
L4:
    r2 = [hexstr]
    r3 = load_address r2
    r4 = _PyObject_Vectorcall(r0, r3, 1, 0)
    if is_error(r4) goto L78 (error at __validate_output:275) else goto L5
L5:
    r5 = load_address _Py_NoneStruct
    r6 = load_address _Py_NoneStruct
    r7 = object 4
    r8 = PySlice_New(r5, r7, r6)
    if is_error(r8) goto L95 (error at __validate_output:275) else goto L6
L6:
    r9 = PyObject_GetItem(r4, r8)
    dec_ref r4
    dec_ref r8
    if is_error(r9) goto L78 (error at __validate_output:275) else goto L7
L7:
    r10 = 'hex'
    r11 = [r9]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775809, 0)
    if is_error(r13) goto L96 (error at __validate_output:275) else goto L8
L8:
    dec_ref r9
    r14 = '0x08c379a0'
    r15 = PyObject_RichCompare(r13, r14, 2)
    if is_error(r15) goto L97 (error at __validate_output:276) else goto L9
L9:
    r16 = PyObject_IsTrue(r15)
    dec_ref r15
    r17 = r16 >= 0 :: signed
    if not r17 goto L97 (error at __validate_output:276) else goto L10 :: bool
L10:
    r18 = truncate r16: i32 to builtins.bool
    if r18 goto L98 else goto L29 :: bool
L11:
    r19 = dank_mids.brownie_patch.call.globals :: static
    r20 = 'eth_abi'
    r21 = CPyDict_GetItem(r19, r20)
    if is_error(r21) goto L78 (error at __validate_output:277) else goto L12
L12:
    r22 = 'string'
    r23 = PyList_New(1)
    if is_error(r23) goto L99 (error at __validate_output:277) else goto L13
L13:
    r24 = get_element_ptr r23 ob_item :: PyListObject
    r25 = load_mem r24 :: ptr*
    inc_ref r22
    set_mem r25, r22 :: builtins.object*
    r26 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r26) goto L100 else goto L16
L14:
    r27 = raise NameError('value for final name "HexBytes" was not set')
    if not r27 goto L78 (error at __validate_output:277) else goto L15 :: bool
L15:
    unreachable
L16:
    r28 = [hexstr]
    r29 = load_address r28
    r30 = _PyObject_Vectorcall(r26, r29, 1, 0)
    if is_error(r30) goto L101 (error at __validate_output:277) else goto L17
L17:
    r31 = load_address _Py_NoneStruct
    r32 = load_address _Py_NoneStruct
    r33 = object 4
    r34 = PySlice_New(r33, r31, r32)
    if is_error(r34) goto L102 (error at __validate_output:277) else goto L18
L18:
    r35 = PyObject_GetItem(r30, r34)
    dec_ref r30
    dec_ref r34
    if is_error(r35) goto L101 (error at __validate_output:277) else goto L19
L19:
    r36 = 'decode_abi'
    r37 = [r21, r23, r35]
    r38 = load_address r37
    r39 = PyObject_VectorcallMethod(r36, r38, 9223372036854775811, 0)
    if is_error(r39) goto L103 (error at __validate_output:277) else goto L20
L20:
    dec_ref r21
    dec_ref r23
    dec_ref r35
    r40 = object 0
    r41 = PyObject_GetItem(r39, r40)
    dec_ref r39
    if is_error(r41) goto L78 (error at __validate_output:277) else goto L21
L21:
    revert_str = r41
    r42 = 'Call reverted: '
    r43 = PyObject_Str(revert_str)
    dec_ref revert_str
    if is_error(r43) goto L78 (error at __validate_output:278) else goto L22
L22:
    r44 = CPyStr_Build(2, r42, r43)
    dec_ref r43
    if is_error(r44) goto L78 (error at __validate_output:278) else goto L23
L23:
    r45 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r45) goto L104 else goto L26
L24:
    r46 = raise NameError('value for final name "Revert" was not set')
    if not r46 goto L78 (error at __validate_output:278) else goto L25 :: bool
L25:
    unreachable
L26:
    r47 = [r44]
    r48 = load_address r47
    r49 = _PyObject_Vectorcall(r45, r48, 1, 0)
    if is_error(r49) goto L105 (error at __validate_output:278) else goto L27
L27:
    dec_ref r44
    CPy_Raise(r49)
    dec_ref r49
    if not 0 goto L78 (error at __validate_output:278) else goto L28 :: bool
L28:
    unreachable
L29:
    r50 = '0x4e487b71'
    r51 = PyObject_RichCompare(r13, r50, 2)
    if is_error(r51) goto L97 (error at __validate_output:279) else goto L30
L30:
    r52 = PyObject_IsTrue(r51)
    dec_ref r51
    r53 = r52 >= 0 :: signed
    if not r53 goto L97 (error at __validate_output:279) else goto L31 :: bool
L31:
    r54 = truncate r52: i32 to builtins.bool
    if r54 goto L106 else goto L58 :: bool
L32:
    r55 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r55) goto L33 else goto L35
L33:
    r56 = raise NameError('value for final name "HexBytes" was not set')
    if not r56 goto L78 (error at __validate_output:280) else goto L34 :: bool
L34:
    unreachable
L35:
    r57 = [hexstr]
    r58 = load_address r57
    r59 = _PyObject_Vectorcall(r55, r58, 1, 0)
    if is_error(r59) goto L78 (error at __validate_output:280) else goto L36
L36:
    r60 = load_address _Py_NoneStruct
    r61 = load_address _Py_NoneStruct
    r62 = object 4
    r63 = PySlice_New(r62, r60, r61)
    if is_error(r63) goto L107 (error at __validate_output:280) else goto L37
L37:
    r64 = PyObject_GetItem(r59, r63)
    dec_ref r59
    dec_ref r63
    if is_error(r64) goto L78 (error at __validate_output:280) else goto L38
L38:
    r65 = 'hex'
    r66 = [r64]
    r67 = load_address r66
    r68 = PyObject_VectorcallMethod(r65, r67, 9223372036854775809, 0)
    if is_error(r68) goto L108 (error at __validate_output:280) else goto L39
L39:
    dec_ref r64
    r69 = load_address PyLong_Type
    r70 = object 16
    r71 = [r68, r70]
    r72 = load_address r71
    r73 = _PyObject_Vectorcall(r69, r72, 2, 0)
    if is_error(r73) goto L109 (error at __validate_output:280) else goto L40
L40:
    dec_ref r68
    r74 = unbox(int, r73)
    dec_ref r73
    if is_error(r74) goto L78 (error at __validate_output:280) else goto L41
L41:
    r75 = dank_mids.brownie_patch.call.globals :: static
    r76 = 'SOLIDITY_ERROR_CODES'
    r77 = CPyDict_GetItem(r75, r76)
    if is_error(r77) goto L110 (error at __validate_output:281) else goto L42
L42:
    inc_ref r74 :: int
    r78 = box(int, r74)
    r79 = PySequence_Contains(r77, r78)
    dec_ref r77
    dec_ref r78
    r80 = r79 >= 0 :: signed
    if not r80 goto L110 (error at __validate_output:281) else goto L43 :: bool
L43:
    r81 = truncate r79: i32 to builtins.bool
    if r81 goto L44 else goto L47 :: bool
L44:
    r82 = dank_mids.brownie_patch.call.globals :: static
    r83 = 'SOLIDITY_ERROR_CODES'
    r84 = CPyDict_GetItem(r82, r83)
    if is_error(r84) goto L110 (error at __validate_output:282) else goto L45
L45:
    r85 = box(int, r74)
    r86 = PyObject_GetItem(r84, r85)
    dec_ref r84
    dec_ref r85
    if is_error(r86) goto L78 (error at __validate_output:282) else goto L46
L46:
    revert_str = r86
    goto L50
L47:
    r87 = 'Panic (error code: '
    r88 = CPyTagged_Str(r74)
    dec_ref r74 :: int
    if is_error(r88) goto L78 (error at __validate_output:284) else goto L48
L48:
    r89 = ')'
    r90 = CPyStr_Build(3, r87, r88, r89)
    dec_ref r88
    if is_error(r90) goto L78 (error at __validate_output:284) else goto L49
L49:
    revert_str = r90
L50:
    r91 = 'Call reverted: '
    r92 = PyObject_Str(revert_str)
    dec_ref revert_str
    if is_error(r92) goto L78 (error at __validate_output:285) else goto L51
L51:
    r93 = CPyStr_Build(2, r91, r92)
    dec_ref r92
    if is_error(r93) goto L78 (error at __validate_output:285) else goto L52
L52:
    r94 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r94) goto L111 else goto L55
L53:
    r95 = raise NameError('value for final name "Revert" was not set')
    if not r95 goto L78 (error at __validate_output:285) else goto L54 :: bool
L54:
    unreachable
L55:
    r96 = [r93]
    r97 = load_address r96
    r98 = _PyObject_Vectorcall(r94, r97, 1, 0)
    if is_error(r98) goto L112 (error at __validate_output:285) else goto L56
L56:
    dec_ref r93
    CPy_Raise(r98)
    dec_ref r98
    if not 0 goto L78 (error at __validate_output:285) else goto L57 :: bool
L57:
    unreachable
L58:
    r99 = '0xc1b84b2f'
    r100 = PyObject_RichCompare(r13, r99, 2)
    dec_ref r13
    if is_error(r100) goto L78 (error at __validate_output:286) else goto L59
L59:
    r101 = PyObject_IsTrue(r100)
    dec_ref r100
    r102 = r101 >= 0 :: signed
    if not r102 goto L78 (error at __validate_output:286) else goto L60 :: bool
L60:
    r103 = truncate r101: i32 to builtins.bool
    if r103 goto L61 else goto L67 :: bool
L61:
    r104 = 'Call reverted: execution reverted'
    r105 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r105) goto L62 else goto L64
L62:
    r106 = raise NameError('value for final name "Revert" was not set')
    if not r106 goto L78 (error at __validate_output:287) else goto L63 :: bool
L63:
    unreachable
L64:
    r107 = [r104]
    r108 = load_address r107
    r109 = _PyObject_Vectorcall(r105, r108, 1, 0)
    if is_error(r109) goto L78 (error at __validate_output:287) else goto L65
L65:
    CPy_Raise(r109)
    dec_ref r109
    if not 0 goto L78 (error at __validate_output:287) else goto L66 :: bool
L66:
    unreachable
L67:
    r110 = 'outputs'
    r111 = CPyDict_GetItem(abi, r110)
    if is_error(r111) goto L78 (error at __validate_output:288) else goto L68
L68:
    r112 = PyObject_IsTrue(r111)
    dec_ref r111
    r113 = r112 >= 0 :: signed
    if not r113 goto L78 (error at __validate_output:288) else goto L69 :: bool
L69:
    r114 = truncate r112: i32 to builtins.bool
    if r114 goto L70 else goto L93 :: bool
L70:
    r115 = PyObject_IsTrue(hexstr)
    r116 = r115 >= 0 :: signed
    if not r116 goto L78 (error at __validate_output:273) else goto L71 :: bool
L71:
    r117 = truncate r115: i32 to builtins.bool
    if r117 goto L93 else goto L72 :: bool
L72:
    r118 = 'No data was returned - the call likely reverted'
    r119 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r119) goto L73 else goto L75
L73:
    r120 = raise NameError('value for final name "Revert" was not set')
    if not r120 goto L78 (error at __validate_output:289) else goto L74 :: bool
L74:
    unreachable
L75:
    r121 = [r118]
    r122 = load_address r121
    r123 = _PyObject_Vectorcall(r119, r122, 1, 0)
    if is_error(r123) goto L78 (error at __validate_output:289) else goto L76
L76:
    CPy_Raise(r123)
    dec_ref r123
    if not 0 goto L78 (error at __validate_output:289) else goto L77 :: bool
L77:
    unreachable
L78:
    r124 = CPy_CatchError()
    r125 = builtins :: module
    r126 = 'ValueError'
    r127 = CPyObject_GetAttr(r125, r126)
    if is_error(r127) goto L91 (error at __validate_output:290) else goto L79
L79:
    r128 = CPy_ExceptionMatches(r127)
    dec_ref r127
    if r128 goto L80 else goto L89 :: bool
L80:
    r129 = CPy_GetExcValue()
L81:
    r130 = dank_mids.brownie_patch.call.globals :: static
    r131 = 'VirtualMachineError'
    r132 = CPyDict_GetItem(r130, r131)
    if is_error(r132) goto L85 (error at __validate_output:292) else goto L82
L82:
    r133 = [r129]
    r134 = load_address r133
    r135 = _PyObject_Vectorcall(r132, r134, 1, 0)
    dec_ref r132
    if is_error(r135) goto L85 (error at __validate_output:292) else goto L83
L83:
    CPy_Raise(r135)
    dec_ref r135
    if not 0 goto L85 (error at __validate_output:292) else goto L113 :: bool
L84:
    unreachable
L85:
    r136 = CPy_CatchError()
    CPy_Raise(r129)
    dec_ref r129
    if not 0 goto L87 (error at __validate_output:294) else goto L114 :: bool
L86:
    unreachable
L87:
    CPy_RestoreExcInfo(r136)
    dec_ref r136
    r137 = CPy_KeepPropagating()
    if not r137 goto L91 else goto L115 :: bool
L88:
    unreachable
L89:
    CPy_Reraise()
    if not 0 goto L91 else goto L116 :: bool
L90:
    unreachable
L91:
    CPy_RestoreExcInfo(r124)
    dec_ref r124
    r138 = CPy_KeepPropagating()
    if not r138 goto L94 else goto L92 :: bool
L92:
    unreachable
L93:
    return 1
L94:
    r139 = <error> :: None
    return r139
L95:
    dec_ref r4
    goto L78
L96:
    dec_ref r9
    goto L78
L97:
    dec_ref r13
    goto L78
L98:
    dec_ref r13
    goto L11
L99:
    dec_ref r21
    goto L78
L100:
    dec_ref r21
    dec_ref r23
    goto L14
L101:
    dec_ref r21
    dec_ref r23
    goto L78
L102:
    dec_ref r21
    dec_ref r23
    dec_ref r30
    goto L78
L103:
    dec_ref r21
    dec_ref r23
    dec_ref r35
    goto L78
L104:
    dec_ref r44
    goto L24
L105:
    dec_ref r44
    goto L78
L106:
    dec_ref r13
    goto L32
L107:
    dec_ref r59
    goto L78
L108:
    dec_ref r64
    goto L78
L109:
    dec_ref r68
    goto L78
L110:
    dec_ref r74 :: int
    goto L78
L111:
    dec_ref r93
    goto L53
L112:
    dec_ref r93
    goto L78
L113:
    dec_ref r124
    dec_ref r129
    goto L84
L114:
    dec_ref r124
    dec_ref r136
    goto L86
L115:
    dec_ref r124
    goto L88
L116:
    dec_ref r124
    goto L90

def format_input_but_cache_checksums(abi, inputs):
    abi :: dict
    inputs :: union[list, tuple]
    r0 :: int
    r1 :: bit
    r2 :: str
    r3 :: object
    r4 :: int
    r5 :: bit
    r6 :: str
    r7 :: object
    r8, r9, r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: str
    r18, r19 :: object
    r20 :: bool
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: list
    r25 :: tuple[object, object, object]
    r26 :: object
    r27 :: str
    r28 :: object
    r29 :: bit
    r30, r31 :: object
    r32 :: str
    r33 :: object
    r34, r35, r36, r37 :: str
    r38 :: object[1]
    r39 :: object_ptr
    r40 :: object
    r41 :: bit
    r42 :: list
L0:
    r0 = CPyObject_Size(inputs)
    if is_error(r0) goto L33 (error at format_input_but_cache_checksums:302) else goto L1
L1:
    r1 = r0 != 0
    dec_ref r0 :: int
    if r1 goto L2 else goto L12 :: bool
L2:
    r2 = 'inputs'
    r3 = CPyDict_GetItem(abi, r2)
    if is_error(r3) goto L33 (error at format_input_but_cache_checksums:302) else goto L3
L3:
    r4 = CPyObject_Size(r3)
    dec_ref r3
    if is_error(r4) goto L33 (error at format_input_but_cache_checksums:302) else goto L4
L4:
    r5 = r4 != 0
    dec_ref r4 :: int
    if r5 goto L12 else goto L5 :: bool
L5:
    r6 = 'name'
    r7 = CPyDict_GetItem(abi, r6)
    if is_error(r7) goto L33 (error at format_input_but_cache_checksums:303) else goto L6
L6:
    r8 = PyObject_Str(r7)
    dec_ref r7
    if is_error(r8) goto L33 (error at format_input_but_cache_checksums:303) else goto L7
L7:
    r9 = ' requires no arguments'
    r10 = CPyStr_Build(2, r8, r9)
    dec_ref r8
    if is_error(r10) goto L33 (error at format_input_but_cache_checksums:303) else goto L8
L8:
    r11 = builtins :: module
    r12 = 'TypeError'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L34 (error at format_input_but_cache_checksums:303) else goto L9
L9:
    r14 = [r10]
    r15 = load_address r14
    r16 = _PyObject_Vectorcall(r13, r15, 1, 0)
    dec_ref r13
    if is_error(r16) goto L34 (error at format_input_but_cache_checksums:303) else goto L10
L10:
    dec_ref r10
    CPy_Raise(r16)
    dec_ref r16
    if not 0 goto L33 (error at format_input_but_cache_checksums:303) else goto L11 :: bool
L11:
    unreachable
L12:
    r17 = 'inputs'
    r18 = CPyDict_GetItem(abi, r17)
    if is_error(r18) goto L33 (error at format_input_but_cache_checksums:304) else goto L13
L13:
    r19 = dank_mids.brownie_patch.call._get_abi_types :: static
    if is_error(r19) goto L35 else goto L16
L14:
    r20 = raise NameError('value for final name "_get_abi_types" was not set')
    if not r20 goto L33 (error at format_input_but_cache_checksums:304) else goto L15 :: bool
L15:
    unreachable
L16:
    r21 = [r18]
    r22 = load_address r21
    r23 = _PyObject_Vectorcall(r19, r22, 1, 0)
    if is_error(r23) goto L36 (error at format_input_but_cache_checksums:304) else goto L17
L17:
    dec_ref r18
L18:
    r24 = _format_tuple_but_cache_checksums(r23, inputs)
    dec_ref r23
    if is_error(r24) goto L20 (error at format_input_but_cache_checksums:306) else goto L19
L19:
    return r24
L20:
    r25 = CPy_CatchError()
    r26 = builtins :: module
    r27 = 'Exception'
    r28 = CPyObject_GetAttr(r26, r27)
    if is_error(r28) goto L31 (error at format_input_but_cache_checksums:307) else goto L21
L21:
    r29 = CPy_ExceptionMatches(r28)
    dec_ref r28
    if r29 goto L22 else goto L29 :: bool
L22:
    r30 = CPy_GetExcValue()
    r31 = PyObject_Type(r30)
    r32 = 'name'
    r33 = CPyDict_GetItem(abi, r32)
    if is_error(r33) goto L37 (error at format_input_but_cache_checksums:308) else goto L23
L23:
    r34 = PyObject_Str(r33)
    dec_ref r33
    if is_error(r34) goto L37 (error at format_input_but_cache_checksums:308) else goto L24
L24:
    r35 = ' '
    r36 = PyObject_Str(r30)
    dec_ref r30
    if is_error(r36) goto L38 (error at format_input_but_cache_checksums:308) else goto L25
L25:
    r37 = CPyStr_Build(3, r34, r35, r36)
    dec_ref r34
    dec_ref r36
    if is_error(r37) goto L39 (error at format_input_but_cache_checksums:308) else goto L26
L26:
    r38 = [r37]
    r39 = load_address r38
    r40 = _PyObject_Vectorcall(r31, r39, 1, 0)
    dec_ref r31
    if is_error(r40) goto L40 (error at format_input_but_cache_checksums:308) else goto L27
L27:
    dec_ref r37
    CPy_Raise(r40)
    dec_ref r40
    if not 0 goto L31 (error at format_input_but_cache_checksums:308) else goto L41 :: bool
L28:
    unreachable
L29:
    CPy_Reraise()
    if not 0 goto L31 else goto L42 :: bool
L30:
    unreachable
L31:
    CPy_RestoreExcInfo(r25)
    dec_ref r25
    r41 = CPy_KeepPropagating()
    if not r41 goto L33 else goto L32 :: bool
L32:
    unreachable
L33:
    r42 = <error> :: list
    return r42
L34:
    dec_ref r10
    goto L33
L35:
    dec_ref r18
    goto L14
L36:
    dec_ref r18
    goto L33
L37:
    dec_ref r30
    dec_ref r31
    goto L31
L38:
    dec_ref r31
    dec_ref r34
    goto L31
L39:
    dec_ref r31
    goto L31
L40:
    dec_ref r37
    goto L31
L41:
    dec_ref r25
    goto L28
L42:
    dec_ref r25
    goto L30

def format_output_but_cache_checksums(abi, outputs):
    abi :: dict
    outputs :: union[list, tuple]
    r0 :: str
    r1, r2 :: object
    r3 :: bool
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: list
    r8 :: str
    r9, r10 :: object
    r11 :: bool
    r12 :: object[2]
    r13 :: object_ptr
    r14, r15 :: object
L0:
    r0 = 'outputs'
    r1 = CPyDict_GetItem(abi, r0)
    if is_error(r1) goto L12 (error at format_output_but_cache_checksums:315) else goto L1
L1:
    r2 = dank_mids.brownie_patch.call._get_abi_types :: static
    if is_error(r2) goto L13 else goto L4
L2:
    r3 = raise NameError('value for final name "_get_abi_types" was not set')
    if not r3 goto L12 (error at format_output_but_cache_checksums:315) else goto L3 :: bool
L3:
    unreachable
L4:
    r4 = [r1]
    r5 = load_address r4
    r6 = _PyObject_Vectorcall(r2, r5, 1, 0)
    if is_error(r6) goto L14 (error at format_output_but_cache_checksums:315) else goto L5
L5:
    dec_ref r1
    r7 = _format_tuple_but_cache_checksums(r6, outputs)
    dec_ref r6
    if is_error(r7) goto L12 (error at format_output_but_cache_checksums:316) else goto L6
L6:
    r8 = 'outputs'
    r9 = CPyDict_GetItem(abi, r8)
    if is_error(r9) goto L15 (error at format_output_but_cache_checksums:317) else goto L7
L7:
    r10 = dank_mids.brownie_patch.call.ReturnValue :: static
    if is_error(r10) goto L16 else goto L10
L8:
    r11 = raise NameError('value for final name "ReturnValue" was not set')
    if not r11 goto L12 (error at format_output_but_cache_checksums:317) else goto L9 :: bool
L9:
    unreachable
L10:
    r12 = [r7, r9]
    r13 = load_address r12
    r14 = _PyObject_Vectorcall(r10, r13, 2, 0)
    if is_error(r14) goto L17 (error at format_output_but_cache_checksums:317) else goto L11
L11:
    dec_ref r7
    dec_ref r9
    return r14
L12:
    r15 = <error> :: object
    return r15
L13:
    dec_ref r1
    goto L2
L14:
    dec_ref r1
    goto L12
L15:
    dec_ref r7
    goto L12
L16:
    dec_ref r7
    dec_ref r9
    goto L8
L17:
    dec_ref r7
    dec_ref r9
    goto L12

def _format_tuple_but_cache_checksums(abi_types, values):
    abi_types :: object
    values :: union[list, tuple]
    r0 :: list
    r1 :: int
    r2 :: object
    r3 :: bool
    r4 :: object
    r5 :: object[2]
    r6 :: object_ptr
    r7, r8, r9, r10, r11 :: object
    r12 :: str
    r13 :: object
    r14 :: i32
    r15 :: bit
    r16 :: bool
    r17 :: union[list, tuple]
    r18 :: list
    r19 :: i32
    r20 :: bit
    r21 :: object
    r22 :: bool
    r23 :: i32
    r24 :: bit
    r25 :: bool
    r26 :: str
    r27 :: object
    r28 :: union[list, tuple]
    r29 :: list
    r30 :: i32
    r31 :: bit
    r32 :: str
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: i32
    r39 :: bit
    r40 :: tuple[object, object, object]
    r41 :: object
    r42 :: str
    r43 :: object
    r44 :: bit
    r45, r46 :: object
    r47, r48, r49, r50, r51 :: str
    r52 :: object[1]
    r53 :: object_ptr
    r54 :: object
    r55, r56, r57 :: bit
    r58 :: list
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L45 (error at _format_tuple_but_cache_checksums:327) else goto L1
L1:
    r1 = CPyObject_Size(abi_types)
    if is_error(r1) goto L46 (error at _format_tuple_but_cache_checksums:328) else goto L2
L2:
    r2 = dank_mids.brownie_patch.call._check_array :: static
    if is_error(r2) goto L47 else goto L5
L3:
    r3 = raise NameError('value for final name "_check_array" was not set')
    if not r3 goto L45 (error at _format_tuple_but_cache_checksums:328) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = box(int, r1)
    r5 = [values, r4]
    r6 = load_address r5
    r7 = _PyObject_Vectorcall(r2, r6, 2, 0)
    if is_error(r7) goto L48 (error at _format_tuple_but_cache_checksums:328) else goto L49
L6:
    dec_ref r4
    r8 = PyObject_GetIter(abi_types)
    if is_error(r8) goto L46 (error at _format_tuple_but_cache_checksums:329) else goto L7
L7:
    r9 = PyObject_GetIter(values)
    if is_error(r9) goto L50 (error at _format_tuple_but_cache_checksums:329) else goto L8
L8:
    r10 = PyIter_Next(r8)
    if is_error(r10) goto L51 else goto L9
L9:
    r11 = PyIter_Next(r9)
    if is_error(r11) goto L52 else goto L10
L10:
L11:
    r12 = 'is_array'
    r13 = CPyObject_GetAttr(r10, r12)
    if is_error(r13) goto L53 (error at _format_tuple_but_cache_checksums:331) else goto L12
L12:
    r14 = PyObject_IsTrue(r13)
    dec_ref r13
    r15 = r14 >= 0 :: signed
    if not r15 goto L53 (error at _format_tuple_but_cache_checksums:331) else goto L13 :: bool
L13:
    r16 = truncate r14: i32 to builtins.bool
    if r16 goto L14 else goto L17 :: bool
L14:
    inc_ref r11
    r17 = cast(union[list, tuple], r11)
    if is_error(r17) goto L53 (error at _format_tuple_but_cache_checksums:332) else goto L15
L15:
    r18 = _format_array_but_cache_checksums(r10, r17)
    dec_ref r10
    dec_ref r17
    if is_error(r18) goto L54 (error at _format_tuple_but_cache_checksums:332) else goto L16
L16:
    r19 = PyList_Append(r0, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L54 (error at _format_tuple_but_cache_checksums:332) else goto L55 :: bool
L17:
    r21 = dank_mids.brownie_patch.call.TupleType :: static
    if is_error(r21) goto L56 else goto L20
L18:
    r22 = raise NameError('value for final name "TupleType" was not set')
    if not r22 goto L30 (error at _format_tuple_but_cache_checksums:333) else goto L57 :: bool
L19:
    unreachable
L20:
    r23 = PyObject_IsInstance(r10, r21)
    r24 = r23 >= 0 :: signed
    if not r24 goto L53 (error at _format_tuple_but_cache_checksums:333) else goto L21 :: bool
L21:
    r25 = truncate r23: i32 to builtins.bool
    if r25 goto L22 else goto L26 :: bool
L22:
    r26 = 'components'
    r27 = CPyObject_GetAttr(r10, r26)
    dec_ref r10
    if is_error(r27) goto L54 (error at _format_tuple_but_cache_checksums:334) else goto L23
L23:
    inc_ref r11
    r28 = cast(union[list, tuple], r11)
    if is_error(r28) goto L58 (error at _format_tuple_but_cache_checksums:334) else goto L24
L24:
    r29 = _format_tuple_but_cache_checksums(r27, r28)
    dec_ref r27
    dec_ref r28
    if is_error(r29) goto L54 (error at _format_tuple_but_cache_checksums:334) else goto L25
L25:
    r30 = PyList_Append(r0, r29)
    dec_ref r29
    r31 = r30 >= 0 :: signed
    if not r31 goto L54 (error at _format_tuple_but_cache_checksums:334) else goto L59 :: bool
L26:
    r32 = 'to_type_str'
    r33 = [r10]
    r34 = load_address r33
    r35 = PyObject_VectorcallMethod(r32, r34, 9223372036854775809, 0)
    if is_error(r35) goto L53 (error at _format_tuple_but_cache_checksums:336) else goto L27
L27:
    dec_ref r10
    r36 = cast(str, r35)
    if is_error(r36) goto L54 (error at _format_tuple_but_cache_checksums:336) else goto L28
L28:
    r37 = _format_single_but_cache_checksums(r36, r11)
    dec_ref r36
    if is_error(r37) goto L54 (error at _format_tuple_but_cache_checksums:336) else goto L29
L29:
    r38 = PyList_Append(r0, r37)
    dec_ref r37
    r39 = r38 >= 0 :: signed
    if not r39 goto L54 (error at _format_tuple_but_cache_checksums:336) else goto L60 :: bool
L30:
    r40 = CPy_CatchError()
    r41 = builtins :: module
    r42 = 'Exception'
    r43 = CPyObject_GetAttr(r41, r42)
    if is_error(r43) goto L61 (error at _format_tuple_but_cache_checksums:337) else goto L31
L31:
    r44 = CPy_ExceptionMatches(r43)
    dec_ref r43
    if r44 goto L32 else goto L62 :: bool
L32:
    r45 = CPy_GetExcValue()
    r46 = PyObject_Type(r45)
    r47 = "'"
    r48 = PyObject_Str(r11)
    dec_ref r11
    if is_error(r48) goto L63 (error at _format_tuple_but_cache_checksums:338) else goto L33
L33:
    r49 = "' - "
    r50 = PyObject_Str(r45)
    dec_ref r45
    if is_error(r50) goto L64 (error at _format_tuple_but_cache_checksums:338) else goto L34
L34:
    r51 = CPyStr_Build(4, r47, r48, r49, r50)
    dec_ref r48
    dec_ref r50
    if is_error(r51) goto L65 (error at _format_tuple_but_cache_checksums:338) else goto L35
L35:
    r52 = [r51]
    r53 = load_address r52
    r54 = _PyObject_Vectorcall(r46, r53, 1, 0)
    dec_ref r46
    if is_error(r54) goto L66 (error at _format_tuple_but_cache_checksums:338) else goto L36
L36:
    dec_ref r51
    CPy_Raise(r54)
    dec_ref r54
    if not 0 goto L40 (error at _format_tuple_but_cache_checksums:338) else goto L67 :: bool
L37:
    unreachable
L38:
    CPy_Reraise()
    if not 0 goto L40 else goto L68 :: bool
L39:
    unreachable
L40:
    CPy_RestoreExcInfo(r40)
    dec_ref r40
    r55 = CPy_KeepPropagating()
    if not r55 goto L45 else goto L41 :: bool
L41:
    unreachable
L42:
    r56 = CPy_NoErrOccurred()
    if not r56 goto L46 (error at _format_tuple_but_cache_checksums:329) else goto L43 :: bool
L43:
    r57 = CPy_NoErrOccurred()
    if not r57 goto L46 (error at _format_tuple_but_cache_checksums:329) else goto L44 :: bool
L44:
    return r0
L45:
    r58 = <error> :: list
    return r58
L46:
    dec_ref r0
    goto L45
L47:
    dec_ref r0
    dec_ref r1 :: int
    goto L3
L48:
    dec_ref r0
    dec_ref r4
    goto L45
L49:
    dec_ref r7
    goto L6
L50:
    dec_ref r0
    dec_ref r8
    goto L45
L51:
    dec_ref r8
    dec_ref r9
    goto L42
L52:
    dec_ref r8
    dec_ref r9
    dec_ref r10
    goto L42
L53:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    dec_ref r10
    goto L30
L54:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    goto L30
L55:
    dec_ref r11
    goto L8
L56:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    dec_ref r10
    goto L18
L57:
    dec_ref r11
    goto L19
L58:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    dec_ref r27
    goto L30
L59:
    dec_ref r11
    goto L8
L60:
    dec_ref r11
    goto L8
L61:
    dec_ref r11
    goto L40
L62:
    dec_ref r11
    goto L38
L63:
    dec_ref r45
    dec_ref r46
    goto L40
L64:
    dec_ref r46
    dec_ref r48
    goto L40
L65:
    dec_ref r46
    goto L40
L66:
    dec_ref r51
    goto L40
L67:
    dec_ref r40
    goto L37
L68:
    dec_ref r40
    goto L39

def _format_array_but_cache_checksums(abi_type, values):
    abi_type :: object
    values :: union[list, tuple]
    r0 :: str
    r1, r2, r3 :: object
    r4 :: int
    r5 :: bit
    r6 :: str
    r7, r8, r9, r10, r11 :: object
    r12 :: union[object, None]
    r13, r14 :: object
    r15 :: bool
    r16 :: object[2]
    r17 :: object_ptr
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: i32
    r24 :: bit
    r25 :: bool
    r26 :: list
    r27, r28 :: object
    r29 :: union[list, tuple]
    r30 :: list
    r31 :: i32
    r32, r33 :: bit
    r34 :: object
    r35 :: bool
    r36 :: i32
    r37 :: bit
    r38 :: bool
    r39 :: str
    r40 :: object
    r41 :: list
    r42, r43 :: object
    r44 :: union[list, tuple]
    r45 :: list
    r46 :: i32
    r47, r48 :: bit
    r49 :: str
    r50 :: object[1]
    r51 :: object_ptr
    r52 :: object
    r53 :: str
    r54 :: list
    r55, r56, r57 :: object
    r58 :: i32
    r59, r60 :: bit
    r61 :: list
L0:
    r0 = 'arrlist'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L48 (error at _format_array_but_cache_checksums:343) else goto L1
L1:
    r2 = object -1
    r3 = PyObject_GetItem(r1, r2)
    dec_ref r1
    if is_error(r3) goto L48 (error at _format_array_but_cache_checksums:343) else goto L2
L2:
    r4 = CPyObject_Size(r3)
    dec_ref r3
    if is_error(r4) goto L48 (error at _format_array_but_cache_checksums:343) else goto L3
L3:
    r5 = r4 != 0
    dec_ref r4 :: int
    if r5 goto L4 else goto L8 :: bool
L4:
    r6 = 'arrlist'
    r7 = CPyObject_GetAttr(abi_type, r6)
    if is_error(r7) goto L48 (error at _format_array_but_cache_checksums:343) else goto L5
L5:
    r8 = object -1
    r9 = PyObject_GetItem(r7, r8)
    dec_ref r7
    if is_error(r9) goto L48 (error at _format_array_but_cache_checksums:343) else goto L6
L6:
    r10 = object 0
    r11 = PyObject_GetItem(r9, r10)
    dec_ref r9
    if is_error(r11) goto L48 (error at _format_array_but_cache_checksums:343) else goto L7
L7:
    r12 = r11
    goto L9
L8:
    r13 = box(None, 1)
    inc_ref r13
    r12 = r13
L9:
    r14 = dank_mids.brownie_patch.call._check_array :: static
    if is_error(r14) goto L49 else goto L12
L10:
    r15 = raise NameError('value for final name "_check_array" was not set')
    if not r15 goto L48 (error at _format_array_but_cache_checksums:343) else goto L11 :: bool
L11:
    unreachable
L12:
    r16 = [values, r12]
    r17 = load_address r16
    r18 = _PyObject_Vectorcall(r14, r17, 2, 0)
    if is_error(r18) goto L50 (error at _format_array_but_cache_checksums:343) else goto L51
L13:
    dec_ref r12
    r19 = 'item_type'
    r20 = CPyObject_GetAttr(abi_type, r19)
    if is_error(r20) goto L48 (error at _format_array_but_cache_checksums:344) else goto L14
L14:
    r21 = 'is_array'
    r22 = CPyObject_GetAttr(r20, r21)
    if is_error(r22) goto L52 (error at _format_array_but_cache_checksums:345) else goto L15
L15:
    r23 = PyObject_IsTrue(r22)
    dec_ref r22
    r24 = r23 >= 0 :: signed
    if not r24 goto L52 (error at _format_array_but_cache_checksums:345) else goto L16 :: bool
L16:
    r25 = truncate r23: i32 to builtins.bool
    if r25 goto L17 else goto L25 :: bool
L17:
    r26 = PyList_New(0)
    if is_error(r26) goto L52 (error at _format_array_but_cache_checksums:346) else goto L18
L18:
    r27 = PyObject_GetIter(values)
    if is_error(r27) goto L53 (error at _format_array_but_cache_checksums:346) else goto L19
L19:
    r28 = PyIter_Next(r27)
    if is_error(r28) goto L54 else goto L20
L20:
    r29 = cast(union[list, tuple], r28)
    if is_error(r29) goto L55 (error at _format_array_but_cache_checksums:346) else goto L21
L21:
    r30 = _format_array_but_cache_checksums(r20, r29)
    dec_ref r29
    if is_error(r30) goto L55 (error at _format_array_but_cache_checksums:346) else goto L22
L22:
    r31 = PyList_Append(r26, r30)
    dec_ref r30
    r32 = r31 >= 0 :: signed
    if not r32 goto L55 (error at _format_array_but_cache_checksums:346) else goto L19 :: bool
L23:
    r33 = CPy_NoErrOccurred()
    if not r33 goto L56 (error at _format_array_but_cache_checksums:346) else goto L24 :: bool
L24:
    return r26
L25:
    r34 = dank_mids.brownie_patch.call.TupleType :: static
    if is_error(r34) goto L57 else goto L28
L26:
    r35 = raise NameError('value for final name "TupleType" was not set')
    if not r35 goto L48 (error at _format_array_but_cache_checksums:347) else goto L27 :: bool
L27:
    unreachable
L28:
    r36 = PyObject_IsInstance(r20, r34)
    r37 = r36 >= 0 :: signed
    if not r37 goto L52 (error at _format_array_but_cache_checksums:347) else goto L29 :: bool
L29:
    r38 = truncate r36: i32 to builtins.bool
    if r38 goto L30 else goto L39 :: bool
L30:
    r39 = 'components'
    r40 = CPyObject_GetAttr(r20, r39)
    dec_ref r20
    if is_error(r40) goto L48 (error at _format_array_but_cache_checksums:348) else goto L31
L31:
    r41 = PyList_New(0)
    if is_error(r41) goto L58 (error at _format_array_but_cache_checksums:349) else goto L32
L32:
    r42 = PyObject_GetIter(values)
    if is_error(r42) goto L59 (error at _format_array_but_cache_checksums:349) else goto L33
L33:
    r43 = PyIter_Next(r42)
    if is_error(r43) goto L60 else goto L34
L34:
    r44 = cast(union[list, tuple], r43)
    if is_error(r44) goto L61 (error at _format_array_but_cache_checksums:349) else goto L35
L35:
    r45 = _format_tuple_but_cache_checksums(r40, r44)
    dec_ref r44
    if is_error(r45) goto L61 (error at _format_array_but_cache_checksums:349) else goto L36
L36:
    r46 = PyList_Append(r41, r45)
    dec_ref r45
    r47 = r46 >= 0 :: signed
    if not r47 goto L61 (error at _format_array_but_cache_checksums:349) else goto L33 :: bool
L37:
    r48 = CPy_NoErrOccurred()
    if not r48 goto L62 (error at _format_array_but_cache_checksums:349) else goto L38 :: bool
L38:
    return r41
L39:
    r49 = 'to_type_str'
    r50 = [r20]
    r51 = load_address r50
    r52 = PyObject_VectorcallMethod(r49, r51, 9223372036854775809, 0)
    if is_error(r52) goto L52 (error at _format_array_but_cache_checksums:351) else goto L40
L40:
    dec_ref r20
    r53 = cast(str, r52)
    if is_error(r53) goto L48 (error at _format_array_but_cache_checksums:351) else goto L41
L41:
    r54 = PyList_New(0)
    if is_error(r54) goto L63 (error at _format_array_but_cache_checksums:352) else goto L42
L42:
    r55 = PyObject_GetIter(values)
    if is_error(r55) goto L64 (error at _format_array_but_cache_checksums:352) else goto L43
L43:
    r56 = PyIter_Next(r55)
    if is_error(r56) goto L65 else goto L44
L44:
    r57 = _format_single_but_cache_checksums(r53, r56)
    dec_ref r56
    if is_error(r57) goto L66 (error at _format_array_but_cache_checksums:352) else goto L45
L45:
    r58 = PyList_Append(r54, r57)
    dec_ref r57
    r59 = r58 >= 0 :: signed
    if not r59 goto L66 (error at _format_array_but_cache_checksums:352) else goto L43 :: bool
L46:
    r60 = CPy_NoErrOccurred()
    if not r60 goto L67 (error at _format_array_but_cache_checksums:352) else goto L47 :: bool
L47:
    return r54
L48:
    r61 = <error> :: list
    return r61
L49:
    dec_ref r12
    goto L10
L50:
    dec_ref r12
    goto L48
L51:
    dec_ref r18
    goto L13
L52:
    dec_ref r20
    goto L48
L53:
    dec_ref r20
    dec_ref r26
    goto L48
L54:
    dec_ref r20
    dec_ref r27
    goto L23
L55:
    dec_ref r20
    dec_ref r26
    dec_ref r27
    goto L48
L56:
    dec_ref r26
    goto L48
L57:
    dec_ref r20
    goto L26
L58:
    dec_ref r40
    goto L48
L59:
    dec_ref r40
    dec_ref r41
    goto L48
L60:
    dec_ref r40
    dec_ref r42
    goto L37
L61:
    dec_ref r40
    dec_ref r41
    dec_ref r42
    goto L48
L62:
    dec_ref r41
    goto L48
L63:
    dec_ref r53
    goto L48
L64:
    dec_ref r53
    dec_ref r54
    goto L48
L65:
    dec_ref r53
    dec_ref r55
    goto L46
L66:
    dec_ref r53
    dec_ref r54
    dec_ref r55
    goto L48
L67:
    dec_ref r54
    goto L48

def _format_single_but_cache_checksums(type_str, value):
    type_str :: str
    value :: object
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4 :: object
    r5 :: bool
    r6 :: object[2]
    r7 :: object_ptr
    r8 :: object
    r9 :: str
    r10 :: i32
    r11 :: bit
    r12 :: bool
    r13 :: object
    r14 :: bool
    r15 :: object[2]
    r16 :: object_ptr
    r17 :: object
    r18 :: str
    r19 :: i32
    r20 :: bit
    r21 :: object
    r22, r23, r24 :: bit
    r25 :: object
    r26 :: bool
    r27 :: object[1]
    r28 :: object_ptr
    r29 :: object
    r30 :: str
    r31 :: i32
    r32 :: bit
    r33 :: object
    r34, r35, r36 :: bit
    r37 :: object
    r38 :: bool
    r39 :: object[1]
    r40 :: object_ptr
    r41 :: object
    r42 :: str
    r43 :: i32
    r44 :: bit
    r45 :: object
    r46, r47, r48 :: bit
    r49, r50, r51 :: object
    r52 :: str
    r53, r54, r55 :: object
    r56 :: tuple[object, object, object, object, object]
    r57 :: object
    r58 :: i32
    r59 :: bit
    r60 :: bool
    r61 :: union[str, bytes, object, int]
    r62 :: str
    r63 :: object
    r64 :: bool
    r65 :: object[1]
    r66 :: object_ptr
    r67 :: object
    r68 :: str
    r69 :: i32
    r70 :: bit
    r71 :: bool
    r72 :: object
    r73 :: bool
    r74 :: object[2]
    r75 :: object_ptr
    r76 :: object
    r77 :: str
    r78 :: i32
    r79 :: bit
    r80 :: bool
    r81 :: object
    r82 :: bool
    r83 :: object[1]
    r84 :: object_ptr
    r85 :: object
    r86, r87 :: str
    r88 :: object
    r89 :: str
    r90 :: object
    r91 :: object[1]
    r92 :: object_ptr
    r93, r94 :: object
L0:
    r0 = 'uint'
    r1 = PySequence_Contains(type_str, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L66 (error at _format_single_but_cache_checksums:357) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L2 else goto L7 :: bool
L2:
    r4 = dank_mids.brownie_patch.call.to_uint :: static
    if is_error(r4) goto L3 else goto L5
L3:
    r5 = raise NameError('value for final name "to_uint" was not set')
    if not r5 goto L66 (error at _format_single_but_cache_checksums:358) else goto L4 :: bool
L4:
    unreachable
L5:
    r6 = [value, type_str]
    r7 = load_address r6
    r8 = _PyObject_Vectorcall(r4, r7, 2, 0)
    if is_error(r8) goto L66 (error at _format_single_but_cache_checksums:358) else goto L6
L6:
    return r8
L7:
    r9 = 'int'
    r10 = PySequence_Contains(type_str, r9)
    r11 = r10 >= 0 :: signed
    if not r11 goto L66 (error at _format_single_but_cache_checksums:359) else goto L8 :: bool
L8:
    r12 = truncate r10: i32 to builtins.bool
    if r12 goto L9 else goto L14 :: bool
L9:
    r13 = dank_mids.brownie_patch.call.to_int :: static
    if is_error(r13) goto L10 else goto L12
L10:
    r14 = raise NameError('value for final name "to_int" was not set')
    if not r14 goto L66 (error at _format_single_but_cache_checksums:360) else goto L11 :: bool
L11:
    unreachable
L12:
    r15 = [value, type_str]
    r16 = load_address r15
    r17 = _PyObject_Vectorcall(r13, r16, 2, 0)
    if is_error(r17) goto L66 (error at _format_single_but_cache_checksums:360) else goto L13
L13:
    return r17
L14:
    r18 = 'fixed168x10'
    r19 = PyUnicode_Compare(type_str, r18)
    r20 = r19 == -1
    if r20 goto L15 else goto L17 :: bool
L15:
    r21 = PyErr_Occurred()
    r22 = r21 != 0
    if r22 goto L16 else goto L17 :: bool
L16:
    r23 = CPy_KeepPropagating()
    if not r23 goto L66 (error at _format_single_but_cache_checksums:361) else goto L17 :: bool
L17:
    r24 = r19 == 0
    if r24 goto L18 else goto L23 :: bool
L18:
    r25 = dank_mids.brownie_patch.call.to_decimal :: static
    if is_error(r25) goto L19 else goto L21
L19:
    r26 = raise NameError('value for final name "to_decimal" was not set')
    if not r26 goto L66 (error at _format_single_but_cache_checksums:362) else goto L20 :: bool
L20:
    unreachable
L21:
    r27 = [value]
    r28 = load_address r27
    r29 = _PyObject_Vectorcall(r25, r28, 1, 0)
    if is_error(r29) goto L66 (error at _format_single_but_cache_checksums:362) else goto L22
L22:
    return r29
L23:
    r30 = 'bool'
    r31 = PyUnicode_Compare(type_str, r30)
    r32 = r31 == -1
    if r32 goto L24 else goto L26 :: bool
L24:
    r33 = PyErr_Occurred()
    r34 = r33 != 0
    if r34 goto L25 else goto L26 :: bool
L25:
    r35 = CPy_KeepPropagating()
    if not r35 goto L66 (error at _format_single_but_cache_checksums:363) else goto L26 :: bool
L26:
    r36 = r31 == 0
    if r36 goto L27 else goto L32 :: bool
L27:
    r37 = dank_mids.brownie_patch.call.to_bool :: static
    if is_error(r37) goto L28 else goto L30
L28:
    r38 = raise NameError('value for final name "to_bool" was not set')
    if not r38 goto L66 (error at _format_single_but_cache_checksums:364) else goto L29 :: bool
L29:
    unreachable
L30:
    r39 = [value]
    r40 = load_address r39
    r41 = _PyObject_Vectorcall(r37, r40, 1, 0)
    if is_error(r41) goto L66 (error at _format_single_but_cache_checksums:364) else goto L31
L31:
    return r41
L32:
    r42 = 'address'
    r43 = PyUnicode_Compare(type_str, r42)
    r44 = r43 == -1
    if r44 goto L33 else goto L35 :: bool
L33:
    r45 = PyErr_Occurred()
    r46 = r45 != 0
    if r46 goto L34 else goto L35 :: bool
L34:
    r47 = CPy_KeepPropagating()
    if not r47 goto L66 (error at _format_single_but_cache_checksums:365) else goto L35 :: bool
L35:
    r48 = r43 == 0
    if r48 goto L36 else goto L47 :: bool
L36:
    r49 = load_address PyUnicode_Type
    r50 = load_address PyBytes_Type
    r51 = builtins :: module
    r52 = 'bytearray'
    r53 = CPyObject_GetAttr(r51, r52)
    if is_error(r53) goto L66 (error at _format_single_but_cache_checksums:368) else goto L37
L37:
    r54 = load_address PyLong_Type
    r55 = load_address PyBool_Type
    inc_ref r49
    inc_ref r50
    inc_ref r54
    inc_ref r55
    r56 = (r49, r50, r53, r54, r55)
    r57 = box(tuple[object, object, object, object, object], r56)
    r58 = PyObject_IsInstance(value, r57)
    dec_ref r57
    r59 = r58 >= 0 :: signed
    if not r59 goto L66 (error at _format_single_but_cache_checksums:368) else goto L38 :: bool
L38:
    r60 = truncate r58: i32 to builtins.bool
    if r60 goto L39 else goto L40 :: bool
L39:
    inc_ref value
    r61 = value
    goto L42
L40:
    r62 = PyObject_Str(value)
    if is_error(r62) goto L66 (error at _format_single_but_cache_checksums:368) else goto L41
L41:
    r61 = r62
L42:
    r63 = dank_mids.brownie_patch.call.to_checksum_address :: static
    if is_error(r63) goto L67 else goto L45
L43:
    r64 = raise NameError('value for final name "to_checksum_address" was not set')
    if not r64 goto L66 (error at _format_single_but_cache_checksums:367) else goto L44 :: bool
L44:
    unreachable
L45:
    r65 = [r61]
    r66 = load_address r65
    r67 = _PyObject_Vectorcall(r63, r66, 1, 0)
    if is_error(r67) goto L68 (error at _format_single_but_cache_checksums:367) else goto L46
L46:
    dec_ref r61
    return r67
L47:
    r68 = 'byte'
    r69 = PySequence_Contains(type_str, r68)
    r70 = r69 >= 0 :: signed
    if not r70 goto L66 (error at _format_single_but_cache_checksums:370) else goto L48 :: bool
L48:
    r71 = truncate r69: i32 to builtins.bool
    if r71 goto L49 else goto L54 :: bool
L49:
    r72 = dank_mids.brownie_patch.call.HexString :: static
    if is_error(r72) goto L50 else goto L52
L50:
    r73 = raise NameError('value for final name "HexString" was not set')
    if not r73 goto L66 (error at _format_single_but_cache_checksums:371) else goto L51 :: bool
L51:
    unreachable
L52:
    r74 = [value, type_str]
    r75 = load_address r74
    r76 = _PyObject_Vectorcall(r72, r75, 2, 0)
    if is_error(r76) goto L66 (error at _format_single_but_cache_checksums:371) else goto L53
L53:
    return r76
L54:
    r77 = 'string'
    r78 = PySequence_Contains(type_str, r77)
    r79 = r78 >= 0 :: signed
    if not r79 goto L66 (error at _format_single_but_cache_checksums:372) else goto L55 :: bool
L55:
    r80 = truncate r78: i32 to builtins.bool
    if r80 goto L56 else goto L61 :: bool
L56:
    r81 = dank_mids.brownie_patch.call.to_string :: static
    if is_error(r81) goto L57 else goto L59
L57:
    r82 = raise NameError('value for final name "to_string" was not set')
    if not r82 goto L66 (error at _format_single_but_cache_checksums:373) else goto L58 :: bool
L58:
    unreachable
L59:
    r83 = [value]
    r84 = load_address r83
    r85 = _PyObject_Vectorcall(r81, r84, 1, 0)
    if is_error(r85) goto L66 (error at _format_single_but_cache_checksums:373) else goto L60
L60:
    return r85
L61:
    r86 = 'Unknown type: '
    r87 = CPyStr_Build(2, r86, type_str)
    if is_error(r87) goto L66 (error at _format_single_but_cache_checksums:374) else goto L62
L62:
    r88 = builtins :: module
    r89 = 'TypeError'
    r90 = CPyObject_GetAttr(r88, r89)
    if is_error(r90) goto L69 (error at _format_single_but_cache_checksums:374) else goto L63
L63:
    r91 = [r87]
    r92 = load_address r91
    r93 = _PyObject_Vectorcall(r90, r92, 1, 0)
    dec_ref r90
    if is_error(r93) goto L69 (error at _format_single_but_cache_checksums:374) else goto L64
L64:
    dec_ref r87
    CPy_Raise(r93)
    dec_ref r93
    if not 0 goto L66 (error at _format_single_but_cache_checksums:374) else goto L65 :: bool
L65:
    unreachable
L66:
    r94 = <error> :: object
    return r94
L67:
    dec_ref r61
    goto L43
L68:
    dec_ref r61
    goto L66
L69:
    dec_ref r87
    goto L66

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: dict
    r30, r31 :: object
    r32 :: str
    r33 :: dict
    r34 :: object
    r35, r36, r37, r38, r39 :: object_ptr
    r40 :: object_ptr[5]
    r41 :: c_ptr
    r42 :: native_int[5]
    r43 :: c_ptr
    r44 :: object
    r45 :: dict
    r46, r47 :: str
    r48 :: bit
    r49 :: object
    r50 :: str
    r51 :: dict
    r52, r53 :: object
    r54 :: str
    r55 :: dict
    r56, r57 :: object
    r58 :: str
    r59 :: dict
    r60, r61 :: object
    r62 :: str
    r63 :: dict
    r64, r65 :: object
    r66 :: str
    r67 :: dict
    r68, r69 :: object
    r70 :: str
    r71 :: dict
    r72, r73 :: object
    r74 :: str
    r75 :: dict
    r76, r77 :: object
    r78 :: str
    r79 :: dict
    r80, r81 :: object
    r82 :: str
    r83 :: dict
    r84, r85 :: object
    r86 :: str
    r87 :: dict
    r88, r89 :: object
    r90 :: str
    r91 :: dict
    r92, r93 :: object
    r94 :: str
    r95 :: dict
    r96, r97 :: object
    r98 :: str
    r99 :: dict
    r100, r101 :: object
    r102 :: str
    r103 :: dict
    r104, r105 :: object
    r106 :: str
    r107 :: dict
    r108, r109 :: object
    r110 :: str
    r111 :: dict
    r112, r113 :: object
    r114 :: str
    r115 :: dict
    r116 :: object
    r117 :: dict
    r118 :: str
    r119 :: object
    r120 :: dict
    r121 :: str
    r122 :: i32
    r123 :: bit
    r124 :: object
    r125 :: bool
    r126 :: str
    r127 :: object
    r128 :: str
    r129 :: object
    r130 :: bool
    r131 :: dict
    r132 :: str
    r133 :: i32
    r134 :: bit
    r135 :: str
    r136 :: dict
    r137 :: str
    r138 :: object
    r139 :: object[1]
    r140 :: object_ptr
    r141 :: object
    r142 :: dict
    r143 :: str
    r144 :: i32
    r145 :: bit
    r146 :: str
    r147 :: object
    r148 :: dict
    r149 :: str
    r150 :: object
    r151 :: object[2]
    r152 :: object_ptr
    r153 :: object
    r154 :: dict
    r155 :: str
    r156 :: i32
    r157 :: bit
    r158 :: dict
    r159 :: str
    r160 :: object
    r161 :: dict
    r162 :: str
    r163, r164 :: object
    r165 :: dict
    r166 :: str
    r167 :: i32
    r168 :: bit
    r169 :: dict
    r170 :: str
    r171 :: object
    r172 :: dict
    r173 :: str
    r174 :: object
    r175 :: dict
    r176 :: str
    r177, r178 :: object
    r179 :: dict
    r180 :: str
    r181 :: object
    r182 :: dict
    r183 :: str
    r184, r185 :: object
    r186 :: tuple[object, object]
    r187, r188 :: object
    r189 :: tuple[object, object]
    r190, r191 :: object
    r192 :: dict
    r193 :: str
    r194 :: i32
    r195 :: bit
    r196 :: str
    r197 :: dict
    r198 :: str
    r199, r200 :: object
    r201 :: dict
    r202 :: str
    r203 :: object
    r204 :: tuple[object, object]
    r205, r206 :: object
    r207 :: dict
    r208 :: str
    r209 :: object
    r210 :: object[2]
    r211 :: object_ptr
    r212 :: object
    r213 :: dict
    r214 :: str
    r215 :: i32
    r216 :: bit
    r217 :: object
    r218 :: str
    r219 :: object
    r220 :: dict
    r221 :: str
    r222 :: i32
    r223 :: bit
    r224 :: dict
    r225 :: str
    r226 :: object
    r227 :: str
    r228 :: object
    r229 :: dict
    r230 :: str
    r231 :: i32
    r232 :: bit
    r233 :: dict
    r234 :: str
    r235 :: object
    r236 :: str
    r237 :: object
    r238 :: str
    r239 :: object
    r240 :: str
    r241 :: object
    r242 :: dict
    r243 :: str
    r244 :: i32
    r245 :: bit
    r246 :: dict
    r247 :: str
    r248 :: object
    r249 :: str
    r250 :: object
    r251 :: str
    r252 :: object
    r253 :: str
    r254 :: object
    r255 :: dict
    r256 :: str
    r257 :: i32
    r258 :: bit
    r259 :: dict
    r260 :: str
    r261 :: object
    r262 :: str
    r263 :: object
    r264 :: str
    r265 :: object
    r266 :: str
    r267 :: object
    r268 :: dict
    r269 :: str
    r270 :: i32
    r271 :: bit
    r272 :: dict
    r273 :: str
    r274 :: object
    r275 :: str
    r276 :: object
    r277 :: str
    r278 :: object
    r279 :: str
    r280 :: object
    r281 :: dict
    r282 :: str
    r283 :: i32
    r284 :: bit
    r285 :: dict
    r286 :: str
    r287 :: object
    r288 :: str
    r289 :: object
    r290 :: dict
    r291 :: str
    r292 :: i32
    r293 :: bit
    r294 :: dict
    r295 :: str
    r296 :: object
    r297 :: str
    r298 :: object
    r299 :: str
    r300 :: object
    r301 :: str
    r302 :: object
    r303 :: dict
    r304 :: str
    r305 :: i32
    r306 :: bit
    r307 :: dict
    r308 :: str
    r309 :: object
    r310 :: str
    r311 :: object
    r312 :: str
    r313 :: object
    r314 :: str
    r315 :: object
    r316 :: dict
    r317 :: str
    r318 :: i32
    r319 :: bit
    r320 :: dict
    r321 :: str
    r322 :: object
    r323 :: str
    r324 :: object
    r325 :: str
    r326 :: object
    r327 :: str
    r328 :: object
    r329 :: dict
    r330 :: str
    r331 :: i32
    r332 :: bit
    r333 :: dict
    r334 :: str
    r335 :: object
    r336 :: str
    r337 :: object
    r338 :: str
    r339 :: object
    r340 :: str
    r341 :: object
    r342 :: dict
    r343 :: str
    r344 :: i32
    r345 :: bit
    r346 :: dict
    r347 :: str
    r348 :: object
    r349 :: str
    r350 :: object
    r351 :: str
    r352 :: object
    r353 :: str
    r354 :: object
    r355 :: dict
    r356 :: str
    r357 :: i32
    r358 :: bit
    r359 :: dict
    r360 :: str
    r361 :: object
    r362 :: str
    r363 :: object
    r364 :: str
    r365 :: object
    r366 :: str
    r367 :: object
    r368 :: dict
    r369 :: str
    r370 :: i32
    r371 :: bit
    r372 :: dict
    r373 :: str
    r374 :: object
    r375 :: str
    r376 :: object
    r377 :: str
    r378 :: object
    r379 :: str
    r380 :: object
    r381 :: dict
    r382 :: str
    r383 :: i32
    r384 :: bit
    r385 :: dict
    r386 :: str
    r387 :: object
    r388 :: str
    r389 :: dict
    r390 :: str
    r391 :: object
    r392 :: object[1]
    r393 :: object_ptr
    r394 :: object
    r395 :: dict
    r396 :: str
    r397 :: i32
    r398 :: bit
    r399 :: dank_mids.brownie_patch.call.__mypyc_lambda__0_obj
    r400 :: dict
    r401 :: str
    r402 :: i32
    r403 :: bit
    r404 :: dank_mids.brownie_patch.call.__mypyc_lambda__1_obj
    r405 :: dict
    r406 :: str
    r407 :: i32
    r408 :: bit
    r409 :: dict
    r410 :: str
    r411 :: object
    r412 :: str
    r413 :: object
    r414 :: dict
    r415 :: str
    r416 :: i32
    r417 :: bit
    r418 :: dict
    r419 :: str
    r420 :: object
    r421 :: dict
    r422 :: str
    r423 :: object
    r424 :: object[1]
    r425 :: object_ptr
    r426 :: object
    r427 :: dict
    r428 :: str
    r429 :: i32
    r430 :: bit
    r431 :: dict
    r432 :: str
    r433 :: object
    r434 :: str
    r435 :: bool
    r436 :: dict
    r437 :: str
    r438 :: object
    r439 :: str
    r440, r441 :: object
    r442 :: dict
    r443 :: str
    r444 :: object
    r445 :: str
    r446 :: object
    r447 :: dict
    r448 :: str
    r449 :: i32
    r450 :: bit
    r451 :: dict
    r452 :: str
    r453 :: object
    r454 :: str
    r455 :: bool
    r456 :: dict
    r457 :: str
    r458 :: object
    r459 :: str
    r460, r461 :: object
    r462 :: dict
    r463 :: str
    r464 :: object
    r465 :: str
    r466 :: object
    r467 :: dict
    r468 :: str
    r469 :: i32
    r470 :: bit
    r471 :: str
    r472 :: set
    r473 :: i32
    r474 :: bit
    r475 :: dict
    r476 :: str
    r477 :: i32
    r478 :: bit
    r479 :: dict
    r480 :: str
    r481 :: object
    r482 :: str
    r483 :: object
    r484 :: dict
    r485 :: str
    r486 :: i32
    r487 :: bit
    r488 :: tuple[object, object, object]
    r489 :: object
    r490 :: str
    r491 :: object
    r492 :: bit
    r493 :: dict
    r494 :: str
    r495 :: object
    r496 :: i32
    r497 :: bit
    r498 :: str
    r499 :: dict
    r500 :: str
    r501 :: object
    r502 :: str
    r503 :: i32
    r504 :: bit
    r505, r506 :: bool
    r507 :: bit
    r508 :: dict
    r509 :: str
    r510 :: object
    r511 :: dict
    r512 :: str
    r513 :: object
    r514 :: str
    r515 :: object
    r516 :: object[3]
    r517 :: object_ptr
    r518 :: object
    r519 :: dict
    r520 :: str
    r521 :: i32
    r522 :: bit
    r523 :: i32
    r524 :: bit
    r525 :: bool
    r526 :: dict
    r527 :: str
    r528 :: object
    r529 :: set
    r530 :: dict
    r531 :: str
    r532, r533 :: object
    r534 :: bool
    r535 :: object[1]
    r536 :: object_ptr
    r537 :: object
    r538 :: i32
    r539 :: bit
    r540 :: dict
    r541 :: str
    r542 :: object
    r543 :: dict
    r544 :: str
    r545 :: object
    r546 :: str
    r547 :: object
    r548 :: str
    r549 :: object
    r550 :: str
    r551 :: i32
    r552 :: bit
    r553 :: dict
    r554 :: str
    r555 :: object
    r556 :: dict
    r557 :: str
    r558 :: object
    r559 :: str
    r560 :: object
    r561 :: str
    r562 :: object
    r563 :: str
    r564 :: i32
    r565 :: bit
    r566 :: dict
    r567 :: str
    r568 :: object
    r569 :: dict
    r570 :: str
    r571 :: object
    r572 :: str
    r573 :: object
    r574 :: str
    r575 :: object
    r576 :: str
    r577 :: i32
    r578 :: bit
    r579 :: dict
    r580 :: str
    r581 :: object
    r582 :: dict
    r583 :: str
    r584 :: object
    r585 :: str
    r586 :: object
    r587 :: str
    r588 :: object
    r589 :: str
    r590 :: i32
    r591 :: bit
    r592 :: dict
    r593 :: str
    r594 :: object
    r595 :: dict
    r596 :: str
    r597 :: object
    r598 :: str
    r599 :: object
    r600 :: str
    r601 :: object
    r602 :: str
    r603 :: i32
    r604 :: bit
    r605 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L219 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address decimal :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('decimal', 'decimal', 'decimal'),)
    r11 = dank_mids.brownie_patch.call.globals :: static
    r12 = 'dank_mids/brownie_patch/call.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L219 else goto L4 :: bool
L4:
    r15 = ('BrokenProcessPool',)
    r16 = 'concurrent.futures.process'
    r17 = dank_mids.brownie_patch.call.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L219 (error at <module>:2) else goto L5
L5:
    concurrent.futures.process = r18 :: module
    dec_ref r18
    r19 = ('Logger', 'getLogger')
    r20 = 'logging'
    r21 = dank_mids.brownie_patch.call.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L219 (error at <module>:3) else goto L6
L6:
    logging = r22 :: module
    dec_ref r22
    r23 = ('PicklingError',)
    r24 = 'pickle'
    r25 = dank_mids.brownie_patch.call.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L219 (error at <module>:4) else goto L7
L7:
    pickle = r26 :: module
    dec_ref r26
    r27 = ('MethodType', 'ModuleType')
    r28 = 'types'
    r29 = dank_mids.brownie_patch.call.globals :: static
    r30 = CPyImport_ImportFromMany(r28, r27, r27, r29)
    if is_error(r30) goto L219 (error at <module>:5) else goto L8
L8:
    types = r30 :: module
    dec_ref r30
    r31 = ('Any', 'Callable', 'Dict', 'Final', 'List', 'NewType', 'Optional', 'Sequence', 'Tuple', 'TypeVar', 'Union')
    r32 = 'typing'
    r33 = dank_mids.brownie_patch.call.globals :: static
    r34 = CPyImport_ImportFromMany(r32, r31, r31, r33)
    if is_error(r34) goto L219 (error at <module>:6) else goto L9
L9:
    typing = r34 :: module
    dec_ref r34
    r35 = load_address brownie.convert.datatypes :: module
    r36 = load_address brownie.convert.normalize :: module
    r37 = load_address brownie.network.contract :: module
    r38 = load_address eth_abi :: module
    r39 = load_address hexbytes :: module
    r40 = [r35, r36, r37, r38, r39]
    r41 = load_address r40
    r42 = [20, 21, 22, 23, 24]
    r43 = load_address r42
    r44 = (('brownie.convert.datatypes', 'brownie', 'brownie'), ('brownie.convert.normalize', 'brownie', 'brownie'), ('brownie.network.contract', 'brownie', 'brownie'), ('eth_abi', 'eth_abi', 'eth_abi'), ('hexbytes', 'hexbytes', 'hexbytes'))
    r45 = dank_mids.brownie_patch.call.globals :: static
    r46 = 'dank_mids/brownie_patch/call.py'
    r47 = '<module>'
    r48 = CPyImport_ImportMany(r44, r41, r45, r46, r47, r43)
    if not r48 goto L219 else goto L10 :: bool
L10:
    r49 = ('AsyncProcessPoolExecutor',)
    r50 = 'a_sync'
    r51 = dank_mids.brownie_patch.call.globals :: static
    r52 = CPyImport_ImportFromMany(r50, r49, r49, r51)
    if is_error(r52) goto L219 (error at <module>:25) else goto L11
L11:
    a_sync = r52 :: module
    dec_ref r52
    r53 = ('chain',)
    r54 = 'brownie'
    r55 = dank_mids.brownie_patch.call.globals :: static
    r56 = CPyImport_ImportFromMany(r54, r53, r53, r55)
    if is_error(r56) goto L219 (error at <module>:26) else goto L12
L12:
    brownie = r56 :: module
    dec_ref r56
    r57 = ('ABIType',)
    r58 = 'brownie.convert.normalize'
    r59 = dank_mids.brownie_patch.call.globals :: static
    r60 = CPyImport_ImportFromMany(r58, r57, r57, r59)
    if is_error(r60) goto L219 (error at <module>:27) else goto L13
L13:
    brownie.convert.normalize = r60 :: module
    dec_ref r60
    r61 = ('get_type_strings',)
    r62 = 'brownie.convert.utils'
    r63 = dank_mids.brownie_patch.call.globals :: static
    r64 = CPyImport_ImportFromMany(r62, r61, r61, r63)
    if is_error(r64) goto L219 (error at <module>:28) else goto L14
L14:
    brownie.convert.utils = r64 :: module
    dec_ref r64
    r65 = ('VirtualMachineError',)
    r66 = 'brownie.exceptions'
    r67 = dank_mids.brownie_patch.call.globals :: static
    r68 = CPyImport_ImportFromMany(r66, r65, r65, r67)
    if is_error(r68) goto L219 (error at <module>:29) else goto L15
L15:
    brownie.exceptions = r68 :: module
    dec_ref r68
    r69 = ('ContractCall',)
    r70 = 'brownie.network.contract'
    r71 = dank_mids.brownie_patch.call.globals :: static
    r72 = CPyImport_ImportFromMany(r70, r69, r69, r71)
    if is_error(r72) goto L219 (error at <module>:30) else goto L16
L16:
    brownie.network.contract = r72 :: module
    dec_ref r72
    r73 = ('SOLIDITY_ERROR_CODES',)
    r74 = 'brownie.project.compiler.solidity'
    r75 = dank_mids.brownie_patch.call.globals :: static
    r76 = CPyImport_ImportFromMany(r74, r73, r73, r75)
    if is_error(r76) goto L219 (error at <module>:31) else goto L17
L17:
    brownie.project.compiler.solidity = r76 :: module
    dec_ref r76
    r77 = ('InsufficientDataBytes',)
    r78 = 'eth_abi.exceptions'
    r79 = dank_mids.brownie_patch.call.globals :: static
    r80 = CPyImport_ImportFromMany(r78, r77, r77, r79)
    if is_error(r80) goto L219 (error at <module>:32) else goto L18
L18:
    eth_abi.exceptions = r80 :: module
    dec_ref r80
    r81 = ('HexStr',)
    r82 = 'eth_typing'
    r83 = dank_mids.brownie_patch.call.globals :: static
    r84 = CPyImport_ImportFromMany(r82, r81, r81, r83)
    if is_error(r84) goto L219 (error at <module>:33) else goto L19
L19:
    eth_typing = r84 :: module
    dec_ref r84
    r85 = ('Address',)
    r86 = 'evmspec.data'
    r87 = dank_mids.brownie_patch.call.globals :: static
    r88 = CPyImport_ImportFromMany(r86, r85, r85, r87)
    if is_error(r88) goto L219 (error at <module>:34) else goto L20
L20:
    evmspec.data = r88 :: module
    dec_ref r88
    r89 = ('BytesLike',)
    r90 = 'hexbytes.main'
    r91 = dank_mids.brownie_patch.call.globals :: static
    r92 = CPyImport_ImportFromMany(r90, r89, r89, r91)
    if is_error(r92) goto L219 (error at <module>:35) else goto L21
L21:
    hexbytes.main = r92 :: module
    dec_ref r92
    r93 = ('MULTICALL2_ADDRESSES',)
    r94 = 'multicall.constants'
    r95 = dank_mids.brownie_patch.call.globals :: static
    r96 = CPyImport_ImportFromMany(r94, r93, r93, r95)
    if is_error(r96) goto L219 (error at <module>:36) else goto L22
L22:
    multicall.constants = r96 :: module
    dec_ref r96
    r97 = ('BlockIdentifier',)
    r98 = 'web3.types'
    r99 = dank_mids.brownie_patch.call.globals :: static
    r100 = CPyImport_ImportFromMany(r98, r97, r97, r99)
    if is_error(r100) goto L219 (error at <module>:37) else goto L23
L23:
    web3.types = r100 :: module
    dec_ref r100
    r101 = ('ENVIRONMENT_VARIABLES', 'exceptions')
    r102 = 'dank_mids'
    r103 = dank_mids.brownie_patch.call.globals :: static
    r104 = CPyImport_ImportFromMany(r102, r101, r101, r103)
    if is_error(r104) goto L219 (error at <module>:39) else goto L24
L24:
    dank_mids = r104 :: module
    dec_ref r104
    r105 = ('ContractMethod',)
    r106 = 'dank_mids.brownie_patch.types'
    r107 = dank_mids.brownie_patch.call.globals :: static
    r108 = CPyImport_ImportFromMany(r106, r105, r105, r107)
    if is_error(r108) goto L219 (error at <module>:40) else goto L25
L25:
    dank_mids.brownie_patch.types = r108 :: module
    dec_ref r108
    r109 = ('lru_cache_lite_nonull',)
    r110 = 'dank_mids.helpers.lru_cache'
    r111 = dank_mids.brownie_patch.call.globals :: static
    r112 = CPyImport_ImportFromMany(r110, r109, r109, r111)
    if is_error(r112) goto L219 (error at <module>:41) else goto L26
L26:
    dank_mids.helpers.lru_cache = r112 :: module
    dec_ref r112
    r113 = ('DankWeb3',)
    r114 = 'dank_mids.helpers._helpers'
    r115 = dank_mids.brownie_patch.call.globals :: static
    r116 = CPyImport_ImportFromMany(r114, r113, r113, r115)
    if is_error(r116) goto L219 (error at <module>:42) else goto L27
L27:
    dank_mids.helpers._helpers = r116 :: module
    dec_ref r116
    r117 = dank_mids.brownie_patch.call.globals :: static
    r118 = 'ENVIRONMENT_VARIABLES'
    r119 = CPyDict_GetItem(r117, r118)
    if is_error(r119) goto L219 (error at <module>:45) else goto L28
L28:
    dank_mids.brownie_patch.call.ENVS = r119 :: static
    r120 = dank_mids.brownie_patch.call.globals :: static
    r121 = 'ENVS'
    r122 = CPyDict_SetItem(r120, r121, r119)
    dec_ref r119
    r123 = r122 >= 0 :: signed
    if not r123 goto L219 (error at <module>:45) else goto L29 :: bool
L29:
    r124 = dank_mids.brownie_patch.call.ENVS :: static
    if is_error(r124) goto L30 else goto L32
L30:
    r125 = raise NameError('value for final name "ENVS" was not set')
    if not r125 goto L219 (error at <module>:46) else goto L31 :: bool
L31:
    unreachable
L32:
    r126 = 'OPERATION_MODE'
    r127 = CPyObject_GetAttr(r124, r126)
    if is_error(r127) goto L219 (error at <module>:46) else goto L33
L33:
    r128 = 'application'
    r129 = CPyObject_GetAttr(r127, r128)
    dec_ref r127
    if is_error(r129) goto L219 (error at <module>:46) else goto L34
L34:
    r130 = unbox(bool, r129)
    if is_error(r130) goto L220 (error at <module>:46) else goto L35
L35:
    dank_mids.brownie_patch.call.APPLICATION_MODE = r130 :: static
    r131 = dank_mids.brownie_patch.call.globals :: static
    r132 = 'APPLICATION_MODE'
    r133 = CPyDict_SetItem(r131, r132, r129)
    dec_ref r129
    r134 = r133 >= 0 :: signed
    if not r134 goto L219 (error at <module>:46) else goto L36 :: bool
L36:
    r135 = '_T'
    r136 = dank_mids.brownie_patch.call.globals :: static
    r137 = 'TypeVar'
    r138 = CPyDict_GetItem(r136, r137)
    if is_error(r138) goto L219 (error at <module>:49) else goto L37
L37:
    r139 = [r135]
    r140 = load_address r139
    r141 = _PyObject_Vectorcall(r138, r140, 1, 0)
    dec_ref r138
    if is_error(r141) goto L219 (error at <module>:49) else goto L38
L38:
    r142 = dank_mids.brownie_patch.call.globals :: static
    r143 = '_T'
    r144 = CPyDict_SetItem(r142, r143, r141)
    dec_ref r141
    r145 = r144 >= 0 :: signed
    if not r145 goto L219 (error at <module>:49) else goto L39 :: bool
L39:
    r146 = 'TypeStr'
    r147 = load_address PyUnicode_Type
    r148 = dank_mids.brownie_patch.call.globals :: static
    r149 = 'NewType'
    r150 = CPyDict_GetItem(r148, r149)
    if is_error(r150) goto L219 (error at <module>:50) else goto L40
L40:
    r151 = [r146, r147]
    r152 = load_address r151
    r153 = _PyObject_Vectorcall(r150, r152, 2, 0)
    dec_ref r150
    if is_error(r153) goto L219 (error at <module>:50) else goto L41
L41:
    r154 = dank_mids.brownie_patch.call.globals :: static
    r155 = 'TypeStr'
    r156 = CPyDict_SetItem(r154, r155, r153)
    dec_ref r153
    r157 = r156 >= 0 :: signed
    if not r157 goto L219 (error at <module>:50) else goto L42 :: bool
L42:
    r158 = dank_mids.brownie_patch.call.globals :: static
    r159 = 'List'
    r160 = CPyDict_GetItem(r158, r159)
    if is_error(r160) goto L219 (error at <module>:51) else goto L43
L43:
    r161 = dank_mids.brownie_patch.call.globals :: static
    r162 = 'TypeStr'
    r163 = CPyDict_GetItem(r161, r162)
    if is_error(r163) goto L221 (error at <module>:51) else goto L44
L44:
    r164 = PyObject_GetItem(r160, r163)
    dec_ref r160
    dec_ref r163
    if is_error(r164) goto L219 (error at <module>:51) else goto L45
L45:
    r165 = dank_mids.brownie_patch.call.globals :: static
    r166 = 'TypeStrs'
    r167 = CPyDict_SetItem(r165, r166, r164)
    dec_ref r164
    r168 = r167 >= 0 :: signed
    if not r168 goto L219 (error at <module>:51) else goto L46 :: bool
L46:
    r169 = dank_mids.brownie_patch.call.globals :: static
    r170 = 'Union'
    r171 = CPyDict_GetItem(r169, r170)
    if is_error(r171) goto L219 (error at <module>:52) else goto L47
L47:
    r172 = dank_mids.brownie_patch.call.globals :: static
    r173 = 'List'
    r174 = CPyDict_GetItem(r172, r173)
    if is_error(r174) goto L222 (error at <module>:52) else goto L48
L48:
    r175 = dank_mids.brownie_patch.call.globals :: static
    r176 = '_T'
    r177 = CPyDict_GetItem(r175, r176)
    if is_error(r177) goto L223 (error at <module>:52) else goto L49
L49:
    r178 = PyObject_GetItem(r174, r177)
    dec_ref r174
    dec_ref r177
    if is_error(r178) goto L222 (error at <module>:52) else goto L50
L50:
    r179 = dank_mids.brownie_patch.call.globals :: static
    r180 = 'Tuple'
    r181 = CPyDict_GetItem(r179, r180)
    if is_error(r181) goto L224 (error at <module>:52) else goto L51
L51:
    r182 = dank_mids.brownie_patch.call.globals :: static
    r183 = '_T'
    r184 = CPyDict_GetItem(r182, r183)
    if is_error(r184) goto L225 (error at <module>:52) else goto L52
L52:
    r185 = load_address _Py_EllipsisObject
    inc_ref r185
    r186 = (r184, r185)
    r187 = box(tuple[object, object], r186)
    r188 = PyObject_GetItem(r181, r187)
    dec_ref r181
    dec_ref r187
    if is_error(r188) goto L224 (error at <module>:52) else goto L53
L53:
    r189 = (r178, r188)
    r190 = box(tuple[object, object], r189)
    r191 = PyObject_GetItem(r171, r190)
    dec_ref r171
    dec_ref r190
    if is_error(r191) goto L219 (error at <module>:52) else goto L54
L54:
    r192 = dank_mids.brownie_patch.call.globals :: static
    r193 = 'ListOrTuple'
    r194 = CPyDict_SetItem(r192, r193, r191)
    dec_ref r191
    r195 = r194 >= 0 :: signed
    if not r195 goto L219 (error at <module>:52) else goto L55 :: bool
L55:
    r196 = 'AbiDict'
    r197 = dank_mids.brownie_patch.call.globals :: static
    r198 = 'Dict'
    r199 = CPyDict_GetItem(r197, r198)
    if is_error(r199) goto L219 (error at <module>:53) else goto L56
L56:
    r200 = load_address PyUnicode_Type
    r201 = dank_mids.brownie_patch.call.globals :: static
    r202 = 'Any'
    r203 = CPyDict_GetItem(r201, r202)
    if is_error(r203) goto L226 (error at <module>:53) else goto L57
L57:
    inc_ref r200
    r204 = (r200, r203)
    r205 = box(tuple[object, object], r204)
    r206 = PyObject_GetItem(r199, r205)
    dec_ref r199
    dec_ref r205
    if is_error(r206) goto L219 (error at <module>:53) else goto L58
L58:
    r207 = dank_mids.brownie_patch.call.globals :: static
    r208 = 'NewType'
    r209 = CPyDict_GetItem(r207, r208)
    if is_error(r209) goto L227 (error at <module>:53) else goto L59
L59:
    r210 = [r196, r206]
    r211 = load_address r210
    r212 = _PyObject_Vectorcall(r209, r211, 2, 0)
    dec_ref r209
    if is_error(r212) goto L227 (error at <module>:53) else goto L60
L60:
    dec_ref r206
    r213 = dank_mids.brownie_patch.call.globals :: static
    r214 = 'AbiDict'
    r215 = CPyDict_SetItem(r213, r214, r212)
    dec_ref r212
    r216 = r215 >= 0 :: signed
    if not r216 goto L219 (error at <module>:53) else goto L61 :: bool
L61:
    r217 = decimal :: module
    r218 = 'Decimal'
    r219 = CPyObject_GetAttr(r217, r218)
    if is_error(r219) goto L219 (error at <module>:57) else goto L62
L62:
    dank_mids.brownie_patch.call.Decimal = r219 :: static
    r220 = dank_mids.brownie_patch.call.globals :: static
    r221 = 'Decimal'
    r222 = CPyDict_SetItem(r220, r221, r219)
    dec_ref r219
    r223 = r222 >= 0 :: signed
    if not r223 goto L219 (error at <module>:57) else goto L63 :: bool
L63:
    r224 = dank_mids.brownie_patch.call.globals :: static
    r225 = 'hexbytes'
    r226 = CPyDict_GetItem(r224, r225)
    if is_error(r226) goto L219 (error at <module>:58) else goto L64
L64:
    r227 = 'HexBytes'
    r228 = CPyObject_GetAttr(r226, r227)
    dec_ref r226
    if is_error(r228) goto L219 (error at <module>:58) else goto L65
L65:
    dank_mids.brownie_patch.call.HexBytes = r228 :: static
    r229 = dank_mids.brownie_patch.call.globals :: static
    r230 = 'HexBytes'
    r231 = CPyDict_SetItem(r229, r230, r228)
    dec_ref r228
    r232 = r231 >= 0 :: signed
    if not r232 goto L219 (error at <module>:58) else goto L66 :: bool
L66:
    r233 = dank_mids.brownie_patch.call.globals :: static
    r234 = 'brownie'
    r235 = CPyDict_GetItem(r233, r234)
    if is_error(r235) goto L219 (error at <module>:59) else goto L67
L67:
    r236 = 'network'
    r237 = CPyObject_GetAttr(r235, r236)
    dec_ref r235
    if is_error(r237) goto L219 (error at <module>:59) else goto L68
L68:
    r238 = 'contract'
    r239 = CPyObject_GetAttr(r237, r238)
    dec_ref r237
    if is_error(r239) goto L219 (error at <module>:59) else goto L69
L69:
    r240 = 'Contract'
    r241 = CPyObject_GetAttr(r239, r240)
    dec_ref r239
    if is_error(r241) goto L219 (error at <module>:59) else goto L70
L70:
    dank_mids.brownie_patch.call.Contract = r241 :: static
    r242 = dank_mids.brownie_patch.call.globals :: static
    r243 = 'Contract'
    r244 = CPyDict_SetItem(r242, r243, r241)
    dec_ref r241
    r245 = r244 >= 0 :: signed
    if not r245 goto L219 (error at <module>:59) else goto L71 :: bool
L71:
    r246 = dank_mids.brownie_patch.call.globals :: static
    r247 = 'brownie'
    r248 = CPyDict_GetItem(r246, r247)
    if is_error(r248) goto L219 (error at <module>:60) else goto L72
L72:
    r249 = 'convert'
    r250 = CPyObject_GetAttr(r248, r249)
    dec_ref r248
    if is_error(r250) goto L219 (error at <module>:60) else goto L73
L73:
    r251 = 'datatypes'
    r252 = CPyObject_GetAttr(r250, r251)
    dec_ref r250
    if is_error(r252) goto L219 (error at <module>:60) else goto L74
L74:
    r253 = 'ReturnValue'
    r254 = CPyObject_GetAttr(r252, r253)
    dec_ref r252
    if is_error(r254) goto L219 (error at <module>:60) else goto L75
L75:
    dank_mids.brownie_patch.call.ReturnValue = r254 :: static
    r255 = dank_mids.brownie_patch.call.globals :: static
    r256 = 'ReturnValue'
    r257 = CPyDict_SetItem(r255, r256, r254)
    dec_ref r254
    r258 = r257 >= 0 :: signed
    if not r258 goto L219 (error at <module>:60) else goto L76 :: bool
L76:
    r259 = dank_mids.brownie_patch.call.globals :: static
    r260 = 'brownie'
    r261 = CPyDict_GetItem(r259, r260)
    if is_error(r261) goto L219 (error at <module>:61) else goto L77
L77:
    r262 = 'convert'
    r263 = CPyObject_GetAttr(r261, r262)
    dec_ref r261
    if is_error(r263) goto L219 (error at <module>:61) else goto L78
L78:
    r264 = 'normalize'
    r265 = CPyObject_GetAttr(r263, r264)
    dec_ref r263
    if is_error(r265) goto L219 (error at <module>:61) else goto L79
L79:
    r266 = 'HexString'
    r267 = CPyObject_GetAttr(r265, r266)
    dec_ref r265
    if is_error(r267) goto L219 (error at <module>:61) else goto L80
L80:
    dank_mids.brownie_patch.call.HexString = r267 :: static
    r268 = dank_mids.brownie_patch.call.globals :: static
    r269 = 'HexString'
    r270 = CPyDict_SetItem(r268, r269, r267)
    dec_ref r267
    r271 = r270 >= 0 :: signed
    if not r271 goto L219 (error at <module>:61) else goto L81 :: bool
L81:
    r272 = dank_mids.brownie_patch.call.globals :: static
    r273 = 'brownie'
    r274 = CPyDict_GetItem(r272, r273)
    if is_error(r274) goto L219 (error at <module>:62) else goto L82
L82:
    r275 = 'convert'
    r276 = CPyObject_GetAttr(r274, r275)
    dec_ref r274
    if is_error(r276) goto L219 (error at <module>:62) else goto L83
L83:
    r277 = 'normalize'
    r278 = CPyObject_GetAttr(r276, r277)
    dec_ref r276
    if is_error(r278) goto L219 (error at <module>:62) else goto L84
L84:
    r279 = 'TupleType'
    r280 = CPyObject_GetAttr(r278, r279)
    dec_ref r278
    if is_error(r280) goto L219 (error at <module>:62) else goto L85
L85:
    dank_mids.brownie_patch.call.TupleType = r280 :: static
    r281 = dank_mids.brownie_patch.call.globals :: static
    r282 = 'TupleType'
    r283 = CPyDict_SetItem(r281, r282, r280)
    dec_ref r280
    r284 = r283 >= 0 :: signed
    if not r284 goto L219 (error at <module>:62) else goto L86 :: bool
L86:
    r285 = dank_mids.brownie_patch.call.globals :: static
    r286 = 'exceptions'
    r287 = CPyDict_GetItem(r285, r286)
    if is_error(r287) goto L219 (error at <module>:64) else goto L87
L87:
    r288 = 'Revert'
    r289 = CPyObject_GetAttr(r287, r288)
    dec_ref r287
    if is_error(r289) goto L219 (error at <module>:64) else goto L88
L88:
    dank_mids.brownie_patch.call.Revert = r289 :: static
    r290 = dank_mids.brownie_patch.call.globals :: static
    r291 = 'Revert'
    r292 = CPyDict_SetItem(r290, r291, r289)
    dec_ref r289
    r293 = r292 >= 0 :: signed
    if not r293 goto L219 (error at <module>:64) else goto L89 :: bool
L89:
    r294 = dank_mids.brownie_patch.call.globals :: static
    r295 = 'brownie'
    r296 = CPyDict_GetItem(r294, r295)
    if is_error(r296) goto L219 (error at <module>:66) else goto L90
L90:
    r297 = 'convert'
    r298 = CPyObject_GetAttr(r296, r297)
    dec_ref r296
    if is_error(r298) goto L219 (error at <module>:66) else goto L91
L91:
    r299 = 'normalize'
    r300 = CPyObject_GetAttr(r298, r299)
    dec_ref r298
    if is_error(r300) goto L219 (error at <module>:66) else goto L92
L92:
    r301 = 'to_bool'
    r302 = CPyObject_GetAttr(r300, r301)
    dec_ref r300
    if is_error(r302) goto L219 (error at <module>:66) else goto L93
L93:
    dank_mids.brownie_patch.call.to_bool = r302 :: static
    r303 = dank_mids.brownie_patch.call.globals :: static
    r304 = 'to_bool'
    r305 = CPyDict_SetItem(r303, r304, r302)
    dec_ref r302
    r306 = r305 >= 0 :: signed
    if not r306 goto L219 (error at <module>:66) else goto L94 :: bool
L94:
    r307 = dank_mids.brownie_patch.call.globals :: static
    r308 = 'brownie'
    r309 = CPyDict_GetItem(r307, r308)
    if is_error(r309) goto L219 (error at <module>:67) else goto L95
L95:
    r310 = 'convert'
    r311 = CPyObject_GetAttr(r309, r310)
    dec_ref r309
    if is_error(r311) goto L219 (error at <module>:67) else goto L96
L96:
    r312 = 'normalize'
    r313 = CPyObject_GetAttr(r311, r312)
    dec_ref r311
    if is_error(r313) goto L219 (error at <module>:67) else goto L97
L97:
    r314 = 'to_decimal'
    r315 = CPyObject_GetAttr(r313, r314)
    dec_ref r313
    if is_error(r315) goto L219 (error at <module>:67) else goto L98
L98:
    dank_mids.brownie_patch.call.to_decimal = r315 :: static
    r316 = dank_mids.brownie_patch.call.globals :: static
    r317 = 'to_decimal'
    r318 = CPyDict_SetItem(r316, r317, r315)
    dec_ref r315
    r319 = r318 >= 0 :: signed
    if not r319 goto L219 (error at <module>:67) else goto L99 :: bool
L99:
    r320 = dank_mids.brownie_patch.call.globals :: static
    r321 = 'brownie'
    r322 = CPyDict_GetItem(r320, r321)
    if is_error(r322) goto L219 (error at <module>:68) else goto L100
L100:
    r323 = 'convert'
    r324 = CPyObject_GetAttr(r322, r323)
    dec_ref r322
    if is_error(r324) goto L219 (error at <module>:68) else goto L101
L101:
    r325 = 'normalize'
    r326 = CPyObject_GetAttr(r324, r325)
    dec_ref r324
    if is_error(r326) goto L219 (error at <module>:68) else goto L102
L102:
    r327 = 'to_int'
    r328 = CPyObject_GetAttr(r326, r327)
    dec_ref r326
    if is_error(r328) goto L219 (error at <module>:68) else goto L103
L103:
    dank_mids.brownie_patch.call.to_int = r328 :: static
    r329 = dank_mids.brownie_patch.call.globals :: static
    r330 = 'to_int'
    r331 = CPyDict_SetItem(r329, r330, r328)
    dec_ref r328
    r332 = r331 >= 0 :: signed
    if not r332 goto L219 (error at <module>:68) else goto L104 :: bool
L104:
    r333 = dank_mids.brownie_patch.call.globals :: static
    r334 = 'brownie'
    r335 = CPyDict_GetItem(r333, r334)
    if is_error(r335) goto L219 (error at <module>:69) else goto L105
L105:
    r336 = 'convert'
    r337 = CPyObject_GetAttr(r335, r336)
    dec_ref r335
    if is_error(r337) goto L219 (error at <module>:69) else goto L106
L106:
    r338 = 'normalize'
    r339 = CPyObject_GetAttr(r337, r338)
    dec_ref r337
    if is_error(r339) goto L219 (error at <module>:69) else goto L107
L107:
    r340 = 'to_string'
    r341 = CPyObject_GetAttr(r339, r340)
    dec_ref r339
    if is_error(r341) goto L219 (error at <module>:69) else goto L108
L108:
    dank_mids.brownie_patch.call.to_string = r341 :: static
    r342 = dank_mids.brownie_patch.call.globals :: static
    r343 = 'to_string'
    r344 = CPyDict_SetItem(r342, r343, r341)
    dec_ref r341
    r345 = r344 >= 0 :: signed
    if not r345 goto L219 (error at <module>:69) else goto L109 :: bool
L109:
    r346 = dank_mids.brownie_patch.call.globals :: static
    r347 = 'brownie'
    r348 = CPyDict_GetItem(r346, r347)
    if is_error(r348) goto L219 (error at <module>:70) else goto L110
L110:
    r349 = 'convert'
    r350 = CPyObject_GetAttr(r348, r349)
    dec_ref r348
    if is_error(r350) goto L219 (error at <module>:70) else goto L111
L111:
    r351 = 'normalize'
    r352 = CPyObject_GetAttr(r350, r351)
    dec_ref r350
    if is_error(r352) goto L219 (error at <module>:70) else goto L112
L112:
    r353 = 'to_uint'
    r354 = CPyObject_GetAttr(r352, r353)
    dec_ref r352
    if is_error(r354) goto L219 (error at <module>:70) else goto L113
L113:
    dank_mids.brownie_patch.call.to_uint = r354 :: static
    r355 = dank_mids.brownie_patch.call.globals :: static
    r356 = 'to_uint'
    r357 = CPyDict_SetItem(r355, r356, r354)
    dec_ref r354
    r358 = r357 >= 0 :: signed
    if not r358 goto L219 (error at <module>:70) else goto L114 :: bool
L114:
    r359 = dank_mids.brownie_patch.call.globals :: static
    r360 = 'brownie'
    r361 = CPyDict_GetItem(r359, r360)
    if is_error(r361) goto L219 (error at <module>:71) else goto L115
L115:
    r362 = 'convert'
    r363 = CPyObject_GetAttr(r361, r362)
    dec_ref r361
    if is_error(r363) goto L219 (error at <module>:71) else goto L116
L116:
    r364 = 'normalize'
    r365 = CPyObject_GetAttr(r363, r364)
    dec_ref r363
    if is_error(r365) goto L219 (error at <module>:71) else goto L117
L117:
    r366 = '_check_array'
    r367 = CPyObject_GetAttr(r365, r366)
    dec_ref r365
    if is_error(r367) goto L219 (error at <module>:71) else goto L118
L118:
    dank_mids.brownie_patch.call._check_array = r367 :: static
    r368 = dank_mids.brownie_patch.call.globals :: static
    r369 = '_check_array'
    r370 = CPyDict_SetItem(r368, r369, r367)
    dec_ref r367
    r371 = r370 >= 0 :: signed
    if not r371 goto L219 (error at <module>:71) else goto L119 :: bool
L119:
    r372 = dank_mids.brownie_patch.call.globals :: static
    r373 = 'brownie'
    r374 = CPyDict_GetItem(r372, r373)
    if is_error(r374) goto L219 (error at <module>:72) else goto L120
L120:
    r375 = 'convert'
    r376 = CPyObject_GetAttr(r374, r375)
    dec_ref r374
    if is_error(r376) goto L219 (error at <module>:72) else goto L121
L121:
    r377 = 'normalize'
    r378 = CPyObject_GetAttr(r376, r377)
    dec_ref r376
    if is_error(r378) goto L219 (error at <module>:72) else goto L122
L122:
    r379 = '_get_abi_types'
    r380 = CPyObject_GetAttr(r378, r379)
    dec_ref r378
    if is_error(r380) goto L219 (error at <module>:72) else goto L123
L123:
    dank_mids.brownie_patch.call._get_abi_types = r380 :: static
    r381 = dank_mids.brownie_patch.call.globals :: static
    r382 = '_get_abi_types'
    r383 = CPyDict_SetItem(r381, r382, r380)
    dec_ref r380
    r384 = r383 >= 0 :: signed
    if not r384 goto L219 (error at <module>:72) else goto L124 :: bool
L124:
    r385 = dank_mids.brownie_patch.call.globals :: static
    r386 = '__name__'
    r387 = CPyDict_GetItem(r385, r386)
    if is_error(r387) goto L219 (error at <module>:75) else goto L125
L125:
    r388 = cast(str, r387)
    if is_error(r388) goto L219 (error at <module>:75) else goto L126
L126:
    r389 = dank_mids.brownie_patch.call.globals :: static
    r390 = 'getLogger'
    r391 = CPyDict_GetItem(r389, r390)
    if is_error(r391) goto L228 (error at <module>:75) else goto L127
L127:
    r392 = [r388]
    r393 = load_address r392
    r394 = _PyObject_Vectorcall(r391, r393, 1, 0)
    dec_ref r391
    if is_error(r394) goto L228 (error at <module>:75) else goto L128
L128:
    dec_ref r388
    dank_mids.brownie_patch.call.logger = r394 :: static
    r395 = dank_mids.brownie_patch.call.globals :: static
    r396 = 'logger'
    r397 = CPyDict_SetItem(r395, r396, r394)
    dec_ref r394
    r398 = r397 >= 0 :: signed
    if not r398 goto L219 (error at <module>:75) else goto L129 :: bool
L129:
    r399 = __mypyc_lambda__0_obj()
    if is_error(r399) goto L219 (error at <module>:78) else goto L130
L130:
    dank_mids.brownie_patch.call.encode = r399 :: static
    r400 = dank_mids.brownie_patch.call.globals :: static
    r401 = 'encode'
    r402 = CPyDict_SetItem(r400, r401, r399)
    dec_ref r399
    r403 = r402 >= 0 :: signed
    if not r403 goto L219 (error at <module>:78) else goto L131 :: bool
L131:
    r404 = __mypyc_lambda__1_obj()
    if is_error(r404) goto L219 (error at <module>:97) else goto L132
L132:
    dank_mids.brownie_patch.call.decode = r404 :: static
    r405 = dank_mids.brownie_patch.call.globals :: static
    r406 = 'decode'
    r407 = CPyDict_SetItem(r405, r406, r404)
    dec_ref r404
    r408 = r407 >= 0 :: signed
    if not r408 goto L219 (error at <module>:97) else goto L133 :: bool
L133:
    r409 = dank_mids.brownie_patch.call.globals :: static
    r410 = 'Address'
    r411 = CPyDict_GetItem(r409, r410)
    if is_error(r411) goto L219 (error at <module>:118) else goto L134
L134:
    r412 = 'checksum'
    r413 = CPyObject_GetAttr(r411, r412)
    dec_ref r411
    if is_error(r413) goto L219 (error at <module>:118) else goto L135
L135:
    dank_mids.brownie_patch.call.to_checksum_address = r413 :: static
    r414 = dank_mids.brownie_patch.call.globals :: static
    r415 = 'to_checksum_address'
    r416 = CPyDict_SetItem(r414, r415, r413)
    dec_ref r413
    r417 = r416 >= 0 :: signed
    if not r417 goto L219 (error at <module>:118) else goto L136 :: bool
L136:
    r418 = dank_mids.brownie_patch.call.globals :: static
    r419 = '_get_coroutine_fn'
    r420 = CPyDict_GetItem(r418, r419)
    if is_error(r420) goto L219 (error at <module>:136) else goto L137
L137:
    r421 = dank_mids.brownie_patch.call.globals :: static
    r422 = 'lru_cache_lite_nonull'
    r423 = CPyDict_GetItem(r421, r422)
    if is_error(r423) goto L229 (error at <module>:136) else goto L138
L138:
    r424 = [r420]
    r425 = load_address r424
    r426 = _PyObject_Vectorcall(r423, r425, 1, 0)
    dec_ref r423
    if is_error(r426) goto L229 (error at <module>:136) else goto L139
L139:
    dec_ref r420
    r427 = dank_mids.brownie_patch.call.globals :: static
    r428 = '_get_coroutine_fn'
    r429 = CPyDict_SetItem(r427, r428, r426)
    dec_ref r426
    r430 = r429 >= 0 :: signed
    if not r430 goto L219 (error at <module>:136) else goto L140 :: bool
L140:
    r431 = dank_mids.brownie_patch.call.globals :: static
    r432 = 'eth_abi'
    r433 = CPyDict_GetItem(r431, r432)
    if is_error(r433) goto L219 (error at <module>:234) else goto L141
L141:
    r434 = 'encode'
    r435 = PyObject_HasAttr(r433, r434)
    dec_ref r433
    if r435 goto L142 else goto L145 :: bool
L142:
    r436 = dank_mids.brownie_patch.call.globals :: static
    r437 = 'eth_abi'
    r438 = CPyDict_GetItem(r436, r437)
    if is_error(r438) goto L219 (error at <module>:234) else goto L143
L143:
    r439 = 'encode'
    r440 = CPyObject_GetAttr(r438, r439)
    dec_ref r438
    if is_error(r440) goto L219 (error at <module>:234) else goto L144
L144:
    r441 = r440
    goto L148
L145:
    r442 = dank_mids.brownie_patch.call.globals :: static
    r443 = 'eth_abi'
    r444 = CPyDict_GetItem(r442, r443)
    if is_error(r444) goto L219 (error at <module>:234) else goto L146
L146:
    r445 = 'encode_abi'
    r446 = CPyObject_GetAttr(r444, r445)
    dec_ref r444
    if is_error(r446) goto L219 (error at <module>:234) else goto L147
L147:
    r441 = r446
L148:
    dank_mids.brownie_patch.call.__eth_abi_encode = r441 :: static
    r447 = dank_mids.brownie_patch.call.globals :: static
    r448 = '__eth_abi_encode'
    r449 = CPyDict_SetItem(r447, r448, r441)
    dec_ref r441
    r450 = r449 >= 0 :: signed
    if not r450 goto L219 (error at <module>:234) else goto L149 :: bool
L149:
    r451 = dank_mids.brownie_patch.call.globals :: static
    r452 = 'eth_abi'
    r453 = CPyDict_GetItem(r451, r452)
    if is_error(r453) goto L219 (error at <module>:237) else goto L150
L150:
    r454 = 'decode'
    r455 = PyObject_HasAttr(r453, r454)
    dec_ref r453
    if r455 goto L151 else goto L154 :: bool
L151:
    r456 = dank_mids.brownie_patch.call.globals :: static
    r457 = 'eth_abi'
    r458 = CPyDict_GetItem(r456, r457)
    if is_error(r458) goto L219 (error at <module>:237) else goto L152
L152:
    r459 = 'decode'
    r460 = CPyObject_GetAttr(r458, r459)
    dec_ref r458
    if is_error(r460) goto L219 (error at <module>:237) else goto L153
L153:
    r461 = r460
    goto L157
L154:
    r462 = dank_mids.brownie_patch.call.globals :: static
    r463 = 'eth_abi'
    r464 = CPyDict_GetItem(r462, r463)
    if is_error(r464) goto L219 (error at <module>:237) else goto L155
L155:
    r465 = 'decode_abi'
    r466 = CPyObject_GetAttr(r464, r465)
    dec_ref r464
    if is_error(r466) goto L219 (error at <module>:237) else goto L156
L156:
    r461 = r466
L157:
    dank_mids.brownie_patch.call.__eth_abi_decode = r461 :: static
    r467 = dank_mids.brownie_patch.call.globals :: static
    r468 = '__eth_abi_decode'
    r469 = CPyDict_SetItem(r467, r468, r461)
    dec_ref r461
    r470 = r469 >= 0 :: signed
    if not r470 goto L219 (error at <module>:237) else goto L158 :: bool
L158:
    r471 = '0xcA11bde05977b3631167028862bE2a173976CA11'
    r472 = PySet_New(0)
    if is_error(r472) goto L219 (error at <module>:250) else goto L159
L159:
    r473 = PySet_Add(r472, r471)
    r474 = r473 >= 0 :: signed
    if not r474 goto L230 (error at <module>:250) else goto L160 :: bool
L160:
    r475 = dank_mids.brownie_patch.call.globals :: static
    r476 = '_skip_proc_pool'
    r477 = CPyDict_SetItem(r475, r476, r472)
    dec_ref r472
    r478 = r477 >= 0 :: signed
    if not r478 goto L219 (error at <module>:250) else goto L161 :: bool
L161:
    if 1 goto L162 else goto L179 :: bool
L162:
    r479 = dank_mids.brownie_patch.call.globals :: static
    r480 = 'chain'
    r481 = CPyDict_GetItem(r479, r480)
    if is_error(r481) goto L165 (error at <module>:254) else goto L163
L163:
    r482 = 'id'
    r483 = CPyObject_GetAttr(r481, r482)
    dec_ref r481
    if is_error(r483) goto L165 (error at <module>:254) else goto L164
L164:
    r484 = dank_mids.brownie_patch.call.globals :: static
    r485 = 'chainid'
    r486 = CPyDict_SetItem(r484, r485, r483)
    dec_ref r483
    r487 = r486 >= 0 :: signed
    if not r487 goto L165 (error at <module>:254) else goto L179 :: bool
L165:
    r488 = CPy_CatchError()
    r489 = builtins :: module
    r490 = 'Exception'
    r491 = CPyObject_GetAttr(r489, r490)
    if is_error(r491) goto L177 (error at <module>:256) else goto L166
L166:
    r492 = CPy_ExceptionMatches(r491)
    dec_ref r491
    if r492 goto L167 else goto L174 :: bool
L167:
    r493 = dank_mids.brownie_patch.call.globals :: static
    r494 = 'e'
    r495 = CPy_GetExcValue()
    r496 = CPyDict_SetItem(r493, r494, r495)
    dec_ref r495
    r497 = r496 >= 0 :: signed
    if not r497 goto L177 (error at <module>:256) else goto L168 :: bool
L168:
    r498 = '429'
    r499 = dank_mids.brownie_patch.call.globals :: static
    r500 = 'e'
    r501 = CPyDict_GetItem(r499, r500)
    if is_error(r501) goto L177 (error at <module>:257) else goto L169
L169:
    r502 = PyObject_Str(r501)
    dec_ref r501
    if is_error(r502) goto L177 (error at <module>:257) else goto L170
L170:
    r503 = PySequence_Contains(r502, r498)
    dec_ref r502
    r504 = r503 >= 0 :: signed
    if not r504 goto L177 (error at <module>:257) else goto L171 :: bool
L171:
    r505 = truncate r503: i32 to builtins.bool
    r506 = r505 ^ 1
    if r506 goto L172 else goto L176 :: bool
L172:
    CPy_Reraise()
    if not 0 goto L177 else goto L231 :: bool
L173:
    unreachable
L174:
    CPy_Reraise()
    if not 0 goto L177 else goto L232 :: bool
L175:
    unreachable
L176:
    CPy_RestoreExcInfo(r488)
    dec_ref r488
    goto L161
L177:
    CPy_RestoreExcInfo(r488)
    dec_ref r488
    r507 = CPy_KeepPropagating()
    if not r507 goto L219 else goto L178 :: bool
L178:
    unreachable
L179:
    r508 = dank_mids.brownie_patch.call.globals :: static
    r509 = 'MULTICALL2_ADDRESSES'
    r510 = CPyDict_GetItem(r508, r509)
    if is_error(r510) goto L219 (error at <module>:259) else goto L180
L180:
    r511 = dank_mids.brownie_patch.call.globals :: static
    r512 = 'chainid'
    r513 = CPyDict_GetItem(r511, r512)
    if is_error(r513) goto L233 (error at <module>:259) else goto L181
L181:
    r514 = 'get'
    r515 = box(None, 1)
    r516 = [r510, r513, r515]
    r517 = load_address r516
    r518 = PyObject_VectorcallMethod(r514, r517, 9223372036854775811, 0)
    if is_error(r518) goto L234 (error at <module>:259) else goto L182
L182:
    dec_ref r510
    dec_ref r513
    r519 = dank_mids.brownie_patch.call.globals :: static
    r520 = 'multicall2'
    r521 = CPyDict_SetItem(r519, r520, r518)
    r522 = r521 >= 0 :: signed
    if not r522 goto L235 (error at <module>:259) else goto L183 :: bool
L183:
    r523 = PyObject_IsTrue(r518)
    dec_ref r518
    r524 = r523 >= 0 :: signed
    if not r524 goto L219 (error at <module>:259) else goto L184 :: bool
L184:
    r525 = truncate r523: i32 to builtins.bool
    if r525 goto L185 else goto L193 :: bool
L185:
    r526 = dank_mids.brownie_patch.call.globals :: static
    r527 = '_skip_proc_pool'
    r528 = CPyDict_GetItem(r526, r527)
    if is_error(r528) goto L219 (error at <module>:260) else goto L186
L186:
    r529 = cast(set, r528)
    if is_error(r529) goto L219 (error at <module>:260) else goto L187
L187:
    r530 = dank_mids.brownie_patch.call.globals :: static
    r531 = 'multicall2'
    r532 = CPyDict_GetItem(r530, r531)
    if is_error(r532) goto L236 (error at <module>:260) else goto L188
L188:
    r533 = dank_mids.brownie_patch.call.to_checksum_address :: static
    if is_error(r533) goto L237 else goto L191
L189:
    r534 = raise NameError('value for final name "to_checksum_address" was not set')
    if not r534 goto L219 (error at <module>:260) else goto L190 :: bool
L190:
    unreachable
L191:
    r535 = [r532]
    r536 = load_address r535
    r537 = _PyObject_Vectorcall(r533, r536, 1, 0)
    if is_error(r537) goto L238 (error at <module>:260) else goto L192
L192:
    dec_ref r532
    r538 = PySet_Add(r529, r537)
    dec_ref r529
    dec_ref r537
    r539 = r538 >= 0 :: signed
    if not r539 goto L219 (error at <module>:260) else goto L193 :: bool
L193:
    r540 = dank_mids.brownie_patch.call.globals :: static
    r541 = 'format_input_but_cache_checksums'
    r542 = CPyDict_GetItem(r540, r541)
    if is_error(r542) goto L219 (error at <module>:320) else goto L194
L194:
    r543 = dank_mids.brownie_patch.call.globals :: static
    r544 = 'brownie'
    r545 = CPyDict_GetItem(r543, r544)
    if is_error(r545) goto L239 (error at <module>:320) else goto L195
L195:
    r546 = 'network'
    r547 = CPyObject_GetAttr(r545, r546)
    dec_ref r545
    if is_error(r547) goto L239 (error at <module>:320) else goto L196
L196:
    r548 = 'contract'
    r549 = CPyObject_GetAttr(r547, r548)
    dec_ref r547
    if is_error(r549) goto L239 (error at <module>:320) else goto L197
L197:
    r550 = 'format_input'
    r551 = PyObject_SetAttr(r549, r550, r542)
    dec_ref r549
    dec_ref r542
    r552 = r551 >= 0 :: signed
    if not r552 goto L219 (error at <module>:320) else goto L198 :: bool
L198:
    r553 = dank_mids.brownie_patch.call.globals :: static
    r554 = 'format_output_but_cache_checksums'
    r555 = CPyDict_GetItem(r553, r554)
    if is_error(r555) goto L219 (error at <module>:321) else goto L199
L199:
    r556 = dank_mids.brownie_patch.call.globals :: static
    r557 = 'brownie'
    r558 = CPyDict_GetItem(r556, r557)
    if is_error(r558) goto L240 (error at <module>:321) else goto L200
L200:
    r559 = 'network'
    r560 = CPyObject_GetAttr(r558, r559)
    dec_ref r558
    if is_error(r560) goto L240 (error at <module>:321) else goto L201
L201:
    r561 = 'contract'
    r562 = CPyObject_GetAttr(r560, r561)
    dec_ref r560
    if is_error(r562) goto L240 (error at <module>:321) else goto L202
L202:
    r563 = 'format_output'
    r564 = PyObject_SetAttr(r562, r563, r555)
    dec_ref r562
    dec_ref r555
    r565 = r564 >= 0 :: signed
    if not r565 goto L219 (error at <module>:321) else goto L203 :: bool
L203:
    r566 = dank_mids.brownie_patch.call.globals :: static
    r567 = '_format_array_but_cache_checksums'
    r568 = CPyDict_GetItem(r566, r567)
    if is_error(r568) goto L219 (error at <module>:378) else goto L204
L204:
    r569 = dank_mids.brownie_patch.call.globals :: static
    r570 = 'brownie'
    r571 = CPyDict_GetItem(r569, r570)
    if is_error(r571) goto L241 (error at <module>:378) else goto L205
L205:
    r572 = 'convert'
    r573 = CPyObject_GetAttr(r571, r572)
    dec_ref r571
    if is_error(r573) goto L241 (error at <module>:378) else goto L206
L206:
    r574 = 'normalize'
    r575 = CPyObject_GetAttr(r573, r574)
    dec_ref r573
    if is_error(r575) goto L241 (error at <module>:378) else goto L207
L207:
    r576 = '_format_array'
    r577 = PyObject_SetAttr(r575, r576, r568)
    dec_ref r575
    dec_ref r568
    r578 = r577 >= 0 :: signed
    if not r578 goto L219 (error at <module>:378) else goto L208 :: bool
L208:
    r579 = dank_mids.brownie_patch.call.globals :: static
    r580 = '_format_single_but_cache_checksums'
    r581 = CPyDict_GetItem(r579, r580)
    if is_error(r581) goto L219 (error at <module>:379) else goto L209
L209:
    r582 = dank_mids.brownie_patch.call.globals :: static
    r583 = 'brownie'
    r584 = CPyDict_GetItem(r582, r583)
    if is_error(r584) goto L242 (error at <module>:379) else goto L210
L210:
    r585 = 'convert'
    r586 = CPyObject_GetAttr(r584, r585)
    dec_ref r584
    if is_error(r586) goto L242 (error at <module>:379) else goto L211
L211:
    r587 = 'normalize'
    r588 = CPyObject_GetAttr(r586, r587)
    dec_ref r586
    if is_error(r588) goto L242 (error at <module>:379) else goto L212
L212:
    r589 = '_format_single'
    r590 = PyObject_SetAttr(r588, r589, r581)
    dec_ref r588
    dec_ref r581
    r591 = r590 >= 0 :: signed
    if not r591 goto L219 (error at <module>:379) else goto L213 :: bool
L213:
    r592 = dank_mids.brownie_patch.call.globals :: static
    r593 = '_format_tuple_but_cache_checksums'
    r594 = CPyDict_GetItem(r592, r593)
    if is_error(r594) goto L219 (error at <module>:380) else goto L214
L214:
    r595 = dank_mids.brownie_patch.call.globals :: static
    r596 = 'brownie'
    r597 = CPyDict_GetItem(r595, r596)
    if is_error(r597) goto L243 (error at <module>:380) else goto L215
L215:
    r598 = 'convert'
    r599 = CPyObject_GetAttr(r597, r598)
    dec_ref r597
    if is_error(r599) goto L243 (error at <module>:380) else goto L216
L216:
    r600 = 'normalize'
    r601 = CPyObject_GetAttr(r599, r600)
    dec_ref r599
    if is_error(r601) goto L243 (error at <module>:380) else goto L217
L217:
    r602 = '_format_tuple'
    r603 = PyObject_SetAttr(r601, r602, r594)
    dec_ref r601
    dec_ref r594
    r604 = r603 >= 0 :: signed
    if not r604 goto L219 (error at <module>:380) else goto L218 :: bool
L218:
    return 1
L219:
    r605 = <error> :: None
    return r605
L220:
    dec_ref r129
    goto L219
L221:
    dec_ref r160
    goto L219
L222:
    dec_ref r171
    goto L219
L223:
    dec_ref r171
    dec_ref r174
    goto L219
L224:
    dec_ref r171
    dec_ref r178
    goto L219
L225:
    dec_ref r171
    dec_ref r178
    dec_ref r181
    goto L219
L226:
    dec_ref r199
    goto L219
L227:
    dec_ref r206
    goto L219
L228:
    dec_ref r388
    goto L219
L229:
    dec_ref r420
    goto L219
L230:
    dec_ref r472
    goto L219
L231:
    dec_ref r488
    goto L173
L232:
    dec_ref r488
    goto L175
L233:
    dec_ref r510
    goto L219
L234:
    dec_ref r510
    dec_ref r513
    goto L219
L235:
    dec_ref r518
    goto L219
L236:
    dec_ref r529
    goto L219
L237:
    dec_ref r529
    dec_ref r532
    goto L189
L238:
    dec_ref r529
    dec_ref r532
    goto L219
L239:
    dec_ref r542
    goto L219
L240:
    dec_ref r555
    goto L219
L241:
    dec_ref r568
    goto L219
L242:
    dec_ref r581
    goto L219
L243:
    dec_ref r594
    goto L219

def decode_raw(data):
    data, r0 :: object
    r1 :: bool
    r2 :: object
    r3 :: bool
    r4 :: object[2]
    r5 :: object_ptr
    r6, r7, r8 :: object
    r9 :: bool
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: tuple[object, object, object]
    r14 :: object
    r15 :: bool
    r16 :: bit
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: list
    r21 :: object
    r22 :: i32
    r23 :: bit
    r24 :: tuple
    r25 :: str
    r26 :: i32
    r27, r28 :: bit
    r29 :: object
L0:
L1:
    r0 = dank_mids.helpers._codec.Raw :: static
    if is_error(r0) goto L2 else goto L4
L2:
    r1 = raise NameError('value for final name "Raw" was not set')
    if not r1 goto L13 (error at decode_raw:45) else goto L3 :: bool
L3:
    unreachable
L4:
    r2 = dank_mids.helpers._codec.json_decode :: static
    if is_error(r2) goto L5 else goto L7
L5:
    r3 = raise NameError('value for final name "json_decode" was not set')
    if not r3 goto L13 (error at decode_raw:45) else goto L6 :: bool
L6:
    unreachable
L7:
    r4 = [data, r0]
    r5 = load_address r4
    r6 = ('type',)
    r7 = _PyObject_Vectorcall(r2, r5, 1, r6)
    if is_error(r7) goto L13 (error at decode_raw:45) else goto L8
L8:
    r8 = dank_mids.helpers._codec.RawResponse :: static
    if is_error(r8) goto L30 else goto L11
L9:
    r9 = raise NameError('value for final name "RawResponse" was not set')
    if not r9 goto L13 (error at decode_raw:45) else goto L10 :: bool
L10:
    unreachable
L11:
    r10 = [r7]
    r11 = load_address r10
    r12 = _PyObject_Vectorcall(r8, r11, 1, 0)
    if is_error(r12) goto L31 (error at decode_raw:45) else goto L12
L12:
    dec_ref r7
    return r12
L13:
    r13 = CPy_CatchError()
    r14 = dank_mids.helpers._codec.DecodeError :: static
    if is_error(r14) goto L14 else goto L16
L14:
    r15 = raise NameError('value for final name "DecodeError" was not set')
    if not r15 goto L27 (error at decode_raw:46) else goto L32 :: bool
L15:
    unreachable
L16:
    r16 = CPy_ExceptionMatches(r14)
    if r16 goto L17 else goto L25 :: bool
L17:
    r17 = CPy_GetExcValue()
    r18 = 'args'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L33 (error at decode_raw:47) else goto L18
L18:
    r20 = PyList_New(0)
    if is_error(r20) goto L34 (error at decode_raw:47) else goto L19
L19:
    r21 = CPyList_Extend(r20, r19)
    dec_ref r19
    if is_error(r21) goto L35 (error at decode_raw:47) else goto L36
L20:
    r22 = PyList_Append(r20, data)
    r23 = r22 >= 0 :: signed
    if not r23 goto L35 (error at decode_raw:47) else goto L21 :: bool
L21:
    r24 = PyList_AsTuple(r20)
    dec_ref r20
    if is_error(r24) goto L33 (error at decode_raw:47) else goto L22
L22:
    r25 = 'args'
    r26 = PyObject_SetAttr(r17, r25, r24)
    dec_ref r17
    dec_ref r24
    r27 = r26 >= 0 :: signed
    if not r27 goto L27 (error at decode_raw:47) else goto L23 :: bool
L23:
    CPy_Reraise()
    if not 0 goto L27 else goto L37 :: bool
L24:
    unreachable
L25:
    CPy_Reraise()
    if not 0 goto L27 else goto L38 :: bool
L26:
    unreachable
L27:
    CPy_RestoreExcInfo(r13)
    dec_ref r13
    r28 = CPy_KeepPropagating()
    if not r28 goto L29 else goto L28 :: bool
L28:
    unreachable
L29:
    r29 = <error> :: object
    return r29
L30:
    dec_ref r7
    goto L9
L31:
    dec_ref r7
    goto L13
L32:
    dec_ref r13
    goto L15
L33:
    dec_ref r17
    goto L27
L34:
    dec_ref r17
    dec_ref r19
    goto L27
L35:
    dec_ref r17
    dec_ref r20
    goto L27
L36:
    dec_ref r21
    goto L20
L37:
    dec_ref r13
    goto L24
L38:
    dec_ref r13
    goto L26

def decode_jsonrpc_batch(data):
    data :: object
    r0 :: dict
    r1 :: str
    r2, r3 :: object
    r4 :: bool
    r5 :: object[2]
    r6 :: object_ptr
    r7, r8, r9 :: object
    r10 :: i32
    r11 :: bit
    r12 :: bool
    r13 :: list
    r14 :: ptr
    r15 :: native_int
    r16 :: list
    r17 :: short_int
    r18 :: ptr
    r19 :: native_int
    r20 :: short_int
    r21 :: bit
    r22 :: native_int
    r23, r24 :: ptr
    r25 :: native_int
    r26 :: ptr
    r27, r28 :: object
    r29 :: bool
    r30 :: object[1]
    r31 :: object_ptr
    r32 :: object
    r33 :: bit
    r34 :: short_int
    r35, r36 :: union[list, object]
L0:
    r0 = dank_mids.helpers._codec.globals :: static
    r1 = 'JSONRPCBatchResponseRaw'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L20 (error at decode_jsonrpc_batch:61) else goto L1
L1:
    r3 = dank_mids.helpers._codec.json_decode :: static
    if is_error(r3) goto L21 else goto L4
L2:
    r4 = raise NameError('value for final name "json_decode" was not set')
    if not r4 goto L20 (error at decode_jsonrpc_batch:61) else goto L3 :: bool
L3:
    unreachable
L4:
    r5 = [data, r2]
    r6 = load_address r5
    r7 = ('type',)
    r8 = _PyObject_Vectorcall(r3, r6, 1, r7)
    if is_error(r8) goto L22 (error at decode_jsonrpc_batch:61) else goto L5
L5:
    dec_ref r2
    r9 = load_address PyList_Type
    r10 = PyObject_IsInstance(r8, r9)
    r11 = r10 >= 0 :: signed
    if not r11 goto L23 (error at decode_jsonrpc_batch:62) else goto L6 :: bool
L6:
    r12 = truncate r10: i32 to builtins.bool
    if r12 goto L7 else goto L18 :: bool
L7:
    r13 = cast(list, r8)
    if is_error(r13) goto L20 (error at decode_jsonrpc_batch:62) else goto L8
L8:
    r14 = get_element_ptr r13 ob_size :: PyVarObject
    r15 = load_mem r14 :: native_int*
    r16 = PyList_New(r15)
    if is_error(r16) goto L24 (error at decode_jsonrpc_batch:62) else goto L9
L9:
    r17 = 0
L10:
    r18 = get_element_ptr r13 ob_size :: PyVarObject
    r19 = load_mem r18 :: native_int*
    r20 = r19 << 1
    r21 = r17 < r20 :: signed
    if r21 goto L11 else goto L25 :: bool
L11:
    r22 = r17 >> 1
    r23 = get_element_ptr r13 ob_item :: PyListObject
    r24 = load_mem r23 :: ptr*
    r25 = r22 * 8
    r26 = r24 + r25
    r27 = load_mem r26 :: builtins.object*
    inc_ref r27
    r28 = dank_mids.helpers._codec.RawResponse :: static
    if is_error(r28) goto L26 else goto L14
L12:
    r29 = raise NameError('value for final name "RawResponse" was not set')
    if not r29 goto L20 (error at decode_jsonrpc_batch:62) else goto L13 :: bool
L13:
    unreachable
L14:
    r30 = [r27]
    r31 = load_address r30
    r32 = _PyObject_Vectorcall(r28, r31, 1, 0)
    if is_error(r32) goto L27 (error at decode_jsonrpc_batch:62) else goto L15
L15:
    dec_ref r27
    r33 = CPyList_SetItemUnsafe(r16, r17, r32)
    if not r33 goto L28 (error at decode_jsonrpc_batch:62) else goto L16 :: bool
L16:
    r34 = r17 + 2
    r17 = r34
    goto L10
L17:
    r35 = r16
    goto L19
L18:
    r35 = r8
L19:
    return r35
L20:
    r36 = <error> :: union[object, list]
    return r36
L21:
    dec_ref r2
    goto L2
L22:
    dec_ref r2
    goto L20
L23:
    dec_ref r8
    goto L20
L24:
    dec_ref r13
    goto L20
L25:
    dec_ref r13
    goto L17
L26:
    dec_ref r13
    dec_ref r16
    dec_ref r27
    goto L12
L27:
    dec_ref r13
    dec_ref r16
    dec_ref r27
    goto L20
L28:
    dec_ref r13
    dec_ref r16
    goto L20

def encode(obj):
    obj, r0 :: object
    r1 :: bool
    r2 :: object
    r3 :: bool
    r4 :: object[2]
    r5 :: object_ptr
    r6, r7 :: object
    r8, r9 :: bytes
L0:
    r0 = dank_mids.helpers._codec._encode_hook :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_encode_hook" was not set')
    if not r1 goto L9 (error at encode:80) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = dank_mids.helpers._codec.json_encode :: static
    if is_error(r2) goto L4 else goto L6
L4:
    r3 = raise NameError('value for final name "json_encode" was not set')
    if not r3 goto L9 (error at encode:80) else goto L5 :: bool
L5:
    unreachable
L6:
    r4 = [obj, r0]
    r5 = load_address r4
    r6 = ('enc_hook',)
    r7 = _PyObject_Vectorcall(r2, r5, 1, r6)
    if is_error(r7) goto L9 (error at encode:80) else goto L7
L7:
    r8 = cast(bytes, r7)
    if is_error(r8) goto L9 (error at encode:80) else goto L8
L8:
    return r8
L9:
    r9 = <error> :: bytes
    return r9

def __mypyc_lambda__0_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__0_obj.__call__(__mypyc_self__, _):
    __mypyc_self__ :: dank_mids.helpers._codec.__mypyc_lambda__0_obj
    _, r0 :: object
L0:
    r0 = load_address _Py_EllipsisObject
    inc_ref r0
    return r0

def __encode_new(values):
    values :: object
    r0 :: tuple[bytes, int]
    r1, r2 :: bytes
    r3, r4 :: int
    r5 :: object
    r6 :: bool
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10, r11 :: object
    r12, r13 :: bytes
L0:
    r0 = __encode_elements_new(values)
    if is_error(r0) goto L8 (error at __encode_new:96) else goto L1
L1:
    r1 = borrow r0[0]
    r2 = unborrow r1
    r3 = borrow r0[1]
    r4 = unborrow r3
    r5 = dank_mids.helpers._codec.encode_uint_256 :: static
    if is_error(r5) goto L9 else goto L4
L2:
    r6 = raise NameError('value for final name "encode_uint_256" was not set')
    if not r6 goto L8 (error at __encode_new:97) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = box(int, r4)
    r8 = [r7]
    r9 = load_address r8
    r10 = _PyObject_Vectorcall(r5, r9, 1, 0)
    if is_error(r10) goto L10 (error at __encode_new:97) else goto L5
L5:
    dec_ref r7
    r11 = PyNumber_Add(r10, r2)
    dec_ref r10
    dec_ref r2
    if is_error(r11) goto L8 (error at __encode_new:97) else goto L6
L6:
    r12 = cast(bytes, r11)
    if is_error(r12) goto L8 (error at __encode_new:97) else goto L7
L7:
    return r12
L8:
    r13 = <error> :: bytes
    return r13
L9:
    dec_ref r2
    dec_ref r4 :: int
    goto L2
L10:
    dec_ref r2
    dec_ref r7
    goto L8

def __encode_elements_new(values):
    values :: object
    r0 :: list
    r1, r2 :: object
    r3 :: tuple[object, object]
    r4 :: object
    r5 :: bool
    r6 :: object
    r7 :: object[1]
    r8 :: object_ptr
    r9 :: object
    r10 :: i32
    r11, r12 :: bit
    r13 :: ptr
    r14 :: native_int
    r15 :: short_int
    count, r16 :: int
    r17 :: tuple[int]
    r18 :: object
    r19 :: list
    r20 :: ptr
    r21 :: native_int
    r22 :: list
    r23 :: short_int
    r24 :: ptr
    r25 :: native_int
    r26 :: short_int
    r27 :: bit
    r28 :: native_int
    r29, r30 :: ptr
    r31 :: native_int
    r32 :: ptr
    r33 :: object
    r34 :: int
    r35 :: object
    r36 :: bit
    r37 :: short_int
    r38 :: object
    r39 :: dict
    r40 :: str
    r41 :: object
    r42 :: object[1]
    r43 :: object_ptr
    r44 :: object
    r45 :: dict
    r46 :: str
    r47, r48 :: object
    r49 :: object[2]
    r50 :: object_ptr
    r51 :: object
    r52 :: list
    r53, r54 :: object
    r55, r56 :: int
    r57 :: object
    r58 :: bool
    r59 :: object
    r60 :: object[1]
    r61 :: object_ptr
    r62 :: object
    r63 :: i32
    r64, r65 :: bit
    r66 :: object
    r67 :: bytes
    r68 :: dict
    r69 :: str
    r70 :: object
    r71 :: object[2]
    r72 :: object_ptr
    r73 :: object
    r74 :: bytes
    r75, r76 :: tuple[bytes, int]
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L38 (error at __encode_elements_new:101) else goto L1
L1:
    r1 = PyObject_GetIter(values)
    if is_error(r1) goto L39 (error at __encode_elements_new:101) else goto L2
L2:
    r2 = PyIter_Next(r1)
    if is_error(r2) goto L40 else goto L3
L3:
    r3 = unbox(tuple[object, object], r2)
    dec_ref r2
    if is_error(r3) goto L41 (error at __encode_elements_new:101) else goto L4
L4:
    r4 = dank_mids.helpers._codec._item_encoder :: static
    if is_error(r4) goto L42 else goto L7
L5:
    r5 = raise NameError('value for final name "_item_encoder" was not set')
    if not r5 goto L38 (error at __encode_elements_new:101) else goto L6 :: bool
L6:
    unreachable
L7:
    r6 = box(tuple[object, object], r3)
    r7 = [r6]
    r8 = load_address r7
    r9 = _PyObject_Vectorcall(r4, r8, 1, 0)
    if is_error(r9) goto L43 (error at __encode_elements_new:101) else goto L8
L8:
    dec_ref r6
    r10 = PyList_Append(r0, r9)
    dec_ref r9
    r11 = r10 >= 0 :: signed
    if not r11 goto L41 (error at __encode_elements_new:101) else goto L2 :: bool
L9:
    r12 = CPy_NoErrOccurred()
    if not r12 goto L39 (error at __encode_elements_new:101) else goto L10 :: bool
L10:
    r13 = get_element_ptr r0 ob_size :: PyVarObject
    r14 = load_mem r13 :: native_int*
    r15 = r14 << 1
    count = r15
    r16 = CPyTagged_Multiply(64, count)
    r17 = (0)
    r18 = CPyList_GetSlice(r0, 0, -2)
    if is_error(r18) goto L44 (error at __encode_elements_new:104) else goto L11
L11:
    r19 = cast(list, r18)
    if is_error(r19) goto L44 (error at __encode_elements_new:104) else goto L12
L12:
    r20 = get_element_ptr r19 ob_size :: PyVarObject
    r21 = load_mem r20 :: native_int*
    r22 = PyList_New(r21)
    if is_error(r22) goto L45 (error at __encode_elements_new:104) else goto L13
L13:
    r23 = 0
L14:
    r24 = get_element_ptr r19 ob_size :: PyVarObject
    r25 = load_mem r24 :: native_int*
    r26 = r25 << 1
    r27 = r23 < r26 :: signed
    if r27 goto L15 else goto L46 :: bool
L15:
    r28 = r23 >> 1
    r29 = get_element_ptr r19 ob_item :: PyListObject
    r30 = load_mem r29 :: ptr*
    r31 = r28 * 8
    r32 = r30 + r31
    r33 = load_mem r32 :: builtins.object*
    inc_ref r33
    r34 = CPyObject_Size(r33)
    dec_ref r33
    if is_error(r34) goto L47 (error at __encode_elements_new:104) else goto L16
L16:
    r35 = box(int, r34)
    r36 = CPyList_SetItemUnsafe(r22, r23, r35)
    if not r36 goto L47 (error at __encode_elements_new:104) else goto L17 :: bool
L17:
    r37 = r23 + 2
    r23 = r37
    goto L14
L18:
    r38 = PyObject_GetIter(r22)
    dec_ref r22
    if is_error(r38) goto L44 (error at __encode_elements_new:104) else goto L19
L19:
    r39 = dank_mids.helpers._codec.globals :: static
    r40 = 'accumulate'
    r41 = CPyDict_GetItem(r39, r40)
    if is_error(r41) goto L48 (error at __encode_elements_new:104) else goto L20
L20:
    r42 = [r38]
    r43 = load_address r42
    r44 = _PyObject_Vectorcall(r41, r43, 1, 0)
    dec_ref r41
    if is_error(r44) goto L48 (error at __encode_elements_new:104) else goto L21
L21:
    dec_ref r38
    r45 = dank_mids.helpers._codec.globals :: static
    r46 = 'chain'
    r47 = CPyDict_GetItem(r45, r46)
    if is_error(r47) goto L49 (error at __encode_elements_new:104) else goto L22
L22:
    r48 = box(tuple[int], r17)
    r49 = [r48, r44]
    r50 = load_address r49
    r51 = _PyObject_Vectorcall(r47, r50, 2, 0)
    dec_ref r47
    if is_error(r51) goto L50 (error at __encode_elements_new:104) else goto L23
L23:
    dec_ref r48
    dec_ref r44
    r52 = PyList_New(0)
    if is_error(r52) goto L51 (error at __encode_elements_new:105) else goto L24
L24:
    r53 = PyObject_GetIter(r51)
    dec_ref r51
    if is_error(r53) goto L52 (error at __encode_elements_new:105) else goto L25
L25:
    r54 = PyIter_Next(r53)
    if is_error(r54) goto L53 else goto L26
L26:
    r55 = unbox(int, r54)
    dec_ref r54
    if is_error(r55) goto L54 (error at __encode_elements_new:105) else goto L27
L27:
    r56 = CPyTagged_Add(r16, r55)
    dec_ref r55 :: int
    r57 = dank_mids.helpers._codec.encode_uint_256 :: static
    if is_error(r57) goto L55 else goto L30
L28:
    r58 = raise NameError('value for final name "encode_uint_256" was not set')
    if not r58 goto L38 (error at __encode_elements_new:105) else goto L29 :: bool
L29:
    unreachable
L30:
    r59 = box(int, r56)
    r60 = [r59]
    r61 = load_address r60
    r62 = _PyObject_Vectorcall(r57, r61, 1, 0)
    if is_error(r62) goto L56 (error at __encode_elements_new:105) else goto L31
L31:
    dec_ref r59
    r63 = PyList_Append(r52, r62)
    dec_ref r62
    r64 = r63 >= 0 :: signed
    if not r64 goto L54 (error at __encode_elements_new:105) else goto L25 :: bool
L32:
    r65 = CPy_NoErrOccurred()
    if not r65 goto L57 (error at __encode_elements_new:105) else goto L33 :: bool
L33:
    r66 = PyObject_GetIter(r52)
    dec_ref r52
    if is_error(r66) goto L58 (error at __encode_elements_new:105) else goto L34
L34:
    r67 = b''
    r68 = dank_mids.helpers._codec.globals :: static
    r69 = 'chain'
    r70 = CPyDict_GetItem(r68, r69)
    if is_error(r70) goto L59 (error at __encode_elements_new:106) else goto L35
L35:
    r71 = [r66, r0]
    r72 = load_address r71
    r73 = _PyObject_Vectorcall(r70, r72, 2, 0)
    dec_ref r70
    if is_error(r73) goto L59 (error at __encode_elements_new:106) else goto L36
L36:
    dec_ref r66
    dec_ref r0
    r74 = CPyBytes_Join(r67, r73)
    dec_ref r73
    if is_error(r74) goto L60 (error at __encode_elements_new:106) else goto L37
L37:
    r75 = (r74, count)
    return r75
L38:
    r76 = <error> :: tuple[bytes, int]
    return r76
L39:
    dec_ref r0
    goto L38
L40:
    dec_ref r1
    goto L9
L41:
    dec_ref r0
    dec_ref r1
    goto L38
L42:
    dec_ref r0
    dec_ref r1
    dec_ref r3
    goto L5
L43:
    dec_ref r0
    dec_ref r1
    dec_ref r6
    goto L38
L44:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r17
    goto L38
L45:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r17
    dec_ref r19
    goto L38
L46:
    dec_ref r19
    goto L18
L47:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r17
    dec_ref r19
    dec_ref r22
    goto L38
L48:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r17
    dec_ref r38
    goto L38
L49:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r17
    dec_ref r44
    goto L38
L50:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r44
    dec_ref r48
    goto L38
L51:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r51
    goto L38
L52:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r52
    goto L38
L53:
    dec_ref r16 :: int
    dec_ref r53
    goto L32
L54:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r52
    dec_ref r53
    goto L38
L55:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r52
    dec_ref r53
    dec_ref r56 :: int
    goto L28
L56:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r52
    dec_ref r53
    dec_ref r59
    goto L38
L57:
    dec_ref r0
    dec_ref count :: int
    dec_ref r52
    goto L38
L58:
    dec_ref r0
    dec_ref count :: int
    goto L38
L59:
    dec_ref r0
    dec_ref count :: int
    dec_ref r66
    goto L38
L60:
    dec_ref count :: int
    goto L38

def mcall_encode(data):
    data :: object
    r0 :: tuple[bool, object]
    r1 :: object
    r2 :: bool
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7, r8 :: bytes
L0:
    inc_ref data
    r0 = (0, data)
    r1 = dank_mids.helpers._codec._mcall_encoder :: static
    if is_error(r1) goto L7 else goto L3
L1:
    r2 = raise NameError('value for final name "_mcall_encoder" was not set')
    if not r2 goto L6 (error at mcall_encode:119) else goto L2 :: bool
L2:
    unreachable
L3:
    r3 = box(tuple[bool, object], r0)
    r4 = [r3]
    r5 = load_address r4
    r6 = _PyObject_Vectorcall(r1, r5, 1, 0)
    if is_error(r6) goto L8 (error at mcall_encode:119) else goto L4
L4:
    dec_ref r3
    r7 = cast(bytes, r6)
    if is_error(r7) goto L6 (error at mcall_encode:119) else goto L5
L5:
    return r7
L6:
    r8 = <error> :: bytes
    return r8
L7:
    dec_ref r0
    goto L1
L8:
    dec_ref r3
    goto L6

def mcall_decode(data):
    data :: object
    r0, r1 :: str
    r2 :: object[2]
    r3 :: object_ptr
    r4, r5 :: object
    r6 :: bool
    r7 :: object[1]
    r8 :: object_ptr
    r9, r10 :: object
    r11 :: bool
    r12 :: object[1]
    r13 :: object_ptr
    r14 :: object
    r15 :: tuple[int, int, tuple]
    r16 :: tuple
    r17 :: tuple[object, object, object]
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: bit
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: tuple
    r26 :: dict
    r27 :: str
    r28 :: object
    r29 :: i32
    r30 :: bit
    r31 :: bool
    r32 :: str
    r33 :: object[1]
    r34 :: object_ptr
    r35, r36 :: object
    r37 :: list
    r38 :: object
    r39 :: i32
    r40 :: bit
    r41 :: tuple
    r42 :: str
    r43 :: i32
    r44, r45 :: bit
    r46 :: ptr
    r47 :: native_int
    r48 :: list
    r49 :: short_int
    r50 :: ptr
    r51 :: native_int
    r52 :: short_int
    r53 :: bit
    r54 :: object
    r55 :: tuple[bool, bytes]
    r56 :: bytes
    r57 :: bit
    r58 :: short_int
    r59 :: union[list, object]
L0:
L1:
    r0 = 'eth_call'
    r1 = 'decode_result'
    r2 = [data, r0]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775810, 0)
    if is_error(r4) goto L12 (error at mcall_decode:128) else goto L2
L2:
    r5 = dank_mids.helpers._codec.ContextFramesBytesIO :: static
    if is_error(r5) goto L41 else goto L5
L3:
    r6 = raise NameError('value for final name "ContextFramesBytesIO" was not set')
    if not r6 goto L12 (error at mcall_decode:128) else goto L4 :: bool
L4:
    unreachable
L5:
    r7 = [r4]
    r8 = load_address r7
    r9 = _PyObject_Vectorcall(r5, r8, 1, 0)
    if is_error(r9) goto L42 (error at mcall_decode:128) else goto L6
L6:
    dec_ref r4
    r10 = dank_mids.helpers._codec._mcall_decoder :: static
    if is_error(r10) goto L43 else goto L9
L7:
    r11 = raise NameError('value for final name "_mcall_decoder" was not set')
    if not r11 goto L12 (error at mcall_decode:128) else goto L8 :: bool
L8:
    unreachable
L9:
    r12 = [r9]
    r13 = load_address r12
    r14 = _PyObject_Vectorcall(r10, r13, 1, 0)
    if is_error(r14) goto L44 (error at mcall_decode:128) else goto L10
L10:
    dec_ref r9
    r15 = unbox(tuple[int, int, tuple], r14)
    dec_ref r14
    if is_error(r15) goto L12 (error at mcall_decode:128) else goto L11
L11:
    r16 = r15[2]
    dec_ref r15
    goto L32
L12:
    r17 = CPy_CatchError()
    r18 = builtins :: module
    r19 = 'Exception'
    r20 = CPyObject_GetAttr(r18, r19)
    if is_error(r20) goto L30 (error at mcall_decode:129) else goto L13
L13:
    r21 = CPy_ExceptionMatches(r20)
    dec_ref r20
    if r21 goto L14 else goto L28 :: bool
L14:
    r22 = CPy_GetExcValue()
    r23 = 'args'
    r24 = CPyObject_GetAttr(r22, r23)
    if is_error(r24) goto L45 (error at mcall_decode:131) else goto L15
L15:
    r25 = cast(tuple, r24)
    if is_error(r25) goto L45 (error at mcall_decode:131) else goto L16
L16:
    r26 = dank_mids.helpers._codec.globals :: static
    r27 = 'PartialResponse'
    r28 = CPyDict_GetItem(r26, r27)
    if is_error(r28) goto L46 (error at mcall_decode:131) else goto L17
L17:
    r29 = PyObject_IsInstance(data, r28)
    dec_ref r28
    r30 = r29 >= 0 :: signed
    if not r30 goto L46 (error at mcall_decode:131) else goto L18 :: bool
L18:
    r31 = truncate r29: i32 to builtins.bool
    if r31 goto L19 else goto L21 :: bool
L19:
    r32 = 'decode_result'
    r33 = [data]
    r34 = load_address r33
    r35 = PyObject_VectorcallMethod(r32, r34, 9223372036854775809, 0)
    if is_error(r35) goto L46 (error at mcall_decode:131) else goto L20
L20:
    r36 = r35
    goto L22
L21:
    inc_ref data
    r36 = data
L22:
    r37 = PyList_New(0)
    if is_error(r37) goto L47 (error at mcall_decode:131) else goto L23
L23:
    r38 = CPyList_Extend(r37, r25)
    dec_ref r25
    if is_error(r38) goto L48 (error at mcall_decode:131) else goto L49
L24:
    r39 = PyList_Append(r37, r36)
    dec_ref r36
    r40 = r39 >= 0 :: signed
    if not r40 goto L50 (error at mcall_decode:131) else goto L25 :: bool
L25:
    r41 = PyList_AsTuple(r37)
    dec_ref r37
    if is_error(r41) goto L45 (error at mcall_decode:131) else goto L26
L26:
    r42 = 'args'
    r43 = PyObject_SetAttr(r22, r42, r41)
    dec_ref r41
    r44 = r43 >= 0 :: signed
    if not r44 goto L45 (error at mcall_decode:131) else goto L27 :: bool
L27:
    CPy_RestoreExcInfo(r17)
    dec_ref r17
    return r22
L28:
    CPy_Reraise()
    if not 0 goto L30 else goto L51 :: bool
L29:
    unreachable
L30:
    CPy_RestoreExcInfo(r17)
    dec_ref r17
    r45 = CPy_KeepPropagating()
    if not r45 goto L40 else goto L31 :: bool
L31:
    unreachable
L32:
    r46 = get_element_ptr r16 ob_size :: PyVarObject
    r47 = load_mem r46 :: native_int*
    r48 = PyList_New(r47)
    if is_error(r48) goto L52 (error at mcall_decode:134) else goto L33
L33:
    r49 = 0
L34:
    r50 = get_element_ptr r16 ob_size :: PyVarObject
    r51 = load_mem r50 :: native_int*
    r52 = r51 << 1
    r53 = r49 < r52 :: signed
    if r53 goto L35 else goto L53 :: bool
L35:
    r54 = CPySequenceTuple_GetItem(r16, r49)
    if is_error(r54) goto L54 (error at mcall_decode:134) else goto L36
L36:
    r55 = unbox(tuple[bool, bytes], r54)
    dec_ref r54
    if is_error(r55) goto L54 (error at mcall_decode:134) else goto L37
L37:
    r56 = r55[1]
    dec_ref r55
    r57 = CPyList_SetItemUnsafe(r48, r49, r56)
    if not r57 goto L54 (error at mcall_decode:134) else goto L38 :: bool
L38:
    r58 = r49 + 2
    r49 = r58
    goto L34
L39:
    return r48
L40:
    r59 = <error> :: union[list, object]
    return r59
L41:
    dec_ref r4
    goto L3
L42:
    dec_ref r4
    goto L12
L43:
    dec_ref r9
    goto L7
L44:
    dec_ref r9
    goto L12
L45:
    dec_ref r22
    goto L30
L46:
    dec_ref r22
    dec_ref r25
    goto L30
L47:
    dec_ref r22
    dec_ref r25
    dec_ref r36
    goto L30
L48:
    dec_ref r22
    dec_ref r36
    dec_ref r37
    goto L30
L49:
    dec_ref r38
    goto L24
L50:
    dec_ref r22
    dec_ref r37
    goto L30
L51:
    dec_ref r17
    goto L29
L52:
    dec_ref r16
    goto L40
L53:
    dec_ref r16
    goto L39
L54:
    dec_ref r16
    dec_ref r48
    goto L40

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13, r14 :: object_ptr
    r15 :: object_ptr[2]
    r16 :: c_ptr
    r17 :: native_int[2]
    r18 :: c_ptr
    r19 :: object
    r20 :: dict
    r21, r22 :: str
    r23 :: bit
    r24 :: object
    r25 :: str
    r26 :: dict
    r27, r28 :: object
    r29 :: str
    r30 :: dict
    r31, r32 :: object
    r33 :: str
    r34 :: dict
    r35, r36 :: object
    r37 :: str
    r38 :: dict
    r39, r40 :: object
    r41 :: str
    r42 :: dict
    r43 :: object
    r44 :: str
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: object[1]
    r49 :: object_ptr
    r50 :: object
    r51 :: dict
    r52 :: str
    r53 :: i32
    r54 :: bit
    r55 :: dict
    r56 :: str
    r57 :: object
    r58 :: dict
    r59 :: str
    r60, r61 :: object
    r62 :: dict
    r63 :: str
    r64 :: object
    r65 :: dict
    r66 :: str
    r67, r68 :: object
    r69 :: tuple[object, object]
    r70, r71 :: object
    r72 :: list
    r73, r74 :: ptr
    r75 :: object
    r76 :: tuple[list, object]
    r77, r78 :: object
    r79 :: dict
    r80 :: str
    r81 :: i32
    r82 :: bit
    r83 :: dict
    r84 :: str
    r85, r86, r87 :: object
    r88 :: dict
    r89 :: str
    r90 :: object
    r91 :: dict
    r92 :: str
    r93 :: object
    r94 :: str
    r95 :: object
    r96 :: tuple[str, object]
    r97, r98, r99 :: object
    r100 :: tuple[object, object]
    r101, r102 :: object
    r103 :: tuple[object, object, object]
    r104, r105 :: object
    r106 :: dict
    r107 :: str
    r108 :: i32
    r109 :: bit
    r110 :: dict
    r111 :: str
    r112, r113 :: object
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: tuple[object, object]
    r118, r119 :: object
    r120 :: dict
    r121 :: str
    r122 :: i32
    r123 :: bit
    r124 :: dict
    r125 :: str
    r126 :: object
    r127 :: str
    r128 :: object
    r129 :: dict
    r130 :: str
    r131 :: i32
    r132 :: bit
    r133 :: object
    r134 :: str
    r135 :: object
    r136 :: dict
    r137 :: str
    r138 :: i32
    r139 :: bit
    r140 :: dict
    r141 :: str
    r142 :: object
    r143 :: str
    r144 :: object
    r145 :: dict
    r146 :: str
    r147 :: i32
    r148 :: bit
    r149 :: dict
    r150 :: str
    r151 :: object
    r152 :: str
    r153 :: object
    r154 :: dict
    r155 :: str
    r156 :: i32
    r157 :: bit
    r158 :: dict
    r159 :: str
    r160 :: object
    r161 :: str
    r162 :: object
    r163 :: str
    r164 :: object
    r165 :: dict
    r166 :: str
    r167 :: i32
    r168 :: bit
    r169 :: dict
    r170 :: str
    r171 :: object
    r172 :: str
    r173 :: object
    r174 :: str
    r175 :: object
    r176 :: dict
    r177 :: str
    r178 :: i32
    r179 :: bit
    r180 :: dict
    r181 :: str
    r182 :: object
    r183 :: str
    r184 :: object
    r185 :: dict
    r186 :: str
    r187 :: i32
    r188 :: bit
    r189 :: object
    r190 :: str
    r191 :: object
    r192 :: dict
    r193 :: str
    r194 :: i32
    r195 :: bit
    r196 :: dict
    r197 :: str
    r198 :: object
    r199 :: str
    r200 :: object
    r201, r202 :: str
    r203 :: object[2]
    r204 :: object_ptr
    r205 :: object
    r206 :: dict
    r207 :: str
    r208 :: i32
    r209 :: bit
    r210 :: object
    r211 :: bool
    r212 :: str
    r213, r214, r215 :: object
    r216 :: dict
    r217 :: str
    r218 :: i32
    r219 :: bit
    r220 :: object
    r221 :: bool
    r222 :: str
    r223 :: object
    r224 :: dict
    r225 :: str
    r226 :: i32
    r227 :: bit
    r228 :: dank_mids.helpers._codec.__mypyc_lambda__0_obj
    r229 :: object
    r230 :: bool
    r231 :: str
    r232 :: i32
    r233 :: bit
    r234 :: object
    r235 :: bool
    r236 :: str
    r237 :: i32
    r238 :: bit
    r239 :: object
    r240 :: bool
    r241 :: str
    r242 :: i32
    r243 :: bit
    r244 :: dict
    r245 :: str
    r246, r247 :: object
    r248 :: bool
    r249 :: str
    r250 :: i32
    r251 :: bit
    r252 :: dict
    r253 :: str
    r254, r255 :: object
    r256 :: bool
    r257 :: str
    r258 :: i32
    r259 :: bit
    r260 :: dict
    r261 :: str
    r262 :: object
    r263 :: str
    r264 :: object
    r265, r266 :: str
    r267 :: object[2]
    r268 :: object_ptr
    r269 :: object
    r270 :: str
    r271 :: object
    r272 :: dict
    r273 :: str
    r274 :: i32
    r275 :: bit
    r276 :: object
    r277 :: dict
    r278 :: str
    r279 :: i32
    r280 :: bit
    r281 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L103 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('accumulate', 'chain')
    r6 = 'itertools'
    r7 = dank_mids.helpers._codec.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L103 (error at <module>:1) else goto L4
L4:
    itertools = r8 :: module
    dec_ref r8
    r9 = ('Any', 'AnyStr', 'Callable', 'Final', 'Iterable', 'List', 'Union', 'Tuple', 'TypeVar')
    r10 = 'typing'
    r11 = dank_mids.helpers._codec.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L103 (error at <module>:2) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = load_address msgspec :: module
    r14 = load_address msgspec.json :: module
    r15 = [r13, r14]
    r16 = load_address r15
    r17 = [4, 5]
    r18 = load_address r17
    r19 = (('msgspec', 'msgspec', 'msgspec'), ('msgspec.json', 'msgspec', 'msgspec'))
    r20 = dank_mids.helpers._codec.globals :: static
    r21 = 'dank_mids/helpers/_codec.py'
    r22 = '<module>'
    r23 = CPyImport_ImportMany(r19, r16, r20, r21, r22, r18)
    if not r23 goto L103 else goto L6 :: bool
L6:
    r24 = ('decoding', 'encoding')
    r25 = 'eth_abi'
    r26 = dank_mids.helpers._codec.globals :: static
    r27 = CPyImport_ImportFromMany(r25, r24, r24, r26)
    if is_error(r27) goto L103 (error at <module>:6) else goto L7
L7:
    eth_abi = r27 :: module
    dec_ref r27
    r28 = ('default_codec',)
    r29 = 'eth_abi.abi'
    r30 = dank_mids.helpers._codec.globals :: static
    r31 = CPyImport_ImportFromMany(r29, r28, r28, r30)
    if is_error(r31) goto L103 (error at <module>:7) else goto L8
L8:
    eth_abi.abi = r31 :: module
    dec_ref r31
    r32 = ('DynamicArrayEncoder', 'TupleEncoder')
    r33 = 'eth_abi.encoding'
    r34 = dank_mids.helpers._codec.globals :: static
    r35 = CPyImport_ImportFromMany(r33, r32, r32, r34)
    if is_error(r35) goto L103 (error at <module>:8) else goto L9
L9:
    eth_abi.encoding = r35 :: module
    dec_ref r35
    r36 = ('types',)
    r37 = 'dank_mids'
    r38 = dank_mids.helpers._codec.globals :: static
    r39 = CPyImport_ImportFromMany(r37, r36, r36, r38)
    if is_error(r39) goto L103 (error at <module>:10) else goto L10
L10:
    dank_mids = r39 :: module
    dec_ref r39
    r40 = ('JSONRPCBatchResponseRaw', 'MulticallChunk', 'PartialResponse')
    r41 = 'dank_mids.types'
    r42 = dank_mids.helpers._codec.globals :: static
    r43 = CPyImport_ImportFromMany(r41, r40, r40, r42)
    if is_error(r43) goto L103 (error at <module>:11) else goto L11
L11:
    dank_mids.types = r43 :: module
    dec_ref r43
    r44 = '__T'
    r45 = dank_mids.helpers._codec.globals :: static
    r46 = 'TypeVar'
    r47 = CPyDict_GetItem(r45, r46)
    if is_error(r47) goto L103 (error at <module>:14) else goto L12
L12:
    r48 = [r44]
    r49 = load_address r48
    r50 = _PyObject_Vectorcall(r47, r49, 1, 0)
    dec_ref r47
    if is_error(r50) goto L103 (error at <module>:14) else goto L13
L13:
    r51 = dank_mids.helpers._codec.globals :: static
    r52 = '__T'
    r53 = CPyDict_SetItem(r51, r52, r50)
    dec_ref r50
    r54 = r53 >= 0 :: signed
    if not r54 goto L103 (error at <module>:14) else goto L14 :: bool
L14:
    r55 = dank_mids.helpers._codec.globals :: static
    r56 = 'Callable'
    r57 = CPyDict_GetItem(r55, r56)
    if is_error(r57) goto L103 (error at <module>:16) else goto L15
L15:
    r58 = dank_mids.helpers._codec.globals :: static
    r59 = 'Tuple'
    r60 = CPyDict_GetItem(r58, r59)
    if is_error(r60) goto L104 (error at <module>:16) else goto L16
L16:
    r61 = load_address PyBool_Type
    r62 = dank_mids.helpers._codec.globals :: static
    r63 = 'Iterable'
    r64 = CPyDict_GetItem(r62, r63)
    if is_error(r64) goto L105 (error at <module>:16) else goto L17
L17:
    r65 = dank_mids.helpers._codec.globals :: static
    r66 = 'MulticallChunk'
    r67 = CPyDict_GetItem(r65, r66)
    if is_error(r67) goto L106 (error at <module>:16) else goto L18
L18:
    r68 = PyObject_GetItem(r64, r67)
    dec_ref r64
    dec_ref r67
    if is_error(r68) goto L105 (error at <module>:16) else goto L19
L19:
    inc_ref r61
    r69 = (r61, r68)
    r70 = box(tuple[object, object], r69)
    r71 = PyObject_GetItem(r60, r70)
    dec_ref r60
    dec_ref r70
    if is_error(r71) goto L104 (error at <module>:16) else goto L20
L20:
    r72 = PyList_New(1)
    if is_error(r72) goto L107 (error at <module>:16) else goto L21
L21:
    r73 = get_element_ptr r72 ob_item :: PyListObject
    r74 = load_mem r73 :: ptr*
    set_mem r74, r71 :: builtins.object*
    r75 = load_address PyBytes_Type
    inc_ref r75
    r76 = (r72, r75)
    r77 = box(tuple[list, object], r76)
    r78 = PyObject_GetItem(r57, r77)
    dec_ref r57
    dec_ref r77
    if is_error(r78) goto L103 (error at <module>:16) else goto L22
L22:
    r79 = dank_mids.helpers._codec.globals :: static
    r80 = 'MulticallEncoder'
    r81 = CPyDict_SetItem(r79, r80, r78)
    dec_ref r78
    r82 = r81 >= 0 :: signed
    if not r82 goto L103 (error at <module>:16) else goto L23 :: bool
L23:
    r83 = dank_mids.helpers._codec.globals :: static
    r84 = 'Tuple'
    r85 = CPyDict_GetItem(r83, r84)
    if is_error(r85) goto L103 (error at <module>:18) else goto L24
L24:
    r86 = load_address PyLong_Type
    r87 = load_address PyLong_Type
    r88 = dank_mids.helpers._codec.globals :: static
    r89 = 'Tuple'
    r90 = CPyDict_GetItem(r88, r89)
    if is_error(r90) goto L108 (error at <module>:18) else goto L25
L25:
    r91 = dank_mids.helpers._codec.globals :: static
    r92 = 'Tuple'
    r93 = CPyDict_GetItem(r91, r92)
    if is_error(r93) goto L109 (error at <module>:18) else goto L26
L26:
    r94 = 'Success'
    r95 = load_address PyBytes_Type
    inc_ref r94
    inc_ref r95
    r96 = (r94, r95)
    r97 = box(tuple[str, object], r96)
    r98 = PyObject_GetItem(r93, r97)
    dec_ref r93
    dec_ref r97
    if is_error(r98) goto L109 (error at <module>:18) else goto L27
L27:
    r99 = load_address _Py_EllipsisObject
    inc_ref r99
    r100 = (r98, r99)
    r101 = box(tuple[object, object], r100)
    r102 = PyObject_GetItem(r90, r101)
    dec_ref r90
    dec_ref r101
    if is_error(r102) goto L108 (error at <module>:18) else goto L28
L28:
    inc_ref r86
    inc_ref r87
    r103 = (r86, r87, r102)
    r104 = box(tuple[object, object, object], r103)
    r105 = PyObject_GetItem(r85, r104)
    dec_ref r85
    dec_ref r104
    if is_error(r105) goto L103 (error at <module>:18) else goto L29
L29:
    r106 = dank_mids.helpers._codec.globals :: static
    r107 = 'DecodedMulticall'
    r108 = CPyDict_SetItem(r106, r107, r105)
    dec_ref r105
    r109 = r108 >= 0 :: signed
    if not r109 goto L103 (error at <module>:18) else goto L30 :: bool
L30:
    r110 = dank_mids.helpers._codec.globals :: static
    r111 = 'Callable'
    r112 = CPyDict_GetItem(r110, r111)
    if is_error(r112) goto L103 (error at <module>:19) else goto L31
L31:
    r113 = load_address _Py_EllipsisObject
    r114 = dank_mids.helpers._codec.globals :: static
    r115 = 'DecodedMulticall'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L110 (error at <module>:19) else goto L32
L32:
    inc_ref r113
    r117 = (r113, r116)
    r118 = box(tuple[object, object], r117)
    r119 = PyObject_GetItem(r112, r118)
    dec_ref r112
    dec_ref r118
    if is_error(r119) goto L103 (error at <module>:19) else goto L33
L33:
    r120 = dank_mids.helpers._codec.globals :: static
    r121 = 'MulticallDecoder'
    r122 = CPyDict_SetItem(r120, r121, r119)
    dec_ref r119
    r123 = r122 >= 0 :: signed
    if not r123 goto L103 (error at <module>:19) else goto L34 :: bool
L34:
    r124 = dank_mids.helpers._codec.globals :: static
    r125 = 'msgspec'
    r126 = CPyDict_GetItem(r124, r125)
    if is_error(r126) goto L103 (error at <module>:23) else goto L35
L35:
    r127 = 'Raw'
    r128 = CPyObject_GetAttr(r126, r127)
    dec_ref r126
    if is_error(r128) goto L103 (error at <module>:23) else goto L36
L36:
    dank_mids.helpers._codec.Raw = r128 :: static
    r129 = dank_mids.helpers._codec.globals :: static
    r130 = 'Raw'
    r131 = CPyDict_SetItem(r129, r130, r128)
    dec_ref r128
    r132 = r131 >= 0 :: signed
    if not r132 goto L103 (error at <module>:23) else goto L37 :: bool
L37:
    r133 = dank_mids.types :: module
    r134 = 'RawResponse'
    r135 = CPyObject_GetAttr(r133, r134)
    if is_error(r135) goto L103 (error at <module>:24) else goto L38
L38:
    dank_mids.helpers._codec.RawResponse = r135 :: static
    r136 = dank_mids.helpers._codec.globals :: static
    r137 = 'RawResponse'
    r138 = CPyDict_SetItem(r136, r137, r135)
    dec_ref r135
    r139 = r138 >= 0 :: signed
    if not r139 goto L103 (error at <module>:24) else goto L39 :: bool
L39:
    r140 = dank_mids.helpers._codec.globals :: static
    r141 = 'decoding'
    r142 = CPyDict_GetItem(r140, r141)
    if is_error(r142) goto L103 (error at <module>:25) else goto L40
L40:
    r143 = 'ContextFramesBytesIO'
    r144 = CPyObject_GetAttr(r142, r143)
    dec_ref r142
    if is_error(r144) goto L103 (error at <module>:25) else goto L41
L41:
    dank_mids.helpers._codec.ContextFramesBytesIO = r144 :: static
    r145 = dank_mids.helpers._codec.globals :: static
    r146 = 'ContextFramesBytesIO'
    r147 = CPyDict_SetItem(r145, r146, r144)
    dec_ref r144
    r148 = r147 >= 0 :: signed
    if not r148 goto L103 (error at <module>:25) else goto L42 :: bool
L42:
    r149 = dank_mids.helpers._codec.globals :: static
    r150 = 'msgspec'
    r151 = CPyDict_GetItem(r149, r150)
    if is_error(r151) goto L103 (error at <module>:26) else goto L43
L43:
    r152 = 'DecodeError'
    r153 = CPyObject_GetAttr(r151, r152)
    dec_ref r151
    if is_error(r153) goto L103 (error at <module>:26) else goto L44
L44:
    dank_mids.helpers._codec.DecodeError = r153 :: static
    r154 = dank_mids.helpers._codec.globals :: static
    r155 = 'DecodeError'
    r156 = CPyDict_SetItem(r154, r155, r153)
    dec_ref r153
    r157 = r156 >= 0 :: signed
    if not r157 goto L103 (error at <module>:26) else goto L45 :: bool
L45:
    r158 = dank_mids.helpers._codec.globals :: static
    r159 = 'msgspec'
    r160 = CPyDict_GetItem(r158, r159)
    if is_error(r160) goto L103 (error at <module>:28) else goto L46
L46:
    r161 = 'json'
    r162 = CPyObject_GetAttr(r160, r161)
    dec_ref r160
    if is_error(r162) goto L103 (error at <module>:28) else goto L47
L47:
    r163 = 'encode'
    r164 = CPyObject_GetAttr(r162, r163)
    dec_ref r162
    if is_error(r164) goto L103 (error at <module>:28) else goto L48
L48:
    dank_mids.helpers._codec.json_encode = r164 :: static
    r165 = dank_mids.helpers._codec.globals :: static
    r166 = 'json_encode'
    r167 = CPyDict_SetItem(r165, r166, r164)
    dec_ref r164
    r168 = r167 >= 0 :: signed
    if not r168 goto L103 (error at <module>:28) else goto L49 :: bool
L49:
    r169 = dank_mids.helpers._codec.globals :: static
    r170 = 'msgspec'
    r171 = CPyDict_GetItem(r169, r170)
    if is_error(r171) goto L103 (error at <module>:29) else goto L50
L50:
    r172 = 'json'
    r173 = CPyObject_GetAttr(r171, r172)
    dec_ref r171
    if is_error(r173) goto L103 (error at <module>:29) else goto L51
L51:
    r174 = 'decode'
    r175 = CPyObject_GetAttr(r173, r174)
    dec_ref r173
    if is_error(r175) goto L103 (error at <module>:29) else goto L52
L52:
    dank_mids.helpers._codec.json_decode = r175 :: static
    r176 = dank_mids.helpers._codec.globals :: static
    r177 = 'json_decode'
    r178 = CPyDict_SetItem(r176, r177, r175)
    dec_ref r175
    r179 = r178 >= 0 :: signed
    if not r179 goto L103 (error at <module>:29) else goto L53 :: bool
L53:
    r180 = dank_mids.helpers._codec.globals :: static
    r181 = 'encoding'
    r182 = CPyDict_GetItem(r180, r181)
    if is_error(r182) goto L103 (error at <module>:30) else goto L54
L54:
    r183 = 'encode_uint_256'
    r184 = CPyObject_GetAttr(r182, r183)
    dec_ref r182
    if is_error(r184) goto L103 (error at <module>:30) else goto L55
L55:
    dank_mids.helpers._codec.encode_uint_256 = r184 :: static
    r185 = dank_mids.helpers._codec.globals :: static
    r186 = 'encode_uint_256'
    r187 = CPyDict_SetItem(r185, r186, r184)
    dec_ref r184
    r188 = r187 >= 0 :: signed
    if not r188 goto L103 (error at <module>:30) else goto L56 :: bool
L56:
    r189 = dank_mids.types :: module
    r190 = '_encode_hook'
    r191 = CPyObject_GetAttr(r189, r190)
    if is_error(r191) goto L103 (error at <module>:31) else goto L57
L57:
    dank_mids.helpers._codec._encode_hook = r191 :: static
    r192 = dank_mids.helpers._codec.globals :: static
    r193 = '_encode_hook'
    r194 = CPyDict_SetItem(r192, r193, r191)
    dec_ref r191
    r195 = r194 >= 0 :: signed
    if not r195 goto L103 (error at <module>:31) else goto L58 :: bool
L58:
    r196 = dank_mids.helpers._codec.globals :: static
    r197 = 'default_codec'
    r198 = CPyDict_GetItem(r196, r197)
    if is_error(r198) goto L103 (error at <module>:85) else goto L59
L59:
    r199 = '_registry'
    r200 = CPyObject_GetAttr(r198, r199)
    dec_ref r198
    if is_error(r200) goto L103 (error at <module>:85) else goto L60
L60:
    r201 = '(bool,(address,bytes)[])'
    r202 = 'get_encoder'
    r203 = [r200, r201]
    r204 = load_address r203
    r205 = PyObject_VectorcallMethod(r202, r204, 9223372036854775810, 0)
    if is_error(r205) goto L111 (error at <module>:85) else goto L61
L61:
    dec_ref r200
    dank_mids.helpers._codec._mcall_encoder = r205 :: static
    r206 = dank_mids.helpers._codec.globals :: static
    r207 = '_mcall_encoder'
    r208 = CPyDict_SetItem(r206, r207, r205)
    dec_ref r205
    r209 = r208 >= 0 :: signed
    if not r209 goto L103 (error at <module>:85) else goto L62 :: bool
L62:
    r210 = dank_mids.helpers._codec._mcall_encoder :: static
    if is_error(r210) goto L63 else goto L65
L63:
    r211 = raise NameError('value for final name "_mcall_encoder" was not set')
    if not r211 goto L103 (error at <module>:88) else goto L64 :: bool
L64:
    unreachable
L65:
    r212 = 'encoders'
    r213 = CPyObject_GetAttr(r210, r212)
    if is_error(r213) goto L103 (error at <module>:88) else goto L66
L66:
    r214 = object -1
    r215 = PyObject_GetItem(r213, r214)
    dec_ref r213
    if is_error(r215) goto L103 (error at <module>:88) else goto L67
L67:
    dank_mids.helpers._codec._array_encoder = r215 :: static
    r216 = dank_mids.helpers._codec.globals :: static
    r217 = '_array_encoder'
    r218 = CPyDict_SetItem(r216, r217, r215)
    dec_ref r215
    r219 = r218 >= 0 :: signed
    if not r219 goto L103 (error at <module>:88) else goto L68 :: bool
L68:
    r220 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r220) goto L69 else goto L71
L69:
    r221 = raise NameError('value for final name "_array_encoder" was not set')
    if not r221 goto L103 (error at <module>:89) else goto L70 :: bool
L70:
    unreachable
L71:
    r222 = 'item_encoder'
    r223 = CPyObject_GetAttr(r220, r222)
    if is_error(r223) goto L103 (error at <module>:89) else goto L72
L72:
    dank_mids.helpers._codec._item_encoder = r223 :: static
    r224 = dank_mids.helpers._codec.globals :: static
    r225 = '_item_encoder'
    r226 = CPyDict_SetItem(r224, r225, r223)
    dec_ref r223
    r227 = r226 >= 0 :: signed
    if not r227 goto L103 (error at <module>:89) else goto L73 :: bool
L73:
    r228 = __mypyc_lambda__0_obj()
    if is_error(r228) goto L103 (error at <module>:92) else goto L74
L74:
    r229 = dank_mids.helpers._codec._mcall_encoder :: static
    if is_error(r229) goto L112 else goto L77
L75:
    r230 = raise NameError('value for final name "_mcall_encoder" was not set')
    if not r230 goto L103 (error at <module>:92) else goto L76 :: bool
L76:
    unreachable
L77:
    r231 = 'validate_value'
    r232 = PyObject_SetAttr(r229, r231, r228)
    r233 = r232 >= 0 :: signed
    if not r233 goto L113 (error at <module>:92) else goto L78 :: bool
L78:
    r234 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r234) goto L114 else goto L81
L79:
    r235 = raise NameError('value for final name "_array_encoder" was not set')
    if not r235 goto L103 (error at <module>:92) else goto L80 :: bool
L80:
    unreachable
L81:
    r236 = 'validate_value'
    r237 = PyObject_SetAttr(r234, r236, r228)
    r238 = r237 >= 0 :: signed
    if not r238 goto L113 (error at <module>:92) else goto L82 :: bool
L82:
    r239 = dank_mids.helpers._codec._item_encoder :: static
    if is_error(r239) goto L115 else goto L85
L83:
    r240 = raise NameError('value for final name "_item_encoder" was not set')
    if not r240 goto L103 (error at <module>:92) else goto L84 :: bool
L84:
    unreachable
L85:
    r241 = 'validate_value'
    r242 = PyObject_SetAttr(r239, r241, r228)
    dec_ref r228
    r243 = r242 >= 0 :: signed
    if not r243 goto L103 (error at <module>:92) else goto L86 :: bool
L86:
    r244 = dank_mids.helpers._codec.globals :: static
    r245 = '__encode_new'
    r246 = CPyDict_GetItem(r244, r245)
    if is_error(r246) goto L103 (error at <module>:109) else goto L87
L87:
    r247 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r247) goto L116 else goto L90
L88:
    r248 = raise NameError('value for final name "_array_encoder" was not set')
    if not r248 goto L103 (error at <module>:109) else goto L89 :: bool
L89:
    unreachable
L90:
    r249 = 'encode'
    r250 = PyObject_SetAttr(r247, r249, r246)
    dec_ref r246
    r251 = r250 >= 0 :: signed
    if not r251 goto L103 (error at <module>:109) else goto L91 :: bool
L91:
    r252 = dank_mids.helpers._codec.globals :: static
    r253 = '__encode_elements_new'
    r254 = CPyDict_GetItem(r252, r253)
    if is_error(r254) goto L103 (error at <module>:110) else goto L92
L92:
    r255 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r255) goto L117 else goto L95
L93:
    r256 = raise NameError('value for final name "_array_encoder" was not set')
    if not r256 goto L103 (error at <module>:110) else goto L94 :: bool
L94:
    unreachable
L95:
    r257 = 'encode_elements'
    r258 = PyObject_SetAttr(r255, r257, r254)
    dec_ref r254
    r259 = r258 >= 0 :: signed
    if not r259 goto L103 (error at <module>:110) else goto L96 :: bool
L96:
    r260 = dank_mids.helpers._codec.globals :: static
    r261 = 'default_codec'
    r262 = CPyDict_GetItem(r260, r261)
    if is_error(r262) goto L103 (error at <module>:113) else goto L97
L97:
    r263 = '_registry'
    r264 = CPyObject_GetAttr(r262, r263)
    dec_ref r262
    if is_error(r264) goto L103 (error at <module>:113) else goto L98
L98:
    r265 = '(uint256,uint256,(bool,bytes)[])'
    r266 = 'get_decoder'
    r267 = [r264, r265]
    r268 = load_address r267
    r269 = PyObject_VectorcallMethod(r266, r268, 9223372036854775810, 0)
    if is_error(r269) goto L118 (error at <module>:113) else goto L99
L99:
    dec_ref r264
    r270 = 'decode'
    r271 = CPyObject_GetAttr(r269, r270)
    dec_ref r269
    if is_error(r271) goto L103 (error at <module>:113) else goto L100
L100:
    dank_mids.helpers._codec._mcall_decoder = r271 :: static
    r272 = dank_mids.helpers._codec.globals :: static
    r273 = '_mcall_decoder'
    r274 = CPyDict_SetItem(r272, r273, r271)
    dec_ref r271
    r275 = r274 >= 0 :: signed
    if not r275 goto L103 (error at <module>:113) else goto L101 :: bool
L101:
    r276 = load_address PyBool_Type
    r277 = dank_mids.helpers._codec.globals :: static
    r278 = 'Success'
    r279 = CPyDict_SetItem(r277, r278, r276)
    r280 = r279 >= 0 :: signed
    if not r280 goto L103 (error at <module>:123) else goto L102 :: bool
L102:
    return 1
L103:
    r281 = <error> :: None
    return r281
L104:
    dec_ref r57
    goto L103
L105:
    dec_ref r57
    dec_ref r60
    goto L103
L106:
    dec_ref r57
    dec_ref r60
    dec_ref r64
    goto L103
L107:
    dec_ref r57
    dec_ref r71
    goto L103
L108:
    dec_ref r85
    goto L103
L109:
    dec_ref r85
    dec_ref r90
    goto L103
L110:
    dec_ref r112
    goto L103
L111:
    dec_ref r200
    goto L103
L112:
    dec_ref r228
    goto L75
L113:
    dec_ref r228
    goto L103
L114:
    dec_ref r228
    goto L79
L115:
    dec_ref r228
    goto L83
L116:
    dec_ref r246
    goto L88
L117:
    dec_ref r254
    goto L93
L118:
    dec_ref r264
    goto L103

def WeakList.__init__(self, data):
    self :: dank_mids.helpers._weaklist.WeakList
    data :: union[object, None]
    r0 :: object
    r1 :: dict
    r2 :: bool
    r3 :: object
    r4 :: bit
    r5, r6 :: None
L0:
    if is_error(data) goto L1 else goto L8
L1:
    r0 = box(None, 1)
    inc_ref r0
    data = r0
L2:
    r1 = PyDict_New()
    if is_error(r1) goto L9 (error at __init__:18) else goto L3
L3:
    self._refs = r1; r2 = is_error
    if not r2 goto L9 (error at __init__:18) else goto L4 :: bool
L4:
    r3 = load_address _Py_NoneStruct
    r4 = data != r3
    if r4 goto L5 else goto L10 :: bool
L5:
    r5 = self.extend(data)
    dec_ref data
    if is_error(r5) goto L7 (error at __init__:20) else goto L6
L6:
    return 1
L7:
    r6 = <error> :: None
    return r6
L8:
    inc_ref data
    goto L2
L9:
    dec_ref data
    goto L7
L10:
    dec_ref data
    goto L6

def WeakList.__repr__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: object
    r1 :: str
    r2 :: object
    r3, r4, r5 :: str
    r6 :: object
    r7 :: str
    r8, r9 :: object
    r10 :: str
    r11 :: object
    r12 :: object[2]
    r13 :: object_ptr
    r14 :: object
    r15, r16, r17, r18 :: str
L0:
    r0 = PyObject_Type(self)
    r1 = '__name__'
    r2 = CPyObject_GetAttr(r0, r1)
    dec_ref r0
    if is_error(r2) goto L8 (error at __repr__:24) else goto L1
L1:
    r3 = cast(str, r2)
    if is_error(r3) goto L8 (error at __repr__:24) else goto L2
L2:
    r4 = '(['
    r5 = ', '
    r6 = builtins :: module
    r7 = 'repr'
    r8 = CPyObject_GetAttr(r6, r7)
    if is_error(r8) goto L9 (error at __repr__:24) else goto L3
L3:
    r9 = builtins :: module
    r10 = 'map'
    r11 = CPyObject_GetAttr(r9, r10)
    if is_error(r11) goto L10 (error at __repr__:24) else goto L4
L4:
    r12 = [r8, self]
    r13 = load_address r12
    r14 = _PyObject_Vectorcall(r11, r13, 2, 0)
    dec_ref r11
    if is_error(r14) goto L10 (error at __repr__:24) else goto L5
L5:
    dec_ref r8
    r15 = PyUnicode_Join(r5, r14)
    dec_ref r14
    if is_error(r15) goto L9 (error at __repr__:24) else goto L6
L6:
    r16 = '])'
    r17 = CPyStr_Build(4, r3, r4, r15, r16)
    dec_ref r3
    dec_ref r15
    if is_error(r17) goto L8 (error at __repr__:24) else goto L7
L7:
    return r17
L8:
    r18 = <error> :: str
    return r18
L9:
    dec_ref r3
    goto L8
L10:
    dec_ref r3
    dec_ref r8
    goto L8

def WeakList.__len__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: dict
    r1 :: native_int
    r2 :: short_int
    r3 :: int
L0:
    r0 = self._refs
    if is_error(r0) goto L2 (error at __len__:27) else goto L1
L1:
    r1 = PyDict_Size(r0)
    dec_ref r0
    r2 = r1 << 1
    return r2
L2:
    r3 = <error> :: int
    return r3

def WeakList.__bool__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: dict
    r1 :: native_int
    r2 :: short_int
    r3 :: bit
    r4 :: bool
L0:
    r0 = self._refs
    if is_error(r0) goto L2 (error at __bool__:30) else goto L1
L1:
    r1 = PyDict_Size(r0)
    dec_ref r0
    r2 = r1 << 1
    r3 = r2 != 0
    return r3
L2:
    r4 = <error> :: bool
    return r4

def WeakList.__contains__(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: dict
    r1 :: int
    r2, r3 :: object
    ref :: union[object, None]
    r4 :: object
    r5 :: bit
    r6 :: bool
    r7 :: object
    r8 :: bit
    r9 :: bool
L0:
    r0 = self._refs
    if is_error(r0) goto L7 (error at __contains__:33) else goto L1
L1:
    r1 = CPyTagged_Id(item)
    r2 = box(int, r1)
    r3 = CPyDict_GetWithNone(r0, r2)
    dec_ref r0
    dec_ref r2
    if is_error(r3) goto L7 (error at __contains__:33) else goto L2
L2:
    ref = r3
    r4 = load_address _Py_NoneStruct
    r5 = ref == r4
    if r5 goto L8 else goto L4 :: bool
L3:
    r6 = 0
    goto L6
L4:
    r7 = _PyObject_Vectorcall(ref, 0, 0, 0)
    dec_ref ref
    if is_error(r7) goto L7 (error at __contains__:34) else goto L5
L5:
    r8 = r7 == item
    dec_ref r7
    r6 = r8
L6:
    return r6
L7:
    r9 = <error> :: bool
    return r9
L8:
    dec_ref ref
    goto L3

def __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    type, value, traceback, arg :: object
    r0 :: dank_mids.helpers._weaklist.__iter___WeakList_env
    r1 :: int
    r2 :: object
    r3 :: bit
    r4 :: dank_mids.helpers._weaklist.WeakList
    r5 :: dict
    r6, r7 :: bool
    r8 :: dict
    r9 :: native_int
    r10 :: short_int
    r11 :: bool
    r12 :: object
    r13 :: bool
    r14 :: object
    r15 :: short_int
    r16 :: tuple[bool, short_int, object]
    r17 :: short_int
    r18, r19 :: bool
    r20 :: object
    r21 :: bool
    r22, r23 :: object
    r24 :: bit
    r25, r26 :: object
    r27 :: bool
    r28 :: object[1]
    r29 :: object_ptr
    r30 :: object
    r31 :: bool
    r32 :: union[object, None]
    r33 :: object
    r34 :: bit
    r35 :: union[object, None]
    r36 :: bool
    r37 :: object
    r38 :: bit
    r39 :: dict
    r40 :: short_int
    r41, r42 :: bit
    r43 :: object
    r44 :: bool
    r45, r46 :: bit
    r47 :: bool
    r48 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L45 (error at __iter__:36) else goto L1
L1:
    r1 = r0.__mypyc_next_label__
    if is_error(r1) goto L46 (error at __iter__:36) else goto L41
L2:
    r2 = load_address _Py_NoneStruct
    r3 = type != r2
    if r3 goto L47 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L45 (error at __iter__:36) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = r0.self
    if is_error(r4) goto L46 (error at __iter__:37) else goto L6
L6:
    r5 = r4._refs
    dec_ref r4
    if is_error(r5) goto L46 (error at __iter__:37) else goto L7
L7:
    inc_ref r5
    r0.__mypyc_temp__0 = r5; r6 = is_error
    if not r6 goto L48 (error at __iter__:-1) else goto L8 :: bool
L8:
    r0.__mypyc_temp__1 = 0; r7 = is_error
    if not r7 goto L48 (error at __iter__:-1) else goto L9 :: bool
L9:
    r8 = r0.__mypyc_temp__0
    if is_error(r8) goto L48 (error at __iter__:37) else goto L10
L10:
    r9 = PyDict_Size(r8)
    dec_ref r8
    r10 = r9 << 1
    r0.__mypyc_temp__2 = r10; r11 = is_error
    if not r11 goto L48 (error at __iter__:-1) else goto L11 :: bool
L11:
    r12 = CPyDict_GetValuesIter(r5)
    dec_ref r5
    if is_error(r12) goto L46 (error at __iter__:37) else goto L12
L12:
    r0.__mypyc_temp__3 = r12; r13 = is_error
    if not r13 goto L46 (error at __iter__:-1) else goto L13 :: bool
L13:
    r14 = r0.__mypyc_temp__3
    if is_error(r14) goto L46 (error at __iter__:37) else goto L14
L14:
    r15 = r0.__mypyc_temp__1
    if is_error(r15) goto L49 (error at __iter__:37) else goto L15
L15:
    r16 = CPyDict_NextValue(r14, r15)
    dec_ref r14
    r17 = r16[1]
    r0.__mypyc_temp__1 = r17; r18 = is_error
    if not r18 goto L50 (error at __iter__:37) else goto L16 :: bool
L16:
    r19 = r16[0]
    if r19 goto L17 else goto L51 :: bool
L17:
    r20 = r16[2]
    dec_ref r16
    r0.r = r20; r21 = is_error
    if not r21 goto L46 (error at __iter__:37) else goto L18 :: bool
L18:
    r22 = r0.r
    if is_error(r22) goto L46 (error at __iter__:38) else goto L19
L19:
    r23 = load_address _Py_NoneStruct
    r24 = r22 != r23
    dec_ref r22
    if r24 goto L20 else goto L34 :: bool
L20:
    r25 = r0.r
    if is_error(r25) goto L46 (error at __iter__:39) else goto L21
L21:
    r26 = dank_mids.helpers._weaklist._call_ref :: static
    if is_error(r26) goto L52 else goto L24
L22:
    r27 = raise NameError('value for final name "_call_ref" was not set')
    if not r27 goto L45 (error at __iter__:39) else goto L23 :: bool
L23:
    unreachable
L24:
    r28 = [r25]
    r29 = load_address r28
    r30 = _PyObject_Vectorcall(r26, r29, 1, 0)
    if is_error(r30) goto L53 (error at __iter__:39) else goto L25
L25:
    dec_ref r25
    r0.obj = r30; r31 = is_error
    if not r31 goto L46 (error at __iter__:39) else goto L26 :: bool
L26:
    r32 = r0.obj
    if is_error(r32) goto L46 (error at __iter__:40) else goto L27
L27:
    r33 = load_address _Py_NoneStruct
    r34 = r32 != r33
    dec_ref r32
    if r34 goto L28 else goto L34 :: bool
L28:
    r35 = r0.obj
    if is_error(r35) goto L46 (error at __iter__:41) else goto L29
L29:
    r0.__mypyc_next_label__ = 2; r36 = is_error
    dec_ref r0
    if not r36 goto L54 (error at __iter__:41) else goto L30 :: bool
L30:
    return r35
L31:
    r37 = load_address _Py_NoneStruct
    r38 = type != r37
    if r38 goto L55 else goto L34 :: bool
L32:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L45 (error at __iter__:41) else goto L33 :: bool
L33:
    unreachable
L34:
    r39 = r0.__mypyc_temp__0
    if is_error(r39) goto L46 (error at __iter__:37) else goto L35
L35:
    r40 = r0.__mypyc_temp__2
    if is_error(r40) goto L56 (error at __iter__:37) else goto L36
L36:
    r41 = CPyDict_CheckSize(r39, r40)
    dec_ref r39
    if not r41 goto L46 (error at __iter__:37) else goto L13 :: bool
L37:
    r42 = CPy_NoErrOccurred()
    if not r42 goto L46 (error at __iter__:37) else goto L38 :: bool
L38:
    r43 = box(None, 1)
    r0.__mypyc_next_label__ = -2; r44 = is_error
    dec_ref r0
    if not r44 goto L45 (error at __iter__:36) else goto L39 :: bool
L39:
    CPyGen_SetStopIterationValue(r43)
    if not 0 goto L45 else goto L40 :: bool
L40:
    unreachable
L41:
    r45 = r1 == 0
    if r45 goto L57 else goto L42 :: bool
L42:
    r46 = r1 == 2
    dec_ref r1 :: int
    if r46 goto L31 else goto L58 :: bool
L43:
    r47 = raise StopIteration
    if not r47 goto L45 (error at __iter__:36) else goto L44 :: bool
L44:
    unreachable
L45:
    r48 = <error> :: object
    return r48
L46:
    dec_ref r0
    goto L45
L47:
    dec_ref r0
    goto L3
L48:
    dec_ref r0
    dec_ref r5
    goto L45
L49:
    dec_ref r0
    dec_ref r14
    goto L45
L50:
    dec_ref r0
    dec_ref r16
    goto L45
L51:
    dec_ref r16
    goto L37
L52:
    dec_ref r0
    dec_ref r25
    goto L22
L53:
    dec_ref r0
    dec_ref r25
    goto L45
L54:
    dec_ref r35
    goto L45
L55:
    dec_ref r0
    goto L32
L56:
    dec_ref r0
    dec_ref r39
    goto L45
L57:
    dec_ref r1 :: int
    goto L2
L58:
    dec_ref r0
    goto L43

def __iter___WeakList_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __iter___WeakList_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __iter___WeakList_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def __iter___WeakList_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def __iter___WeakList_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def WeakList.__iter__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: dank_mids.helpers._weaklist.__iter___WeakList_env
    r1 :: bool
    r2 :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = __iter___WeakList_env()
    if is_error(r0) goto L6 (error at __iter__:36) else goto L1
L1:
    inc_ref self
    r0.self = self; r1 = is_error
    if not r1 goto L7 (error at __iter__:36) else goto L2 :: bool
L2:
    r2 = __iter___WeakList_gen()
    if is_error(r2) goto L7 (error at __iter__:36) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L8 (error at __iter__:36) else goto L4 :: bool
L4:
    r0.__mypyc_next_label__ = 0; r4 = is_error
    dec_ref r0
    if not r4 goto L9 (error at __iter__:36) else goto L5 :: bool
L5:
    return r2
L6:
    r5 = <error> :: object
    return r5
L7:
    dec_ref r0
    goto L6
L8:
    dec_ref r0
    dec_ref r2
    goto L6
L9:
    dec_ref r2
    goto L6

def WeakList.append(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: str
    r1, r2 :: object
    r3 :: bool
    r4 :: object[2]
    r5 :: object_ptr
    r6 :: object
    r7 :: dict
    r8 :: int
    r9 :: object
    r10 :: i32
    r11 :: bit
    r12 :: None
L0:
    r0 = '_gc_callback'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L8 (error at append:45) else goto L1
L1:
    r2 = dank_mids.helpers._weaklist.ref :: static
    if is_error(r2) goto L9 else goto L4
L2:
    r3 = raise NameError('value for final name "ref" was not set')
    if not r3 goto L8 (error at append:45) else goto L3 :: bool
L3:
    unreachable
L4:
    r4 = [item, r1]
    r5 = load_address r4
    r6 = _PyObject_Vectorcall(r2, r5, 2, 0)
    if is_error(r6) goto L10 (error at append:45) else goto L5
L5:
    dec_ref r1
    r7 = self._refs
    if is_error(r7) goto L11 (error at append:45) else goto L6
L6:
    r8 = CPyTagged_Id(item)
    r9 = box(int, r8)
    r10 = CPyDict_SetItem(r7, r9, r6)
    dec_ref r7
    dec_ref r9
    dec_ref r6
    r11 = r10 >= 0 :: signed
    if not r11 goto L8 (error at append:45) else goto L7 :: bool
L7:
    return 1
L8:
    r12 = <error> :: None
    return r12
L9:
    dec_ref r1
    goto L2
L10:
    dec_ref r1
    goto L8
L11:
    dec_ref r6
    goto L8

def WeakList.extend(self, items):
    self :: dank_mids.helpers._weaklist.WeakList
    items :: object
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: list
    r4, r5 :: object
    r6 :: int
    r7 :: object
    r8 :: bool
    r9 :: object[2]
    r10 :: object_ptr
    r11 :: object
    r12 :: tuple[int, object]
    r13 :: object
    r14 :: i32
    r15, r16 :: bit
    r17 :: i32
    r18 :: bit
    r19 :: None
L0:
    r0 = '_gc_callback'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L13 (error at extend:48) else goto L1
L1:
    r2 = self._refs
    if is_error(r2) goto L14 (error at extend:49) else goto L2
L2:
    r3 = PyList_New(0)
    if is_error(r3) goto L15 (error at extend:49) else goto L3
L3:
    r4 = PyObject_GetIter(items)
    if is_error(r4) goto L16 (error at extend:49) else goto L4
L4:
    r5 = PyIter_Next(r4)
    if is_error(r5) goto L17 else goto L5
L5:
    r6 = CPyTagged_Id(r5)
    r7 = dank_mids.helpers._weaklist.ref :: static
    if is_error(r7) goto L18 else goto L8
L6:
    r8 = raise NameError('value for final name "ref" was not set')
    if not r8 goto L13 (error at extend:49) else goto L7 :: bool
L7:
    unreachable
L8:
    r9 = [r5, r1]
    r10 = load_address r9
    r11 = _PyObject_Vectorcall(r7, r10, 2, 0)
    if is_error(r11) goto L19 (error at extend:49) else goto L9
L9:
    dec_ref r5
    r12 = (r6, r11)
    r13 = box(tuple[int, object], r12)
    r14 = PyList_Append(r3, r13)
    dec_ref r13
    r15 = r14 >= 0 :: signed
    if not r15 goto L20 (error at extend:49) else goto L4 :: bool
L10:
    r16 = CPy_NoErrOccurred()
    if not r16 goto L21 (error at extend:49) else goto L11 :: bool
L11:
    r17 = CPyDict_UpdateFromAny(r2, r3)
    dec_ref r2
    dec_ref r3
    r18 = r17 >= 0 :: signed
    if not r18 goto L13 (error at extend:49) else goto L12 :: bool
L12:
    return 1
L13:
    r19 = <error> :: None
    return r19
L14:
    dec_ref r1
    goto L13
L15:
    dec_ref r1
    dec_ref r2
    goto L13
L16:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    goto L13
L17:
    dec_ref r1
    dec_ref r4
    goto L10
L18:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    dec_ref r5
    dec_ref r6 :: int
    goto L6
L19:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    dec_ref r5
    dec_ref r6 :: int
    goto L13
L20:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    goto L13
L21:
    dec_ref r2
    dec_ref r3
    goto L13

def WeakList.remove(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: int
    r1 :: dict
    r2, r3 :: object
    ref :: union[object, None]
    r4 :: object
    r5 :: bit
    r6 :: object
    r7, r8 :: bit
    r9 :: str
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: dict
    r17 :: object
    r18 :: i32
    r19 :: bit
    r20 :: None
L0:
    r0 = CPyTagged_Id(item)
    r1 = self._refs
    if is_error(r1) goto L13 (error at remove:53) else goto L1
L1:
    inc_ref r0 :: int
    r2 = box(int, r0)
    r3 = CPyDict_GetWithNone(r1, r2)
    dec_ref r1
    dec_ref r2
    if is_error(r3) goto L13 (error at remove:53) else goto L2
L2:
    ref = r3
    r4 = load_address _Py_NoneStruct
    r5 = ref == r4
    if r5 goto L14 else goto L3 :: bool
L3:
    r6 = _PyObject_Vectorcall(ref, 0, 0, 0)
    dec_ref ref
    if is_error(r6) goto L13 (error at remove:54) else goto L4
L4:
    r7 = r6 == item
    dec_ref r6
    r8 = r7 ^ 1
    if r8 goto L15 else goto L9 :: bool
L5:
    r9 = 'list.remove(x): x not in list'
    r10 = builtins :: module
    r11 = 'ValueError'
    r12 = CPyObject_GetAttr(r10, r11)
    if is_error(r12) goto L12 (error at remove:55) else goto L6
L6:
    r13 = [r9]
    r14 = load_address r13
    r15 = _PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L12 (error at remove:55) else goto L7
L7:
    CPy_Raise(r15)
    dec_ref r15
    if not 0 goto L12 (error at remove:55) else goto L8 :: bool
L8:
    unreachable
L9:
    r16 = self._refs
    if is_error(r16) goto L13 (error at remove:56) else goto L10
L10:
    r17 = box(int, r0)
    r18 = PyObject_DelItem(r16, r17)
    dec_ref r16
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L12 (error at remove:56) else goto L11 :: bool
L11:
    return 1
L12:
    r20 = <error> :: None
    return r20
L13:
    dec_ref r0 :: int
    goto L12
L14:
    dec_ref r0 :: int
    dec_ref ref
    goto L5
L15:
    dec_ref r0 :: int
    goto L5

def WeakList._gc_callback(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: dict
    r1 :: int
    r2 :: str
    r3, r4 :: object
    r5 :: object[3]
    r6 :: object_ptr
    r7 :: object
    r8 :: None
L0:
    r0 = self._refs
    if is_error(r0) goto L3 (error at _gc_callback:60) else goto L1
L1:
    r1 = CPyTagged_Id(item)
    r2 = 'pop'
    r3 = box(int, r1)
    r4 = box(None, 1)
    r5 = [r0, r3, r4]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r2, r6, 9223372036854775811, 0)
    if is_error(r7) goto L4 (error at _gc_callback:60) else goto L5
L2:
    dec_ref r0
    dec_ref r3
    return 1
L3:
    r8 = <error> :: None
    return r8
L4:
    dec_ref r0
    dec_ref r3
    goto L3
L5:
    dec_ref r7
    goto L2

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18 :: object
    r19 :: str
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: dict
    r34 :: str
    r35 :: i32
    r36 :: bit
    r37 :: dict
    r38 :: str
    r39 :: object
    r40 :: dict
    r41 :: str
    r42 :: object
    r43 :: list
    r44, r45 :: ptr
    r46 :: object
    r47 :: tuple[list, object]
    r48, r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: object
    r55 :: str
    r56 :: object
    r57 :: dict
    r58 :: str
    r59 :: i32
    r60 :: bit
    r61 :: object
    r62 :: str
    r63 :: object
    r64 :: str
    r65 :: object
    r66 :: dict
    r67 :: str
    r68 :: i32
    r69 :: bit
    r70 :: dict
    r71 :: str
    r72 :: object
    r73 :: dict
    r74 :: str
    r75, r76 :: object
    r77 :: tuple
    r78 :: str
    r79, r80 :: object
    r81 :: bool
    r82, r83, r84 :: str
    r85 :: tuple
    r86 :: i32
    r87 :: bit
    r88 :: dict
    r89 :: str
    r90 :: i32
    r91 :: bit
    r92 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L30 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address weakref :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('weakref', 'weakref', 'weakref'),)
    r11 = dank_mids.helpers._weaklist.globals :: static
    r12 = 'dank_mids/helpers/_weaklist.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L30 else goto L4 :: bool
L4:
    r15 = ('Any', 'Callable', 'Dict', 'Final', 'Generic', 'Iterable', 'Iterator', 'Optional', 'TypeVar', 'final')
    r16 = 'typing'
    r17 = dank_mids.helpers._weaklist.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L30 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = '_T'
    r20 = dank_mids.helpers._weaklist.globals :: static
    r21 = 'TypeVar'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L30 (error at <module>:5) else goto L6
L6:
    r23 = [r19]
    r24 = load_address r23
    r25 = _PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L30 (error at <module>:5) else goto L7
L7:
    r26 = dank_mids.helpers._weaklist.globals :: static
    r27 = '_T'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L30 (error at <module>:5) else goto L8 :: bool
L8:
    r30 = weakref :: module
    r31 = 'ReferenceType'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L30 (error at <module>:7) else goto L9
L9:
    r33 = dank_mids.helpers._weaklist.globals :: static
    r34 = 'Ref'
    r35 = CPyDict_SetItem(r33, r34, r32)
    dec_ref r32
    r36 = r35 >= 0 :: signed
    if not r36 goto L30 (error at <module>:7) else goto L10 :: bool
L10:
    r37 = dank_mids.helpers._weaklist.globals :: static
    r38 = 'Callable'
    r39 = CPyDict_GetItem(r37, r38)
    if is_error(r39) goto L30 (error at <module>:8) else goto L11
L11:
    r40 = dank_mids.helpers._weaklist.globals :: static
    r41 = 'Any'
    r42 = CPyDict_GetItem(r40, r41)
    if is_error(r42) goto L31 (error at <module>:8) else goto L12
L12:
    r43 = PyList_New(1)
    if is_error(r43) goto L32 (error at <module>:8) else goto L13
L13:
    r44 = get_element_ptr r43 ob_item :: PyListObject
    r45 = load_mem r44 :: ptr*
    set_mem r45, r42 :: builtins.object*
    r46 = box(None, 1)
    inc_ref r46
    r47 = (r43, r46)
    r48 = box(tuple[list, object], r47)
    r49 = PyObject_GetItem(r39, r48)
    dec_ref r39
    dec_ref r48
    if is_error(r49) goto L30 (error at <module>:8) else goto L14
L14:
    r50 = dank_mids.helpers._weaklist.globals :: static
    r51 = 'GCCallback'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L30 (error at <module>:8) else goto L15 :: bool
L15:
    r54 = weakref :: module
    r55 = 'ref'
    r56 = CPyObject_GetAttr(r54, r55)
    if is_error(r56) goto L30 (error at <module>:10) else goto L16
L16:
    dank_mids.helpers._weaklist.ref = r56 :: static
    r57 = dank_mids.helpers._weaklist.globals :: static
    r58 = 'ref'
    r59 = CPyDict_SetItem(r57, r58, r56)
    dec_ref r56
    r60 = r59 >= 0 :: signed
    if not r60 goto L30 (error at <module>:10) else goto L17 :: bool
L17:
    r61 = weakref :: module
    r62 = 'ref'
    r63 = CPyObject_GetAttr(r61, r62)
    if is_error(r63) goto L30 (error at <module>:11) else goto L18
L18:
    r64 = '__call__'
    r65 = CPyObject_GetAttr(r63, r64)
    dec_ref r63
    if is_error(r65) goto L30 (error at <module>:11) else goto L19
L19:
    dank_mids.helpers._weaklist._call_ref = r65 :: static
    r66 = dank_mids.helpers._weaklist.globals :: static
    r67 = '_call_ref'
    r68 = CPyDict_SetItem(r66, r67, r65)
    dec_ref r65
    r69 = r68 >= 0 :: signed
    if not r69 goto L30 (error at <module>:11) else goto L20 :: bool
L20:
    r70 = dank_mids.helpers._weaklist.globals :: static
    r71 = 'Generic'
    r72 = CPyDict_GetItem(r70, r71)
    if is_error(r72) goto L30 (error at <module>:15) else goto L21
L21:
    r73 = dank_mids.helpers._weaklist.globals :: static
    r74 = '_T'
    r75 = CPyDict_GetItem(r73, r74)
    if is_error(r75) goto L33 (error at <module>:15) else goto L22
L22:
    r76 = PyObject_GetItem(r72, r75)
    dec_ref r72
    dec_ref r75
    if is_error(r76) goto L30 (error at <module>:15) else goto L23
L23:
    r77 = PyTuple_Pack(1, r76)
    dec_ref r76
    if is_error(r77) goto L30 (error at <module>:15) else goto L24
L24:
    r78 = 'dank_mids.helpers._weaklist'
    r79 = dank_mids.helpers._weaklist.WeakList_template :: type
    r80 = CPyType_FromTemplate(r79, r77, r78)
    dec_ref r77
    if is_error(r80) goto L30 (error at <module>:15) else goto L25
L25:
    r81 = WeakList_trait_vtable_setup()
    if is_error(r81) goto L34 (error at <module>:-1) else goto L26
L26:
    r82 = '__mypyc_attrs__'
    r83 = '_refs'
    r84 = '__dict__'
    r85 = PyTuple_Pack(2, r83, r84)
    if is_error(r85) goto L34 (error at <module>:15) else goto L27
L27:
    r86 = PyObject_SetAttr(r80, r82, r85)
    dec_ref r85
    r87 = r86 >= 0 :: signed
    if not r87 goto L34 (error at <module>:15) else goto L28 :: bool
L28:
    dank_mids.helpers._weaklist.WeakList = r80 :: type
    r88 = dank_mids.helpers._weaklist.globals :: static
    r89 = 'WeakList'
    r90 = CPyDict_SetItem(r88, r89, r80)
    dec_ref r80
    r91 = r90 >= 0 :: signed
    if not r91 goto L30 (error at <module>:15) else goto L29 :: bool
L29:
    return 1
L30:
    r92 = <error> :: None
    return r92
L31:
    dec_ref r39
    goto L30
L32:
    dec_ref r39
    dec_ref r42
    goto L30
L33:
    dec_ref r72
    goto L30
L34:
    dec_ref r80
    goto L30

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20 :: object
    r21, r22, r23, r24 :: str
    r25 :: list
    r26, r27, r28, r29, r30 :: ptr
    r31 :: dict
    r32 :: str
    r33 :: i32
    r34 :: bit
    r35 :: object
    r36 :: str
    r37 :: dict
    r38, r39 :: object
    r40 :: str
    r41 :: dict
    r42 :: object
    r43 :: dict
    r44 :: str
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: str
    r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: object
    r53 :: object[1]
    r54 :: object_ptr
    r55, r56 :: object
    r57 :: str
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: object[1]
    r62 :: object_ptr
    r63 :: object
    r64 :: bool
    r65 :: object
    r66 :: str
    r67 :: dict
    r68 :: object
    r69 :: dict
    r70 :: str
    r71 :: object
    r72 :: str
    r73 :: object[1]
    r74 :: object_ptr
    r75 :: object
    r76 :: i32
    r77 :: bit
    r78 :: bool
    r79 :: object
    r80 :: str
    r81 :: dict
    r82 :: object
    r83 :: dict
    r84 :: str
    r85 :: object
    r86 :: dict
    r87 :: str
    r88 :: object
    r89 :: object[1]
    r90 :: object_ptr
    r91 :: object
    r92 :: dict
    r93 :: str
    r94 :: i32
    r95 :: bit
    r96 :: dict
    r97 :: str
    r98 :: object
    r99 :: str
    r100 :: object
    r101 :: dict
    r102 :: str
    r103 :: i32
    r104 :: bit
    r105 :: dict
    r106 :: str
    r107 :: object
    r108, r109, r110, r111 :: str
    r112 :: list
    r113, r114, r115, r116, r117 :: ptr
    r118 :: object
    r119 :: i32
    r120 :: bit
    r121, r122 :: tuple[object, object, object]
    r123, r124, r125 :: object
    r126 :: object[4]
    r127 :: object_ptr
    r128 :: object
    r129 :: i32
    r130 :: bit
    r131 :: bool
    r132 :: bit
    r133, r134, r135 :: tuple[object, object, object]
    r136 :: object
    r137 :: object[4]
    r138 :: object_ptr
    r139 :: object
    r140 :: bit
    r141 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L56 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('suppress',)
    r6 = 'contextlib'
    r7 = dank_mids.brownie_patch.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L56 (error at <module>:1) else goto L4
L4:
    contextlib = r8 :: module
    dec_ref r8
    r9 = ('AsyncEth',)
    r10 = 'web3.eth'
    r11 = dank_mids.brownie_patch.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L56 (error at <module>:3) else goto L5
L5:
    web3.eth = r12 :: module
    dec_ref r12
    r13 = ('setup_dank_w3_from_sync',)
    r14 = 'dank_mids.helpers'
    r15 = dank_mids.brownie_patch.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L56 (error at <module>:5) else goto L6
L6:
    dank_mids.helpers = r16 :: module
    dec_ref r16
    r17 = ('DankContractCall', 'DankContractMethod', 'DankContractTx', 'DankOverloadedMethod')
    r18 = 'dank_mids.brownie_patch.types'
    r19 = dank_mids.brownie_patch.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L56 (error at <module>:6) else goto L7
L7:
    dank_mids.brownie_patch.types = r20 :: module
    dec_ref r20
    r21 = 'DankContractCall'
    r22 = 'DankContractMethod'
    r23 = 'DankContractTx'
    r24 = 'DankOverloadedMethod'
    r25 = PyList_New(4)
    if is_error(r25) goto L56 (error at <module>:13) else goto L8
L8:
    r26 = get_element_ptr r25 ob_item :: PyListObject
    r27 = load_mem r26 :: ptr*
    inc_ref r21
    set_mem r27, r21 :: builtins.object*
    inc_ref r22
    r28 = r27 + 8
    set_mem r28, r22 :: builtins.object*
    inc_ref r23
    r29 = r27 + 16
    set_mem r29, r23 :: builtins.object*
    inc_ref r24
    r30 = r27 + 24
    set_mem r30, r24 :: builtins.object*
    r31 = dank_mids.brownie_patch.globals :: static
    r32 = '__all__'
    r33 = CPyDict_SetItem(r31, r32, r25)
    dec_ref r25
    r34 = r33 >= 0 :: signed
    if not r34 goto L56 (error at <module>:13) else goto L9 :: bool
L9:
    r35 = ('DankEth',)
    r36 = 'dank_mids.eth'
    r37 = dank_mids.brownie_patch.globals :: static
    r38 = CPyImport_ImportFromMany(r36, r35, r35, r37)
    if is_error(r38) goto L56 (error at <module>:15) else goto L10
L10:
    dank_mids.eth = r38 :: module
    dec_ref r38
    r39 = ('DankWeb3',)
    r40 = 'dank_mids.helpers._helpers'
    r41 = dank_mids.brownie_patch.globals :: static
    r42 = CPyImport_ImportFromMany(r40, r39, r39, r41)
    if is_error(r42) goto L56 (error at <module>:16) else goto L11
L11:
    dank_mids.helpers._helpers = r42 :: module
    dec_ref r42
    r43 = dank_mids.brownie_patch.globals :: static
    r44 = 'dank_web3'
    r45 = dank_mids.brownie_patch.globals :: static
    r46 = 'dank_eth'
    r47 = builtins :: module
    r48 = 'ImportError'
    r49 = CPyObject_GetAttr(r47, r48)
    if is_error(r49) goto L56 (error at <module>:33) else goto L12
L12:
    r50 = dank_mids.brownie_patch.globals :: static
    r51 = 'suppress'
    r52 = CPyDict_GetItem(r50, r51)
    if is_error(r52) goto L57 (error at <module>:33) else goto L13
L13:
    r53 = [r49]
    r54 = load_address r53
    r55 = _PyObject_Vectorcall(r52, r54, 1, 0)
    dec_ref r52
    if is_error(r55) goto L57 (error at <module>:33) else goto L14
L14:
    dec_ref r49
    r56 = PyObject_Type(r55)
    r57 = '__exit__'
    r58 = CPyObject_GetAttr(r56, r57)
    if is_error(r58) goto L58 (error at <module>:33) else goto L15
L15:
    r59 = '__enter__'
    r60 = CPyObject_GetAttr(r56, r59)
    dec_ref r56
    if is_error(r60) goto L59 (error at <module>:33) else goto L16
L16:
    r61 = [r55]
    r62 = load_address r61
    r63 = _PyObject_Vectorcall(r60, r62, 1, 0)
    dec_ref r60
    if is_error(r63) goto L59 (error at <module>:33) else goto L60
L17:
    r64 = 1
L18:
    r65 = ('network', 'web3')
    r66 = 'brownie'
    r67 = dank_mids.brownie_patch.globals :: static
    r68 = CPyImport_ImportFromMany(r66, r65, r65, r67)
    if is_error(r68) goto L35 (error at <module>:34) else goto L19
L19:
    brownie = r68 :: module
    dec_ref r68
    r69 = dank_mids.brownie_patch.globals :: static
    r70 = 'network'
    r71 = CPyDict_GetItem(r69, r70)
    if is_error(r71) goto L35 (error at <module>:36) else goto L20
L20:
    r72 = 'is_connected'
    r73 = [r71]
    r74 = load_address r73
    r75 = PyObject_VectorcallMethod(r72, r74, 9223372036854775809, 0)
    if is_error(r75) goto L61 (error at <module>:36) else goto L21
L21:
    dec_ref r71
    r76 = PyObject_IsTrue(r75)
    dec_ref r75
    r77 = r76 >= 0 :: signed
    if not r77 goto L35 (error at <module>:36) else goto L22 :: bool
L22:
    r78 = truncate r76: i32 to builtins.bool
    if r78 goto L23 else goto L43 :: bool
L23:
    r79 = ('Contract', 'patch_contract')
    r80 = 'dank_mids.brownie_patch.contract'
    r81 = dank_mids.brownie_patch.globals :: static
    r82 = CPyImport_ImportFromMany(r80, r79, r79, r81)
    if is_error(r82) goto L35 (error at <module>:37) else goto L24
L24:
    dank_mids.brownie_patch.contract = r82 :: module
    dec_ref r82
    r83 = dank_mids.brownie_patch.globals :: static
    r84 = 'web3'
    r85 = CPyDict_GetItem(r83, r84)
    if is_error(r85) goto L35 (error at <module>:39) else goto L25
L25:
    r86 = dank_mids.brownie_patch.globals :: static
    r87 = 'setup_dank_w3_from_sync'
    r88 = CPyDict_GetItem(r86, r87)
    if is_error(r88) goto L62 (error at <module>:39) else goto L26
L26:
    r89 = [r85]
    r90 = load_address r89
    r91 = _PyObject_Vectorcall(r88, r90, 1, 0)
    dec_ref r88
    if is_error(r91) goto L62 (error at <module>:39) else goto L27
L27:
    dec_ref r85
    r92 = dank_mids.brownie_patch.globals :: static
    r93 = 'dank_web3'
    r94 = CPyDict_SetItem(r92, r93, r91)
    dec_ref r91
    r95 = r94 >= 0 :: signed
    if not r95 goto L35 (error at <module>:39) else goto L28 :: bool
L28:
    r96 = dank_mids.brownie_patch.globals :: static
    r97 = 'dank_web3'
    r98 = CPyDict_GetItem(r96, r97)
    if is_error(r98) goto L35 (error at <module>:40) else goto L29
L29:
    r99 = 'eth'
    r100 = CPyObject_GetAttr(r98, r99)
    dec_ref r98
    if is_error(r100) goto L35 (error at <module>:40) else goto L30
L30:
    r101 = dank_mids.brownie_patch.globals :: static
    r102 = 'dank_eth'
    r103 = CPyDict_SetItem(r101, r102, r100)
    dec_ref r100
    r104 = r103 >= 0 :: signed
    if not r104 goto L35 (error at <module>:40) else goto L31 :: bool
L31:
    r105 = dank_mids.brownie_patch.globals :: static
    r106 = '__all__'
    r107 = CPyDict_GetItem(r105, r106)
    if is_error(r107) goto L35 (error at <module>:41) else goto L32
L32:
    r108 = 'Contract'
    r109 = 'patch_contract'
    r110 = 'dank_web3'
    r111 = 'dank_eth'
    r112 = PyList_New(4)
    if is_error(r112) goto L63 (error at <module>:41) else goto L33
L33:
    r113 = get_element_ptr r112 ob_item :: PyListObject
    r114 = load_mem r113 :: ptr*
    inc_ref r108
    set_mem r114, r108 :: builtins.object*
    inc_ref r109
    r115 = r114 + 8
    set_mem r115, r109 :: builtins.object*
    inc_ref r110
    r116 = r114 + 16
    set_mem r116, r110 :: builtins.object*
    inc_ref r111
    r117 = r114 + 24
    set_mem r117, r111 :: builtins.object*
    r118 = PyNumber_InPlaceAdd(r107, r112)
    dec_ref r107
    dec_ref r112
    if is_error(r118) goto L35 (error at <module>:41) else goto L34
L34:
    r119 = CPyDict_SetItem(r105, r106, r118)
    dec_ref r118
    r120 = r119 >= 0 :: signed
    if not r120 goto L35 (error at <module>:41) else goto L43 :: bool
L35:
    r121 = CPy_CatchError()
    r64 = 0
    r122 = CPy_GetExcInfo()
    r123 = r122[0]
    r124 = r122[1]
    r125 = r122[2]
    dec_ref r122
    r126 = [r55, r123, r124, r125]
    r127 = load_address r126
    r128 = _PyObject_Vectorcall(r58, r127, 4, 0)
    if is_error(r128) goto L64 (error at <module>:33) else goto L36
L36:
    dec_ref r123
    dec_ref r124
    dec_ref r125
    r129 = PyObject_IsTrue(r128)
    dec_ref r128
    r130 = r129 >= 0 :: signed
    if not r130 goto L41 (error at <module>:33) else goto L37 :: bool
L37:
    r131 = truncate r129: i32 to builtins.bool
    if r131 goto L40 else goto L38 :: bool
L38:
    CPy_Reraise()
    if not 0 goto L41 else goto L65 :: bool
L39:
    unreachable
L40:
    CPy_RestoreExcInfo(r121)
    dec_ref r121
    goto L43
L41:
    CPy_RestoreExcInfo(r121)
    dec_ref r121
    r132 = CPy_KeepPropagating()
    if not r132 goto L44 else goto L66 :: bool
L42:
    unreachable
L43:
    r133 = <error> :: tuple[object, object, object]
    r134 = r133
    goto L45
L44:
    r135 = CPy_CatchError()
    r134 = r135
L45:
    if r64 goto L46 else goto L67 :: bool
L46:
    r136 = load_address _Py_NoneStruct
    r137 = [r55, r136, r136, r136]
    r138 = load_address r137
    r139 = _PyObject_Vectorcall(r58, r138, 4, 0)
    dec_ref r58
    if is_error(r139) goto L68 (error at <module>:33) else goto L69
L47:
    dec_ref r55
L48:
    if is_error(r134) goto L55 else goto L49
L49:
    CPy_Reraise()
    if not 0 goto L51 else goto L70 :: bool
L50:
    unreachable
L51:
    if is_error(r134) goto L53 else goto L52
L52:
    CPy_RestoreExcInfo(r134)
    xdec_ref r134
L53:
    r140 = CPy_KeepPropagating()
    if not r140 goto L56 else goto L54 :: bool
L54:
    unreachable
L55:
    return 1
L56:
    r141 = <error> :: None
    return r141
L57:
    dec_ref r49
    goto L56
L58:
    dec_ref r55
    dec_ref r56
    goto L56
L59:
    dec_ref r55
    dec_ref r58
    goto L56
L60:
    dec_ref r63
    goto L17
L61:
    dec_ref r71
    goto L35
L62:
    dec_ref r85
    goto L35
L63:
    dec_ref r107
    goto L35
L64:
    dec_ref r123
    dec_ref r124
    dec_ref r125
    goto L41
L65:
    dec_ref r55
    dec_ref r58
    dec_ref r121
    goto L39
L66:
    dec_ref r55
    dec_ref r58
    goto L42
L67:
    dec_ref r55
    dec_ref r58
    goto L48
L68:
    dec_ref r55
    goto L51
L69:
    dec_ref r139
    goto L47
L70:
    xdec_ref r134
    goto L50

def UIDGenerator.__init__(self):
    self :: dank_mids._uid.UIDGenerator
    r0 :: str
    r1 :: dict
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6, r7 :: object
    r8 :: None
L0:
    self._value = -2
    r0 = 'uid'
    r1 = dank_mids._uid.globals :: static
    r2 = 'AlertingRLock'
    r3 = CPyDict_GetItem(r1, r2)
    if is_error(r3) goto L3 (error at __init__:24) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = ('name',)
    r7 = _PyObject_Vectorcall(r3, r5, 0, r6)
    dec_ref r3
    if is_error(r7) goto L3 (error at __init__:24) else goto L2
L2:
    self._lock = r7
    return 1
L3:
    r8 = <error> :: None
    return r8

def UIDGenerator.latest(self):
    self :: dank_mids._uid.UIDGenerator
    r0 :: int
L0:
    r0 = self._value
    return r0

def UIDGenerator.next(self):
    self :: dank_mids._uid.UIDGenerator
    r0, r1 :: object
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8 :: object
    r9, r10 :: int
    r11 :: bool
    r12, r13 :: tuple[object, object, object]
    r14 :: object
    r15 :: object[4]
    r16 :: object_ptr
    r17 :: object
    r18 :: bit
    r19 :: int
L0:
    r0 = self._lock
    r1 = PyObject_Type(r0)
    r2 = '__exit__'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L20 (error at next:48) else goto L1
L1:
    r4 = '__enter__'
    r5 = CPyObject_GetAttr(r1, r4)
    dec_ref r1
    if is_error(r5) goto L21 (error at next:48) else goto L2
L2:
    r6 = [r0]
    r7 = load_address r6
    r8 = _PyObject_Vectorcall(r5, r7, 1, 0)
    dec_ref r5
    if is_error(r8) goto L21 (error at next:48) else goto L22
L3:
L4:
    r9 = borrow self._value
    r10 = CPyTagged_Add(r9, 2)
    inc_ref r10 :: int
    self._value = r10
L5:
    r12 = <error> :: tuple[object, object, object]
    r13 = r12
L6:
    if 1 goto L7 else goto L23 :: bool
L7:
    r14 = load_address _Py_NoneStruct
    r15 = [r0, r14, r14, r14]
    r16 = load_address r15
    r17 = _PyObject_Vectorcall(r3, r16, 4, 0)
    dec_ref r3
    if is_error(r17) goto L24 (error at next:48) else goto L25
L8:
    dec_ref r0
L9:
    if is_error(r13) goto L12 else goto L26
L10:
    CPy_Reraise()
    if not 0 goto L14 else goto L27 :: bool
L11:
    unreachable
L12:
    if is_error(r10) goto L18 else goto L13
L13:
    return r10
L14:
    if is_error(r13) goto L16 else goto L15
L15:
    CPy_RestoreExcInfo(r13)
    xdec_ref r13
L16:
    r18 = CPy_KeepPropagating()
    if not r18 goto L19 else goto L17 :: bool
L17:
    unreachable
L18:
    unreachable
L19:
    r19 = <error> :: int
    return r19
L20:
    dec_ref r0
    dec_ref r1
    goto L19
L21:
    dec_ref r0
    dec_ref r3
    goto L19
L22:
    dec_ref r8
    goto L3
L23:
    dec_ref r0
    dec_ref r3
    goto L9
L24:
    dec_ref r0
    xdec_ref r10 :: int
    goto L14
L25:
    dec_ref r17
    goto L8
L26:
    xdec_ref r10 :: int
    goto L10
L27:
    xdec_ref r13
    goto L11

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11, r12 :: object
    r13 :: bool
    r14, r15, r16 :: str
    r17 :: tuple
    r18 :: i32
    r19 :: bit
    r20 :: dict
    r21 :: str
    r22 :: i32
    r23 :: bit
    r24 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L10 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('AlertingRLock',)
    r6 = 'dank_mids.helpers._lock'
    r7 = dank_mids._uid.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L10 (error at <module>:1) else goto L4
L4:
    dank_mids.helpers._lock = r8 :: module
    dec_ref r8
    r9 = <error> :: object
    r10 = 'dank_mids._uid'
    r11 = dank_mids._uid.UIDGenerator_template :: type
    r12 = CPyType_FromTemplate(r11, r9, r10)
    if is_error(r12) goto L10 (error at <module>:4) else goto L5
L5:
    r13 = UIDGenerator_trait_vtable_setup()
    if is_error(r13) goto L11 (error at <module>:-1) else goto L6
L6:
    r14 = '__mypyc_attrs__'
    r15 = '_value'
    r16 = '_lock'
    r17 = PyTuple_Pack(2, r15, r16)
    if is_error(r17) goto L11 (error at <module>:4) else goto L7
L7:
    r18 = PyObject_SetAttr(r12, r14, r17)
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L11 (error at <module>:4) else goto L8 :: bool
L8:
    dank_mids._uid.UIDGenerator = r12 :: type
    r20 = dank_mids._uid.globals :: static
    r21 = 'UIDGenerator'
    r22 = CPyDict_SetItem(r20, r21, r12)
    dec_ref r12
    r23 = r22 >= 0 :: signed
    if not r23 goto L10 (error at <module>:4) else goto L9 :: bool
L9:
    return 1
L10:
    r24 = <error> :: None
    return r24
L11:
    dec_ref r12
    goto L10

def coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    type, value, traceback, arg, r0, r1 :: object
    r2 :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_env
    r3 :: int
    r4 :: object
    r5 :: bit
    r6 :: dank_mids.brownie_patch.types.DankOverloadedMethod
    r7 :: tuple
    r8 :: str
    r9 :: object[2]
    r10 :: object_ptr
    r11 :: object
    r12 :: union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx]
    r13 :: bool
    r14 :: union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx]
    r15 :: tuple
    r16, r17 :: union[int, None]
    r18 :: union[dict, None]
    r19 :: str
    r20 :: object
    r21 :: list
    r22 :: object
    r23, r24, r25 :: str
    r26 :: tuple
    r27 :: dict
    r28, r29 :: object
    r30 :: bool
    r31, r32, r33, r34, r35 :: object
    r36 :: bool
    r37 :: object
    r38 :: bit
    r39 :: tuple[object, object, object]
    r40 :: bool
    r41 :: object_ptr
    r42 :: object
    r43, r44 :: bool
    r45 :: tuple[object, object, object]
    r46 :: bool
    r47, r48 :: tuple[object, object, object]
    r49 :: bit
    r50, r51, r52 :: object
    r53 :: bool
    r54, r55 :: bit
    r56 :: bool
    r57 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_env__
    if is_error(r2) goto L64 (error at coroutine:56) else goto L1
L1:
    r3 = r2.__mypyc_next_label__
    if is_error(r3) goto L65 (error at coroutine:56) else goto L59
L2:
    r4 = load_address _Py_NoneStruct
    r5 = type != r4
    if r5 goto L66 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L63 (error at coroutine:56) else goto L4 :: bool
L4:
    unreachable
L5:
    r6 = r2.self
    if is_error(r6) goto L65 (error at coroutine:74) else goto L6
L6:
    r7 = r2.args
    if is_error(r7) goto L67 (error at coroutine:74) else goto L7
L7:
    r8 = '_get_fn_from_args'
    r9 = [r6, r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775810, 0)
    if is_error(r11) goto L68 (error at coroutine:74) else goto L8
L8:
    dec_ref r6
    dec_ref r7
    r12 = cast(union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx], r11)
    if is_error(r12) goto L65 (error at coroutine:74) else goto L9
L9:
    r2.call = r12; r13 = is_error
    if not r13 goto L65 (error at coroutine:74) else goto L10 :: bool
L10:
    r14 = r2.call
    if is_error(r14) goto L65 (error at coroutine:75) else goto L11
L11:
    r15 = r2.args
    if is_error(r15) goto L69 (error at coroutine:76) else goto L12
L12:
    r16 = r2.block_identifier
    if is_error(r16) goto L70 (error at coroutine:76) else goto L13
L13:
    r17 = r2.decimals
    if is_error(r17) goto L71 (error at coroutine:76) else goto L14
L14:
    r18 = r2.override
    if is_error(r18) goto L72 (error at coroutine:76) else goto L15
L15:
    r19 = 'coroutine'
    r20 = CPyObject_GetAttr(r14, r19)
    dec_ref r14
    if is_error(r20) goto L73 (error at coroutine:75) else goto L16
L16:
    r21 = PyList_New(0)
    if is_error(r21) goto L74 (error at coroutine:75) else goto L17
L17:
    r22 = CPyList_Extend(r21, r15)
    dec_ref r15
    if is_error(r22) goto L75 (error at coroutine:75) else goto L76
L18:
    r23 = 'block_identifier'
    r24 = 'decimals'
    r25 = 'override'
    r26 = PyList_AsTuple(r21)
    dec_ref r21
    if is_error(r26) goto L77 (error at coroutine:75) else goto L19
L19:
    r27 = CPyDict_Build(3, r23, r16, r24, r17, r25, r18)
    dec_ref r16
    dec_ref r17
    dec_ref r18
    if is_error(r27) goto L78 (error at coroutine:75) else goto L20
L20:
    r28 = PyObject_Call(r20, r26, r27)
    dec_ref r20
    dec_ref r26
    dec_ref r27
    if is_error(r28) goto L65 (error at coroutine:75) else goto L21
L21:
    r29 = CPy_GetCoro(r28)
    dec_ref r28
    if is_error(r29) goto L65 (error at coroutine:75) else goto L22
L22:
    r2.__mypyc_temp__0 = r29; r30 = is_error
    if not r30 goto L65 (error at coroutine:-1) else goto L23 :: bool
L23:
    r31 = r2.__mypyc_temp__0
    if is_error(r31) goto L65 (error at coroutine:-1) else goto L24
L24:
    r32 = CPyIter_Next(r31)
    dec_ref r31
    if is_error(r32) goto L79 else goto L27
L25:
    r33 = CPy_FetchStopIterationValue()
    if is_error(r33) goto L80 (error at coroutine:75) else goto L26
L26:
    r34 = r33
    goto L56
L27:
    r35 = r32
L28:
    r2.__mypyc_next_label__ = 2; r36 = is_error
    if not r36 goto L81 (error at coroutine:75) else goto L82 :: bool
L29:
    return r35
L30:
    r37 = load_address _Py_NoneStruct
    r38 = type != r37
    if r38 goto L31 else goto L33 :: bool
L31:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L34 (error at coroutine:75) else goto L83 :: bool
L32:
    unreachable
L33:
    inc_ref arg
    goto L51
L34:
    r39 = CPy_CatchError()
    r2.__mypyc_temp__1 = r39; r40 = is_error
    if not r40 goto L84 (error at coroutine:-1) else goto L35 :: bool
L35:
    r41 = load_address r1
    r42 = r2.__mypyc_temp__0
    if is_error(r42) goto L84 (error at coroutine:-1) else goto L36
L36:
    r43 = CPy_YieldFromErrorHandle(r42, r41)
    dec_ref r42
    if is_error(r43) goto L84 (error at coroutine:75) else goto L37
L37:
    if r43 goto L43 else goto L38 :: bool
L38:
    if is_error(r1) goto L39 else goto L41
L39:
    r44 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r44 goto L48 (error at coroutine:-1) else goto L85 :: bool
L40:
    unreachable
L41:
    inc_ref r1
    r35 = r1
    r45 = r2.__mypyc_temp__1
    if is_error(r45) goto L86 (error at coroutine:-1) else goto L42
L42:
    CPy_RestoreExcInfo(r45)
    dec_ref r45
    goto L28
L43:
    if is_error(r1) goto L44 else goto L46
L44:
    r46 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r46 goto L48 (error at coroutine:-1) else goto L87 :: bool
L45:
    unreachable
L46:
    r34 = r1
    r47 = r2.__mypyc_temp__1
    if is_error(r47) goto L88 (error at coroutine:-1) else goto L47
L47:
    CPy_RestoreExcInfo(r47)
    dec_ref r47
    goto L56
L48:
    r48 = r2.__mypyc_temp__1
    dec_ref r2
    if is_error(r48) goto L63 (error at coroutine:-1) else goto L49
L49:
    CPy_RestoreExcInfo(r48)
    dec_ref r48
    r49 = CPy_KeepPropagating()
    if not r49 goto L63 else goto L50 :: bool
L50:
    unreachable
L51:
    r50 = r2.__mypyc_temp__0
    if is_error(r50) goto L89 (error at coroutine:-1) else goto L52
L52:
    r51 = CPyIter_Send(r50, arg)
    dec_ref r50
    dec_ref arg
    if is_error(r51) goto L90 else goto L53
L53:
    r35 = r51
    goto L28
L54:
    r52 = CPy_FetchStopIterationValue()
    if is_error(r52) goto L80 (error at coroutine:75) else goto L55
L55:
    r34 = r52
L56:
    r2.__mypyc_next_label__ = -2; r53 = is_error
    dec_ref r2
    if not r53 goto L91 (error at coroutine:75) else goto L57 :: bool
L57:
    CPyGen_SetStopIterationValue(r34)
    dec_ref r34
    if not 0 goto L63 else goto L58 :: bool
L58:
    unreachable
L59:
    r54 = r3 == 0
    if r54 goto L92 else goto L60 :: bool
L60:
    r55 = r3 == 2
    dec_ref r3 :: int
    if r55 goto L30 else goto L93 :: bool
L61:
    r56 = raise StopIteration
    if not r56 goto L63 (error at coroutine:56) else goto L62 :: bool
L62:
    unreachable
L63:
    r57 = <error> :: object
    return r57
L64:
    xdec_ref r1
    goto L63
L65:
    xdec_ref r1
    dec_ref r2
    goto L63
L66:
    xdec_ref r1
    dec_ref r2
    goto L3
L67:
    xdec_ref r1
    dec_ref r2
    dec_ref r6
    goto L63
L68:
    xdec_ref r1
    dec_ref r2
    dec_ref r6
    dec_ref r7
    goto L63
L69:
    xdec_ref r1
    dec_ref r2
    dec_ref r14
    goto L63
L70:
    xdec_ref r1
    dec_ref r2
    dec_ref r14
    dec_ref r15
    goto L63
L71:
    xdec_ref r1
    dec_ref r2
    dec_ref r14
    dec_ref r15
    dec_ref r16
    goto L63
L72:
    xdec_ref r1
    dec_ref r2
    dec_ref r14
    dec_ref r15
    dec_ref r16
    dec_ref r17
    goto L63
L73:
    xdec_ref r1
    dec_ref r2
    dec_ref r15
    dec_ref r16
    dec_ref r17
    dec_ref r18
    goto L63
L74:
    xdec_ref r1
    dec_ref r2
    dec_ref r15
    dec_ref r16
    dec_ref r17
    dec_ref r18
    dec_ref r20
    goto L63
L75:
    xdec_ref r1
    dec_ref r2
    dec_ref r16
    dec_ref r17
    dec_ref r18
    dec_ref r20
    dec_ref r21
    goto L63
L76:
    dec_ref r22
    goto L18
L77:
    xdec_ref r1
    dec_ref r2
    dec_ref r16
    dec_ref r17
    dec_ref r18
    dec_ref r20
    goto L63
L78:
    xdec_ref r1
    dec_ref r2
    dec_ref r20
    dec_ref r26
    goto L63
L79:
    xdec_ref r1
    goto L25
L80:
    dec_ref r2
    goto L63
L81:
    dec_ref r35
    goto L34
L82:
    xdec_ref r1
    dec_ref r2
    goto L29
L83:
    xdec_ref r1
    dec_ref r2
    goto L32
L84:
    xdec_ref r1
    goto L48
L85:
    dec_ref r2
    goto L40
L86:
    xdec_ref r1
    dec_ref r35
    goto L48
L87:
    dec_ref r2
    goto L45
L88:
    dec_ref r34
    goto L48
L89:
    xdec_ref r1
    dec_ref r2
    dec_ref arg
    goto L63
L90:
    xdec_ref r1
    goto L54
L91:
    dec_ref r34
    goto L63
L92:
    dec_ref r3 :: int
    goto L2
L93:
    xdec_ref r1
    dec_ref r2
    goto L61

def coroutine_DankOverloadedMethod_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine_DankOverloadedMethod_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine_DankOverloadedMethod_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine_DankOverloadedMethod_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutine_DankOverloadedMethod_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def coroutine_DankOverloadedMethod_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def DankOverloadedMethod.coroutine(self, args, block_identifier, decimals, override):
    self :: dank_mids.brownie_patch.types.DankOverloadedMethod
    args :: tuple
    block_identifier, decimals :: union[int, None]
    override :: union[dict, None]
    r0, r1, r2 :: object
    r3 :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_env
    r4, r5, r6, r7, r8 :: bool
    r9 :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    r10, r11 :: bool
    r12 :: object
L0:
    if is_error(block_identifier) goto L1 else goto L17
L1:
    r0 = box(None, 1)
    inc_ref r0
    block_identifier = r0
L2:
    if is_error(decimals) goto L3 else goto L18
L3:
    r1 = box(None, 1)
    inc_ref r1
    decimals = r1
L4:
    if is_error(override) goto L5 else goto L19
L5:
    r2 = box(None, 1)
    inc_ref r2
    override = r2
L6:
    r3 = coroutine_DankOverloadedMethod_env()
    if is_error(r3) goto L20 (error at coroutine:56) else goto L7
L7:
    inc_ref self
    r3.self = self; r4 = is_error
    if not r4 goto L21 (error at coroutine:56) else goto L8 :: bool
L8:
    inc_ref args
    r3.args = args; r5 = is_error
    if not r5 goto L21 (error at coroutine:56) else goto L9 :: bool
L9:
    r3.block_identifier = block_identifier; r6 = is_error
    if not r6 goto L22 (error at coroutine:56) else goto L10 :: bool
L10:
    r3.decimals = decimals; r7 = is_error
    if not r7 goto L23 (error at coroutine:56) else goto L11 :: bool
L11:
    r3.override = override; r8 = is_error
    if not r8 goto L24 (error at coroutine:56) else goto L12 :: bool
L12:
    r9 = coroutine_DankOverloadedMethod_gen()
    if is_error(r9) goto L24 (error at coroutine:56) else goto L13
L13:
    inc_ref r3
    r9.__mypyc_env__ = r3; r10 = is_error
    if not r10 goto L25 (error at coroutine:56) else goto L14 :: bool
L14:
    r3.__mypyc_next_label__ = 0; r11 = is_error
    dec_ref r3
    if not r11 goto L26 (error at coroutine:56) else goto L15 :: bool
L15:
    return r9
L16:
    r12 = <error> :: object
    return r12
L17:
    inc_ref block_identifier
    goto L2
L18:
    inc_ref decimals
    goto L4
L19:
    inc_ref override
    goto L6
L20:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    goto L16
L21:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r3
    goto L16
L22:
    dec_ref decimals
    dec_ref override
    dec_ref r3
    goto L16
L23:
    dec_ref override
    dec_ref r3
    goto L16
L24:
    dec_ref r3
    goto L16
L25:
    dec_ref r3
    dec_ref r9
    goto L16
L26:
    dec_ref r9
    goto L16

def DankOverloadedMethod._add_fn(self, abi, natspec):
    self :: dank_mids.brownie_patch.types.DankOverloadedMethod
    abi, natspec :: dict
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6, r7 :: str
    r8 :: object
    r9 :: list
    r10 :: str
    r11, r12, r13 :: object
    r14 :: str
    r15 :: object
    r16, r17, r18 :: str
    r19 :: object[3]
    r20 :: object_ptr
    r21 :: object
    r22 :: i32
    r23, r24 :: bit
    r25 :: tuple
    r26 :: dict
    r27 :: i32
    r28 :: bit
    r29 :: str
    r30 :: object
    r31 :: str
    r32 :: object[2]
    r33 :: object_ptr
    r34 :: object
    r35 :: None
L0:
    r0 = '_address'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L20 (error at _add_fn:90) else goto L1
L1:
    r2 = '_name'
    r3 = CPyObject_GetAttr(self, r2)
    if is_error(r3) goto L21 (error at _add_fn:90) else goto L2
L2:
    r4 = '_owner'
    r5 = CPyObject_GetAttr(self, r4)
    if is_error(r5) goto L22 (error at _add_fn:90) else goto L3
L3:
    r6 = cast(str, r1)
    if is_error(r6) goto L23 (error at _add_fn:90) else goto L4
L4:
    r7 = cast(str, r3)
    if is_error(r7) goto L24 (error at _add_fn:90) else goto L5
L5:
    r8 = _get_method_object(r6, abi, r7, r5, natspec)
    dec_ref r6
    dec_ref r7
    dec_ref r5
    if is_error(r8) goto L20 (error at _add_fn:90) else goto L6
L6:
    r9 = PyList_New(0)
    if is_error(r9) goto L25 (error at _add_fn:91) else goto L7
L7:
    r10 = 'inputs'
    r11 = CPyDict_GetItem(abi, r10)
    if is_error(r11) goto L26 (error at _add_fn:91) else goto L8
L8:
    r12 = PyObject_GetIter(r11)
    dec_ref r11
    if is_error(r12) goto L26 (error at _add_fn:91) else goto L9
L9:
    r13 = PyIter_Next(r12)
    if is_error(r13) goto L27 else goto L10
L10:
    r14 = 'type'
    r15 = PyObject_GetItem(r13, r14)
    dec_ref r13
    if is_error(r15) goto L28 (error at _add_fn:91) else goto L11
L11:
    r16 = '256'
    r17 = ''
    r18 = 'replace'
    r19 = [r15, r16, r17]
    r20 = load_address r19
    r21 = PyObject_VectorcallMethod(r18, r20, 9223372036854775811, 0)
    if is_error(r21) goto L29 (error at _add_fn:91) else goto L12
L12:
    dec_ref r15
    r22 = PyList_Append(r9, r21)
    dec_ref r21
    r23 = r22 >= 0 :: signed
    if not r23 goto L28 (error at _add_fn:91) else goto L9 :: bool
L13:
    r24 = CPy_NoErrOccurred()
    if not r24 goto L26 (error at _add_fn:91) else goto L14 :: bool
L14:
    r25 = PyList_AsTuple(r9)
    dec_ref r9
    if is_error(r25) goto L25 (error at _add_fn:91) else goto L15
L15:
    r26 = self.methods
    if is_error(r26) goto L30 (error at _add_fn:92) else goto L16
L16:
    r27 = CPyDict_SetItem(r26, r25, r8)
    dec_ref r26
    dec_ref r25
    dec_ref r8
    r28 = r27 >= 0 :: signed
    if not r28 goto L20 (error at _add_fn:92) else goto L17 :: bool
L17:
    r29 = 'natspec'
    r30 = CPyObject_GetAttr(self, r29)
    if is_error(r30) goto L20 (error at _add_fn:93) else goto L18
L18:
    r31 = 'update'
    r32 = [r30, natspec]
    r33 = load_address r32
    r34 = PyObject_VectorcallMethod(r31, r33, 9223372036854775810, 0)
    if is_error(r34) goto L31 (error at _add_fn:93) else goto L32
L19:
    dec_ref r30
    return 1
L20:
    r35 = <error> :: None
    return r35
L21:
    dec_ref r1
    goto L20
L22:
    dec_ref r1
    dec_ref r3
    goto L20
L23:
    dec_ref r3
    dec_ref r5
    goto L20
L24:
    dec_ref r5
    dec_ref r6
    goto L20
L25:
    dec_ref r8
    goto L20
L26:
    dec_ref r8
    dec_ref r9
    goto L20
L27:
    dec_ref r12
    goto L13
L28:
    dec_ref r8
    dec_ref r9
    dec_ref r12
    goto L20
L29:
    dec_ref r8
    dec_ref r9
    dec_ref r12
    dec_ref r15
    goto L20
L30:
    dec_ref r8
    dec_ref r25
    goto L20
L31:
    dec_ref r30
    goto L20
L32:
    dec_ref r34
    goto L19

def _get_method_object(address, abi, name, owner, natspec):
    address :: str
    abi :: dict
    name :: str
    owner :: union[object, None]
    natspec :: dict
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4 :: str
    r5, constant :: object
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10, r11 :: bool
    r12 :: str
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: bool
    r17 :: object
    r18 :: i32
    r19 :: bit
    r20 :: bool
    r21 :: tuple
    r22 :: dict
    r23 :: dank_mids.brownie_patch.types.DankContractCall
    r24 :: tuple
    r25 :: dict
    r26 :: dank_mids.brownie_patch.types.DankContractTx
    r27 :: object
L0:
    r0 = 'constant'
    r1 = PyDict_Contains(abi, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L24 (error at _get_method_object:125) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L2 else goto L4 :: bool
L2:
    r4 = 'constant'
    r5 = CPyDict_GetItem(abi, r4)
    if is_error(r5) goto L24 (error at _get_method_object:126) else goto L3
L3:
    constant = r5
    goto L14
L4:
    r6 = 'stateMutability'
    r7 = CPyDict_GetItem(abi, r6)
    if is_error(r7) goto L24 (error at _get_method_object:128) else goto L5
L5:
    r8 = 'view'
    r9 = PyObject_RichCompare(r7, r8, 2)
    dec_ref r7
    if is_error(r9) goto L24 (error at _get_method_object:-1) else goto L6
L6:
    r10 = unbox(bool, r9)
    dec_ref r9
    if is_error(r10) goto L24 (error at _get_method_object:-1) else goto L7
L7:
    if r10 goto L8 else goto L9 :: bool
L8:
    r11 = r10
    goto L13
L9:
    r12 = 'stateMutability'
    r13 = CPyDict_GetItem(abi, r12)
    if is_error(r13) goto L24 (error at _get_method_object:128) else goto L10
L10:
    r14 = 'pure'
    r15 = PyObject_RichCompare(r13, r14, 2)
    dec_ref r13
    if is_error(r15) goto L24 (error at _get_method_object:-1) else goto L11
L11:
    r16 = unbox(bool, r15)
    dec_ref r15
    if is_error(r16) goto L24 (error at _get_method_object:-1) else goto L12
L12:
    r11 = r16
L13:
    r17 = box(bool, r11)
    inc_ref r17
    constant = r17
L14:
    r18 = PyObject_IsTrue(constant)
    dec_ref constant
    r19 = r18 >= 0 :: signed
    if not r19 goto L24 (error at _get_method_object:126) else goto L15 :: bool
L15:
    r20 = truncate r18: i32 to builtins.bool
    if r20 goto L16 else goto L20 :: bool
L16:
    r21 = PyTuple_Pack(5, address, abi, name, owner, natspec)
    if is_error(r21) goto L24 (error at _get_method_object:131) else goto L17
L17:
    r22 = PyDict_New()
    if is_error(r22) goto L25 (error at _get_method_object:131) else goto L18
L18:
    r23 = DankContractCall(r21, r22)
    dec_ref r21
    dec_ref r22
    if is_error(r23) goto L24 (error at _get_method_object:131) else goto L19
L19:
    return r23
L20:
    r24 = PyTuple_Pack(5, address, abi, name, owner, natspec)
    if is_error(r24) goto L24 (error at _get_method_object:132) else goto L21
L21:
    r25 = PyDict_New()
    if is_error(r25) goto L26 (error at _get_method_object:132) else goto L22
L22:
    r26 = DankContractTx(r24, r25)
    dec_ref r24
    dec_ref r25
    if is_error(r26) goto L24 (error at _get_method_object:132) else goto L23
L23:
    return r26
L24:
    r27 = <error> :: object
    return r27
L25:
    dec_ref r21
    goto L24
L26:
    dec_ref r24
    goto L24

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20 :: object
    r21 :: str
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: object[1]
    r26 :: object_ptr
    r27 :: object
    r28 :: dict
    r29 :: str
    r30 :: i32
    r31 :: bit
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: dict
    r36 :: str
    r37 :: object
    r38 :: dict
    r39 :: str
    r40 :: object
    r41 :: dict
    r42 :: str
    r43 :: object
    r44 :: tuple[object, object, object]
    r45, r46 :: object
    r47 :: dict
    r48 :: str
    r49 :: i32
    r50 :: bit
    r51 :: dict
    r52 :: str
    r53 :: object
    r54 :: dict
    r55 :: str
    r56 :: object
    r57 :: tuple
    r58 :: str
    r59, r60 :: object
    r61 :: bool
    r62, r63 :: str
    r64 :: tuple
    r65 :: i32
    r66 :: bit
    r67 :: dict
    r68 :: str
    r69 :: i32
    r70 :: bit
    r71 :: dict
    r72 :: str
    r73 :: object
    r74 :: dict
    r75 :: str
    r76 :: object
    r77 :: tuple
    r78 :: str
    r79, r80 :: object
    r81 :: bool
    r82, r83 :: str
    r84 :: tuple
    r85 :: i32
    r86 :: bit
    r87 :: dict
    r88 :: str
    r89 :: i32
    r90 :: bit
    r91 :: dict
    r92 :: str
    r93, r94, r95 :: object
    r96 :: tuple[object, object]
    r97, r98 :: object
    r99 :: dict
    r100 :: str
    r101 :: i32
    r102 :: bit
    r103 :: dict
    r104 :: str
    r105 :: object
    r106 :: dict
    r107 :: str
    r108 :: object
    r109 :: dict
    r110 :: str
    r111, r112 :: object
    r113 :: tuple
    r114 :: str
    r115, r116 :: object
    r117 :: bool
    r118, r119, r120 :: str
    r121 :: tuple
    r122 :: i32
    r123 :: bit
    r124 :: dict
    r125 :: str
    r126 :: i32
    r127 :: bit
    r128 :: dict
    r129 :: str
    r130, r131, r132, r133 :: object
    r134 :: tuple[object, object, object]
    r135, r136 :: object
    r137 :: dict
    r138 :: str
    r139 :: i32
    r140 :: bit
    r141 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L49 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Dict', 'Optional', 'Tuple', 'TypeVar', 'Union', 'final')
    r6 = 'typing'
    r7 = dank_mids.brownie_patch.types.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L49 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ContractCall', 'ContractTx', 'OverloadedMethod')
    r10 = 'brownie.network.contract'
    r11 = dank_mids.brownie_patch.types.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L49 (error at <module>:3) else goto L5
L5:
    brownie.network.contract = r12 :: module
    dec_ref r12
    r13 = ('AccountsType',)
    r14 = 'brownie.typing'
    r15 = dank_mids.brownie_patch.types.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L49 (error at <module>:4) else goto L6
L6:
    brownie.typing = r16 :: module
    dec_ref r16
    r17 = ('_DankMethod', '_DankMethodMixin', '_EVMType')
    r18 = 'dank_mids.brownie_patch._method'
    r19 = dank_mids.brownie_patch.types.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L49 (error at <module>:6) else goto L7
L7:
    dank_mids.brownie_patch._method = r20 :: module
    dec_ref r20
    r21 = '_T'
    r22 = dank_mids.brownie_patch.types.globals :: static
    r23 = 'TypeVar'
    r24 = CPyDict_GetItem(r22, r23)
    if is_error(r24) goto L49 (error at <module>:9) else goto L8
L8:
    r25 = [r21]
    r26 = load_address r25
    r27 = _PyObject_Vectorcall(r24, r26, 1, 0)
    dec_ref r24
    if is_error(r27) goto L49 (error at <module>:9) else goto L9
L9:
    r28 = dank_mids.brownie_patch.types.globals :: static
    r29 = '_T'
    r30 = CPyDict_SetItem(r28, r29, r27)
    dec_ref r27
    r31 = r30 >= 0 :: signed
    if not r31 goto L49 (error at <module>:9) else goto L10 :: bool
L10:
    r32 = dank_mids.brownie_patch.types.globals :: static
    r33 = 'Union'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L49 (error at <module>:11) else goto L11
L11:
    r35 = dank_mids.brownie_patch.types.globals :: static
    r36 = 'ContractCall'
    r37 = CPyDict_GetItem(r35, r36)
    if is_error(r37) goto L50 (error at <module>:11) else goto L12
L12:
    r38 = dank_mids.brownie_patch.types.globals :: static
    r39 = 'ContractTx'
    r40 = CPyDict_GetItem(r38, r39)
    if is_error(r40) goto L51 (error at <module>:11) else goto L13
L13:
    r41 = dank_mids.brownie_patch.types.globals :: static
    r42 = 'OverloadedMethod'
    r43 = CPyDict_GetItem(r41, r42)
    if is_error(r43) goto L52 (error at <module>:11) else goto L14
L14:
    r44 = (r37, r40, r43)
    r45 = box(tuple[object, object, object], r44)
    r46 = PyObject_GetItem(r34, r45)
    dec_ref r34
    dec_ref r45
    if is_error(r46) goto L49 (error at <module>:11) else goto L15
L15:
    r47 = dank_mids.brownie_patch.types.globals :: static
    r48 = 'ContractMethod'
    r49 = CPyDict_SetItem(r47, r48, r46)
    dec_ref r46
    r50 = r49 >= 0 :: signed
    if not r50 goto L49 (error at <module>:11) else goto L16 :: bool
L16:
    r51 = dank_mids.brownie_patch.types.globals :: static
    r52 = '_DankMethod'
    r53 = CPyDict_GetItem(r51, r52)
    if is_error(r53) goto L49 (error at <module>:16) else goto L17
L17:
    r54 = dank_mids.brownie_patch.types.globals :: static
    r55 = 'ContractCall'
    r56 = CPyDict_GetItem(r54, r55)
    if is_error(r56) goto L53 (error at <module>:16) else goto L18
L18:
    r57 = PyTuple_Pack(2, r53, r56)
    dec_ref r53
    dec_ref r56
    if is_error(r57) goto L49 (error at <module>:16) else goto L19
L19:
    r58 = 'dank_mids.brownie_patch.types'
    r59 = dank_mids.brownie_patch.types.DankContractCall_template :: type
    r60 = CPyType_FromTemplate(r59, r57, r58)
    dec_ref r57
    if is_error(r60) goto L49 (error at <module>:16) else goto L20
L20:
    r61 = DankContractCall_trait_vtable_setup()
    if is_error(r61) goto L54 (error at <module>:-1) else goto L21
L21:
    r62 = '__mypyc_attrs__'
    r63 = '__dict__'
    r64 = PyTuple_Pack(1, r63)
    if is_error(r64) goto L54 (error at <module>:16) else goto L22
L22:
    r65 = PyObject_SetAttr(r60, r62, r64)
    dec_ref r64
    r66 = r65 >= 0 :: signed
    if not r66 goto L54 (error at <module>:16) else goto L23 :: bool
L23:
    dank_mids.brownie_patch.types.DankContractCall = r60 :: type
    r67 = dank_mids.brownie_patch.types.globals :: static
    r68 = 'DankContractCall'
    r69 = CPyDict_SetItem(r67, r68, r60)
    dec_ref r60
    r70 = r69 >= 0 :: signed
    if not r70 goto L49 (error at <module>:16) else goto L24 :: bool
L24:
    r71 = dank_mids.brownie_patch.types.globals :: static
    r72 = '_DankMethod'
    r73 = CPyDict_GetItem(r71, r72)
    if is_error(r73) goto L49 (error at <module>:28) else goto L25
L25:
    r74 = dank_mids.brownie_patch.types.globals :: static
    r75 = 'ContractTx'
    r76 = CPyDict_GetItem(r74, r75)
    if is_error(r76) goto L55 (error at <module>:28) else goto L26
L26:
    r77 = PyTuple_Pack(2, r73, r76)
    dec_ref r73
    dec_ref r76
    if is_error(r77) goto L49 (error at <module>:28) else goto L27
L27:
    r78 = 'dank_mids.brownie_patch.types'
    r79 = dank_mids.brownie_patch.types.DankContractTx_template :: type
    r80 = CPyType_FromTemplate(r79, r77, r78)
    dec_ref r77
    if is_error(r80) goto L49 (error at <module>:28) else goto L28
L28:
    r81 = DankContractTx_trait_vtable_setup()
    if is_error(r81) goto L56 (error at <module>:-1) else goto L29
L29:
    r82 = '__mypyc_attrs__'
    r83 = '__dict__'
    r84 = PyTuple_Pack(1, r83)
    if is_error(r84) goto L56 (error at <module>:28) else goto L30
L30:
    r85 = PyObject_SetAttr(r80, r82, r84)
    dec_ref r84
    r86 = r85 >= 0 :: signed
    if not r86 goto L56 (error at <module>:28) else goto L31 :: bool
L31:
    dank_mids.brownie_patch.types.DankContractTx = r80 :: type
    r87 = dank_mids.brownie_patch.types.globals :: static
    r88 = 'DankContractTx'
    r89 = CPyDict_SetItem(r87, r88, r80)
    dec_ref r80
    r90 = r89 >= 0 :: signed
    if not r90 goto L49 (error at <module>:28) else goto L32 :: bool
L32:
    r91 = dank_mids.brownie_patch.types.globals :: static
    r92 = 'Union'
    r93 = CPyDict_GetItem(r91, r92)
    if is_error(r93) goto L49 (error at <module>:39) else goto L33
L33:
    r94 = dank_mids.brownie_patch.types.DankContractCall :: type
    r95 = dank_mids.brownie_patch.types.DankContractTx :: type
    inc_ref r94
    inc_ref r95
    r96 = (r94, r95)
    r97 = box(tuple[object, object], r96)
    r98 = PyObject_GetItem(r93, r97)
    dec_ref r93
    dec_ref r97
    if is_error(r98) goto L49 (error at <module>:39) else goto L34
L34:
    r99 = dank_mids.brownie_patch.types.globals :: static
    r100 = '_NonOverloaded'
    r101 = CPyDict_SetItem(r99, r100, r98)
    dec_ref r98
    r102 = r101 >= 0 :: signed
    if not r102 goto L49 (error at <module>:39) else goto L35 :: bool
L35:
    r103 = dank_mids.brownie_patch.types.globals :: static
    r104 = 'OverloadedMethod'
    r105 = CPyDict_GetItem(r103, r104)
    if is_error(r105) goto L49 (error at <module>:44) else goto L36
L36:
    r106 = dank_mids.brownie_patch.types.globals :: static
    r107 = '_DankMethodMixin'
    r108 = CPyDict_GetItem(r106, r107)
    if is_error(r108) goto L57 (error at <module>:44) else goto L37
L37:
    r109 = dank_mids.brownie_patch.types.globals :: static
    r110 = '_T'
    r111 = CPyDict_GetItem(r109, r110)
    if is_error(r111) goto L58 (error at <module>:44) else goto L38
L38:
    r112 = PyObject_GetItem(r108, r111)
    dec_ref r108
    dec_ref r111
    if is_error(r112) goto L57 (error at <module>:44) else goto L39
L39:
    r113 = PyTuple_Pack(2, r105, r112)
    dec_ref r105
    dec_ref r112
    if is_error(r113) goto L49 (error at <module>:44) else goto L40
L40:
    r114 = 'dank_mids.brownie_patch.types'
    r115 = dank_mids.brownie_patch.types.DankOverloadedMethod_template :: type
    r116 = CPyType_FromTemplate(r115, r113, r114)
    dec_ref r113
    if is_error(r116) goto L49 (error at <module>:44) else goto L41
L41:
    r117 = DankOverloadedMethod_trait_vtable_setup()
    if is_error(r117) goto L59 (error at <module>:-1) else goto L42
L42:
    r118 = '__mypyc_attrs__'
    r119 = 'methods'
    r120 = '__dict__'
    r121 = PyTuple_Pack(2, r119, r120)
    if is_error(r121) goto L59 (error at <module>:44) else goto L43
L43:
    r122 = PyObject_SetAttr(r116, r118, r121)
    dec_ref r121
    r123 = r122 >= 0 :: signed
    if not r123 goto L59 (error at <module>:44) else goto L44 :: bool
L44:
    dank_mids.brownie_patch.types.DankOverloadedMethod = r116 :: type
    r124 = dank_mids.brownie_patch.types.globals :: static
    r125 = 'DankOverloadedMethod'
    r126 = CPyDict_SetItem(r124, r125, r116)
    dec_ref r116
    r127 = r126 >= 0 :: signed
    if not r127 goto L49 (error at <module>:44) else goto L45 :: bool
L45:
    r128 = dank_mids.brownie_patch.types.globals :: static
    r129 = 'Union'
    r130 = CPyDict_GetItem(r128, r129)
    if is_error(r130) goto L49 (error at <module>:96) else goto L46
L46:
    r131 = dank_mids.brownie_patch.types.DankContractCall :: type
    r132 = dank_mids.brownie_patch.types.DankContractTx :: type
    r133 = dank_mids.brownie_patch.types.DankOverloadedMethod :: type
    inc_ref r131
    inc_ref r132
    inc_ref r133
    r134 = (r131, r132, r133)
    r135 = box(tuple[object, object, object], r134)
    r136 = PyObject_GetItem(r130, r135)
    dec_ref r130
    dec_ref r135
    if is_error(r136) goto L49 (error at <module>:96) else goto L47
L47:
    r137 = dank_mids.brownie_patch.types.globals :: static
    r138 = 'DankContractMethod'
    r139 = CPyDict_SetItem(r137, r138, r136)
    dec_ref r136
    r140 = r139 >= 0 :: signed
    if not r140 goto L49 (error at <module>:96) else goto L48 :: bool
L48:
    return 1
L49:
    r141 = <error> :: None
    return r141
L50:
    dec_ref r34
    goto L49
L51:
    dec_ref r34
    dec_ref r37
    goto L49
L52:
    dec_ref r34
    dec_ref r37
    dec_ref r40
    goto L49
L53:
    dec_ref r53
    goto L49
L54:
    dec_ref r60
    goto L49
L55:
    dec_ref r73
    goto L49
L56:
    dec_ref r80
    goto L49
L57:
    dec_ref r105
    goto L49
L58:
    dec_ref r105
    dec_ref r108
    goto L49
L59:
    dec_ref r116
    goto L49

def coroutine__patch_overloaded_method_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def coroutine__patch_overloaded_method_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    type, value, traceback, arg, r0, r1 :: object
    r2 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_env
    r3 :: int
    r4 :: dank_mids.brownie_patch.overloaded._patch_overloaded_method_env
    r5 :: object
    r6 :: bit
    r7 :: object
    r8 :: tuple
    r9 :: str
    r10 :: object[2]
    r11 :: object_ptr
    r12 :: object
    r13 :: bool
    r14 :: tuple[object, object, object]
    r15 :: bool
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: bit
    r20 :: object
    r21 :: bool
    r22 :: object
    r23 :: str
    r24 :: bool
    r25 :: str
    r26 :: object
    r27 :: str
    r28 :: object
    r29, r30, r31 :: str
    r32 :: object
    r33 :: str
    r34 :: object
    r35, r36 :: str
    r37 :: tuple[str, str]
    r38, r39 :: bool
    r40 :: tuple[str, str]
    r41, r42 :: object
    r43, r44 :: bool
    r45, r46 :: object
    r47 :: str
    r48 :: bool
    r49, r50 :: str
    r51 :: i32
    r52 :: bit
    r53, r54 :: bool
    r55 :: bit
    r56, r57, r58 :: str
    r59 :: object[2]
    r60 :: object_ptr
    r61 :: object
    r62 :: int
    r63 :: bool
    r64 :: str
    r65 :: int
    r66 :: object
    r67, r68, r69 :: str
    r70 :: int
    r71 :: object
    r72, r73 :: str
    r74 :: object
    r75 :: str
    r76 :: object
    r77 :: object[1]
    r78 :: object_ptr
    r79 :: object
    r80 :: tuple[object, object, object]
    r81 :: bit
    r82 :: str
    r83 :: union[int, str, bytes, None]
    r84 :: str
    r85 :: union[int, None]
    r86 :: str
    r87 :: union[dict, None]
    r88 :: dict
    r89 :: bool
    r90 :: dict
    r91 :: bool
    r92 :: dict
    r93, r94 :: bool
    r95 :: dict
    r96 :: native_int
    r97 :: short_int
    r98 :: bool
    r99 :: object
    r100 :: bool
    r101 :: object
    r102 :: short_int
    r103 :: tuple[bool, short_int, object, object]
    r104 :: short_int
    r105, r106 :: bool
    r107, r108 :: object
    r109 :: str
    r110 :: union[int, str, bytes, None, dict]
    r111, r112 :: bool
    r113 :: union[int, str, bytes, None, dict]
    r114 :: object
    r115 :: bit
    r116 :: str
    r117 :: union[int, str, bytes, None, dict]
    r118 :: union[int, str, bytes, dict]
    r119 :: dict
    r120 :: i32
    r121 :: bit
    r122 :: dict
    r123 :: short_int
    r124, r125 :: bit
    r126 :: dict
    r127 :: bool
    r128 :: object
    r129 :: tuple
    r130 :: dict
    r131 :: str
    r132 :: object
    r133 :: list
    r134 :: object
    r135 :: dict
    r136 :: i32
    r137 :: bit
    r138 :: tuple
    r139, r140 :: object
    r141 :: bool
    r142, r143, r144, r145, r146 :: object
    r147 :: bool
    r148 :: object
    r149 :: bit
    r150 :: tuple[object, object, object]
    r151 :: bool
    r152 :: object_ptr
    r153 :: object
    r154, r155 :: bool
    r156 :: tuple[object, object, object]
    r157 :: bool
    r158, r159 :: tuple[object, object, object]
    r160 :: bit
    r161, r162, r163 :: object
    r164 :: bool
    r165, r166 :: bit
    r167 :: bool
    r168 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_env__
    if is_error(r2) goto L153 (error at coroutine:24) else goto L1
L1:
    r3 = r2.__mypyc_next_label__
    if is_error(r3) goto L154 (error at coroutine:24) else goto L2
L2:
    r4 = r2.__mypyc_env__
    if is_error(r4) goto L155 (error at coroutine:24) else goto L148
L3:
    r5 = load_address _Py_NoneStruct
    r6 = type != r5
    if r6 goto L156 else goto L6 :: bool
L4:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L152 (error at coroutine:24) else goto L5 :: bool
L5:
    unreachable
L6:
    r7 = r2.self
    if is_error(r7) goto L157 (error at coroutine:45) else goto L7
L7:
    r8 = r2.args
    if is_error(r8) goto L158 (error at coroutine:45) else goto L8
L8:
    r9 = '_get_fn_from_args'
    r10 = [r7, r8]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775810, 0)
    if is_error(r12) goto L159 (error at coroutine:45) else goto L9
L9:
    dec_ref r7
    dec_ref r8
    r2.fn = r12; r13 = is_error
    if not r13 goto L157 (error at coroutine:45) else goto L160 :: bool
L10:
    r14 = CPy_CatchError()
    r2.__mypyc_temp__0 = r14; r15 = is_error
    if not r15 goto L161 (error at coroutine:-1) else goto L11 :: bool
L11:
    r16 = builtins :: module
    r17 = 'ValueError'
    r18 = CPyObject_GetAttr(r16, r17)
    if is_error(r18) goto L161 (error at coroutine:46) else goto L12
L12:
    r19 = CPy_ExceptionMatches(r18)
    dec_ref r18
    if r19 goto L13 else goto L162 :: bool
L13:
    r20 = CPy_GetExcValue()
    r2.e = r20; r21 = is_error
    if not r21 goto L161 (error at coroutine:46) else goto L14 :: bool
L14:
    r22 = r2.e
    if is_error(r22) goto L161 (error at coroutine:47) else goto L15
L15:
    r23 = PyObject_Str(r22)
    dec_ref r22
    if is_error(r23) goto L161 (error at coroutine:47) else goto L16
L16:
    r2.exc_str = r23; r24 = is_error
    if not r24 goto L161 (error at coroutine:47) else goto L17 :: bool
L17:
    r25 = "Contract has more than one function '."
    r26 = r4.call
    if is_error(r26) goto L161 (error at coroutine:49) else goto L18
L18:
    r27 = '_name'
    r28 = CPyObject_GetAttr(r26, r27)
    dec_ref r26
    if is_error(r28) goto L161 (error at coroutine:49) else goto L19
L19:
    r29 = PyObject_Str(r28)
    dec_ref r28
    if is_error(r29) goto L161 (error at coroutine:49) else goto L20
L20:
    r30 = CPyStr_Build(2, r25, r29)
    dec_ref r29
    if is_error(r30) goto L161 (error at coroutine:49) else goto L21
L21:
    r31 = 'You must explicitly declare which function you are calling, e.g. .'
    r32 = r4.call
    dec_ref r4
    if is_error(r32) goto L163 (error at coroutine:50) else goto L22
L22:
    r33 = '_name'
    r34 = CPyObject_GetAttr(r32, r33)
    dec_ref r32
    if is_error(r34) goto L163 (error at coroutine:50) else goto L23
L23:
    r35 = PyObject_Str(r34)
    dec_ref r34
    if is_error(r35) goto L163 (error at coroutine:50) else goto L24
L24:
    r36 = CPyStr_Build(2, r31, r35)
    dec_ref r35
    if is_error(r36) goto L163 (error at coroutine:50) else goto L25
L25:
    r37 = (r30, r36)
    r2.match_on = r37; r38 = is_error
    if not r38 goto L62 (error at coroutine:48) else goto L26 :: bool
L26:
    r39 = 1
    r40 = r2.match_on
    if is_error(r40) goto L62 (error at coroutine:52) else goto L27
L27:
    inc_ref r40
    r41 = box(tuple[str, str], r40)
    r42 = PyObject_GetIter(r41)
    dec_ref r41
    if is_error(r42) goto L164 (error at coroutine:52) else goto L28
L28:
    r2.__mypyc_temp__1 = r40; r43 = is_error
    if not r43 goto L165 (error at coroutine:-1) else goto L29 :: bool
L29:
    r2.__mypyc_temp__2 = r42; r44 = is_error
    if not r44 goto L62 (error at coroutine:-1) else goto L30 :: bool
L30:
    r45 = r2.__mypyc_temp__2
    if is_error(r45) goto L62 (error at coroutine:52) else goto L31
L31:
    r46 = PyIter_Next(r45)
    dec_ref r45
    if is_error(r46) goto L39 else goto L32
L32:
    r47 = cast(str, r46)
    if is_error(r47) goto L62 (error at coroutine:52) else goto L33
L33:
    r2.s = r47; r48 = is_error
    if not r48 goto L62 (error at coroutine:52) else goto L34 :: bool
L34:
    r49 = r2.s
    if is_error(r49) goto L62 (error at coroutine:52) else goto L35
L35:
    r50 = r2.exc_str
    if is_error(r50) goto L166 (error at coroutine:52) else goto L36
L36:
    r51 = PySequence_Contains(r50, r49)
    dec_ref r50
    dec_ref r49
    r52 = r51 >= 0 :: signed
    if not r52 goto L62 (error at coroutine:52) else goto L37 :: bool
L37:
    r53 = truncate r51: i32 to builtins.bool
    r54 = r53 ^ 1
    if r54 goto L38 else goto L30 :: bool
L38:
    r39 = 0
    goto L40
L39:
    r55 = CPy_NoErrOccurred()
    if not r55 goto L62 (error at coroutine:52) else goto L40 :: bool
L40:
    if r39 goto L41 else goto L58 :: bool
L41:
    r56 = r2.exc_str
    if is_error(r56) goto L62 (error at coroutine:53) else goto L42
L42:
    r57 = '(*args)'
    r58 = 'find'
    r59 = [r56, r57]
    r60 = load_address r59
    r61 = PyObject_VectorcallMethod(r58, r60, 9223372036854775810, 0)
    if is_error(r61) goto L167 (error at coroutine:53) else goto L43
L43:
    dec_ref r56
    r62 = unbox(int, r61)
    dec_ref r61
    if is_error(r62) goto L62 (error at coroutine:53) else goto L44
L44:
    r2.breakpoint = r62; r63 = is_error
    if not r63 goto L62 (error at coroutine:53) else goto L45 :: bool
L45:
    r64 = r2.exc_str
    if is_error(r64) goto L62 (error at coroutine:54) else goto L46
L46:
    r65 = r2.breakpoint
    if is_error(r65) goto L168 (error at coroutine:54) else goto L47
L47:
    r66 = CPyStr_GetSlice(r64, 0, r65)
    dec_ref r64
    dec_ref r65 :: int
    if is_error(r66) goto L62 (error at coroutine:54) else goto L48
L48:
    r67 = cast(str, r66)
    if is_error(r67) goto L62 (error at coroutine:54) else goto L49
L49:
    r68 = '.coroutine'
    r69 = r2.exc_str
    if is_error(r69) goto L169 (error at coroutine:54) else goto L50
L50:
    r70 = r2.breakpoint
    if is_error(r70) goto L170 (error at coroutine:54) else goto L51
L51:
    r71 = CPyStr_GetSlice(r69, r70, 9223372036854775806)
    dec_ref r69
    dec_ref r70 :: int
    if is_error(r71) goto L169 (error at coroutine:54) else goto L52
L52:
    r72 = cast(str, r71)
    if is_error(r72) goto L169 (error at coroutine:54) else goto L53
L53:
    r73 = CPyStr_Build(3, r67, r68, r72)
    dec_ref r67
    dec_ref r72
    if is_error(r73) goto L62 (error at coroutine:54) else goto L54
L54:
    r74 = builtins :: module
    r75 = 'ValueError'
    r76 = CPyObject_GetAttr(r74, r75)
    if is_error(r76) goto L171 (error at coroutine:54) else goto L55
L55:
    r77 = [r73]
    r78 = load_address r77
    r79 = _PyObject_Vectorcall(r76, r78, 1, 0)
    dec_ref r76
    if is_error(r79) goto L171 (error at coroutine:54) else goto L56
L56:
    dec_ref r73
    CPy_Raise(r79)
    dec_ref r79
    if not 0 goto L62 (error at coroutine:54) else goto L172 :: bool
L57:
    unreachable
L58:
    CPy_Reraise()
    if not 0 goto L62 else goto L173 :: bool
L59:
    unreachable
L60:
    CPy_Reraise()
    if not 0 goto L62 else goto L174 :: bool
L61:
    unreachable
L62:
    r80 = r2.__mypyc_temp__0
    dec_ref r2
    if is_error(r80) goto L152 (error at coroutine:-1) else goto L63
L63:
    CPy_RestoreExcInfo(r80)
    dec_ref r80
    r81 = CPy_KeepPropagating()
    if not r81 goto L152 else goto L64 :: bool
L64:
    unreachable
L65:
    r82 = 'block_identifier'
    r83 = r2.block_identifier
    if is_error(r83) goto L154 (error at coroutine:57) else goto L66
L66:
    r84 = 'decimals'
    r85 = r2.decimals
    if is_error(r85) goto L175 (error at coroutine:57) else goto L67
L67:
    r86 = 'override'
    r87 = r2.override
    if is_error(r87) goto L176 (error at coroutine:57) else goto L68
L68:
    r88 = CPyDict_Build(3, r82, r83, r84, r85, r86, r87)
    dec_ref r83
    dec_ref r85
    dec_ref r87
    if is_error(r88) goto L154 (error at coroutine:57) else goto L69
L69:
    r2.kwargs = r88; r89 = is_error
    if not r89 goto L154 (error at coroutine:57) else goto L70 :: bool
L70:
    r90 = PyDict_New()
    if is_error(r90) goto L154 (error at coroutine:58) else goto L71
L71:
    r2.__mypyc_temp__3 = r90; r91 = is_error
    if not r91 goto L154 (error at coroutine:-1) else goto L72 :: bool
L72:
    r92 = r2.kwargs
    if is_error(r92) goto L154 (error at coroutine:58) else goto L73
L73:
    inc_ref r92
    r2.__mypyc_temp__4 = r92; r93 = is_error
    if not r93 goto L177 (error at coroutine:-1) else goto L74 :: bool
L74:
    r2.__mypyc_temp__5 = 0; r94 = is_error
    if not r94 goto L177 (error at coroutine:-1) else goto L75 :: bool
L75:
    r95 = r2.__mypyc_temp__4
    if is_error(r95) goto L177 (error at coroutine:58) else goto L76
L76:
    r96 = PyDict_Size(r95)
    dec_ref r95
    r97 = r96 << 1
    r2.__mypyc_temp__6 = r97; r98 = is_error
    if not r98 goto L177 (error at coroutine:-1) else goto L77 :: bool
L77:
    r99 = CPyDict_GetItemsIter(r92)
    dec_ref r92
    if is_error(r99) goto L154 (error at coroutine:58) else goto L78
L78:
    r2.__mypyc_temp__7 = r99; r100 = is_error
    if not r100 goto L154 (error at coroutine:-1) else goto L79 :: bool
L79:
    r101 = r2.__mypyc_temp__7
    if is_error(r101) goto L154 (error at coroutine:58) else goto L80
L80:
    r102 = r2.__mypyc_temp__5
    if is_error(r102) goto L178 (error at coroutine:58) else goto L81
L81:
    r103 = CPyDict_NextItem(r101, r102)
    dec_ref r101
    r104 = r103[1]
    r2.__mypyc_temp__5 = r104; r105 = is_error
    if not r105 goto L179 (error at coroutine:58) else goto L82 :: bool
L82:
    r106 = r103[0]
    if r106 goto L83 else goto L180 :: bool
L83:
    r107 = r103[2]
    r108 = r103[3]
    dec_ref r103
    r109 = cast(str, r107)
    if is_error(r109) goto L181 (error at coroutine:58) else goto L84
L84:
    r110 = cast(union[int, str, bytes, None, dict], r108)
    if is_error(r110) goto L182 (error at coroutine:58) else goto L85
L85:
    r2.k = r109; r111 = is_error
    if not r111 goto L183 (error at coroutine:58) else goto L86 :: bool
L86:
    r2.v = r110; r112 = is_error
    if not r112 goto L154 (error at coroutine:58) else goto L87 :: bool
L87:
    r113 = r2.v
    if is_error(r113) goto L154 (error at coroutine:58) else goto L88
L88:
    r114 = load_address _Py_NoneStruct
    r115 = r113 != r114
    dec_ref r113
    if r115 goto L89 else goto L94 :: bool
L89:
    r116 = r2.k
    if is_error(r116) goto L154 (error at coroutine:58) else goto L90
L90:
    r117 = r2.v
    if is_error(r117) goto L184 (error at coroutine:58) else goto L91
L91:
    r118 = cast(union[int, str, bytes, dict], r117)
    if is_error(r118) goto L184 (error at coroutine:58) else goto L92
L92:
    r119 = r2.__mypyc_temp__3
    if is_error(r119) goto L185 (error at coroutine:-1) else goto L93
L93:
    r120 = CPyDict_SetItem(r119, r116, r118)
    dec_ref r119
    dec_ref r116
    dec_ref r118
    r121 = r120 >= 0 :: signed
    if not r121 goto L154 (error at coroutine:58) else goto L94 :: bool
L94:
    r122 = r2.__mypyc_temp__4
    if is_error(r122) goto L154 (error at coroutine:58) else goto L95
L95:
    r123 = r2.__mypyc_temp__6
    if is_error(r123) goto L186 (error at coroutine:58) else goto L96
L96:
    r124 = CPyDict_CheckSize(r122, r123)
    dec_ref r122
    if not r124 goto L154 (error at coroutine:58) else goto L79 :: bool
L97:
    r125 = CPy_NoErrOccurred()
    if not r125 goto L154 (error at coroutine:58) else goto L98 :: bool
L98:
    r126 = r2.__mypyc_temp__3
    if is_error(r126) goto L154 (error at coroutine:-1) else goto L99
L99:
    r2.kwargs = r126; r127 = is_error
    if not r127 goto L154 (error at coroutine:58) else goto L100 :: bool
L100:
    r128 = r2.fn
    if is_error(r128) goto L154 (error at coroutine:59) else goto L101
L101:
    r129 = r2.args
    if is_error(r129) goto L187 (error at coroutine:59) else goto L102
L102:
    r130 = r2.kwargs
    if is_error(r130) goto L188 (error at coroutine:59) else goto L103
L103:
    r131 = 'coroutine'
    r132 = CPyObject_GetAttr(r128, r131)
    dec_ref r128
    if is_error(r132) goto L189 (error at coroutine:59) else goto L104
L104:
    r133 = PyList_New(0)
    if is_error(r133) goto L190 (error at coroutine:59) else goto L105
L105:
    r134 = CPyList_Extend(r133, r129)
    dec_ref r129
    if is_error(r134) goto L191 (error at coroutine:59) else goto L192
L106:
    r135 = PyDict_New()
    if is_error(r135) goto L191 (error at coroutine:59) else goto L107
L107:
    r136 = CPyDict_UpdateInDisplay(r135, r130)
    dec_ref r130
    r137 = r136 >= 0 :: signed
    if not r137 goto L193 (error at coroutine:59) else goto L108 :: bool
L108:
    r138 = PyList_AsTuple(r133)
    dec_ref r133
    if is_error(r138) goto L194 (error at coroutine:59) else goto L109
L109:
    r139 = PyObject_Call(r132, r138, r135)
    dec_ref r132
    dec_ref r138
    dec_ref r135
    if is_error(r139) goto L154 (error at coroutine:59) else goto L110
L110:
    r140 = CPy_GetCoro(r139)
    dec_ref r139
    if is_error(r140) goto L154 (error at coroutine:59) else goto L111
L111:
    r2.__mypyc_temp__8 = r140; r141 = is_error
    if not r141 goto L154 (error at coroutine:-1) else goto L112 :: bool
L112:
    r142 = r2.__mypyc_temp__8
    if is_error(r142) goto L154 (error at coroutine:-1) else goto L113
L113:
    r143 = CPyIter_Next(r142)
    dec_ref r142
    if is_error(r143) goto L195 else goto L116
L114:
    r144 = CPy_FetchStopIterationValue()
    if is_error(r144) goto L196 (error at coroutine:59) else goto L115
L115:
    r145 = r144
    goto L145
L116:
    r146 = r143
L117:
    r2.__mypyc_next_label__ = 2; r147 = is_error
    if not r147 goto L197 (error at coroutine:59) else goto L198 :: bool
L118:
    return r146
L119:
    r148 = load_address _Py_NoneStruct
    r149 = type != r148
    if r149 goto L120 else goto L122 :: bool
L120:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L123 (error at coroutine:59) else goto L199 :: bool
L121:
    unreachable
L122:
    inc_ref arg
    goto L140
L123:
    r150 = CPy_CatchError()
    r2.__mypyc_temp__9 = r150; r151 = is_error
    if not r151 goto L200 (error at coroutine:-1) else goto L124 :: bool
L124:
    r152 = load_address r1
    r153 = r2.__mypyc_temp__8
    if is_error(r153) goto L200 (error at coroutine:-1) else goto L125
L125:
    r154 = CPy_YieldFromErrorHandle(r153, r152)
    dec_ref r153
    if is_error(r154) goto L200 (error at coroutine:59) else goto L126
L126:
    if r154 goto L132 else goto L127 :: bool
L127:
    if is_error(r1) goto L128 else goto L130
L128:
    r155 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r155 goto L137 (error at coroutine:-1) else goto L201 :: bool
L129:
    unreachable
L130:
    inc_ref r1
    r146 = r1
    r156 = r2.__mypyc_temp__9
    if is_error(r156) goto L202 (error at coroutine:-1) else goto L131
L131:
    CPy_RestoreExcInfo(r156)
    dec_ref r156
    goto L117
L132:
    if is_error(r1) goto L133 else goto L135
L133:
    r157 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r157 goto L137 (error at coroutine:-1) else goto L203 :: bool
L134:
    unreachable
L135:
    r145 = r1
    r158 = r2.__mypyc_temp__9
    if is_error(r158) goto L204 (error at coroutine:-1) else goto L136
L136:
    CPy_RestoreExcInfo(r158)
    dec_ref r158
    goto L145
L137:
    r159 = r2.__mypyc_temp__9
    dec_ref r2
    if is_error(r159) goto L152 (error at coroutine:-1) else goto L138
L138:
    CPy_RestoreExcInfo(r159)
    dec_ref r159
    r160 = CPy_KeepPropagating()
    if not r160 goto L152 else goto L139 :: bool
L139:
    unreachable
L140:
    r161 = r2.__mypyc_temp__8
    if is_error(r161) goto L205 (error at coroutine:-1) else goto L141
L141:
    r162 = CPyIter_Send(r161, arg)
    dec_ref r161
    dec_ref arg
    if is_error(r162) goto L206 else goto L142
L142:
    r146 = r162
    goto L117
L143:
    r163 = CPy_FetchStopIterationValue()
    if is_error(r163) goto L196 (error at coroutine:59) else goto L144
L144:
    r145 = r163
L145:
    r2.__mypyc_next_label__ = -2; r164 = is_error
    dec_ref r2
    if not r164 goto L207 (error at coroutine:59) else goto L146 :: bool
L146:
    CPyGen_SetStopIterationValue(r145)
    dec_ref r145
    if not 0 goto L152 else goto L147 :: bool
L147:
    unreachable
L148:
    r165 = r3 == 0
    if r165 goto L208 else goto L209 :: bool
L149:
    r166 = r3 == 2
    dec_ref r3 :: int
    if r166 goto L119 else goto L210 :: bool
L150:
    r167 = raise StopIteration
    if not r167 goto L152 (error at coroutine:24) else goto L151 :: bool
L151:
    unreachable
L152:
    r168 = <error> :: object
    return r168
L153:
    xdec_ref r1
    goto L152
L154:
    xdec_ref r1
    dec_ref r2
    goto L152
L155:
    xdec_ref r1
    dec_ref r2
    dec_ref r3 :: int
    goto L152
L156:
    xdec_ref r1
    dec_ref r2
    dec_ref r4
    goto L4
L157:
    xdec_ref r1
    goto L10
L158:
    xdec_ref r1
    dec_ref r7
    goto L10
L159:
    xdec_ref r1
    dec_ref r7
    dec_ref r8
    goto L10
L160:
    dec_ref r4
    goto L65
L161:
    dec_ref r4
    goto L62
L162:
    dec_ref r4
    goto L60
L163:
    dec_ref r30
    goto L62
L164:
    dec_ref r40
    goto L62
L165:
    dec_ref r42
    goto L62
L166:
    dec_ref r49
    goto L62
L167:
    dec_ref r56
    goto L62
L168:
    dec_ref r64
    goto L62
L169:
    dec_ref r67
    goto L62
L170:
    dec_ref r67
    dec_ref r69
    goto L62
L171:
    dec_ref r73
    goto L62
L172:
    dec_ref r2
    goto L57
L173:
    dec_ref r2
    goto L59
L174:
    dec_ref r2
    goto L61
L175:
    xdec_ref r1
    dec_ref r2
    dec_ref r83
    goto L152
L176:
    xdec_ref r1
    dec_ref r2
    dec_ref r83
    dec_ref r85
    goto L152
L177:
    xdec_ref r1
    dec_ref r2
    dec_ref r92
    goto L152
L178:
    xdec_ref r1
    dec_ref r2
    dec_ref r101
    goto L152
L179:
    xdec_ref r1
    dec_ref r2
    dec_ref r103
    goto L152
L180:
    dec_ref r103
    goto L97
L181:
    xdec_ref r1
    dec_ref r2
    dec_ref r108
    goto L152
L182:
    xdec_ref r1
    dec_ref r2
    dec_ref r109
    goto L152
L183:
    xdec_ref r1
    dec_ref r2
    dec_ref r110
    goto L152
L184:
    xdec_ref r1
    dec_ref r2
    dec_ref r116
    goto L152
L185:
    xdec_ref r1
    dec_ref r2
    dec_ref r116
    dec_ref r118
    goto L152
L186:
    xdec_ref r1
    dec_ref r2
    dec_ref r122
    goto L152
L187:
    xdec_ref r1
    dec_ref r2
    dec_ref r128
    goto L152
L188:
    xdec_ref r1
    dec_ref r2
    dec_ref r128
    dec_ref r129
    goto L152
L189:
    xdec_ref r1
    dec_ref r2
    dec_ref r129
    dec_ref r130
    goto L152
L190:
    xdec_ref r1
    dec_ref r2
    dec_ref r129
    dec_ref r130
    dec_ref r132
    goto L152
L191:
    xdec_ref r1
    dec_ref r2
    dec_ref r130
    dec_ref r132
    dec_ref r133
    goto L152
L192:
    dec_ref r134
    goto L106
L193:
    xdec_ref r1
    dec_ref r2
    dec_ref r132
    dec_ref r133
    dec_ref r135
    goto L152
L194:
    xdec_ref r1
    dec_ref r2
    dec_ref r132
    dec_ref r135
    goto L152
L195:
    xdec_ref r1
    goto L114
L196:
    dec_ref r2
    goto L152
L197:
    dec_ref r146
    goto L123
L198:
    xdec_ref r1
    dec_ref r2
    goto L118
L199:
    xdec_ref r1
    dec_ref r2
    goto L121
L200:
    xdec_ref r1
    goto L137
L201:
    dec_ref r2
    goto L129
L202:
    xdec_ref r1
    dec_ref r146
    goto L137
L203:
    dec_ref r2
    goto L134
L204:
    dec_ref r145
    goto L137
L205:
    xdec_ref r1
    dec_ref r2
    dec_ref arg
    goto L152
L206:
    xdec_ref r1
    goto L143
L207:
    dec_ref r145
    goto L152
L208:
    dec_ref r3 :: int
    goto L3
L209:
    dec_ref r4
    goto L149
L210:
    xdec_ref r1
    dec_ref r2
    goto L150

def coroutine__patch_overloaded_method_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine__patch_overloaded_method_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine__patch_overloaded_method_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine__patch_overloaded_method_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine__patch_overloaded_method_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine__patch_overloaded_method_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutine__patch_overloaded_method_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutine__patch_overloaded_method_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def coroutine__patch_overloaded_method_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine__patch_overloaded_method_obj.__call__(__mypyc_self__, self, args, block_identifier, decimals, override):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_obj
    self :: object
    args :: tuple
    block_identifier :: union[int, str, bytes, None]
    decimals :: union[int, None]
    override :: union[dict, None]
    r0 :: dank_mids.brownie_patch.overloaded._patch_overloaded_method_env
    r1, r2, r3 :: object
    r4 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_env
    r5, r6, r7, r8, r9, r10 :: bool
    r11 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    r12, r13 :: bool
    r14 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L18 (error at coroutine:24) else goto L1
L1:
    if is_error(block_identifier) goto L2 else goto L19
L2:
    r1 = box(None, 1)
    inc_ref r1
    block_identifier = r1
L3:
    if is_error(decimals) goto L4 else goto L20
L4:
    r2 = box(None, 1)
    inc_ref r2
    decimals = r2
L5:
    if is_error(override) goto L6 else goto L21
L6:
    r3 = box(None, 1)
    inc_ref r3
    override = r3
L7:
    r4 = coroutine__patch_overloaded_method_env()
    if is_error(r4) goto L22 (error at coroutine:24) else goto L8
L8:
    r4.__mypyc_env__ = r0; r5 = is_error
    if not r5 goto L23 (error at coroutine:24) else goto L9 :: bool
L9:
    inc_ref self
    r4.self = self; r6 = is_error
    if not r6 goto L23 (error at coroutine:24) else goto L10 :: bool
L10:
    inc_ref args
    r4.args = args; r7 = is_error
    if not r7 goto L23 (error at coroutine:24) else goto L11 :: bool
L11:
    r4.block_identifier = block_identifier; r8 = is_error
    if not r8 goto L24 (error at coroutine:24) else goto L12 :: bool
L12:
    r4.decimals = decimals; r9 = is_error
    if not r9 goto L25 (error at coroutine:24) else goto L13 :: bool
L13:
    r4.override = override; r10 = is_error
    if not r10 goto L26 (error at coroutine:24) else goto L14 :: bool
L14:
    r11 = coroutine__patch_overloaded_method_gen()
    if is_error(r11) goto L26 (error at coroutine:24) else goto L15
L15:
    inc_ref r4
    r11.__mypyc_env__ = r4; r12 = is_error
    if not r12 goto L27 (error at coroutine:24) else goto L16 :: bool
L16:
    r4.__mypyc_next_label__ = 0; r13 = is_error
    dec_ref r4
    if not r13 goto L28 (error at coroutine:24) else goto L17 :: bool
L17:
    return r11
L18:
    r14 = <error> :: object
    return r14
L19:
    inc_ref block_identifier
    goto L3
L20:
    inc_ref decimals
    goto L5
L21:
    inc_ref override
    goto L7
L22:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r0
    goto L18
L23:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L18
L24:
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L18
L25:
    dec_ref override
    dec_ref r4
    goto L18
L26:
    dec_ref r4
    goto L18
L27:
    dec_ref r4
    dec_ref r11
    goto L18
L28:
    dec_ref r11
    goto L18

def _patch_overloaded_method(call, w3):
    call, w3 :: object
    r0 :: dank_mids.brownie_patch.overloaded._patch_overloaded_method_env
    r1 :: bool
    r2 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_obj
    r3 :: bool
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: i32
    r17 :: bit
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: str
    r24 :: object[1]
    r25 :: object_ptr
    r26, r27, r28 :: object
    r29 :: dict
    r30 :: str
    r31 :: object
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: tuple[object, object]
    r36 :: object
    r37 :: i32
    r38 :: bit
    r39 :: bool
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: object
    r45 :: set
    r46 :: i32
    r47 :: bit
    r48 :: bool
    r49 :: str
    r50 :: object
    r51 :: i32
    r52 :: bit
    r53 :: str
    r54 :: object
    r55 :: str
    r56 :: object
    r57 :: int
    r58 :: dict
    r59 :: str
    r60, r61 :: object
    r62 :: object[2]
    r63 :: object_ptr
    r64 :: object
    r65 :: dict
    r66 :: str
    r67 :: object
    r68 :: object[2]
    r69 :: object_ptr
    r70 :: object
    r71 :: str
    r72 :: i32
    r73, r74 :: bit
    r75 :: object
    r76 :: dict
    r77 :: str
    r78 :: object
    r79 :: object[2]
    r80 :: object_ptr
    r81, r82 :: object
    r83 :: str
    r84 :: i32
    r85 :: bit
    r86 :: None
L0:
    r0 = _patch_overloaded_method_env()
    if is_error(r0) goto L39 (error at _patch_overloaded_method:12) else goto L1
L1:
    inc_ref call
    r0.call = call; r1 = is_error
    if not r1 goto L40 (error at _patch_overloaded_method:12) else goto L2 :: bool
L2:
    r2 = coroutine__patch_overloaded_method_obj()
    if is_error(r2) goto L40 (error at _patch_overloaded_method:24) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L41 (error at _patch_overloaded_method:24) else goto L4 :: bool
L4:
    r4 = r0.call
    if is_error(r4) goto L41 (error at _patch_overloaded_method:23) else goto L5
L5:
    r5 = dank_mids.brownie_patch.overloaded.globals :: static
    r6 = 'wraps'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L42 (error at _patch_overloaded_method:23) else goto L6
L6:
    r8 = [r4]
    r9 = load_address r8
    r10 = _PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L42 (error at _patch_overloaded_method:23) else goto L7
L7:
    dec_ref r4
    r11 = [r2]
    r12 = load_address r11
    r13 = _PyObject_Vectorcall(r10, r12, 1, 0)
    dec_ref r10
    if is_error(r13) goto L41 (error at _patch_overloaded_method:24) else goto L8
L8:
    dec_ref r2
    inc_ref r13
    r14 = dank_mids.brownie_patch.overloaded.globals :: static
    r15 = 'coroutine'
    r16 = CPyDict_SetItem(r14, r15, r13)
    dec_ref r13
    r17 = r16 >= 0 :: signed
    if not r17 goto L43 (error at _patch_overloaded_method:24) else goto L9 :: bool
L9:
    r18 = r0.call
    if is_error(r18) goto L43 (error at _patch_overloaded_method:61) else goto L10
L10:
    r19 = '__dict__'
    r20 = CPyObject_GetAttr(r18, r19)
    dec_ref r18
    if is_error(r20) goto L43 (error at _patch_overloaded_method:61) else goto L11
L11:
    r21 = 'methods'
    r22 = PyObject_GetItem(r20, r21)
    dec_ref r20
    if is_error(r22) goto L43 (error at _patch_overloaded_method:61) else goto L12
L12:
    r23 = 'values'
    r24 = [r22]
    r25 = load_address r24
    r26 = PyObject_VectorcallMethod(r23, r25, 9223372036854775809, 0)
    if is_error(r26) goto L44 (error at _patch_overloaded_method:61) else goto L13
L13:
    dec_ref r22
    r27 = PyObject_GetIter(r26)
    dec_ref r26
    if is_error(r27) goto L43 (error at _patch_overloaded_method:61) else goto L14
L14:
    r28 = PyIter_Next(r27)
    if is_error(r28) goto L45 else goto L15
L15:
    r29 = dank_mids.brownie_patch.overloaded.globals :: static
    r30 = 'ContractCall'
    r31 = CPyDict_GetItem(r29, r30)
    if is_error(r31) goto L46 (error at _patch_overloaded_method:62) else goto L16
L16:
    r32 = dank_mids.brownie_patch.overloaded.globals :: static
    r33 = 'ContractTx'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L47 (error at _patch_overloaded_method:62) else goto L17
L17:
    r35 = (r31, r34)
    r36 = box(tuple[object, object], r35)
    r37 = PyObject_IsInstance(r28, r36)
    dec_ref r36
    r38 = r37 >= 0 :: signed
    if not r38 goto L46 (error at _patch_overloaded_method:62) else goto L18 :: bool
L18:
    r39 = truncate r37: i32 to builtins.bool
    if r39 goto L19 else goto L48 :: bool
L19:
    r40 = '_address'
    r41 = CPyObject_GetAttr(r28, r40)
    if is_error(r41) goto L46 (error at _patch_overloaded_method:63) else goto L20
L20:
    r42 = dank_mids.brownie_patch.overloaded.globals :: static
    r43 = '_skip_proc_pool'
    r44 = CPyDict_GetItem(r42, r43)
    if is_error(r44) goto L49 (error at _patch_overloaded_method:63) else goto L21
L21:
    r45 = cast(set, r44)
    if is_error(r45) goto L49 (error at _patch_overloaded_method:63) else goto L22
L22:
    r46 = PySet_Contains(r45, r41)
    dec_ref r45
    dec_ref r41
    r47 = r46 >= 0 :: signed
    if not r47 goto L46 (error at _patch_overloaded_method:63) else goto L23 :: bool
L23:
    r48 = truncate r46: i32 to builtins.bool
    r49 = '_skip_decoder_proc_pool'
    r50 = box(bool, r48)
    r51 = PyObject_SetAttr(r28, r49, r50)
    r52 = r51 >= 0 :: signed
    if not r52 goto L46 (error at _patch_overloaded_method:63) else goto L24 :: bool
L24:
    r53 = 'abi'
    r54 = CPyObject_GetAttr(r28, r53)
    if is_error(r54) goto L46 (error at _patch_overloaded_method:64) else goto L25
L25:
    r55 = 'inputs'
    r56 = PyObject_GetItem(r54, r55)
    dec_ref r54
    if is_error(r56) goto L46 (error at _patch_overloaded_method:64) else goto L26
L26:
    r57 = CPyObject_Size(r56)
    dec_ref r56
    if is_error(r57) goto L46 (error at _patch_overloaded_method:64) else goto L27
L27:
    r58 = dank_mids.brownie_patch.overloaded.globals :: static
    r59 = '_get_coroutine_fn'
    r60 = CPyDict_GetItem(r58, r59)
    if is_error(r60) goto L50 (error at _patch_overloaded_method:64) else goto L28
L28:
    r61 = box(int, r57)
    r62 = [w3, r61]
    r63 = load_address r62
    r64 = _PyObject_Vectorcall(r60, r63, 2, 0)
    dec_ref r60
    if is_error(r64) goto L51 (error at _patch_overloaded_method:64) else goto L29
L29:
    dec_ref r61
    r65 = dank_mids.brownie_patch.overloaded.globals :: static
    r66 = 'MethodType'
    r67 = CPyDict_GetItem(r65, r66)
    if is_error(r67) goto L52 (error at _patch_overloaded_method:64) else goto L30
L30:
    r68 = [r64, r28]
    r69 = load_address r68
    r70 = _PyObject_Vectorcall(r67, r69, 2, 0)
    dec_ref r67
    if is_error(r70) goto L52 (error at _patch_overloaded_method:64) else goto L31
L31:
    dec_ref r64
    r71 = 'coroutine'
    r72 = PyObject_SetAttr(r28, r71, r70)
    dec_ref r28
    dec_ref r70
    r73 = r72 >= 0 :: signed
    if not r73 goto L53 (error at _patch_overloaded_method:64) else goto L14 :: bool
L32:
    r74 = CPy_NoErrOccurred()
    if not r74 goto L43 (error at _patch_overloaded_method:61) else goto L33 :: bool
L33:
    r75 = r0.call
    if is_error(r75) goto L43 (error at _patch_overloaded_method:69) else goto L34
L34:
    r76 = dank_mids.brownie_patch.overloaded.globals :: static
    r77 = 'MethodType'
    r78 = CPyDict_GetItem(r76, r77)
    if is_error(r78) goto L54 (error at _patch_overloaded_method:69) else goto L35
L35:
    r79 = [r13, r75]
    r80 = load_address r79
    r81 = _PyObject_Vectorcall(r78, r80, 2, 0)
    dec_ref r78
    if is_error(r81) goto L54 (error at _patch_overloaded_method:69) else goto L36
L36:
    dec_ref r13
    dec_ref r75
    r82 = r0.call
    dec_ref r0
    if is_error(r82) goto L55 (error at _patch_overloaded_method:69) else goto L37
L37:
    r83 = 'coroutine'
    r84 = PyObject_SetAttr(r82, r83, r81)
    dec_ref r82
    dec_ref r81
    r85 = r84 >= 0 :: signed
    if not r85 goto L39 (error at _patch_overloaded_method:69) else goto L38 :: bool
L38:
    return 1
L39:
    r86 = <error> :: None
    return r86
L40:
    dec_ref r0
    goto L39
L41:
    dec_ref r0
    dec_ref r2
    goto L39
L42:
    dec_ref r0
    dec_ref r2
    dec_ref r4
    goto L39
L43:
    dec_ref r0
    dec_ref r13
    goto L39
L44:
    dec_ref r0
    dec_ref r13
    dec_ref r22
    goto L39
L45:
    dec_ref r27
    goto L32
L46:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    goto L39
L47:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r31
    goto L39
L48:
    dec_ref r28
    goto L14
L49:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r41
    goto L39
L50:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r57 :: int
    goto L39
L51:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r61
    goto L39
L52:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r64
    goto L39
L53:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    goto L39
L54:
    dec_ref r0
    dec_ref r13
    dec_ref r75
    goto L39
L55:
    dec_ref r81
    goto L39

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24, r25 :: object
    r26 :: str
    r27 :: dict
    r28, r29 :: object
    r30 :: str
    r31 :: dict
    r32, r33 :: object
    r34 :: str
    r35 :: dict
    r36 :: object
    r37 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L12 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('wraps',)
    r6 = 'functools'
    r7 = dank_mids.brownie_patch.overloaded.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L12 (error at <module>:1) else goto L4
L4:
    functools = r8 :: module
    dec_ref r8
    r9 = ('MethodType',)
    r10 = 'types'
    r11 = dank_mids.brownie_patch.overloaded.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L12 (error at <module>:2) else goto L5
L5:
    types = r12 :: module
    dec_ref r12
    r13 = ('Any', 'Dict', 'Optional', 'Union')
    r14 = 'typing'
    r15 = dank_mids.brownie_patch.overloaded.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L12 (error at <module>:3) else goto L6
L6:
    typing = r16 :: module
    dec_ref r16
    r17 = ('Contract',)
    r18 = 'brownie'
    r19 = dank_mids.brownie_patch.overloaded.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L12 (error at <module>:5) else goto L7
L7:
    brownie = r20 :: module
    dec_ref r20
    r21 = ('ContractCall', 'ContractTx', 'OverloadedMethod')
    r22 = 'brownie.network.contract'
    r23 = dank_mids.brownie_patch.overloaded.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L12 (error at <module>:6) else goto L8
L8:
    brownie.network.contract = r24 :: module
    dec_ref r24
    r25 = ('_get_coroutine_fn', '_skip_proc_pool')
    r26 = 'dank_mids.brownie_patch.call'
    r27 = dank_mids.brownie_patch.overloaded.globals :: static
    r28 = CPyImport_ImportFromMany(r26, r25, r25, r27)
    if is_error(r28) goto L12 (error at <module>:7) else goto L9
L9:
    dank_mids.brownie_patch.call = r28 :: module
    dec_ref r28
    r29 = ('ContractMethod',)
    r30 = 'dank_mids.brownie_patch.types'
    r31 = dank_mids.brownie_patch.overloaded.globals :: static
    r32 = CPyImport_ImportFromMany(r30, r29, r29, r31)
    if is_error(r32) goto L12 (error at <module>:8) else goto L10
L10:
    dank_mids.brownie_patch.types = r32 :: module
    dec_ref r32
    r33 = ('DankWeb3',)
    r34 = 'dank_mids.helpers._helpers'
    r35 = dank_mids.brownie_patch.overloaded.globals :: static
    r36 = CPyImport_ImportFromMany(r34, r33, r33, r35)
    if is_error(r36) goto L12 (error at <module>:9) else goto L11
L11:
    dank_mids.helpers._helpers = r36 :: module
    dec_ref r36
    return 1
L12:
    r37 = <error> :: None
    return r37

def lru_cache_lite_wrap_lru_cache_lite_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def lru_cache_lite_wrap_lru_cache_lite_obj.__call__(__mypyc_self__, args):
    __mypyc_self__ :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_obj
    args :: tuple
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_env
    r1 :: dict
    r2, r3, retval, r4 :: object
    r5 :: bit
    r6 :: object
    r7 :: list
    r8 :: object
    r9 :: tuple
    r10 :: dict
    r11 :: object
    r12 :: dict
    r13 :: i32
    r14 :: bit
    r15 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L15 (error at lru_cache_lite_wrap:41) else goto L1
L1:
    r1 = r0.cache
    if is_error(r1) goto L16 (error at lru_cache_lite_wrap:42) else goto L2
L2:
    r2 = r0.cache_miss
    if is_error(r2) goto L17 (error at lru_cache_lite_wrap:42) else goto L3
L3:
    r3 = CPyDict_Get(r1, args, r2)
    dec_ref r1
    dec_ref r2
    if is_error(r3) goto L16 (error at lru_cache_lite_wrap:42) else goto L4
L4:
    retval = r3
    r4 = r0.cache_miss
    if is_error(r4) goto L18 (error at lru_cache_lite_wrap:43) else goto L5
L5:
    r5 = retval == r4
    dec_ref r4
    if r5 goto L19 else goto L20 :: bool
L6:
    r6 = r0.func
    if is_error(r6) goto L16 (error at lru_cache_lite_wrap:44) else goto L7
L7:
    r7 = PyList_New(0)
    if is_error(r7) goto L21 (error at lru_cache_lite_wrap:44) else goto L8
L8:
    r8 = CPyList_Extend(r7, args)
    if is_error(r8) goto L22 (error at lru_cache_lite_wrap:44) else goto L23
L9:
    r9 = PyList_AsTuple(r7)
    dec_ref r7
    if is_error(r9) goto L21 (error at lru_cache_lite_wrap:44) else goto L10
L10:
    r10 = PyDict_New()
    if is_error(r10) goto L24 (error at lru_cache_lite_wrap:44) else goto L11
L11:
    r11 = PyObject_Call(r6, r9, r10)
    dec_ref r6
    dec_ref r9
    dec_ref r10
    if is_error(r11) goto L16 (error at lru_cache_lite_wrap:44) else goto L12
L12:
    retval = r11
    r12 = r0.cache
    dec_ref r0
    if is_error(r12) goto L25 (error at lru_cache_lite_wrap:45) else goto L13
L13:
    r13 = CPyDict_SetItem(r12, args, retval)
    dec_ref r12
    r14 = r13 >= 0 :: signed
    if not r14 goto L25 (error at lru_cache_lite_wrap:45) else goto L14 :: bool
L14:
    return retval
L15:
    r15 = <error> :: object
    return r15
L16:
    dec_ref r0
    goto L15
L17:
    dec_ref r0
    dec_ref r1
    goto L15
L18:
    dec_ref r0
    dec_ref retval
    goto L15
L19:
    dec_ref retval
    goto L6
L20:
    dec_ref r0
    goto L14
L21:
    dec_ref r0
    dec_ref r6
    goto L15
L22:
    dec_ref r0
    dec_ref r6
    dec_ref r7
    goto L15
L23:
    dec_ref r8
    goto L9
L24:
    dec_ref r0
    dec_ref r6
    dec_ref r9
    goto L15
L25:
    dec_ref retval
    goto L15

def lru_cache_lite(func):
    func :: object
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_env
    r1 :: bool
    r2 :: dict
    r3 :: bool
    r4 :: object
    r5 :: str
    r6, r7 :: object
    r8 :: bool
    r9 :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_obj
    r10 :: bool
    r11 :: object
    r12 :: dict
    r13 :: str
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: object[1]
    r19 :: object_ptr
    r20 :: object
    r21 :: dict
    r22 :: str
    r23 :: i32
    r24 :: bit
    r25 :: dict
    r26 :: str
    r27 :: i32
    r28 :: bit
    r29 :: object
L0:
    r0 = lru_cache_lite_env()
    if is_error(r0) goto L17 (error at lru_cache_lite:11) else goto L1
L1:
    inc_ref func
    r0.func = func; r1 = is_error
    if not r1 goto L18 (error at lru_cache_lite:11) else goto L2 :: bool
L2:
    r2 = PyDict_New()
    if is_error(r2) goto L18 (error at lru_cache_lite:37) else goto L3
L3:
    r0.cache = r2; r3 = is_error
    if not r3 goto L18 (error at lru_cache_lite:37) else goto L4 :: bool
L4:
    r4 = builtins :: module
    r5 = 'object'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L18 (error at lru_cache_lite:38) else goto L5
L5:
    r7 = _PyObject_Vectorcall(r6, 0, 0, 0)
    dec_ref r6
    if is_error(r7) goto L18 (error at lru_cache_lite:38) else goto L6
L6:
    r0.cache_miss = r7; r8 = is_error
    if not r8 goto L18 (error at lru_cache_lite:38) else goto L7 :: bool
L7:
    r9 = lru_cache_lite_wrap_lru_cache_lite_obj()
    if is_error(r9) goto L18 (error at lru_cache_lite:41) else goto L8
L8:
    inc_ref r0
    r9.__mypyc_env__ = r0; r10 = is_error
    if not r10 goto L19 (error at lru_cache_lite:41) else goto L9 :: bool
L9:
    r11 = r0.func
    if is_error(r11) goto L19 (error at lru_cache_lite:40) else goto L10
L10:
    r12 = dank_mids.helpers.lru_cache.globals :: static
    r13 = 'wraps'
    r14 = CPyDict_GetItem(r12, r13)
    if is_error(r14) goto L20 (error at lru_cache_lite:40) else goto L11
L11:
    r15 = [r11]
    r16 = load_address r15
    r17 = _PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L20 (error at lru_cache_lite:40) else goto L12
L12:
    dec_ref r11
    r18 = [r9]
    r19 = load_address r18
    r20 = _PyObject_Vectorcall(r17, r19, 1, 0)
    dec_ref r17
    if is_error(r20) goto L19 (error at lru_cache_lite:41) else goto L13
L13:
    dec_ref r9
    inc_ref r20
    r21 = dank_mids.helpers.lru_cache.globals :: static
    r22 = 'lru_cache_lite_wrap'
    r23 = CPyDict_SetItem(r21, r22, r20)
    dec_ref r20
    r24 = r23 >= 0 :: signed
    if not r24 goto L21 (error at lru_cache_lite:41) else goto L14 :: bool
L14:
    r25 = r0.cache
    dec_ref r0
    if is_error(r25) goto L22 (error at lru_cache_lite:48) else goto L15
L15:
    r26 = 'cache'
    r27 = PyObject_SetAttr(r20, r26, r25)
    dec_ref r25
    r28 = r27 >= 0 :: signed
    if not r28 goto L22 (error at lru_cache_lite:48) else goto L16 :: bool
L16:
    return r20
L17:
    r29 = <error> :: object
    return r29
L18:
    dec_ref r0
    goto L17
L19:
    dec_ref r0
    dec_ref r9
    goto L17
L20:
    dec_ref r0
    dec_ref r9
    dec_ref r11
    goto L17
L21:
    dec_ref r0
    dec_ref r20
    goto L17
L22:
    dec_ref r20
    goto L17

def lru_cache_lite_wrap_lru_cache_lite_nonull_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def lru_cache_lite_wrap_lru_cache_lite_nonull_obj.__call__(__mypyc_self__, args):
    __mypyc_self__ :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_nonull_obj
    args :: tuple
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_nonull_env
    r1 :: dict
    r2 :: object
    retval :: union[object, None]
    r3 :: object
    r4 :: bit
    r5 :: object
    r6 :: list
    r7 :: object
    r8 :: tuple
    r9 :: dict
    r10 :: object
    r11 :: dict
    r12 :: i32
    r13 :: bit
    r14 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L13 (error at lru_cache_lite_wrap:89) else goto L1
L1:
    r1 = r0.cache
    if is_error(r1) goto L14 (error at lru_cache_lite_wrap:90) else goto L2
L2:
    r2 = CPyDict_GetWithNone(r1, args)
    dec_ref r1
    if is_error(r2) goto L14 (error at lru_cache_lite_wrap:90) else goto L3
L3:
    retval = r2
    r3 = load_address _Py_NoneStruct
    r4 = retval == r3
    if r4 goto L15 else goto L16 :: bool
L4:
    r5 = r0.func
    if is_error(r5) goto L14 (error at lru_cache_lite_wrap:92) else goto L5
L5:
    r6 = PyList_New(0)
    if is_error(r6) goto L17 (error at lru_cache_lite_wrap:92) else goto L6
L6:
    r7 = CPyList_Extend(r6, args)
    if is_error(r7) goto L18 (error at lru_cache_lite_wrap:92) else goto L19
L7:
    r8 = PyList_AsTuple(r6)
    dec_ref r6
    if is_error(r8) goto L17 (error at lru_cache_lite_wrap:92) else goto L8
L8:
    r9 = PyDict_New()
    if is_error(r9) goto L20 (error at lru_cache_lite_wrap:92) else goto L9
L9:
    r10 = PyObject_Call(r5, r8, r9)
    dec_ref r5
    dec_ref r8
    dec_ref r9
    if is_error(r10) goto L14 (error at lru_cache_lite_wrap:92) else goto L10
L10:
    retval = r10
    r11 = r0.cache
    dec_ref r0
    if is_error(r11) goto L21 (error at lru_cache_lite_wrap:93) else goto L11
L11:
    r12 = CPyDict_SetItem(r11, args, retval)
    dec_ref r11
    r13 = r12 >= 0 :: signed
    if not r13 goto L21 (error at lru_cache_lite_wrap:93) else goto L12 :: bool
L12:
    return retval
L13:
    r14 = <error> :: object
    return r14
L14:
    dec_ref r0
    goto L13
L15:
    dec_ref retval
    goto L4
L16:
    dec_ref r0
    goto L12
L17:
    dec_ref r0
    dec_ref r5
    goto L13
L18:
    dec_ref r0
    dec_ref r5
    dec_ref r6
    goto L13
L19:
    dec_ref r7
    goto L7
L20:
    dec_ref r0
    dec_ref r5
    dec_ref r8
    goto L13
L21:
    dec_ref retval
    goto L13

def lru_cache_lite_nonull(func):
    func :: object
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_nonull_env
    r1 :: bool
    r2 :: dict
    r3 :: bool
    r4 :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_nonull_obj
    r5 :: bool
    r6 :: object
    r7 :: dict
    r8 :: str
    r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: i32
    r19 :: bit
    r20 :: dict
    r21 :: str
    r22 :: i32
    r23 :: bit
    r24 :: object
L0:
    r0 = lru_cache_lite_nonull_env()
    if is_error(r0) goto L14 (error at lru_cache_lite_nonull:52) else goto L1
L1:
    inc_ref func
    r0.func = func; r1 = is_error
    if not r1 goto L15 (error at lru_cache_lite_nonull:52) else goto L2 :: bool
L2:
    r2 = PyDict_New()
    if is_error(r2) goto L15 (error at lru_cache_lite_nonull:86) else goto L3
L3:
    r0.cache = r2; r3 = is_error
    if not r3 goto L15 (error at lru_cache_lite_nonull:86) else goto L4 :: bool
L4:
    r4 = lru_cache_lite_wrap_lru_cache_lite_nonull_obj()
    if is_error(r4) goto L15 (error at lru_cache_lite_nonull:89) else goto L5
L5:
    inc_ref r0
    r4.__mypyc_env__ = r0; r5 = is_error
    if not r5 goto L16 (error at lru_cache_lite_nonull:89) else goto L6 :: bool
L6:
    r6 = r0.func
    if is_error(r6) goto L16 (error at lru_cache_lite_nonull:88) else goto L7
L7:
    r7 = dank_mids.helpers.lru_cache.globals :: static
    r8 = 'wraps'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L17 (error at lru_cache_lite_nonull:88) else goto L8
L8:
    r10 = [r6]
    r11 = load_address r10
    r12 = _PyObject_Vectorcall(r9, r11, 1, 0)
    dec_ref r9
    if is_error(r12) goto L17 (error at lru_cache_lite_nonull:88) else goto L9
L9:
    dec_ref r6
    r13 = [r4]
    r14 = load_address r13
    r15 = _PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L16 (error at lru_cache_lite_nonull:89) else goto L10
L10:
    dec_ref r4
    inc_ref r15
    r16 = dank_mids.helpers.lru_cache.globals :: static
    r17 = 'lru_cache_lite_wrap'
    r18 = CPyDict_SetItem(r16, r17, r15)
    dec_ref r15
    r19 = r18 >= 0 :: signed
    if not r19 goto L18 (error at lru_cache_lite_nonull:89) else goto L11 :: bool
L11:
    r20 = r0.cache
    dec_ref r0
    if is_error(r20) goto L19 (error at lru_cache_lite_nonull:96) else goto L12
L12:
    r21 = 'cache'
    r22 = PyObject_SetAttr(r15, r21, r20)
    dec_ref r20
    r23 = r22 >= 0 :: signed
    if not r23 goto L19 (error at lru_cache_lite_nonull:96) else goto L13 :: bool
L13:
    return r15
L14:
    r24 = <error> :: object
    return r24
L15:
    dec_ref r0
    goto L14
L16:
    dec_ref r0
    dec_ref r4
    goto L14
L17:
    dec_ref r0
    dec_ref r4
    dec_ref r6
    goto L14
L18:
    dec_ref r0
    dec_ref r15
    goto L14
L19:
    dec_ref r15
    goto L14

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: str
    r18 :: dict
    r19 :: str
    r20 :: object
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: dict
    r25 :: str
    r26 :: i32
    r27 :: bit
    r28 :: str
    r29 :: dict
    r30 :: str
    r31 :: object
    r32 :: object[1]
    r33 :: object_ptr
    r34 :: object
    r35 :: dict
    r36 :: str
    r37 :: i32
    r38 :: bit
    r39, r40 :: str
    r41 :: list
    r42, r43, r44 :: ptr
    r45 :: dict
    r46 :: str
    r47 :: i32
    r48 :: bit
    r49 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L15 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('wraps',)
    r6 = 'functools'
    r7 = dank_mids.helpers.lru_cache.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L15 (error at <module>:1) else goto L4
L4:
    functools = r8 :: module
    dec_ref r8
    r9 = ('Callable', 'Dict', 'TypeVar')
    r10 = 'typing'
    r11 = dank_mids.helpers.lru_cache.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L15 (error at <module>:2) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = ('ParamSpec',)
    r14 = 'typing_extensions'
    r15 = dank_mids.helpers.lru_cache.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L15 (error at <module>:4) else goto L6
L6:
    typing_extensions = r16 :: module
    dec_ref r16
    r17 = '__P'
    r18 = dank_mids.helpers.lru_cache.globals :: static
    r19 = 'ParamSpec'
    r20 = CPyDict_GetItem(r18, r19)
    if is_error(r20) goto L15 (error at <module>:7) else goto L7
L7:
    r21 = [r17]
    r22 = load_address r21
    r23 = _PyObject_Vectorcall(r20, r22, 1, 0)
    dec_ref r20
    if is_error(r23) goto L15 (error at <module>:7) else goto L8
L8:
    r24 = dank_mids.helpers.lru_cache.globals :: static
    r25 = '__P'
    r26 = CPyDict_SetItem(r24, r25, r23)
    dec_ref r23
    r27 = r26 >= 0 :: signed
    if not r27 goto L15 (error at <module>:7) else goto L9 :: bool
L9:
    r28 = '__T'
    r29 = dank_mids.helpers.lru_cache.globals :: static
    r30 = 'TypeVar'
    r31 = CPyDict_GetItem(r29, r30)
    if is_error(r31) goto L15 (error at <module>:8) else goto L10
L10:
    r32 = [r28]
    r33 = load_address r32
    r34 = _PyObject_Vectorcall(r31, r33, 1, 0)
    dec_ref r31
    if is_error(r34) goto L15 (error at <module>:8) else goto L11
L11:
    r35 = dank_mids.helpers.lru_cache.globals :: static
    r36 = '__T'
    r37 = CPyDict_SetItem(r35, r36, r34)
    dec_ref r34
    r38 = r37 >= 0 :: signed
    if not r38 goto L15 (error at <module>:8) else goto L12 :: bool
L12:
    r39 = 'lru_cache_lite'
    r40 = 'lru_cache_lite_nonull'
    r41 = PyList_New(2)
    if is_error(r41) goto L15 (error at <module>:100) else goto L13
L13:
    r42 = get_element_ptr r41 ob_item :: PyListObject
    r43 = load_mem r42 :: ptr*
    inc_ref r39
    set_mem r43, r39 :: builtins.object*
    inc_ref r40
    r44 = r43 + 8
    set_mem r44, r40 :: builtins.object*
    r45 = dank_mids.helpers.lru_cache.globals :: static
    r46 = '__all__'
    r47 = CPyDict_SetItem(r45, r46, r41)
    dec_ref r41
    r48 = r47 >= 0 :: signed
    if not r48 goto L15 (error at <module>:100) else goto L14 :: bool
L14:
    return 1
L15:
    r49 = <error> :: None
    return r49
