def gatherish_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1, r2, r3, r4, r5, r6, r7 :: object
    r8 :: i32
    r9 :: object
    r10 :: bit
    r11 :: object
    r12 :: bool
    r13 :: object
    r14 :: bool
    r15 :: list
    r16 :: bool
    r17, r18 :: object
    r19, r20 :: bool
    r21, r22 :: object
    r23 :: bool
    r24, r25 :: object
    r26 :: union[str, None]
    r27 :: object
    r28 :: bool
    r29 :: object[3]
    r30 :: object_ptr
    r31, r32 :: object
    r33 :: list
    r34 :: i32
    r35, r36 :: bit
    r37 :: list
    r38 :: object
    r39 :: bool
    r40 :: object
    r41 :: bool
    r42, r43 :: object
    r44 :: bool
    r45, r46, r47, r48, r49 :: object
    r50 :: bool
    r51 :: object
    r52 :: bool
    r53 :: object
    r54 :: bit
    r55 :: tuple[object, object, object]
    r56 :: bool
    r57 :: object_ptr
    r58 :: object
    r59 :: bool
    r60, r61, r62 :: tuple[object, object, object]
    r63 :: bit
    r64, r65, r66, r67 :: object
    r68 :: bool
    r69, r70 :: object
    r71 :: bool
    r72, r73, r74, r75, r76 :: object
    r77 :: bool
    r78 :: object
    r79 :: bool
    r80 :: object
    r81 :: bit
    r82 :: tuple[object, object, object]
    r83 :: bool
    r84 :: object_ptr
    r85 :: object
    r86 :: bool
    r87, r88, r89 :: tuple[object, object, object]
    r90 :: bit
    r91, r92, r93, r94, r95 :: object
    r96, r97 :: bool
    r98, r99 :: object
    r100 :: bool
    r101, r102 :: object
    r103 :: bool
    r104, r105, r106, r107, r108 :: object
    r109 :: bool
    r110 :: object
    r111 :: bool
    r112 :: object
    r113 :: bit
    r114 :: tuple[object, object, object]
    r115 :: bool
    r116 :: object_ptr
    r117 :: object
    r118 :: bool
    r119, r120, r121 :: tuple[object, object, object]
    r122 :: bit
    r123, r124, r125 :: object
    r126 :: tuple[object, object, object]
    r127 :: bool
    r128 :: object
    r129 :: str
    r130 :: object
    r131 :: bit
    r132, r133 :: object
    r134, r135 :: bool
    r136, r137 :: object
    r138 :: bool
    r139, r140 :: object
    r141 :: bool
    r142, r143, r144, r145, r146 :: object
    r147 :: bool
    r148 :: object
    r149 :: bool
    r150 :: object
    r151 :: bit
    r152 :: tuple[object, object, object]
    r153 :: bool
    r154 :: object_ptr
    r155 :: object
    r156 :: bool
    r157, r158, r159 :: tuple[object, object, object]
    r160 :: bit
    r161, r162, r163 :: object
    r164 :: tuple[object, object, object]
    r165 :: bool
    r166 :: object
    r167 :: str
    r168 :: object
    r169 :: bit
    r170, r171 :: tuple[object, object, object]
    r172, r173 :: bit
    r174 :: tuple[object, object, object]
    r175, r176 :: bit
    r177 :: object
    r178 :: bool
    r179, r180, r181, r182, r183 :: bit
    r184 :: bool
    r185 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = <error> :: object
    r5 = r4
    r6 = <error> :: object
    r7 = r6
    r8 = __mypyc_self__.__mypyc_next_label__
    goto L194
L1:
    r9 = load_address _Py_NoneStruct
    r10 = type != r9
    if r10 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L201 (error at gatherish:33) else goto L3 :: bool
L3:
    unreachable
L4:
    r11 = dank_mids.helpers._gather.get_running_loop :: static
    if is_error(r11) goto L5 else goto L7
L5:
    r12 = raise NameError('value for final name "get_running_loop" was not set')
    if not r12 goto L201 (error at gatherish:41) else goto L6 :: bool
L6:
    unreachable
L7:
    r13 = PyObject_Vectorcall(r11, 0, 0, 0)
    if is_error(r13) goto L201 (error at gatherish:41) else goto L8
L8:
    __mypyc_self__.loop = r13; r14 = is_error
    if not r14 goto L201 (error at gatherish:41) else goto L9 :: bool
L9:
    r15 = PyList_New(0)
    if is_error(r15) goto L201 (error at gatherish:44) else goto L10
L10:
    __mypyc_self__.__mypyc_temp__0 = r15; r16 = is_error
    if not r16 goto L201 (error at gatherish:-1) else goto L11 :: bool
L11:
    r17 = __mypyc_self__.coros
    if is_error(r17) goto L201 (error at gatherish:44) else goto L12
L12:
    r18 = PyObject_GetIter(r17)
    if is_error(r18) goto L202 (error at gatherish:44) else goto L13
L13:
    __mypyc_self__.__mypyc_temp__1 = r17; r19 = is_error
    if not r19 goto L203 (error at gatherish:-1) else goto L14 :: bool
L14:
    __mypyc_self__.__mypyc_temp__2 = r18; r20 = is_error
    if not r20 goto L201 (error at gatherish:-1) else goto L15 :: bool
L15:
    r21 = __mypyc_self__.__mypyc_temp__2
    if is_error(r21) goto L201 (error at gatherish:44) else goto L16
L16:
    r22 = PyIter_Next(r21)
    dec_ref r21
    if is_error(r22) goto L27 else goto L17
L17:
    __mypyc_self__.coro = r22; r23 = is_error
    if not r23 goto L201 (error at gatherish:44) else goto L18 :: bool
L18:
    r24 = __mypyc_self__.coro
    if is_error(r24) goto L201 (error at gatherish:44) else goto L19
L19:
    r25 = __mypyc_self__.loop
    if is_error(r25) goto L204 (error at gatherish:44) else goto L20
L20:
    r26 = __mypyc_self__.name
    if is_error(r26) goto L205 (error at gatherish:44) else goto L21
L21:
    r27 = dank_mids.helpers._gather.Task :: static
    if is_error(r27) goto L206 else goto L24
L22:
    r28 = raise NameError('value for final name "Task" was not set')
    if not r28 goto L201 (error at gatherish:44) else goto L23 :: bool
L23:
    unreachable
L24:
    r29 = [r24, r25, r26]
    r30 = load_address r29
    r31 = ('loop', 'name')
    r32 = PyObject_Vectorcall(r27, r30, 1, r31)
    if is_error(r32) goto L207 (error at gatherish:44) else goto L25
L25:
    dec_ref r24
    dec_ref r25
    dec_ref r26
    r33 = __mypyc_self__.__mypyc_temp__0
    if is_error(r33) goto L208 (error at gatherish:-1) else goto L26
L26:
    r34 = PyList_Append(r33, r32)
    dec_ref r33
    dec_ref r32
    r35 = r34 >= 0 :: signed
    if not r35 goto L201 (error at gatherish:44) else goto L15 :: bool
L27:
    r36 = CPy_NoErrOccurred()
    if not r36 goto L201 (error at gatherish:44) else goto L28 :: bool
L28:
    r37 = __mypyc_self__.__mypyc_temp__0
    if is_error(r37) goto L201 (error at gatherish:-1) else goto L29
L29:
    r38 = PyObject_GetIter(r37)
    dec_ref r37
    if is_error(r38) goto L201 (error at gatherish:44) else goto L30
L30:
    __mypyc_self__.tasks = r38; r39 = is_error
    if not r39 goto L201 (error at gatherish:44) else goto L31 :: bool
L31:
    r40 = dank_mids.helpers._gather.yield_to_loop :: static
    if is_error(r40) goto L32 else goto L34
L32:
    r41 = raise NameError('value for final name "yield_to_loop" was not set')
    if not r41 goto L201 (error at gatherish:49) else goto L33 :: bool
L33:
    unreachable
L34:
    r42 = PyObject_Vectorcall(r40, 0, 0, 0)
    if is_error(r42) goto L201 (error at gatherish:49) else goto L35
L35:
    r43 = CPy_GetCoro(r42)
    dec_ref r42
    if is_error(r43) goto L201 (error at gatherish:49) else goto L36
L36:
    __mypyc_self__.__mypyc_temp__3 = r43; r44 = is_error
    if not r44 goto L201 (error at gatherish:-1) else goto L37 :: bool
L37:
    r45 = __mypyc_self__.__mypyc_temp__3
    if is_error(r45) goto L201 (error at gatherish:-1) else goto L38
L38:
    r46 = CPyIter_Next(r45)
    dec_ref r45
    if is_error(r46) goto L39 else goto L41
L39:
    r47 = CPy_FetchStopIterationValue()
    if is_error(r47) goto L201 (error at gatherish:49) else goto L40
L40:
    r48 = r47
    dec_ref r48
    r49 = <error> :: object
    __mypyc_self__.__mypyc_temp__3 = r49; r50 = is_error
    if not r50 goto L201 (error at gatherish:49) else goto L63 :: bool
L41:
    r51 = r46
L42:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r51
L43:
    r53 = load_address _Py_NoneStruct
    r54 = type != r53
    if r54 goto L44 else goto L209 :: bool
L44:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L47 (error at gatherish:49) else goto L210 :: bool
L45:
    unreachable
L46:
    inc_ref arg
    goto L58
L47:
    r55 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__4 = r55; r56 = is_error
    if not r56 goto L211 (error at gatherish:-1) else goto L48 :: bool
L48:
    r57 = load_address r1
    r58 = __mypyc_self__.__mypyc_temp__3
    if is_error(r58) goto L211 (error at gatherish:-1) else goto L49
L49:
    r59 = CPy_YieldFromErrorHandle(r58, r57)
    dec_ref r58
    if is_error(r59) goto L211 (error at gatherish:49) else goto L50
L50:
    if r59 goto L53 else goto L51 :: bool
L51:
    r51 = r1
    r60 = __mypyc_self__.__mypyc_temp__4
    if is_error(r60) goto L212 (error at gatherish:-1) else goto L52
L52:
    CPy_RestoreExcInfo(r60)
    dec_ref r60
    goto L42
L53:
    r48 = r1
    dec_ref r48
    r61 = __mypyc_self__.__mypyc_temp__4
    if is_error(r61) goto L55 (error at gatherish:-1) else goto L54
L54:
    CPy_RestoreExcInfo(r61)
    dec_ref r61
    goto L63
L55:
    r62 = __mypyc_self__.__mypyc_temp__4
    if is_error(r62) goto L201 (error at gatherish:-1) else goto L56
L56:
    CPy_RestoreExcInfo(r62)
    dec_ref r62
    r63 = CPy_KeepPropagating()
    if not r63 goto L201 else goto L57 :: bool
L57:
    unreachable
L58:
    r64 = __mypyc_self__.__mypyc_temp__3
    if is_error(r64) goto L213 (error at gatherish:-1) else goto L59
L59:
    r65 = CPyIter_Send(r64, arg)
    dec_ref r64
    dec_ref arg
    if is_error(r65) goto L61 else goto L60
L60:
    r51 = r65
    goto L42
L61:
    r66 = CPy_FetchStopIterationValue()
    if is_error(r66) goto L201 (error at gatherish:49) else goto L62
L62:
    r48 = r66
    dec_ref r48
L63:
    r67 = dank_mids.helpers._gather.yield_to_loop :: static
    if is_error(r67) goto L64 else goto L66
L64:
    r68 = raise NameError('value for final name "yield_to_loop" was not set')
    if not r68 goto L201 (error at gatherish:50) else goto L65 :: bool
L65:
    unreachable
L66:
    r69 = PyObject_Vectorcall(r67, 0, 0, 0)
    if is_error(r69) goto L201 (error at gatherish:50) else goto L67
L67:
    r70 = CPy_GetCoro(r69)
    dec_ref r69
    if is_error(r70) goto L201 (error at gatherish:50) else goto L68
L68:
    __mypyc_self__.__mypyc_temp__5 = r70; r71 = is_error
    if not r71 goto L201 (error at gatherish:-1) else goto L69 :: bool
L69:
    r72 = __mypyc_self__.__mypyc_temp__5
    if is_error(r72) goto L201 (error at gatherish:-1) else goto L70
L70:
    r73 = CPyIter_Next(r72)
    dec_ref r72
    if is_error(r73) goto L71 else goto L73
L71:
    r74 = CPy_FetchStopIterationValue()
    if is_error(r74) goto L201 (error at gatherish:50) else goto L72
L72:
    r75 = r74
    dec_ref r75
    r76 = <error> :: object
    __mypyc_self__.__mypyc_temp__5 = r76; r77 = is_error
    if not r77 goto L201 (error at gatherish:50) else goto L95 :: bool
L73:
    r78 = r73
L74:
    __mypyc_self__.__mypyc_next_label__ = 2
    return r78
L75:
    r80 = load_address _Py_NoneStruct
    r81 = type != r80
    if r81 goto L76 else goto L214 :: bool
L76:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L79 (error at gatherish:50) else goto L215 :: bool
L77:
    unreachable
L78:
    inc_ref arg
    goto L90
L79:
    r82 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__6 = r82; r83 = is_error
    if not r83 goto L216 (error at gatherish:-1) else goto L80 :: bool
L80:
    r84 = load_address r3
    r85 = __mypyc_self__.__mypyc_temp__5
    if is_error(r85) goto L216 (error at gatherish:-1) else goto L81
L81:
    r86 = CPy_YieldFromErrorHandle(r85, r84)
    dec_ref r85
    if is_error(r86) goto L216 (error at gatherish:50) else goto L82
L82:
    if r86 goto L85 else goto L83 :: bool
L83:
    r78 = r3
    r87 = __mypyc_self__.__mypyc_temp__6
    if is_error(r87) goto L217 (error at gatherish:-1) else goto L84
L84:
    CPy_RestoreExcInfo(r87)
    dec_ref r87
    goto L74
L85:
    r75 = r3
    dec_ref r75
    r88 = __mypyc_self__.__mypyc_temp__6
    if is_error(r88) goto L87 (error at gatherish:-1) else goto L86
L86:
    CPy_RestoreExcInfo(r88)
    dec_ref r88
    goto L95
L87:
    r89 = __mypyc_self__.__mypyc_temp__6
    if is_error(r89) goto L201 (error at gatherish:-1) else goto L88
L88:
    CPy_RestoreExcInfo(r89)
    dec_ref r89
    r90 = CPy_KeepPropagating()
    if not r90 goto L201 else goto L89 :: bool
L89:
    unreachable
L90:
    r91 = __mypyc_self__.__mypyc_temp__5
    if is_error(r91) goto L218 (error at gatherish:-1) else goto L91
L91:
    r92 = CPyIter_Send(r91, arg)
    dec_ref r91
    dec_ref arg
    if is_error(r92) goto L93 else goto L92
L92:
    r78 = r92
    goto L74
L93:
    r93 = CPy_FetchStopIterationValue()
    if is_error(r93) goto L201 (error at gatherish:50) else goto L94
L94:
    r75 = r93
    dec_ref r75
L95:
    r94 = __mypyc_self__.tasks
    if is_error(r94) goto L201 (error at gatherish:51) else goto L96
L96:
    r95 = PyObject_GetIter(r94)
    if is_error(r95) goto L219 (error at gatherish:51) else goto L97
L97:
    __mypyc_self__.__mypyc_temp__7 = r94; r96 = is_error
    if not r96 goto L220 (error at gatherish:-1) else goto L98 :: bool
L98:
    __mypyc_self__.__mypyc_temp__8 = r95; r97 = is_error
    if not r97 goto L201 (error at gatherish:-1) else goto L99 :: bool
L99:
    r98 = __mypyc_self__.__mypyc_temp__8
    if is_error(r98) goto L201 (error at gatherish:51) else goto L100
L100:
    r99 = PyIter_Next(r98)
    dec_ref r98
    if is_error(r99) goto L188 else goto L101
L101:
    __mypyc_self__.task = r99; r100 = is_error
    if not r100 goto L201 (error at gatherish:51) else goto L102 :: bool
L102:
    r101 = __mypyc_self__.task
    if is_error(r101) goto L131 (error at gatherish:53) else goto L103
L103:
    r102 = CPy_GetCoro(r101)
    dec_ref r101
    if is_error(r102) goto L131 (error at gatherish:53) else goto L104
L104:
    __mypyc_self__.__mypyc_temp__9 = r102; r103 = is_error
    if not r103 goto L131 (error at gatherish:-1) else goto L105 :: bool
L105:
    r104 = __mypyc_self__.__mypyc_temp__9
    if is_error(r104) goto L131 (error at gatherish:-1) else goto L106
L106:
    r105 = CPyIter_Next(r104)
    dec_ref r104
    if is_error(r105) goto L107 else goto L109
L107:
    r106 = CPy_FetchStopIterationValue()
    if is_error(r106) goto L131 (error at gatherish:53) else goto L108
L108:
    r107 = r106
    dec_ref r107
    r108 = <error> :: object
    __mypyc_self__.__mypyc_temp__9 = r108; r109 = is_error
    if not r109 goto L131 (error at gatherish:53) else goto L99 :: bool
L109:
    r110 = r105
L110:
    __mypyc_self__.__mypyc_next_label__ = 3
    return r110
L111:
    r112 = load_address _Py_NoneStruct
    r113 = type != r112
    if r113 goto L112 else goto L221 :: bool
L112:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L115 (error at gatherish:53) else goto L222 :: bool
L113:
    unreachable
L114:
    inc_ref arg
    goto L126
L115:
    r114 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__10 = r114; r115 = is_error
    if not r115 goto L223 (error at gatherish:-1) else goto L116 :: bool
L116:
    r116 = load_address r5
    r117 = __mypyc_self__.__mypyc_temp__9
    if is_error(r117) goto L223 (error at gatherish:-1) else goto L117
L117:
    r118 = CPy_YieldFromErrorHandle(r117, r116)
    dec_ref r117
    if is_error(r118) goto L223 (error at gatherish:53) else goto L118
L118:
    if r118 goto L121 else goto L119 :: bool
L119:
    r110 = r5
    r119 = __mypyc_self__.__mypyc_temp__10
    if is_error(r119) goto L224 (error at gatherish:-1) else goto L120
L120:
    CPy_RestoreExcInfo(r119)
    dec_ref r119
    goto L110
L121:
    r107 = r5
    dec_ref r107
    r120 = __mypyc_self__.__mypyc_temp__10
    if is_error(r120) goto L123 (error at gatherish:-1) else goto L122
L122:
    CPy_RestoreExcInfo(r120)
    dec_ref r120
    goto L99
L123:
    r121 = __mypyc_self__.__mypyc_temp__10
    if is_error(r121) goto L131 (error at gatherish:-1) else goto L124
L124:
    CPy_RestoreExcInfo(r121)
    dec_ref r121
    r122 = CPy_KeepPropagating()
    if not r122 goto L131 else goto L125 :: bool
L125:
    unreachable
L126:
    r123 = __mypyc_self__.__mypyc_temp__9
    if is_error(r123) goto L225 (error at gatherish:-1) else goto L127
L127:
    r124 = CPyIter_Send(r123, arg)
    dec_ref r123
    dec_ref arg
    if is_error(r124) goto L129 else goto L128
L128:
    r110 = r124
    goto L110
L129:
    r125 = CPy_FetchStopIterationValue()
    if is_error(r125) goto L131 (error at gatherish:53) else goto L130
L130:
    r107 = r125
    dec_ref r107
    goto L99
L131:
    r126 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__11 = r126; r127 = is_error
    if not r127 goto L185 (error at gatherish:-1) else goto L132 :: bool
L132:
    r128 = builtins :: module
    r129 = 'Exception'
    r130 = CPyObject_GetAttr(r128, r129)
    if is_error(r130) goto L185 (error at gatherish:54) else goto L133
L133:
    r131 = CPy_ExceptionMatches(r130)
    dec_ref r130
    if r131 goto L134 else goto L183 :: bool
L134:
    r132 = __mypyc_self__.tasks
    if is_error(r132) goto L185 (error at gatherish:57) else goto L135
L135:
    r133 = PyObject_GetIter(r132)
    if is_error(r133) goto L226 (error at gatherish:57) else goto L136
L136:
    __mypyc_self__.__mypyc_temp__12 = r132; r134 = is_error
    if not r134 goto L227 (error at gatherish:-1) else goto L137 :: bool
L137:
    __mypyc_self__.__mypyc_temp__13 = r133; r135 = is_error
    if not r135 goto L185 (error at gatherish:-1) else goto L138 :: bool
L138:
    r136 = __mypyc_self__.__mypyc_temp__13
    if is_error(r136) goto L185 (error at gatherish:57) else goto L139
L139:
    r137 = PyIter_Next(r136)
    dec_ref r136
    if is_error(r137) goto L180 else goto L140
L140:
    __mypyc_self__.task = r137; r138 = is_error
    if not r138 goto L185 (error at gatherish:57) else goto L141 :: bool
L141:
    r139 = __mypyc_self__.task
    if is_error(r139) goto L170 (error at gatherish:60) else goto L142
L142:
    r140 = CPy_GetCoro(r139)
    dec_ref r139
    if is_error(r140) goto L170 (error at gatherish:60) else goto L143
L143:
    __mypyc_self__.__mypyc_temp__14 = r140; r141 = is_error
    if not r141 goto L170 (error at gatherish:-1) else goto L144 :: bool
L144:
    r142 = __mypyc_self__.__mypyc_temp__14
    if is_error(r142) goto L170 (error at gatherish:-1) else goto L145
L145:
    r143 = CPyIter_Next(r142)
    dec_ref r142
    if is_error(r143) goto L146 else goto L148
L146:
    r144 = CPy_FetchStopIterationValue()
    if is_error(r144) goto L170 (error at gatherish:60) else goto L147
L147:
    r145 = r144
    dec_ref r145
    r146 = <error> :: object
    __mypyc_self__.__mypyc_temp__14 = r146; r147 = is_error
    if not r147 goto L170 (error at gatherish:60) else goto L138 :: bool
L148:
    r148 = r143
L149:
    __mypyc_self__.__mypyc_next_label__ = 4
    return r148
L150:
    r150 = load_address _Py_NoneStruct
    r151 = type != r150
    if r151 goto L151 else goto L228 :: bool
L151:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L154 (error at gatherish:60) else goto L229 :: bool
L152:
    unreachable
L153:
    inc_ref arg
    goto L165
L154:
    r152 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__15 = r152; r153 = is_error
    if not r153 goto L230 (error at gatherish:-1) else goto L155 :: bool
L155:
    r154 = load_address r7
    r155 = __mypyc_self__.__mypyc_temp__14
    if is_error(r155) goto L230 (error at gatherish:-1) else goto L156
L156:
    r156 = CPy_YieldFromErrorHandle(r155, r154)
    dec_ref r155
    if is_error(r156) goto L230 (error at gatherish:60) else goto L157
L157:
    if r156 goto L160 else goto L158 :: bool
L158:
    r148 = r7
    r157 = __mypyc_self__.__mypyc_temp__15
    if is_error(r157) goto L231 (error at gatherish:-1) else goto L159
L159:
    CPy_RestoreExcInfo(r157)
    dec_ref r157
    goto L149
L160:
    r145 = r7
    dec_ref r145
    r158 = __mypyc_self__.__mypyc_temp__15
    if is_error(r158) goto L162 (error at gatherish:-1) else goto L161
L161:
    CPy_RestoreExcInfo(r158)
    dec_ref r158
    goto L138
L162:
    r159 = __mypyc_self__.__mypyc_temp__15
    if is_error(r159) goto L170 (error at gatherish:-1) else goto L163
L163:
    CPy_RestoreExcInfo(r159)
    dec_ref r159
    r160 = CPy_KeepPropagating()
    if not r160 goto L170 else goto L164 :: bool
L164:
    unreachable
L165:
    r161 = __mypyc_self__.__mypyc_temp__14
    if is_error(r161) goto L232 (error at gatherish:-1) else goto L166
L166:
    r162 = CPyIter_Send(r161, arg)
    dec_ref r161
    dec_ref arg
    if is_error(r162) goto L168 else goto L167
L167:
    r148 = r162
    goto L149
L168:
    r163 = CPy_FetchStopIterationValue()
    if is_error(r163) goto L170 (error at gatherish:60) else goto L169
L169:
    r145 = r163
    dec_ref r145
    goto L138
L170:
    r164 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__16 = r164; r165 = is_error
    if not r165 goto L177 (error at gatherish:-1) else goto L171 :: bool
L171:
    r166 = builtins :: module
    r167 = 'Exception'
    r168 = CPyObject_GetAttr(r166, r167)
    if is_error(r168) goto L177 (error at gatherish:61) else goto L172
L172:
    r169 = CPy_ExceptionMatches(r168)
    dec_ref r168
    if r169 goto L175 else goto L173 :: bool
L173:
    CPy_Reraise()
    if not 0 goto L177 else goto L174 :: bool
L174:
    unreachable
L175:
    r170 = __mypyc_self__.__mypyc_temp__16
    if is_error(r170) goto L185 (error at gatherish:-1) else goto L176
L176:
    CPy_RestoreExcInfo(r170)
    dec_ref r170
    goto L138
L177:
    r171 = __mypyc_self__.__mypyc_temp__16
    if is_error(r171) goto L185 (error at gatherish:-1) else goto L178
L178:
    CPy_RestoreExcInfo(r171)
    dec_ref r171
    r172 = CPy_KeepPropagating()
    if not r172 goto L185 else goto L179 :: bool
L179:
    unreachable
L180:
    r173 = CPy_NoErrOccurred()
    if not r173 goto L185 (error at gatherish:57) else goto L181 :: bool
L181:
    CPy_Reraise()
    if not 0 goto L185 else goto L182 :: bool
L182:
    unreachable
L183:
    CPy_Reraise()
    if not 0 goto L185 else goto L184 :: bool
L184:
    unreachable
L185:
    r174 = __mypyc_self__.__mypyc_temp__11
    if is_error(r174) goto L201 (error at gatherish:-1) else goto L186
L186:
    CPy_RestoreExcInfo(r174)
    dec_ref r174
    r175 = CPy_KeepPropagating()
    if not r175 goto L201 else goto L187 :: bool
L187:
    unreachable
L188:
    r176 = CPy_NoErrOccurred()
    if not r176 goto L201 (error at gatherish:51) else goto L189 :: bool
L189:
    r177 = box(None, 1)
    __mypyc_self__.__mypyc_next_label__ = -1
L190:
    if is_error(stop_iter_ptr) goto L191 else goto L193
L191:
    CPyGen_SetStopIterationValue(r177)
    if not 0 goto L201 else goto L192 :: bool
L192:
    unreachable
L193:
    inc_ref r177
    set_mem stop_iter_ptr, r177 :: builtins.object*
    return 0
L194:
    r179 = r8 == 0
    if r179 goto L233 else goto L195 :: bool
L195:
    r180 = r8 == 1
    if r180 goto L234 else goto L235 :: bool
L196:
    r181 = r8 == 2
    if r181 goto L236 else goto L237 :: bool
L197:
    r182 = r8 == 3
    if r182 goto L238 else goto L239 :: bool
L198:
    r183 = r8 == 4
    if r183 goto L150 else goto L240 :: bool
L199:
    r184 = raise StopIteration
    if not r184 goto L201 (error at gatherish:33) else goto L200 :: bool
L200:
    unreachable
L201:
    r185 = <error> :: object
    return r185
L202:
    dec_ref r17
    goto L201
L203:
    dec_ref r18
    goto L201
L204:
    dec_ref r24
    goto L201
L205:
    dec_ref r24
    dec_ref r25
    goto L201
L206:
    dec_ref r24
    dec_ref r25
    dec_ref r26
    goto L22
L207:
    dec_ref r24
    dec_ref r25
    dec_ref r26
    goto L201
L208:
    dec_ref r32
    goto L201
L209:
    xdec_ref r1
    goto L46
L210:
    xdec_ref r1
    goto L45
L211:
    xdec_ref r1
    goto L55
L212:
    dec_ref r51
    goto L55
L213:
    dec_ref arg
    goto L201
L214:
    xdec_ref r3
    goto L78
L215:
    xdec_ref r3
    goto L77
L216:
    xdec_ref r3
    goto L87
L217:
    dec_ref r78
    goto L87
L218:
    dec_ref arg
    goto L201
L219:
    dec_ref r94
    goto L201
L220:
    dec_ref r95
    goto L201
L221:
    xdec_ref r5
    goto L114
L222:
    xdec_ref r5
    goto L113
L223:
    xdec_ref r5
    goto L123
L224:
    dec_ref r110
    goto L123
L225:
    dec_ref arg
    goto L131
L226:
    dec_ref r132
    goto L185
L227:
    dec_ref r133
    goto L185
L228:
    xdec_ref r7
    goto L153
L229:
    xdec_ref r7
    goto L152
L230:
    xdec_ref r7
    goto L162
L231:
    dec_ref r148
    goto L162
L232:
    dec_ref arg
    goto L170
L233:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    goto L1
L234:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    goto L43
L235:
    xdec_ref r1
    goto L196
L236:
    xdec_ref r5
    xdec_ref r7
    goto L75
L237:
    xdec_ref r3
    goto L197
L238:
    xdec_ref r7
    goto L111
L239:
    xdec_ref r5
    goto L198
L240:
    xdec_ref r7
    goto L199

def gatherish_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = gatherish_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def gatherish_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = gatherish_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def gatherish_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def gatherish_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = gatherish_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def gatherish_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def gatherish_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def gatherish(coros, name):
    coros :: object
    name :: union[str, None]
    r0 :: object
    r1 :: dank_mids.helpers._gather.gatherish_gen
    r2, r3, r4 :: bool
    r5 :: dank_mids.helpers._gather.gatherish_gen
L0:
    if is_error(name) goto L1 else goto L7
L1:
    r0 = box(None, 1)
    inc_ref r0
    name = r0
L2:
    r1 = gatherish_gen()
    if is_error(r1) goto L8 (error at gatherish:33) else goto L3
L3:
    r1.__mypyc_next_label__ = 0
    inc_ref coros
    r1.coros = coros; r3 = is_error
    if not r3 goto L9 (error at gatherish:33) else goto L4 :: bool
L4:
    r1.name = name; r4 = is_error
    if not r4 goto L10 (error at gatherish:33) else goto L5 :: bool
L5:
    return r1
L6:
    r5 = <error> :: dank_mids.helpers._gather.gatherish_gen
    return r5
L7:
    inc_ref name
    goto L2
L8:
    dec_ref name
    goto L6
L9:
    dec_ref name
    dec_ref r1
    goto L6
L10:
    dec_ref r1
    goto L6

def first_completed_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1, r2, r3 :: object
    r4 :: i32
    r5 :: object
    r6 :: bit
    r7 :: bool
    r8 :: tuple
    r9 :: str
    r10 :: object
    r11 :: bool
    r12 :: object[2]
    r13 :: object_ptr
    r14, r15, r16 :: object
    r17 :: bool
    r18, r19, r20, r21, r22 :: object
    r23 :: bool
    r24 :: object
    r25 :: bool
    r26 :: object
    r27 :: bit
    r28 :: tuple[object, object, object]
    r29 :: bool
    r30 :: object_ptr
    r31 :: object
    r32 :: bool
    r33, r34, r35 :: tuple[object, object, object]
    r36 :: bit
    r37, r38, r39 :: object
    r40 :: tuple[set, set]
    r41 :: object
    r42 :: bool
    r43 :: tuple
    r44 :: str
    r45 :: object
    r46 :: bool
    r47 :: object[2]
    r48 :: object_ptr
    r49, r50, r51 :: object
    r52 :: bool
    r53, r54, r55, r56, r57 :: object
    r58 :: bool
    r59 :: object
    r60 :: bool
    r61 :: object
    r62 :: bit
    r63 :: tuple[object, object, object]
    r64 :: bool
    r65 :: object_ptr
    r66 :: object
    r67 :: bool
    r68, r69, r70 :: tuple[object, object, object]
    r71 :: bit
    r72, r73, r74 :: object
    r75 :: tuple[set, set]
    r76, r77, r78 :: set
    r79 :: bool
    r80 :: set
    r81 :: bool
    r82 :: set
    r83 :: object
    r84, r85 :: bool
    r86, r87 :: object
    r88 :: bool
    r89 :: object
    r90 :: str
    r91 :: object[1]
    r92 :: object_ptr
    r93 :: object
    r94 :: bit
    r95 :: set
    r96 :: bool
    r97, r98, r99 :: bit
    r100 :: bool
    r101 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = __mypyc_self__.__mypyc_next_label__
    goto L98
L1:
    r5 = load_address _Py_NoneStruct
    r6 = type != r5
    if r6 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L103 (error at first_completed:74) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = __mypyc_self__.cancel
    if is_error(r7) goto L103 (error at first_completed:77) else goto L5
L5:
    if r7 goto L45 else goto L6 :: bool
L6:
    r8 = __mypyc_self__.fs
    if is_error(r8) goto L103 (error at first_completed:78) else goto L7
L7:
    r9 = 'FIRST_COMPLETED'
    r10 = dank_mids.helpers._gather.wait :: static
    if is_error(r10) goto L104 else goto L10
L8:
    r11 = raise NameError('value for final name "wait" was not set')
    if not r11 goto L103 (error at first_completed:78) else goto L9 :: bool
L9:
    unreachable
L10:
    r12 = [r8, r9]
    r13 = load_address r12
    r14 = ('return_when',)
    r15 = PyObject_Vectorcall(r10, r13, 1, r14)
    if is_error(r15) goto L105 (error at first_completed:78) else goto L11
L11:
    dec_ref r8
    r16 = CPy_GetCoro(r15)
    dec_ref r15
    if is_error(r16) goto L103 (error at first_completed:78) else goto L12
L12:
    __mypyc_self__.__mypyc_temp__17 = r16; r17 = is_error
    if not r17 goto L103 (error at first_completed:-1) else goto L13 :: bool
L13:
    r18 = __mypyc_self__.__mypyc_temp__17
    if is_error(r18) goto L103 (error at first_completed:-1) else goto L14
L14:
    r19 = CPyIter_Next(r18)
    dec_ref r18
    if is_error(r19) goto L15 else goto L17
L15:
    r20 = CPy_FetchStopIterationValue()
    if is_error(r20) goto L103 (error at first_completed:78) else goto L16
L16:
    r21 = r20
    r22 = <error> :: object
    __mypyc_self__.__mypyc_temp__17 = r22; r23 = is_error
    if not r23 goto L106 (error at first_completed:78) else goto L39 :: bool
L17:
    r24 = r19
L18:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r24
L19:
    r26 = load_address _Py_NoneStruct
    r27 = type != r26
    if r27 goto L20 else goto L107 :: bool
L20:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L23 (error at first_completed:78) else goto L108 :: bool
L21:
    unreachable
L22:
    inc_ref arg
    goto L34
L23:
    r28 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__18 = r28; r29 = is_error
    if not r29 goto L109 (error at first_completed:-1) else goto L24 :: bool
L24:
    r30 = load_address r1
    r31 = __mypyc_self__.__mypyc_temp__17
    if is_error(r31) goto L109 (error at first_completed:-1) else goto L25
L25:
    r32 = CPy_YieldFromErrorHandle(r31, r30)
    dec_ref r31
    if is_error(r32) goto L109 (error at first_completed:78) else goto L26
L26:
    if r32 goto L29 else goto L27 :: bool
L27:
    r24 = r1
    r33 = __mypyc_self__.__mypyc_temp__18
    if is_error(r33) goto L110 (error at first_completed:-1) else goto L28
L28:
    CPy_RestoreExcInfo(r33)
    dec_ref r33
    goto L18
L29:
    r21 = r1
    r34 = __mypyc_self__.__mypyc_temp__18
    if is_error(r34) goto L111 (error at first_completed:-1) else goto L30
L30:
    CPy_RestoreExcInfo(r34)
    dec_ref r34
    goto L39
L31:
    r35 = __mypyc_self__.__mypyc_temp__18
    if is_error(r35) goto L103 (error at first_completed:-1) else goto L32
L32:
    CPy_RestoreExcInfo(r35)
    dec_ref r35
    r36 = CPy_KeepPropagating()
    if not r36 goto L103 else goto L33 :: bool
L33:
    unreachable
L34:
    r37 = __mypyc_self__.__mypyc_temp__17
    if is_error(r37) goto L112 (error at first_completed:-1) else goto L35
L35:
    r38 = CPyIter_Send(r37, arg)
    dec_ref r37
    dec_ref arg
    if is_error(r38) goto L37 else goto L36
L36:
    r24 = r38
    goto L18
L37:
    r39 = CPy_FetchStopIterationValue()
    if is_error(r39) goto L103 (error at first_completed:78) else goto L38
L38:
    r21 = r39
L39:
    r40 = unbox(tuple[set, set], r21)
    dec_ref r21
    if is_error(r40) goto L103 (error at first_completed:78) else goto L40
L40:
    r41 = box(tuple[set, set], r40)
    __mypyc_self__.__mypyc_next_label__ = -1
L41:
    if is_error(stop_iter_ptr) goto L42 else goto L44
L42:
    CPyGen_SetStopIterationValue(r41)
    dec_ref r41
    if not 0 goto L103 else goto L43 :: bool
L43:
    unreachable
L44:
    set_mem stop_iter_ptr, r41 :: builtins.object*
    return 0
L45:
    r43 = __mypyc_self__.fs
    if is_error(r43) goto L103 (error at first_completed:79) else goto L46
L46:
    r44 = 'FIRST_COMPLETED'
    r45 = dank_mids.helpers._gather.wait :: static
    if is_error(r45) goto L113 else goto L49
L47:
    r46 = raise NameError('value for final name "wait" was not set')
    if not r46 goto L103 (error at first_completed:79) else goto L48 :: bool
L48:
    unreachable
L49:
    r47 = [r43, r44]
    r48 = load_address r47
    r49 = ('return_when',)
    r50 = PyObject_Vectorcall(r45, r48, 1, r49)
    if is_error(r50) goto L114 (error at first_completed:79) else goto L50
L50:
    dec_ref r43
    r51 = CPy_GetCoro(r50)
    dec_ref r50
    if is_error(r51) goto L103 (error at first_completed:79) else goto L51
L51:
    __mypyc_self__.__mypyc_temp__19 = r51; r52 = is_error
    if not r52 goto L103 (error at first_completed:-1) else goto L52 :: bool
L52:
    r53 = __mypyc_self__.__mypyc_temp__19
    if is_error(r53) goto L103 (error at first_completed:-1) else goto L53
L53:
    r54 = CPyIter_Next(r53)
    dec_ref r53
    if is_error(r54) goto L54 else goto L56
L54:
    r55 = CPy_FetchStopIterationValue()
    if is_error(r55) goto L103 (error at first_completed:79) else goto L55
L55:
    r56 = r55
    r57 = <error> :: object
    __mypyc_self__.__mypyc_temp__19 = r57; r58 = is_error
    if not r58 goto L115 (error at first_completed:79) else goto L78 :: bool
L56:
    r59 = r54
L57:
    __mypyc_self__.__mypyc_next_label__ = 2
    return r59
L58:
    r61 = load_address _Py_NoneStruct
    r62 = type != r61
    if r62 goto L59 else goto L116 :: bool
L59:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L62 (error at first_completed:79) else goto L117 :: bool
L60:
    unreachable
L61:
    inc_ref arg
    goto L73
L62:
    r63 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__20 = r63; r64 = is_error
    if not r64 goto L118 (error at first_completed:-1) else goto L63 :: bool
L63:
    r65 = load_address r3
    r66 = __mypyc_self__.__mypyc_temp__19
    if is_error(r66) goto L118 (error at first_completed:-1) else goto L64
L64:
    r67 = CPy_YieldFromErrorHandle(r66, r65)
    dec_ref r66
    if is_error(r67) goto L118 (error at first_completed:79) else goto L65
L65:
    if r67 goto L68 else goto L66 :: bool
L66:
    r59 = r3
    r68 = __mypyc_self__.__mypyc_temp__20
    if is_error(r68) goto L119 (error at first_completed:-1) else goto L67
L67:
    CPy_RestoreExcInfo(r68)
    dec_ref r68
    goto L57
L68:
    r56 = r3
    r69 = __mypyc_self__.__mypyc_temp__20
    if is_error(r69) goto L120 (error at first_completed:-1) else goto L69
L69:
    CPy_RestoreExcInfo(r69)
    dec_ref r69
    goto L78
L70:
    r70 = __mypyc_self__.__mypyc_temp__20
    if is_error(r70) goto L103 (error at first_completed:-1) else goto L71
L71:
    CPy_RestoreExcInfo(r70)
    dec_ref r70
    r71 = CPy_KeepPropagating()
    if not r71 goto L103 else goto L72 :: bool
L72:
    unreachable
L73:
    r72 = __mypyc_self__.__mypyc_temp__19
    if is_error(r72) goto L121 (error at first_completed:-1) else goto L74
L74:
    r73 = CPyIter_Send(r72, arg)
    dec_ref r72
    dec_ref arg
    if is_error(r73) goto L76 else goto L75
L75:
    r59 = r73
    goto L57
L76:
    r74 = CPy_FetchStopIterationValue()
    if is_error(r74) goto L103 (error at first_completed:79) else goto L77
L77:
    r56 = r74
L78:
    r75 = unbox(tuple[set, set], r56)
    dec_ref r56
    if is_error(r75) goto L103 (error at first_completed:79) else goto L79
L79:
    r76 = borrow r75[0]
    r77 = borrow r75[1]
    r78 = unborrow r76
    __mypyc_self__.done = r78; r79 = is_error
    if not r79 goto L103 (error at first_completed:79) else goto L80 :: bool
L80:
    r80 = unborrow r77
    __mypyc_self__.pending = r80; r81 = is_error
    if not r81 goto L103 (error at first_completed:79) else goto L81 :: bool
L81:
    r82 = __mypyc_self__.pending
    if is_error(r82) goto L103 (error at first_completed:80) else goto L82
L82:
    r83 = PyObject_GetIter(r82)
    if is_error(r83) goto L122 (error at first_completed:80) else goto L83
L83:
    __mypyc_self__.__mypyc_temp__21 = r82; r84 = is_error
    if not r84 goto L123 (error at first_completed:-1) else goto L84 :: bool
L84:
    __mypyc_self__.__mypyc_temp__22 = r83; r85 = is_error
    if not r85 goto L103 (error at first_completed:-1) else goto L85 :: bool
L85:
    r86 = __mypyc_self__.__mypyc_temp__22
    if is_error(r86) goto L103 (error at first_completed:80) else goto L86
L86:
    r87 = PyIter_Next(r86)
    dec_ref r86
    if is_error(r87) goto L91 else goto L87
L87:
    __mypyc_self__.p = r87; r88 = is_error
    if not r88 goto L103 (error at first_completed:80) else goto L88 :: bool
L88:
    r89 = __mypyc_self__.p
    if is_error(r89) goto L103 (error at first_completed:81) else goto L89
L89:
    r90 = 'cancel'
    r91 = [r89]
    r92 = load_address r91
    r93 = PyObject_VectorcallMethod(r90, r92, 9223372036854775809, 0)
    if is_error(r93) goto L124 (error at first_completed:81) else goto L125
L90:
    dec_ref r89
    goto L85
L91:
    r94 = CPy_NoErrOccurred()
    if not r94 goto L103 (error at first_completed:80) else goto L92 :: bool
L92:
    r95 = __mypyc_self__.done
    if is_error(r95) goto L103 (error at first_completed:82) else goto L93
L93:
    __mypyc_self__.__mypyc_next_label__ = -1
L94:
    if is_error(stop_iter_ptr) goto L95 else goto L97
L95:
    CPyGen_SetStopIterationValue(r95)
    dec_ref r95
    if not 0 goto L103 else goto L96 :: bool
L96:
    unreachable
L97:
    set_mem stop_iter_ptr, r95 :: builtins.object*
    return 0
L98:
    r97 = r4 == 0
    if r97 goto L126 else goto L99 :: bool
L99:
    r98 = r4 == 1
    if r98 goto L127 else goto L128 :: bool
L100:
    r99 = r4 == 2
    if r99 goto L58 else goto L129 :: bool
L101:
    r100 = raise StopIteration
    if not r100 goto L103 (error at first_completed:74) else goto L102 :: bool
L102:
    unreachable
L103:
    r101 = <error> :: object
    return r101
L104:
    dec_ref r8
    goto L8
L105:
    dec_ref r8
    goto L103
L106:
    dec_ref r21
    goto L103
L107:
    xdec_ref r1
    goto L22
L108:
    xdec_ref r1
    goto L21
L109:
    xdec_ref r1
    goto L31
L110:
    dec_ref r24
    goto L31
L111:
    dec_ref r21
    goto L31
L112:
    dec_ref arg
    goto L103
L113:
    dec_ref r43
    goto L47
L114:
    dec_ref r43
    goto L103
L115:
    dec_ref r56
    goto L103
L116:
    xdec_ref r3
    goto L61
L117:
    xdec_ref r3
    goto L60
L118:
    xdec_ref r3
    goto L70
L119:
    dec_ref r59
    goto L70
L120:
    dec_ref r56
    goto L70
L121:
    dec_ref arg
    goto L103
L122:
    dec_ref r82
    goto L103
L123:
    dec_ref r83
    goto L103
L124:
    dec_ref r89
    goto L103
L125:
    dec_ref r93
    goto L90
L126:
    xdec_ref r1
    xdec_ref r3
    goto L1
L127:
    xdec_ref r3
    goto L19
L128:
    xdec_ref r1
    goto L100
L129:
    xdec_ref r3
    goto L101

def first_completed_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = first_completed_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def first_completed_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = first_completed_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def first_completed_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def first_completed_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = first_completed_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def first_completed_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def first_completed_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def first_completed(fs, cancel):
    fs :: tuple
    cancel :: bool
    r0 :: dank_mids.helpers._gather.first_completed_gen
    r1, r2, r3 :: bool
    r4 :: dank_mids.helpers._gather.first_completed_gen
L0:
    if is_error(cancel) goto L1 else goto L2
L1:
    cancel = 0
L2:
    r0 = first_completed_gen()
    if is_error(r0) goto L6 (error at first_completed:74) else goto L3
L3:
    r0.__mypyc_next_label__ = 0
    inc_ref fs
    r0.fs = fs; r2 = is_error
    if not r2 goto L7 (error at first_completed:74) else goto L4 :: bool
L4:
    r0.cancel = cancel; r3 = is_error
    if not r3 goto L7 (error at first_completed:74) else goto L5 :: bool
L5:
    return r0
L6:
    r4 = <error> :: dank_mids.helpers._gather.first_completed_gen
    return r4
L7:
    dec_ref r0
    goto L6

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18 :: object
    r19 :: object_ptr
    r20 :: object_ptr[1]
    r21 :: c_ptr
    r22 :: native_int[1]
    r23 :: c_ptr
    r24 :: object
    r25 :: dict
    r26, r27 :: str
    r28 :: bit
    r29 :: str
    r30 :: dict
    r31 :: str
    r32 :: object
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36 :: dict
    r37 :: str
    r38 :: i32
    r39 :: bit
    r40 :: dict
    r41 :: str
    r42 :: object
    r43 :: str
    r44 :: object
    r45 :: dict
    r46 :: str
    r47 :: i32
    r48 :: bit
    r49 :: dict
    r50 :: str
    r51 :: object
    r52 :: str
    r53 :: object
    r54 :: dict
    r55 :: str
    r56 :: i32
    r57 :: bit
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: dict
    r62 :: str
    r63 :: i32
    r64 :: bit
    r65 :: object
    r66 :: str
    r67 :: object
    r68 :: dict
    r69 :: str
    r70 :: i32
    r71 :: bit
    r72 :: object
    r73 :: str
    r74 :: object
    r75 :: dict
    r76 :: str
    r77 :: i32
    r78 :: bit
    r79 :: dict
    r80 :: str
    r81 :: object
    r82 :: str
    r83 :: object
    r84 :: str
    r85 :: object
    r86 :: dict
    r87 :: str
    r88 :: i32
    r89 :: bit
    r90 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L26 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address asyncio :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('asyncio', 'asyncio', 'asyncio'),)
    r11 = dank_mids.helpers._gather.globals :: static
    r12 = 'dank_mids/helpers/_gather.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L26 else goto L4 :: bool
L4:
    r15 = ('Coroutine', 'Final', 'Iterable', 'Literal', 'Optional', 'Set', 'Tuple', 'TypeVar', 'Union', 'overload')
    r16 = 'typing'
    r17 = dank_mids.helpers._gather.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L26 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = load_address a_sync.asyncio :: module
    r20 = [r19]
    r21 = load_address r20
    r22 = [15]
    r23 = load_address r22
    r24 = (('a_sync.asyncio', 'a_sync', 'a_sync'),)
    r25 = dank_mids.helpers._gather.globals :: static
    r26 = 'dank_mids/helpers/_gather.py'
    r27 = '<module>'
    r28 = CPyImport_ImportMany(r24, r21, r25, r26, r27, r23)
    if not r28 goto L26 else goto L6 :: bool
L6:
    r29 = '__T'
    r30 = dank_mids.helpers._gather.globals :: static
    r31 = 'TypeVar'
    r32 = CPyDict_GetItem(r30, r31)
    if is_error(r32) goto L26 (error at <module>:18) else goto L7
L7:
    r33 = [r29]
    r34 = load_address r33
    r35 = PyObject_Vectorcall(r32, r34, 1, 0)
    dec_ref r32
    if is_error(r35) goto L26 (error at <module>:18) else goto L8
L8:
    r36 = dank_mids.helpers._gather.globals :: static
    r37 = '__T'
    r38 = CPyDict_SetItem(r36, r37, r35)
    dec_ref r35
    r39 = r38 >= 0 :: signed
    if not r39 goto L26 (error at <module>:18) else goto L9 :: bool
L9:
    r40 = dank_mids.helpers._gather.globals :: static
    r41 = 'Set'
    r42 = CPyDict_GetItem(r40, r41)
    if is_error(r42) goto L26 (error at <module>:20) else goto L10
L10:
    r43 = 'asyncio.Future[__T]'
    r44 = PyObject_GetItem(r42, r43)
    dec_ref r42
    if is_error(r44) goto L26 (error at <module>:20) else goto L11
L11:
    r45 = dank_mids.helpers._gather.globals :: static
    r46 = 'FinishedTasks'
    r47 = CPyDict_SetItem(r45, r46, r44)
    dec_ref r44
    r48 = r47 >= 0 :: signed
    if not r48 goto L26 (error at <module>:20) else goto L12 :: bool
L12:
    r49 = dank_mids.helpers._gather.globals :: static
    r50 = 'Set'
    r51 = CPyDict_GetItem(r49, r50)
    if is_error(r51) goto L26 (error at <module>:21) else goto L13
L13:
    r52 = 'asyncio.Future[__T]'
    r53 = PyObject_GetItem(r51, r52)
    dec_ref r51
    if is_error(r53) goto L26 (error at <module>:21) else goto L14
L14:
    r54 = dank_mids.helpers._gather.globals :: static
    r55 = 'PendingTasks'
    r56 = CPyDict_SetItem(r54, r55, r53)
    dec_ref r53
    r57 = r56 >= 0 :: signed
    if not r57 goto L26 (error at <module>:21) else goto L15 :: bool
L15:
    r58 = asyncio :: module
    r59 = 'Task'
    r60 = CPyObject_GetAttr(r58, r59)
    if is_error(r60) goto L26 (error at <module>:25) else goto L16
L16:
    dank_mids.helpers._gather.Task = r60 :: static
    r61 = dank_mids.helpers._gather.globals :: static
    r62 = 'Task'
    r63 = CPyDict_SetItem(r61, r62, r60)
    dec_ref r60
    r64 = r63 >= 0 :: signed
    if not r64 goto L26 (error at <module>:25) else goto L17 :: bool
L17:
    r65 = asyncio :: module
    r66 = 'get_running_loop'
    r67 = CPyObject_GetAttr(r65, r66)
    if is_error(r67) goto L26 (error at <module>:26) else goto L18
L18:
    dank_mids.helpers._gather.get_running_loop = r67 :: static
    r68 = dank_mids.helpers._gather.globals :: static
    r69 = 'get_running_loop'
    r70 = CPyDict_SetItem(r68, r69, r67)
    dec_ref r67
    r71 = r70 >= 0 :: signed
    if not r71 goto L26 (error at <module>:26) else goto L19 :: bool
L19:
    r72 = asyncio :: module
    r73 = 'wait'
    r74 = CPyObject_GetAttr(r72, r73)
    if is_error(r74) goto L26 (error at <module>:27) else goto L20
L20:
    dank_mids.helpers._gather.wait = r74 :: static
    r75 = dank_mids.helpers._gather.globals :: static
    r76 = 'wait'
    r77 = CPyDict_SetItem(r75, r76, r74)
    dec_ref r74
    r78 = r77 >= 0 :: signed
    if not r78 goto L26 (error at <module>:27) else goto L21 :: bool
L21:
    r79 = dank_mids.helpers._gather.globals :: static
    r80 = 'a_sync'
    r81 = CPyDict_GetItem(r79, r80)
    if is_error(r81) goto L26 (error at <module>:30) else goto L22
L22:
    r82 = 'asyncio'
    r83 = CPyObject_GetAttr(r81, r82)
    dec_ref r81
    if is_error(r83) goto L26 (error at <module>:30) else goto L23
L23:
    r84 = 'sleep0'
    r85 = CPyObject_GetAttr(r83, r84)
    dec_ref r83
    if is_error(r85) goto L26 (error at <module>:30) else goto L24
L24:
    dank_mids.helpers._gather.yield_to_loop = r85 :: static
    r86 = dank_mids.helpers._gather.globals :: static
    r87 = 'yield_to_loop'
    r88 = CPyDict_SetItem(r86, r87, r85)
    dec_ref r85
    r89 = r88 >= 0 :: signed
    if not r89 goto L26 (error at <module>:30) else goto L25 :: bool
L25:
    return 1
L26:
    r90 = <error> :: None
    return r90

def __init___FunctionABI_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __init___FunctionABI_obj.__call__(__mypyc_self__, self, abi):
    __mypyc_self__ :: dank_mids.brownie_patch._abi.__init___FunctionABI_obj
    self :: dank_mids.brownie_patch._abi.FunctionABI
    abi :: dict
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3, r4 :: str
    r5 :: i32
    r6 :: bit
    r7, r8 :: str
    r9 :: i32
    r10 :: bit
    r11 :: None
L0:
    r0 = 'abi'
    r1 = PyObject_SetAttr(self, r0, abi)
    r2 = r1 >= 0 :: signed
    if not r2 goto L6 (error at __init__:47) else goto L1 :: bool
L1:
    r3 = build_function_signature(abi)
    if is_error(r3) goto L6 (error at __init__:53) else goto L2
L2:
    r4 = 'input_sig'
    r5 = PyObject_SetAttr(self, r4, r3)
    r6 = r5 >= 0 :: signed
    if not r6 goto L7 (error at __init__:54) else goto L3 :: bool
L3:
    r7 = build_function_selector(r3)
    dec_ref r3
    if is_error(r7) goto L6 (error at __init__:60) else goto L4
L4:
    r8 = 'signature'
    r9 = PyObject_SetAttr(self, r8, r7)
    dec_ref r7
    r10 = r9 >= 0 :: signed
    if not r10 goto L6 (error at __init__:60) else goto L5 :: bool
L5:
    return 1
L6:
    r11 = <error> :: None
    return r11
L7:
    dec_ref r3
    goto L6

def singleton_FunctionABI_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def singleton_FunctionABI_obj.__call__(__mypyc_self__, abi):
    __mypyc_self__ :: dank_mids.brownie_patch._abi.singleton_FunctionABI_obj
    abi :: dict
    r0 :: list
    r1 :: ptr
    r2 :: native_int
    r3 :: tuple
    r4 :: native_int
    r5 :: ptr
    r6 :: native_int
    r7 :: bit
    r8, r9 :: ptr
    r10 :: native_int
    r11 :: ptr
    r12 :: object
    r13 :: str
    r14, r15 :: object
    r16 :: tuple[str, object]
    r17 :: object
    r18 :: native_int
    r19 :: object
    r20 :: bool
    r21 :: object
    r22 :: dank_mids.brownie_patch._abi.FunctionABI
    r23 :: tuple[object, object, object]
    r24 :: object
    r25 :: str
    r26 :: object
    r27 :: bit
    r28 :: object
    r29 :: dict
    r30 :: i32
    r31 :: bit
    r32 :: tuple
    r33 :: object
    r34 :: dank_mids.brownie_patch._abi.FunctionABI
    r35 :: object
    r36 :: bool
    r37 :: i32
    r38 :: bit
    r39 :: object
    r40 :: str
    r41 :: object
    r42 :: bit
    r43 :: object
    r44 :: str
    r45 :: object
    r46 :: str
    r47 :: object
    r48 :: object[2]
    r49 :: object_ptr
    r50 :: object
    r51 :: bit
    r52 :: dank_mids.brownie_patch._abi.FunctionABI
L0:
    r0 = CPySequence_Sort(abi)
    if is_error(r0) goto L39 (error at singleton:74) else goto L1
L1:
    r1 = get_element_ptr r0 ob_size :: PyVarObject
    r2 = load_mem r1 :: native_int*
    r3 = PyTuple_New(r2)
    if is_error(r3) goto L40 (error at singleton:74) else goto L2
L2:
    r4 = 0
L3:
    r5 = get_element_ptr r0 ob_size :: PyVarObject
    r6 = load_mem r5 :: native_int*
    r7 = r4 < r6 :: signed
    if r7 goto L4 else goto L41 :: bool
L4:
    r8 = get_element_ptr r0 ob_item :: PyListObject
    r9 = load_mem r8 :: ptr*
    r10 = r4 * 8
    r11 = r9 + r10
    r12 = load_mem r11 :: builtins.object*
    r13 = cast(str, r12)
    if is_error(r13) goto L42 (error at singleton:74) else goto L5
L5:
    r14 = CPyDict_GetItem(abi, r13)
    if is_error(r14) goto L43 (error at singleton:74) else goto L6
L6:
    r15 = make_hashable(r14)
    dec_ref r14
    if is_error(r15) goto L43 (error at singleton:74) else goto L7
L7:
    r16 = (r13, r15)
    r17 = box(tuple[str, object], r16)
    CPySequenceTuple_SetItemUnsafe(r3, r4, r17)
L8:
    r18 = r4 + 1
    r4 = r18
    goto L3
L9:
L10:
    r19 = dank_mids.brownie_patch._abi._singletons :: static
    if is_error(r19) goto L11 else goto L13
L11:
    r20 = raise NameError('value for final name "_singletons" was not set')
    if not r20 goto L16 (error at singleton:76) else goto L44 :: bool
L12:
    unreachable
L13:
    r21 = PyObject_GetItem(r19, r3)
    if is_error(r21) goto L16 (error at singleton:76) else goto L14
L14:
    r22 = cast(dank_mids.brownie_patch._abi.FunctionABI, r21)
    if is_error(r22) goto L16 (error at singleton:76) else goto L45
L15:
    return r22
L16:
    r23 = CPy_CatchError()
    r24 = builtins :: module
    r25 = 'KeyError'
    r26 = CPyObject_GetAttr(r24, r25)
    if is_error(r26) goto L46 (error at singleton:77) else goto L17
L17:
    r27 = CPy_ExceptionMatches(r26)
    dec_ref r26
    if r27 goto L18 else goto L28 :: bool
L18:
    r28 = dank_mids.brownie_patch._abi.FunctionABI :: type
    r29 = PyDict_New()
    if is_error(r29) goto L46 (error at singleton:78) else goto L19
L19:
    r30 = CPyDict_UpdateInDisplay(r29, abi)
    r31 = r30 >= 0 :: signed
    if not r31 goto L47 (error at singleton:78) else goto L20 :: bool
L20:
    r32 = PyTuple_Pack(0)
    if is_error(r32) goto L47 (error at singleton:78) else goto L21
L21:
    r33 = PyObject_Call(r28, r32, r29)
    dec_ref r32
    dec_ref r29
    if is_error(r33) goto L46 (error at singleton:78) else goto L22
L22:
    r34 = cast(dank_mids.brownie_patch._abi.FunctionABI, r33)
    if is_error(r34) goto L46 (error at singleton:78) else goto L23
L23:
    inc_ref r34
    r35 = dank_mids.brownie_patch._abi._singletons :: static
    if is_error(r35) goto L48 else goto L26
L24:
    r36 = raise NameError('value for final name "_singletons" was not set')
    if not r36 goto L37 (error at singleton:78) else goto L49 :: bool
L25:
    unreachable
L26:
    r37 = PyObject_SetItem(r35, r3, r34)
    dec_ref r3
    dec_ref r34
    r38 = r37 >= 0 :: signed
    if not r38 goto L50 (error at singleton:78) else goto L27 :: bool
L27:
    CPy_RestoreExcInfo(r23)
    dec_ref r23
    return r34
L28:
    r39 = builtins :: module
    r40 = 'AttributeError'
    r41 = CPyObject_GetAttr(r39, r40)
    if is_error(r41) goto L46 (error at singleton:80) else goto L29
L29:
    r42 = CPy_ExceptionMatches(r41)
    dec_ref r41
    if r42 goto L30 else goto L51 :: bool
L30:
    r43 = CPy_GetExcValue()
    r44 = PyObject_Str(r43)
    dec_ref r43
    if is_error(r44) goto L46 (error at singleton:81) else goto L31
L31:
    r45 = builtins :: module
    r46 = 'AttributeError'
    r47 = CPyObject_GetAttr(r45, r46)
    if is_error(r47) goto L52 (error at singleton:81) else goto L32
L32:
    r48 = [r44, r3]
    r49 = load_address r48
    r50 = PyObject_Vectorcall(r47, r49, 2, 0)
    dec_ref r47
    if is_error(r50) goto L52 (error at singleton:81) else goto L33
L33:
    dec_ref r44
    dec_ref r3
    CPy_Raise(r50)
    dec_ref r50
    if not 0 goto L37 (error at singleton:81) else goto L53 :: bool
L34:
    unreachable
L35:
    CPy_Reraise()
    if not 0 goto L37 else goto L54 :: bool
L36:
    unreachable
L37:
    CPy_RestoreExcInfo(r23)
    dec_ref r23
    r51 = CPy_KeepPropagating()
    if not r51 goto L39 else goto L38 :: bool
L38:
    unreachable
L39:
    r52 = <error> :: dank_mids.brownie_patch._abi.FunctionABI
    return r52
L40:
    dec_ref r0
    goto L39
L41:
    dec_ref r0
    goto L9
L42:
    dec_ref r0
    dec_ref r3
    goto L39
L43:
    dec_ref r0
    dec_ref r3
    dec_ref r13
    goto L39
L44:
    dec_ref r3
    goto L12
L45:
    dec_ref r3
    goto L15
L46:
    dec_ref r3
    goto L37
L47:
    dec_ref r3
    dec_ref r29
    goto L37
L48:
    dec_ref r3
    dec_ref r34
    dec_ref r34
    goto L24
L49:
    dec_ref r23
    goto L25
L50:
    dec_ref r34
    goto L37
L51:
    dec_ref r3
    goto L35
L52:
    dec_ref r3
    dec_ref r44
    goto L37
L53:
    dec_ref r23
    goto L34
L54:
    dec_ref r23
    goto L36

def get_type_strings(abi_params, substitutions):
    abi_params :: object
    substitutions :: union[dict, None]
    r0 :: object
    r1 :: list
    r2 :: object
    r3 :: bit
    r4 :: dict
    r5, r6 :: object
    r7 :: dict
    r8 :: str
    r9 :: object
    r10, type_str, r11 :: str
    r12 :: i32
    r13 :: bool
    r14 :: str
    r15 :: object
    r16 :: dict
    r17 :: list
    r18 :: object
    r19, r20, r21, r22, r23, r24 :: str
    r25 :: i32
    r26 :: bit
    r27 :: dict
    r28 :: short_int
    r29 :: native_int
    r30 :: object
    r31 :: tuple[bool, short_int, object, object]
    r32 :: short_int
    r33 :: bool
    r34, r35 :: object
    r36 :: str
    r37 :: i32
    r38 :: bool
    r39 :: str
    r40 :: object[3]
    r41 :: object_ptr
    r42 :: object
    r43 :: str
    r44, r45 :: bit
    r46 :: i32
    r47, r48 :: bit
    r49 :: list
L0:
    if is_error(substitutions) goto L1 else goto L34
L1:
    r0 = box(None, 1)
    inc_ref r0
    substitutions = r0
L2:
    r1 = PyList_New(0)
    if is_error(r1) goto L35 (error at get_type_strings:89) else goto L3
L3:
    r2 = load_address _Py_NoneStruct
    r3 = substitutions == r2
    if r3 goto L36 else goto L6 :: bool
L4:
    r4 = PyDict_New()
    if is_error(r4) goto L37 (error at get_type_strings:91) else goto L5
L5:
    substitutions = r4
L6:
    r5 = PyObject_GetIter(abi_params)
    if is_error(r5) goto L38 (error at get_type_strings:93) else goto L7
L7:
    r6 = PyIter_Next(r5)
    if is_error(r6) goto L39 else goto L8
L8:
    r7 = cast(dict, r6)
    if is_error(r7) goto L40 (error at get_type_strings:93) else goto L9
L9:
    r8 = 'type'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L41 (error at get_type_strings:94) else goto L10
L10:
    r10 = cast(str, r9)
    if is_error(r10) goto L41 (error at get_type_strings:94) else goto L11
L11:
    type_str = r10
    r11 = 'tuple'
    r12 = CPyStr_Startswith(type_str, r11)
    r13 = truncate r12: i32 to builtins.bool
    if r13 goto L12 else goto L42 :: bool
L12:
    r14 = 'components'
    r15 = CPyDict_GetItem(r7, r14)
    dec_ref r7
    if is_error(r15) goto L43 (error at get_type_strings:96) else goto L13
L13:
    inc_ref substitutions
    r16 = cast(dict, substitutions)
    if is_error(r16) goto L44 (error at get_type_strings:96) else goto L14
L14:
    r17 = get_type_strings(r15, r16)
    dec_ref r15
    dec_ref r16
    if is_error(r17) goto L43 (error at get_type_strings:96) else goto L15
L15:
    r18 = CPyStr_GetSlice(type_str, 10, 9223372036854775806)
    dec_ref type_str
    if is_error(r18) goto L45 (error at get_type_strings:97) else goto L16
L16:
    r19 = cast(str, r18)
    if is_error(r19) goto L45 (error at get_type_strings:97) else goto L17
L17:
    r20 = '('
    r21 = ','
    r22 = PyUnicode_Join(r21, r17)
    dec_ref r17
    if is_error(r22) goto L46 (error at get_type_strings:98) else goto L18
L18:
    r23 = ')'
    r24 = CPyStr_Build(4, r20, r22, r23, r19)
    dec_ref r22
    dec_ref r19
    if is_error(r24) goto L40 (error at get_type_strings:98) else goto L19
L19:
    r25 = PyList_Append(r1, r24)
    dec_ref r24
    r26 = r25 >= 0 :: signed
    if not r26 goto L40 (error at get_type_strings:98) else goto L7 :: bool
L20:
    inc_ref substitutions
    r27 = cast(dict, substitutions)
    if is_error(r27) goto L43 (error at get_type_strings:100) else goto L21
L21:
    r28 = 0
    r29 = PyDict_Size(r27)
    r30 = CPyDict_GetItemsIter(r27)
    if is_error(r30) goto L47 (error at get_type_strings:100) else goto L22
L22:
    r31 = CPyDict_NextItem(r30, r28)
    r32 = r31[1]
    r28 = r32
    r33 = r31[0]
    if r33 goto L23 else goto L48 :: bool
L23:
    r34 = r31[2]
    r35 = r31[3]
    dec_ref r31
    r36 = cast(str, r34)
    if is_error(r36) goto L49 (error at get_type_strings:100) else goto L24
L24:
    r37 = CPyStr_Startswith(type_str, r36)
    r38 = truncate r37: i32 to builtins.bool
    if r38 goto L25 else goto L50 :: bool
L25:
    r39 = 'replace'
    r40 = [type_str, r36, r35]
    r41 = load_address r40
    r42 = PyObject_VectorcallMethod(r39, r41, 9223372036854775811, 0)
    if is_error(r42) goto L51 (error at get_type_strings:102) else goto L26
L26:
    dec_ref type_str
    dec_ref r36
    dec_ref r35
    r43 = cast(str, r42)
    if is_error(r43) goto L52 (error at get_type_strings:102) else goto L27
L27:
    type_str = r43
L28:
    r44 = CPyDict_CheckSize(r27, r29)
    if not r44 goto L53 (error at get_type_strings:100) else goto L22 :: bool
L29:
    r45 = CPy_NoErrOccurred()
    if not r45 goto L43 (error at get_type_strings:100) else goto L30 :: bool
L30:
    r46 = PyList_Append(r1, type_str)
    dec_ref type_str
    r47 = r46 >= 0 :: signed
    if not r47 goto L40 (error at get_type_strings:103) else goto L7 :: bool
L31:
    r48 = CPy_NoErrOccurred()
    if not r48 goto L37 (error at get_type_strings:93) else goto L32 :: bool
L32:
    return r1
L33:
    r49 = <error> :: list
    return r49
L34:
    inc_ref substitutions
    goto L2
L35:
    dec_ref substitutions
    goto L33
L36:
    dec_ref substitutions
    goto L4
L37:
    dec_ref r1
    goto L33
L38:
    dec_ref substitutions
    dec_ref r1
    goto L33
L39:
    dec_ref substitutions
    dec_ref r5
    goto L31
L40:
    dec_ref substitutions
    dec_ref r1
    dec_ref r5
    goto L33
L41:
    dec_ref substitutions
    dec_ref r1
    dec_ref r5
    dec_ref r7
    goto L33
L42:
    dec_ref r7
    goto L20
L43:
    dec_ref substitutions
    dec_ref r1
    dec_ref r5
    dec_ref type_str
    goto L33
L44:
    dec_ref substitutions
    dec_ref r1
    dec_ref r5
    dec_ref type_str
    dec_ref r15
    goto L33
L45:
    dec_ref substitutions
    dec_ref r1
    dec_ref r5
    dec_ref r17
    goto L33
L46:
    dec_ref substitutions
    dec_ref r1
    dec_ref r5
    dec_ref r19
    goto L33
L47:
    dec_ref substitutions
    dec_ref r1
    dec_ref r5
    dec_ref type_str
    dec_ref r27
    goto L33
L48:
    dec_ref r27
    dec_ref r30
    dec_ref r31
    goto L29
L49:
    dec_ref substitutions
    dec_ref r1
    dec_ref r5
    dec_ref type_str
    dec_ref r27
    dec_ref r30
    dec_ref r35
    goto L33
L50:
    dec_ref r36
    dec_ref r35
    goto L28
L51:
    dec_ref substitutions
    dec_ref r1
    dec_ref r5
    dec_ref type_str
    dec_ref r27
    dec_ref r30
    dec_ref r36
    dec_ref r35
    goto L33
L52:
    dec_ref substitutions
    dec_ref r1
    dec_ref r5
    dec_ref r27
    dec_ref r30
    goto L33
L53:
    dec_ref substitutions
    dec_ref r1
    dec_ref r5
    dec_ref type_str
    dec_ref r27
    dec_ref r30
    goto L33

def build_function_signature(abi):
    abi :: dict
    r0 :: str
    r1 :: object
    r2 :: union[dict, None]
    r3 :: list
    r4 :: str
    r5 :: object
    r6, r7, r8, r9, r10, r11, r12 :: str
L0:
    r0 = 'inputs'
    r1 = CPyDict_GetItem(abi, r0)
    if is_error(r1) goto L7 (error at build_function_signature:109) else goto L1
L1:
    r2 = <error> :: union[dict, None]
    r3 = get_type_strings(r1, r2)
    dec_ref r1
    if is_error(r3) goto L7 (error at build_function_signature:109) else goto L2
L2:
    r4 = 'name'
    r5 = CPyDict_GetItem(abi, r4)
    if is_error(r5) goto L8 (error at build_function_signature:110) else goto L3
L3:
    r6 = cast(str, r5)
    if is_error(r6) goto L8 (error at build_function_signature:110) else goto L4
L4:
    r7 = '('
    r8 = ','
    r9 = PyUnicode_Join(r8, r3)
    dec_ref r3
    if is_error(r9) goto L9 (error at build_function_signature:110) else goto L5
L5:
    r10 = ')'
    r11 = CPyStr_Build(4, r6, r7, r9, r10)
    dec_ref r6
    dec_ref r9
    if is_error(r11) goto L7 (error at build_function_signature:110) else goto L6
L6:
    return r11
L7:
    r12 = <error> :: str
    return r12
L8:
    dec_ref r3
    goto L7
L9:
    dec_ref r6
    goto L7

def build_function_selector(input_signature):
    input_signature, r0 :: str
    r1 :: bytes
    r2 :: object
    r3 :: bool
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: str
    r8 :: object[1]
    r9 :: object_ptr
    r10, r11, r12, r13, r14, r15 :: object
    r16, r17, r18 :: str
L0:
    r0 = '0x'
    r1 = PyUnicode_AsUTF8String(input_signature)
    if is_error(r1) goto L11 (error at build_function_selector:114) else goto L1
L1:
    r2 = dank_mids.brownie_patch._abi.keccak :: static
    if is_error(r2) goto L12 else goto L4
L2:
    r3 = raise NameError('value for final name "keccak" was not set')
    if not r3 goto L11 (error at build_function_selector:114) else goto L3 :: bool
L3:
    unreachable
L4:
    r4 = [r1]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r2, r5, 1, 0)
    if is_error(r6) goto L13 (error at build_function_selector:114) else goto L5
L5:
    dec_ref r1
    r7 = 'hex'
    r8 = [r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775809, 0)
    if is_error(r10) goto L14 (error at build_function_selector:114) else goto L6
L6:
    dec_ref r6
    r11 = load_address _Py_NoneStruct
    r12 = load_address _Py_NoneStruct
    r13 = object 8
    r14 = PySlice_New(r11, r13, r12)
    if is_error(r14) goto L15 (error at build_function_selector:114) else goto L7
L7:
    r15 = PyObject_GetItem(r10, r14)
    dec_ref r10
    dec_ref r14
    if is_error(r15) goto L11 (error at build_function_selector:114) else goto L8
L8:
    r16 = PyObject_Str(r15)
    dec_ref r15
    if is_error(r16) goto L11 (error at build_function_selector:114) else goto L9
L9:
    r17 = CPyStr_Build(2, r0, r16)
    dec_ref r16
    if is_error(r17) goto L11 (error at build_function_selector:114) else goto L10
L10:
    return r17
L11:
    r18 = <error> :: str
    return r18
L12:
    dec_ref r1
    goto L2
L13:
    dec_ref r1
    goto L11
L14:
    dec_ref r6
    goto L11
L15:
    dec_ref r10
    goto L11

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24, r25 :: object
    r26 :: str
    r27 :: dict
    r28, r29 :: object
    r30 :: str
    r31 :: dict
    r32 :: object
    r33 :: dict
    r34 :: str
    r35 :: object
    r36 :: dict
    r37 :: str
    r38, r39 :: object
    r40 :: dict
    r41 :: str
    r42 :: object
    r43 :: tuple[object, object]
    r44, r45, r46 :: object
    r47 :: tuple[object, object]
    r48, r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: dict
    r55 :: str
    r56, r57 :: object
    r58 :: dict
    r59 :: str
    r60 :: i32
    r61 :: bit
    r62 :: dict
    r63 :: str
    r64 :: object
    r65 :: str
    r66 :: object
    r67 :: dict
    r68 :: str
    r69 :: i32
    r70 :: bit
    r71 :: tuple
    r72, r73 :: object
    r74 :: str
    r75 :: bool
    r76, r77 :: str
    r78 :: object
    r79 :: object[2]
    r80 :: object_ptr
    r81 :: object
    r82, r83, r84, r85 :: dict
    r86 :: dank_mids.brownie_patch._abi.__init___FunctionABI_obj
    r87 :: str
    r88 :: i32
    r89 :: bit
    r90 :: dank_mids.brownie_patch._abi.singleton_FunctionABI_obj
    r91 :: object
    r92 :: str
    r93 :: object
    r94 :: object[1]
    r95 :: object_ptr
    r96 :: object
    r97 :: str
    r98 :: i32
    r99 :: bit
    r100, r101 :: str
    r102 :: i32
    r103 :: bit
    r104, r105 :: str
    r106 :: i32
    r107 :: bit
    r108, r109 :: str
    r110 :: i32
    r111 :: bit
    r112 :: object[3]
    r113 :: object_ptr
    r114 :: object
    r115 :: dict
    r116 :: str
    r117, r118 :: object
    r119 :: object[1]
    r120 :: object_ptr
    r121, r122 :: object
    r123 :: object[1]
    r124 :: object_ptr
    r125 :: object
    r126 :: dict
    r127 :: str
    r128 :: object
    r129 :: object[1]
    r130 :: object_ptr
    r131 :: object
    r132 :: dict
    r133 :: str
    r134 :: i32
    r135 :: bit
    r136 :: object
    r137 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L49 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Dict', 'Final', 'List', 'Optional', 'Sequence', 'Tuple', 'final')
    r6 = 'typing'
    r7 = dank_mids.brownie_patch._abi.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L49 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('WeakValueDictionary',)
    r10 = 'weakref'
    r11 = dank_mids.brownie_patch._abi.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L49 (error at <module>:2) else goto L5
L5:
    weakref = r12 :: module
    dec_ref r12
    r13 = ('auto',)
    r14 = 'eth_hash'
    r15 = dank_mids.brownie_patch._abi.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L49 (error at <module>:4) else goto L6
L6:
    eth_hash = r16 :: module
    dec_ref r16
    r17 = ('ABIComponent', 'ABIFunction')
    r18 = 'eth_typing'
    r19 = dank_mids.brownie_patch._abi.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L49 (error at <module>:5) else goto L7
L7:
    eth_typing = r20 :: module
    dec_ref r20
    r21 = ('mypyc_attr',)
    r22 = 'mypy_extensions'
    r23 = dank_mids.brownie_patch._abi.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L49 (error at <module>:6) else goto L8
L8:
    mypy_extensions = r24 :: module
    dec_ref r24
    r25 = ('Unpack',)
    r26 = 'typing_extensions'
    r27 = dank_mids.brownie_patch._abi.globals :: static
    r28 = CPyImport_ImportFromMany(r26, r25, r25, r27)
    if is_error(r28) goto L49 (error at <module>:7) else goto L9
L9:
    typing_extensions = r28 :: module
    dec_ref r28
    r29 = ('make_hashable',)
    r30 = 'dank_mids.helpers.hashing'
    r31 = dank_mids.brownie_patch._abi.globals :: static
    r32 = CPyImport_ImportFromMany(r30, r29, r29, r31)
    if is_error(r32) goto L49 (error at <module>:9) else goto L10
L10:
    dank_mids.helpers.hashing = r32 :: module
    dec_ref r32
    r33 = dank_mids.brownie_patch._abi.globals :: static
    r34 = 'Tuple'
    r35 = CPyDict_GetItem(r33, r34)
    if is_error(r35) goto L49 (error at <module>:12) else goto L11
L11:
    r36 = dank_mids.brownie_patch._abi.globals :: static
    r37 = 'Tuple'
    r38 = CPyDict_GetItem(r36, r37)
    if is_error(r38) goto L50 (error at <module>:12) else goto L12
L12:
    r39 = load_address PyUnicode_Type
    r40 = dank_mids.brownie_patch._abi.globals :: static
    r41 = 'Any'
    r42 = CPyDict_GetItem(r40, r41)
    if is_error(r42) goto L51 (error at <module>:12) else goto L13
L13:
    inc_ref r39
    r43 = (r39, r42)
    r44 = box(tuple[object, object], r43)
    r45 = PyObject_GetItem(r38, r44)
    dec_ref r38
    dec_ref r44
    if is_error(r45) goto L50 (error at <module>:12) else goto L14
L14:
    r46 = load_address _Py_EllipsisObject
    inc_ref r46
    r47 = (r45, r46)
    r48 = box(tuple[object, object], r47)
    r49 = PyObject_GetItem(r35, r48)
    dec_ref r35
    dec_ref r48
    if is_error(r49) goto L49 (error at <module>:12) else goto L15
L15:
    r50 = dank_mids.brownie_patch._abi.globals :: static
    r51 = 'SingletonKey'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L49 (error at <module>:12) else goto L16 :: bool
L16:
    r54 = dank_mids.brownie_patch._abi.globals :: static
    r55 = 'WeakValueDictionary'
    r56 = CPyDict_GetItem(r54, r55)
    if is_error(r56) goto L49 (error at <module>:14) else goto L17
L17:
    r57 = PyObject_Vectorcall(r56, 0, 0, 0)
    dec_ref r56
    if is_error(r57) goto L49 (error at <module>:14) else goto L18
L18:
    dank_mids.brownie_patch._abi._singletons = r57 :: static
    r58 = dank_mids.brownie_patch._abi.globals :: static
    r59 = '_singletons'
    r60 = CPyDict_SetItem(r58, r59, r57)
    dec_ref r57
    r61 = r60 >= 0 :: signed
    if not r61 goto L49 (error at <module>:14) else goto L19 :: bool
L19:
    r62 = dank_mids.brownie_patch._abi.globals :: static
    r63 = 'auto'
    r64 = CPyDict_GetItem(r62, r63)
    if is_error(r64) goto L49 (error at <module>:17) else goto L20
L20:
    r65 = 'keccak'
    r66 = CPyObject_GetAttr(r64, r65)
    dec_ref r64
    if is_error(r66) goto L49 (error at <module>:17) else goto L21
L21:
    dank_mids.brownie_patch._abi.keccak = r66 :: static
    r67 = dank_mids.brownie_patch._abi.globals :: static
    r68 = 'keccak'
    r69 = CPyDict_SetItem(r67, r68, r66)
    dec_ref r66
    r70 = r69 >= 0 :: signed
    if not r70 goto L49 (error at <module>:17) else goto L22 :: bool
L22:
    r71 = PyTuple_Pack(0)
    if is_error(r71) goto L49 (error at <module>:31) else goto L23
L23:
    r72 = load_address PyType_Type
    r73 = CPy_CalculateMetaclass(r72, r71)
    if is_error(r73) goto L52 (error at <module>:31) else goto L24
L24:
    r74 = '__prepare__'
    r75 = PyObject_HasAttr(r73, r74)
    if r75 goto L25 else goto L29 :: bool
L25:
    r76 = 'FunctionABI'
    r77 = '__prepare__'
    r78 = CPyObject_GetAttr(r73, r77)
    if is_error(r78) goto L52 (error at <module>:31) else goto L26
L26:
    r79 = [r76, r71]
    r80 = load_address r79
    r81 = PyObject_Vectorcall(r78, r80, 2, 0)
    dec_ref r78
    if is_error(r81) goto L52 (error at <module>:31) else goto L27
L27:
    r82 = cast(dict, r81)
    if is_error(r82) goto L52 (error at <module>:31) else goto L28
L28:
    r83 = r82
    goto L31
L29:
    r84 = PyDict_New()
    if is_error(r84) goto L52 (error at <module>:31) else goto L30
L30:
    r83 = r84
L31:
    r85 = PyDict_New()
    if is_error(r85) goto L53 (error at <module>:31) else goto L32
L32:
    r86 = __init___FunctionABI_obj()
    if is_error(r86) goto L54 (error at <module>:39) else goto L33
L33:
    r87 = '__init__'
    r88 = CPyDict_SetItem(r83, r87, r86)
    dec_ref r86
    r89 = r88 >= 0 :: signed
    if not r89 goto L54 (error at <module>:39) else goto L34 :: bool
L34:
    r90 = singleton_FunctionABI_obj()
    if is_error(r90) goto L54 (error at <module>:67) else goto L35
L35:
    r91 = builtins :: module
    r92 = 'staticmethod'
    r93 = CPyObject_GetAttr(r91, r92)
    if is_error(r93) goto L55 (error at <module>:67) else goto L36
L36:
    r94 = [r90]
    r95 = load_address r94
    r96 = PyObject_Vectorcall(r93, r95, 1, 0)
    dec_ref r93
    if is_error(r96) goto L55 (error at <module>:67) else goto L37
L37:
    dec_ref r90
    r97 = 'singleton'
    r98 = CPyDict_SetItem(r83, r97, r96)
    dec_ref r96
    r99 = r98 >= 0 :: signed
    if not r99 goto L54 (error at <module>:67) else goto L38 :: bool
L38:
    r100 = 'FunctionABI'
    r101 = '__annotations__'
    r102 = CPyDict_SetItem(r83, r101, r85)
    dec_ref r85
    r103 = r102 >= 0 :: signed
    if not r103 goto L53 (error at <module>:31) else goto L39 :: bool
L39:
    r104 = 'mypyc filler docstring'
    r105 = '__doc__'
    r106 = CPyDict_SetItem(r83, r105, r104)
    r107 = r106 >= 0 :: signed
    if not r107 goto L53 (error at <module>:31) else goto L40 :: bool
L40:
    r108 = 'dank_mids.brownie_patch._abi'
    r109 = '__module__'
    r110 = CPyDict_SetItem(r83, r109, r108)
    r111 = r110 >= 0 :: signed
    if not r111 goto L53 (error at <module>:31) else goto L41 :: bool
L41:
    r112 = [r100, r71, r83]
    r113 = load_address r112
    r114 = PyObject_Vectorcall(r73, r113, 3, 0)
    if is_error(r114) goto L53 (error at <module>:31) else goto L42
L42:
    dec_ref r83
    dec_ref r71
    r115 = dank_mids.brownie_patch._abi.globals :: static
    r116 = 'mypyc_attr'
    r117 = CPyDict_GetItem(r115, r116)
    if is_error(r117) goto L56 (error at <module>:28) else goto L43
L43:
    r118 = box(bool, 0)
    r119 = [r118]
    r120 = load_address r119
    r121 = ('native_class',)
    r122 = PyObject_Vectorcall(r117, r120, 0, r121)
    dec_ref r117
    if is_error(r122) goto L56 (error at <module>:28) else goto L44
L44:
    r123 = [r114]
    r124 = load_address r123
    r125 = PyObject_Vectorcall(r122, r124, 1, 0)
    dec_ref r122
    if is_error(r125) goto L56 (error at <module>:31) else goto L45
L45:
    dec_ref r114
    r126 = dank_mids.brownie_patch._abi.globals :: static
    r127 = 'final'
    r128 = CPyDict_GetItem(r126, r127)
    if is_error(r128) goto L57 (error at <module>:27) else goto L46
L46:
    r129 = [r125]
    r130 = load_address r129
    r131 = PyObject_Vectorcall(r128, r130, 1, 0)
    dec_ref r128
    if is_error(r131) goto L57 (error at <module>:31) else goto L47
L47:
    dec_ref r125
    dank_mids.brownie_patch._abi.FunctionABI = r131 :: type
    r132 = dank_mids.brownie_patch._abi.globals :: static
    r133 = 'FunctionABI'
    r134 = CPyDict_SetItem(r132, r133, r131)
    dec_ref r131
    r135 = r134 >= 0 :: signed
    if not r135 goto L49 (error at <module>:31) else goto L48 :: bool
L48:
    r136 = dank_mids.brownie_patch._abi.FunctionABI :: type
    return 1
L49:
    r137 = <error> :: None
    return r137
L50:
    dec_ref r35
    goto L49
L51:
    dec_ref r35
    dec_ref r38
    goto L49
L52:
    dec_ref r71
    goto L49
L53:
    dec_ref r71
    dec_ref r83
    goto L49
L54:
    dec_ref r71
    dec_ref r83
    dec_ref r85
    goto L49
L55:
    dec_ref r71
    dec_ref r83
    dec_ref r85
    dec_ref r90
    goto L49
L56:
    dec_ref r114
    goto L49
L57:
    dec_ref r125
    goto L49

def UIDGenerator.__init__(self):
    self :: dank_mids._uid.UIDGenerator
    r0 :: str
    r1 :: dict
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6, r7 :: object
    r8 :: None
L0:
    self._value = -2
    r0 = 'uid'
    r1 = dank_mids._uid.globals :: static
    r2 = 'AlertingRLock'
    r3 = CPyDict_GetItem(r1, r2)
    if is_error(r3) goto L3 (error at __init__:24) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = ('name',)
    r7 = PyObject_Vectorcall(r3, r5, 0, r6)
    dec_ref r3
    if is_error(r7) goto L3 (error at __init__:24) else goto L2
L2:
    self._lock = r7
    return 1
L3:
    r8 = <error> :: None
    return r8

def UIDGenerator.latest(self):
    self :: dank_mids._uid.UIDGenerator
    r0 :: int
L0:
    r0 = self._value
    return r0

def UIDGenerator.next(self):
    self :: dank_mids._uid.UIDGenerator
    r0, r1 :: object
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8 :: object
    r9, r10 :: int
    r11 :: bool
    r12, r13 :: tuple[object, object, object]
    r14 :: object
    r15 :: object[4]
    r16 :: object_ptr
    r17 :: object
    r18 :: bit
    r19 :: int
L0:
    r0 = self._lock
    r1 = PyObject_Type(r0)
    r2 = '__exit__'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L20 (error at next:48) else goto L1
L1:
    r4 = '__enter__'
    r5 = CPyObject_GetAttr(r1, r4)
    dec_ref r1
    if is_error(r5) goto L21 (error at next:48) else goto L2
L2:
    r6 = [r0]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r5, r7, 1, 0)
    dec_ref r5
    if is_error(r8) goto L21 (error at next:48) else goto L22
L3:
L4:
    r9 = borrow self._value
    r10 = CPyTagged_Add(r9, 2)
    inc_ref r10 :: int
    self._value = r10
L5:
    r12 = <error> :: tuple[object, object, object]
    r13 = r12
L6:
    if 1 goto L7 else goto L23 :: bool
L7:
    r14 = load_address _Py_NoneStruct
    r15 = [r0, r14, r14, r14]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r3, r16, 4, 0)
    dec_ref r3
    if is_error(r17) goto L24 (error at next:48) else goto L25
L8:
    dec_ref r0
L9:
    if is_error(r13) goto L12 else goto L26
L10:
    CPy_Reraise()
    if not 0 goto L14 else goto L27 :: bool
L11:
    unreachable
L12:
    if is_error(r10) goto L18 else goto L13
L13:
    return r10
L14:
    if is_error(r13) goto L16 else goto L15
L15:
    CPy_RestoreExcInfo(r13)
    xdec_ref r13
L16:
    r18 = CPy_KeepPropagating()
    if not r18 goto L19 else goto L17 :: bool
L17:
    unreachable
L18:
    unreachable
L19:
    r19 = <error> :: int
    return r19
L20:
    dec_ref r0
    dec_ref r1
    goto L19
L21:
    dec_ref r0
    dec_ref r3
    goto L19
L22:
    dec_ref r8
    goto L3
L23:
    dec_ref r0
    dec_ref r3
    goto L9
L24:
    dec_ref r0
    xdec_ref r10 :: int
    goto L14
L25:
    dec_ref r17
    goto L8
L26:
    xdec_ref r10 :: int
    goto L10
L27:
    xdec_ref r13
    goto L11

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11, r12 :: object
    r13 :: bool
    r14, r15, r16 :: str
    r17 :: tuple
    r18 :: i32
    r19 :: bit
    r20 :: dict
    r21 :: str
    r22 :: i32
    r23 :: bit
    r24 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L10 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('AlertingRLock',)
    r6 = 'dank_mids.helpers._lock'
    r7 = dank_mids._uid.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L10 (error at <module>:1) else goto L4
L4:
    dank_mids.helpers._lock = r8 :: module
    dec_ref r8
    r9 = <error> :: object
    r10 = 'dank_mids._uid'
    r11 = dank_mids._uid.UIDGenerator_template :: type
    r12 = CPyType_FromTemplate(r11, r9, r10)
    if is_error(r12) goto L10 (error at <module>:4) else goto L5
L5:
    r13 = UIDGenerator_trait_vtable_setup()
    if is_error(r13) goto L11 (error at <module>:-1) else goto L6
L6:
    r14 = '__mypyc_attrs__'
    r15 = '_value'
    r16 = '_lock'
    r17 = PyTuple_Pack(2, r15, r16)
    if is_error(r17) goto L11 (error at <module>:4) else goto L7
L7:
    r18 = PyObject_SetAttr(r12, r14, r17)
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L11 (error at <module>:4) else goto L8 :: bool
L8:
    dank_mids._uid.UIDGenerator = r12 :: type
    r20 = dank_mids._uid.globals :: static
    r21 = 'UIDGenerator'
    r22 = CPyDict_SetItem(r20, r21, r12)
    dec_ref r12
    r23 = r22 >= 0 :: signed
    if not r23 goto L10 (error at <module>:4) else goto L9 :: bool
L9:
    return 1
L10:
    r24 = <error> :: None
    return r24
L11:
    dec_ref r12
    goto L10

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20 :: object
    r21, r22, r23, r24 :: str
    r25 :: list
    r26, r27, r28, r29, r30 :: ptr
    r31 :: dict
    r32 :: str
    r33 :: i32
    r34 :: bit
    r35 :: object
    r36 :: str
    r37 :: dict
    r38, r39 :: object
    r40 :: str
    r41 :: dict
    r42 :: object
    r43 :: dict
    r44 :: str
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: str
    r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: object
    r53 :: object[1]
    r54 :: object_ptr
    r55, r56 :: object
    r57 :: str
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: object[1]
    r62 :: object_ptr
    r63 :: object
    r64 :: bool
    r65 :: object
    r66 :: str
    r67 :: dict
    r68 :: object
    r69 :: dict
    r70 :: str
    r71 :: object
    r72 :: str
    r73 :: object[1]
    r74 :: object_ptr
    r75 :: object
    r76 :: i32
    r77 :: bit
    r78 :: bool
    r79 :: object
    r80 :: str
    r81 :: dict
    r82 :: object
    r83 :: dict
    r84 :: str
    r85 :: object
    r86 :: dict
    r87 :: str
    r88 :: object
    r89 :: object[1]
    r90 :: object_ptr
    r91 :: object
    r92 :: dict
    r93 :: str
    r94 :: i32
    r95 :: bit
    r96 :: dict
    r97 :: str
    r98 :: object
    r99 :: str
    r100 :: object
    r101 :: dict
    r102 :: str
    r103 :: i32
    r104 :: bit
    r105 :: dict
    r106 :: str
    r107 :: object
    r108, r109, r110, r111 :: str
    r112 :: list
    r113, r114, r115, r116, r117 :: ptr
    r118 :: object
    r119 :: i32
    r120 :: bit
    r121, r122 :: tuple[object, object, object]
    r123, r124, r125 :: object
    r126 :: object[4]
    r127 :: object_ptr
    r128 :: object
    r129 :: i32
    r130 :: bit
    r131 :: bool
    r132 :: bit
    r133, r134, r135 :: tuple[object, object, object]
    r136 :: object
    r137 :: object[4]
    r138 :: object_ptr
    r139 :: object
    r140 :: bit
    r141 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L56 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('suppress',)
    r6 = 'contextlib'
    r7 = dank_mids.brownie_patch.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L56 (error at <module>:1) else goto L4
L4:
    contextlib = r8 :: module
    dec_ref r8
    r9 = ('AsyncEth',)
    r10 = 'web3.eth'
    r11 = dank_mids.brownie_patch.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L56 (error at <module>:3) else goto L5
L5:
    web3.eth = r12 :: module
    dec_ref r12
    r13 = ('setup_dank_w3_from_sync',)
    r14 = 'dank_mids.helpers'
    r15 = dank_mids.brownie_patch.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L56 (error at <module>:5) else goto L6
L6:
    dank_mids.helpers = r16 :: module
    dec_ref r16
    r17 = ('DankContractCall', 'DankContractMethod', 'DankContractTx', 'DankOverloadedMethod')
    r18 = 'dank_mids.brownie_patch.types'
    r19 = dank_mids.brownie_patch.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L56 (error at <module>:6) else goto L7
L7:
    dank_mids.brownie_patch.types = r20 :: module
    dec_ref r20
    r21 = 'DankContractCall'
    r22 = 'DankContractMethod'
    r23 = 'DankContractTx'
    r24 = 'DankOverloadedMethod'
    r25 = PyList_New(4)
    if is_error(r25) goto L56 (error at <module>:13) else goto L8
L8:
    r26 = get_element_ptr r25 ob_item :: PyListObject
    r27 = load_mem r26 :: ptr*
    inc_ref r21
    set_mem r27, r21 :: builtins.object*
    inc_ref r22
    r28 = r27 + 8
    set_mem r28, r22 :: builtins.object*
    inc_ref r23
    r29 = r27 + 16
    set_mem r29, r23 :: builtins.object*
    inc_ref r24
    r30 = r27 + 24
    set_mem r30, r24 :: builtins.object*
    r31 = dank_mids.brownie_patch.globals :: static
    r32 = '__all__'
    r33 = CPyDict_SetItem(r31, r32, r25)
    dec_ref r25
    r34 = r33 >= 0 :: signed
    if not r34 goto L56 (error at <module>:13) else goto L9 :: bool
L9:
    r35 = ('DankEth',)
    r36 = 'dank_mids.eth'
    r37 = dank_mids.brownie_patch.globals :: static
    r38 = CPyImport_ImportFromMany(r36, r35, r35, r37)
    if is_error(r38) goto L56 (error at <module>:15) else goto L10
L10:
    dank_mids.eth = r38 :: module
    dec_ref r38
    r39 = ('DankWeb3',)
    r40 = 'dank_mids.helpers._helpers'
    r41 = dank_mids.brownie_patch.globals :: static
    r42 = CPyImport_ImportFromMany(r40, r39, r39, r41)
    if is_error(r42) goto L56 (error at <module>:16) else goto L11
L11:
    dank_mids.helpers._helpers = r42 :: module
    dec_ref r42
    r43 = dank_mids.brownie_patch.globals :: static
    r44 = 'dank_web3'
    r45 = dank_mids.brownie_patch.globals :: static
    r46 = 'dank_eth'
    r47 = builtins :: module
    r48 = 'ImportError'
    r49 = CPyObject_GetAttr(r47, r48)
    if is_error(r49) goto L56 (error at <module>:33) else goto L12
L12:
    r50 = dank_mids.brownie_patch.globals :: static
    r51 = 'suppress'
    r52 = CPyDict_GetItem(r50, r51)
    if is_error(r52) goto L57 (error at <module>:33) else goto L13
L13:
    r53 = [r49]
    r54 = load_address r53
    r55 = PyObject_Vectorcall(r52, r54, 1, 0)
    dec_ref r52
    if is_error(r55) goto L57 (error at <module>:33) else goto L14
L14:
    dec_ref r49
    r56 = PyObject_Type(r55)
    r57 = '__exit__'
    r58 = CPyObject_GetAttr(r56, r57)
    if is_error(r58) goto L58 (error at <module>:33) else goto L15
L15:
    r59 = '__enter__'
    r60 = CPyObject_GetAttr(r56, r59)
    dec_ref r56
    if is_error(r60) goto L59 (error at <module>:33) else goto L16
L16:
    r61 = [r55]
    r62 = load_address r61
    r63 = PyObject_Vectorcall(r60, r62, 1, 0)
    dec_ref r60
    if is_error(r63) goto L59 (error at <module>:33) else goto L60
L17:
    r64 = 1
L18:
    r65 = ('network', 'web3')
    r66 = 'brownie'
    r67 = dank_mids.brownie_patch.globals :: static
    r68 = CPyImport_ImportFromMany(r66, r65, r65, r67)
    if is_error(r68) goto L35 (error at <module>:34) else goto L19
L19:
    brownie = r68 :: module
    dec_ref r68
    r69 = dank_mids.brownie_patch.globals :: static
    r70 = 'network'
    r71 = CPyDict_GetItem(r69, r70)
    if is_error(r71) goto L35 (error at <module>:36) else goto L20
L20:
    r72 = 'is_connected'
    r73 = [r71]
    r74 = load_address r73
    r75 = PyObject_VectorcallMethod(r72, r74, 9223372036854775809, 0)
    if is_error(r75) goto L61 (error at <module>:36) else goto L21
L21:
    dec_ref r71
    r76 = PyObject_IsTrue(r75)
    dec_ref r75
    r77 = r76 >= 0 :: signed
    if not r77 goto L35 (error at <module>:36) else goto L22 :: bool
L22:
    r78 = truncate r76: i32 to builtins.bool
    if r78 goto L23 else goto L43 :: bool
L23:
    r79 = ('Contract', 'patch_contract')
    r80 = 'dank_mids.brownie_patch.contract'
    r81 = dank_mids.brownie_patch.globals :: static
    r82 = CPyImport_ImportFromMany(r80, r79, r79, r81)
    if is_error(r82) goto L35 (error at <module>:37) else goto L24
L24:
    dank_mids.brownie_patch.contract = r82 :: module
    dec_ref r82
    r83 = dank_mids.brownie_patch.globals :: static
    r84 = 'web3'
    r85 = CPyDict_GetItem(r83, r84)
    if is_error(r85) goto L35 (error at <module>:39) else goto L25
L25:
    r86 = dank_mids.brownie_patch.globals :: static
    r87 = 'setup_dank_w3_from_sync'
    r88 = CPyDict_GetItem(r86, r87)
    if is_error(r88) goto L62 (error at <module>:39) else goto L26
L26:
    r89 = [r85]
    r90 = load_address r89
    r91 = PyObject_Vectorcall(r88, r90, 1, 0)
    dec_ref r88
    if is_error(r91) goto L62 (error at <module>:39) else goto L27
L27:
    dec_ref r85
    r92 = dank_mids.brownie_patch.globals :: static
    r93 = 'dank_web3'
    r94 = CPyDict_SetItem(r92, r93, r91)
    dec_ref r91
    r95 = r94 >= 0 :: signed
    if not r95 goto L35 (error at <module>:39) else goto L28 :: bool
L28:
    r96 = dank_mids.brownie_patch.globals :: static
    r97 = 'dank_web3'
    r98 = CPyDict_GetItem(r96, r97)
    if is_error(r98) goto L35 (error at <module>:40) else goto L29
L29:
    r99 = 'eth'
    r100 = CPyObject_GetAttr(r98, r99)
    dec_ref r98
    if is_error(r100) goto L35 (error at <module>:40) else goto L30
L30:
    r101 = dank_mids.brownie_patch.globals :: static
    r102 = 'dank_eth'
    r103 = CPyDict_SetItem(r101, r102, r100)
    dec_ref r100
    r104 = r103 >= 0 :: signed
    if not r104 goto L35 (error at <module>:40) else goto L31 :: bool
L31:
    r105 = dank_mids.brownie_patch.globals :: static
    r106 = '__all__'
    r107 = CPyDict_GetItem(r105, r106)
    if is_error(r107) goto L35 (error at <module>:41) else goto L32
L32:
    r108 = 'Contract'
    r109 = 'patch_contract'
    r110 = 'dank_web3'
    r111 = 'dank_eth'
    r112 = PyList_New(4)
    if is_error(r112) goto L63 (error at <module>:41) else goto L33
L33:
    r113 = get_element_ptr r112 ob_item :: PyListObject
    r114 = load_mem r113 :: ptr*
    inc_ref r108
    set_mem r114, r108 :: builtins.object*
    inc_ref r109
    r115 = r114 + 8
    set_mem r115, r109 :: builtins.object*
    inc_ref r110
    r116 = r114 + 16
    set_mem r116, r110 :: builtins.object*
    inc_ref r111
    r117 = r114 + 24
    set_mem r117, r111 :: builtins.object*
    r118 = PyNumber_InPlaceAdd(r107, r112)
    dec_ref r107
    dec_ref r112
    if is_error(r118) goto L35 (error at <module>:41) else goto L34
L34:
    r119 = CPyDict_SetItem(r105, r106, r118)
    dec_ref r118
    r120 = r119 >= 0 :: signed
    if not r120 goto L35 (error at <module>:41) else goto L43 :: bool
L35:
    r121 = CPy_CatchError()
    r64 = 0
    r122 = CPy_GetExcInfo()
    r123 = r122[0]
    r124 = r122[1]
    r125 = r122[2]
    dec_ref r122
    r126 = [r55, r123, r124, r125]
    r127 = load_address r126
    r128 = PyObject_Vectorcall(r58, r127, 4, 0)
    if is_error(r128) goto L64 (error at <module>:33) else goto L36
L36:
    dec_ref r123
    dec_ref r124
    dec_ref r125
    r129 = PyObject_IsTrue(r128)
    dec_ref r128
    r130 = r129 >= 0 :: signed
    if not r130 goto L41 (error at <module>:33) else goto L37 :: bool
L37:
    r131 = truncate r129: i32 to builtins.bool
    if r131 goto L40 else goto L38 :: bool
L38:
    CPy_Reraise()
    if not 0 goto L41 else goto L65 :: bool
L39:
    unreachable
L40:
    CPy_RestoreExcInfo(r121)
    dec_ref r121
    goto L43
L41:
    CPy_RestoreExcInfo(r121)
    dec_ref r121
    r132 = CPy_KeepPropagating()
    if not r132 goto L44 else goto L66 :: bool
L42:
    unreachable
L43:
    r133 = <error> :: tuple[object, object, object]
    r134 = r133
    goto L45
L44:
    r135 = CPy_CatchError()
    r134 = r135
L45:
    if r64 goto L46 else goto L67 :: bool
L46:
    r136 = load_address _Py_NoneStruct
    r137 = [r55, r136, r136, r136]
    r138 = load_address r137
    r139 = PyObject_Vectorcall(r58, r138, 4, 0)
    dec_ref r58
    if is_error(r139) goto L68 (error at <module>:33) else goto L69
L47:
    dec_ref r55
L48:
    if is_error(r134) goto L55 else goto L49
L49:
    CPy_Reraise()
    if not 0 goto L51 else goto L70 :: bool
L50:
    unreachable
L51:
    if is_error(r134) goto L53 else goto L52
L52:
    CPy_RestoreExcInfo(r134)
    xdec_ref r134
L53:
    r140 = CPy_KeepPropagating()
    if not r140 goto L56 else goto L54 :: bool
L54:
    unreachable
L55:
    return 1
L56:
    r141 = <error> :: None
    return r141
L57:
    dec_ref r49
    goto L56
L58:
    dec_ref r55
    dec_ref r56
    goto L56
L59:
    dec_ref r55
    dec_ref r58
    goto L56
L60:
    dec_ref r63
    goto L17
L61:
    dec_ref r71
    goto L35
L62:
    dec_ref r85
    goto L35
L63:
    dec_ref r107
    goto L35
L64:
    dec_ref r123
    dec_ref r124
    dec_ref r125
    goto L41
L65:
    dec_ref r55
    dec_ref r58
    dec_ref r121
    goto L39
L66:
    dec_ref r55
    dec_ref r58
    goto L42
L67:
    dec_ref r55
    dec_ref r58
    goto L48
L68:
    dec_ref r55
    goto L51
L69:
    dec_ref r139
    goto L47
L70:
    xdec_ref r134
    goto L50

def return_as_is(x):
    x :: object
L0:
    inc_ref x
    return x

def abi_request_formatters_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0 :: i32
    r1 :: object
    r2 :: bit
    r3 :: dict
    r4, r5 :: bool
    r6 :: dict
    r7 :: native_int
    r8 :: bool
    r9 :: object
    r10 :: bool
    r11 :: object
    r12 :: short_int
    r13 :: tuple[bool, short_int, object, object]
    r14 :: short_int
    r15, r16 :: bool
    r17, r18 :: object
    r19 :: union[list, dict]
    r20, r21 :: bool
    r22 :: union[list, dict]
    r23 :: bit
    r24, r25 :: object
    r26 :: tuple
    r27 :: union[list, dict]
    r28 :: list
    r29 :: tuple
    r30 :: dank_mids._web3.abi.Formatter
    r31 :: tuple[object, dank_mids._web3.abi.Formatter]
    r32 :: object
    r33 :: bool
    r34 :: object
    r35 :: bit
    r36 :: union[list, dict]
    r37 :: bit
    r38 :: object
    r39 :: union[list, dict]
    r40, r41 :: dict
    r42 :: str
    r43 :: object
    r44 :: object[2]
    r45 :: object_ptr
    r46 :: object
    r47 :: bool
    r48, r49 :: object
    r50 :: dict
    r51 :: str
    r52, r53 :: object
    r54 :: object[2]
    r55 :: object_ptr
    r56 :: object
    r57 :: tuple[object, object]
    r58 :: object
    r59 :: bool
    r60 :: object
    r61 :: bit
    r62, r63, r64 :: str
    r65 :: union[list, dict]
    r66, r67 :: str
    r68 :: object[3]
    r69 :: object_ptr
    r70 :: object
    r71 :: list
    r72, r73, r74 :: ptr
    r75 :: str
    r76 :: object
    r77 :: str
    r78 :: object
    r79 :: object[1]
    r80 :: object_ptr
    r81 :: object
    r82 :: dict
    r83 :: native_int
    r84, r85 :: bit
    r86 :: object
    r87 :: bool
    r88, r89, r90 :: bit
    r91 :: bool
    r92 :: object
L0:
    r0 = __mypyc_self__.__mypyc_next_label__
    goto L64
L1:
    r1 = load_address _Py_NoneStruct
    r2 = type != r1
    if r2 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L69 (error at abi_request_formatters:27) else goto L3 :: bool
L3:
    unreachable
L4:
    r3 = __mypyc_self__.abis
    if is_error(r3) goto L69 (error at abi_request_formatters:31) else goto L5
L5:
    inc_ref r3
    __mypyc_self__.__mypyc_temp__0 = r3; r4 = is_error
    if not r4 goto L70 (error at abi_request_formatters:-1) else goto L6 :: bool
L6:
    __mypyc_self__.__mypyc_temp__1 = 0; r5 = is_error
    if not r5 goto L70 (error at abi_request_formatters:-1) else goto L7 :: bool
L7:
    r6 = __mypyc_self__.__mypyc_temp__0
    if is_error(r6) goto L70 (error at abi_request_formatters:31) else goto L8
L8:
    r7 = PyDict_Size(r6)
    dec_ref r6
    __mypyc_self__.__mypyc_temp__2 = r7; r8 = is_error
    if not r8 goto L70 (error at abi_request_formatters:-1) else goto L9 :: bool
L9:
    r9 = CPyDict_GetItemsIter(r3)
    dec_ref r3
    if is_error(r9) goto L69 (error at abi_request_formatters:31) else goto L10
L10:
    __mypyc_self__.__mypyc_temp__3 = r9; r10 = is_error
    if not r10 goto L69 (error at abi_request_formatters:-1) else goto L11 :: bool
L11:
    r11 = __mypyc_self__.__mypyc_temp__3
    if is_error(r11) goto L69 (error at abi_request_formatters:31) else goto L12
L12:
    r12 = __mypyc_self__.__mypyc_temp__1
    if is_error(r12) goto L71 (error at abi_request_formatters:31) else goto L13
L13:
    r13 = CPyDict_NextItem(r11, r12)
    dec_ref r11
    r14 = r13[1]
    __mypyc_self__.__mypyc_temp__1 = r14; r15 = is_error
    if not r15 goto L72 (error at abi_request_formatters:31) else goto L14 :: bool
L14:
    r16 = r13[0]
    if r16 goto L15 else goto L73 :: bool
L15:
    r17 = r13[2]
    r18 = r13[3]
    dec_ref r13
    r19 = cast(union[list, dict], r18)
    if is_error(r19) goto L74 (error at abi_request_formatters:31) else goto L16
L16:
    __mypyc_self__.method = r17; r20 = is_error
    if not r20 goto L75 (error at abi_request_formatters:31) else goto L17 :: bool
L17:
    __mypyc_self__.abi_types = r19; r21 = is_error
    if not r21 goto L69 (error at abi_request_formatters:31) else goto L18 :: bool
L18:
    r22 = __mypyc_self__.abi_types
    if is_error(r22) goto L69 (error at abi_request_formatters:32) else goto L19
L19:
    r23 = PyList_Check(r22)
    dec_ref r22
    if r23 goto L20 else goto L31 :: bool
L20:
    r24 = __mypyc_self__.method
    if is_error(r24) goto L69 (error at abi_request_formatters:33) else goto L21
L21:
    r25 = __mypyc_self__.normalizers
    if is_error(r25) goto L76 (error at abi_request_formatters:33) else goto L22
L22:
    r26 = PySequence_Tuple(r25)
    dec_ref r25
    if is_error(r26) goto L76 (error at abi_request_formatters:33) else goto L23
L23:
    r27 = __mypyc_self__.abi_types
    if is_error(r27) goto L77 (error at abi_request_formatters:33) else goto L24
L24:
    r28 = cast(list, r27)
    if is_error(r28) goto L77 (error at abi_request_formatters:33) else goto L25
L25:
    r29 = PyList_AsTuple(r28)
    dec_ref r28
    if is_error(r29) goto L77 (error at abi_request_formatters:33) else goto L26
L26:
    r30 = get_formatter(r26, r29)
    dec_ref r26
    dec_ref r29
    if is_error(r30) goto L76 (error at abi_request_formatters:33) else goto L27
L27:
    r31 = (r24, r30)
    r32 = box(tuple[object, dank_mids._web3.abi.Formatter], r31)
    __mypyc_self__.__mypyc_next_label__ = 1
    return r32
L28:
    r34 = load_address _Py_NoneStruct
    r35 = type != r34
    if r35 goto L29 else goto L55 :: bool
L29:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L69 (error at abi_request_formatters:33) else goto L30 :: bool
L30:
    unreachable
L31:
    r36 = __mypyc_self__.abi_types
    if is_error(r36) goto L69 (error at abi_request_formatters:34) else goto L32
L32:
    r37 = PyDict_Check(r36)
    dec_ref r36
    if r37 goto L33 else goto L47 :: bool
L33:
    r38 = __mypyc_self__.normalizers
    if is_error(r38) goto L69 (error at abi_request_formatters:35) else goto L34
L34:
    r39 = __mypyc_self__.abi_types
    if is_error(r39) goto L78 (error at abi_request_formatters:35) else goto L35
L35:
    r40 = cast(dict, r39)
    if is_error(r40) goto L78 (error at abi_request_formatters:35) else goto L36
L36:
    r41 = dank_mids._web3.formatters.globals :: static
    r42 = 'apply_abi_formatters_to_dict'
    r43 = CPyDict_GetItem(r41, r42)
    if is_error(r43) goto L79 (error at abi_request_formatters:35) else goto L37
L37:
    r44 = [r38, r40]
    r45 = load_address r44
    r46 = PyObject_Vectorcall(r43, r45, 2, 0)
    dec_ref r43
    if is_error(r46) goto L79 (error at abi_request_formatters:35) else goto L38
L38:
    dec_ref r38
    dec_ref r40
    __mypyc_self__.single_dict_formatter = r46; r47 = is_error
    if not r47 goto L69 (error at abi_request_formatters:35) else goto L39 :: bool
L39:
    r48 = __mypyc_self__.method
    if is_error(r48) goto L69 (error at abi_request_formatters:36) else goto L40
L40:
    r49 = __mypyc_self__.single_dict_formatter
    if is_error(r49) goto L80 (error at abi_request_formatters:36) else goto L41
L41:
    r50 = dank_mids._web3.formatters.globals :: static
    r51 = 'apply_formatter_at_index'
    r52 = CPyDict_GetItem(r50, r51)
    if is_error(r52) goto L81 (error at abi_request_formatters:36) else goto L42
L42:
    r53 = object 0
    r54 = [r49, r53]
    r55 = load_address r54
    r56 = PyObject_Vectorcall(r52, r55, 2, 0)
    dec_ref r52
    if is_error(r56) goto L81 (error at abi_request_formatters:36) else goto L43
L43:
    dec_ref r49
    r57 = (r48, r56)
    r58 = box(tuple[object, object], r57)
    __mypyc_self__.__mypyc_next_label__ = 2
    return r58
L44:
    r60 = load_address _Py_NoneStruct
    r61 = type != r60
    if r61 goto L45 else goto L55 :: bool
L45:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L69 (error at abi_request_formatters:36) else goto L46 :: bool
L46:
    unreachable
L47:
    r62 = ''
    r63 = 'ABI definitions must be a list or dictionary, got '
    r64 = '{!r:{}}'
    r65 = __mypyc_self__.abi_types
    if is_error(r65) goto L69 (error at abi_request_formatters:38) else goto L48
L48:
    r66 = ''
    r67 = 'format'
    r68 = [r64, r65, r66]
    r69 = load_address r68
    r70 = PyObject_VectorcallMethod(r67, r69, 9223372036854775811, 0)
    if is_error(r70) goto L82 (error at abi_request_formatters:38) else goto L49
L49:
    dec_ref r65
    r71 = PyList_New(2)
    if is_error(r71) goto L83 (error at abi_request_formatters:38) else goto L50
L50:
    r72 = get_element_ptr r71 ob_item :: PyListObject
    r73 = load_mem r72 :: ptr*
    inc_ref r63
    set_mem r73, r63 :: builtins.object*
    r74 = r73 + 8
    set_mem r74, r70 :: builtins.object*
    r75 = PyUnicode_Join(r62, r71)
    dec_ref r71
    if is_error(r75) goto L69 (error at abi_request_formatters:38) else goto L51
L51:
    r76 = builtins :: module
    r77 = 'TypeError'
    r78 = CPyObject_GetAttr(r76, r77)
    if is_error(r78) goto L84 (error at abi_request_formatters:38) else goto L52
L52:
    r79 = [r75]
    r80 = load_address r79
    r81 = PyObject_Vectorcall(r78, r80, 1, 0)
    dec_ref r78
    if is_error(r81) goto L84 (error at abi_request_formatters:38) else goto L53
L53:
    dec_ref r75
    CPy_Raise(r81)
    dec_ref r81
    if not 0 goto L69 (error at abi_request_formatters:38) else goto L54 :: bool
L54:
    unreachable
L55:
    r82 = __mypyc_self__.__mypyc_temp__0
    if is_error(r82) goto L69 (error at abi_request_formatters:31) else goto L56
L56:
    r83 = __mypyc_self__.__mypyc_temp__2
    if is_error(r83) goto L85 (error at abi_request_formatters:31) else goto L57
L57:
    r84 = CPyDict_CheckSize(r82, r83)
    dec_ref r82
    if not r84 goto L69 (error at abi_request_formatters:31) else goto L11 :: bool
L58:
    r85 = CPy_NoErrOccurred()
    if not r85 goto L69 (error at abi_request_formatters:31) else goto L59 :: bool
L59:
    r86 = box(None, 1)
    __mypyc_self__.__mypyc_next_label__ = -1
L60:
    if is_error(stop_iter_ptr) goto L61 else goto L63
L61:
    CPyGen_SetStopIterationValue(r86)
    if not 0 goto L69 else goto L62 :: bool
L62:
    unreachable
L63:
    inc_ref r86
    set_mem stop_iter_ptr, r86 :: builtins.object*
    return 0
L64:
    r88 = r0 == 0
    if r88 goto L1 else goto L65 :: bool
L65:
    r89 = r0 == 1
    if r89 goto L28 else goto L66 :: bool
L66:
    r90 = r0 == 2
    if r90 goto L44 else goto L67 :: bool
L67:
    r91 = raise StopIteration
    if not r91 goto L69 (error at abi_request_formatters:27) else goto L68 :: bool
L68:
    unreachable
L69:
    r92 = <error> :: object
    return r92
L70:
    dec_ref r3
    goto L69
L71:
    dec_ref r11
    goto L69
L72:
    dec_ref r13
    goto L69
L73:
    dec_ref r13
    goto L58
L74:
    dec_ref r17
    goto L69
L75:
    dec_ref r19
    goto L69
L76:
    dec_ref r24
    goto L69
L77:
    dec_ref r24
    dec_ref r26
    goto L69
L78:
    dec_ref r38
    goto L69
L79:
    dec_ref r38
    dec_ref r40
    goto L69
L80:
    dec_ref r48
    goto L69
L81:
    dec_ref r48
    dec_ref r49
    goto L69
L82:
    dec_ref r65
    goto L69
L83:
    dec_ref r70
    goto L69
L84:
    dec_ref r75
    goto L69
L85:
    dec_ref r82
    goto L69

def abi_request_formatters_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = abi_request_formatters_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def abi_request_formatters_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = abi_request_formatters_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def abi_request_formatters_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def abi_request_formatters_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = abi_request_formatters_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def abi_request_formatters_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def abi_request_formatters(normalizers, abis):
    normalizers :: object
    abis :: dict
    r0 :: dank_mids._web3.formatters.abi_request_formatters_gen
    r1, r2, r3 :: bool
    r4 :: dank_mids._web3.formatters.abi_request_formatters_gen
L0:
    r0 = abi_request_formatters_gen()
    if is_error(r0) goto L4 (error at abi_request_formatters:27) else goto L1
L1:
    r0.__mypyc_next_label__ = 0
    inc_ref normalizers
    r0.normalizers = normalizers; r2 = is_error
    if not r2 goto L5 (error at abi_request_formatters:27) else goto L2 :: bool
L2:
    inc_ref abis
    r0.abis = abis; r3 = is_error
    if not r3 goto L5 (error at abi_request_formatters:27) else goto L3 :: bool
L3:
    return r0
L4:
    r4 = <error> :: dank_mids._web3.formatters.abi_request_formatters_gen
    return r4
L5:
    dec_ref r0
    goto L4

def get_request_formatters(method_name):
    method_name, r0 :: object
    r1 :: bool
    r2 :: str
    r3 :: object[2]
    r4 :: object_ptr
    r5, formatters, r6 :: object
    r7 :: bit
    r8 :: list
    r9 :: tuple[object, object, object]
    r10 :: bool
    r11, r12, r13 :: object
    r14 :: str
    r15 :: object[2]
    r16 :: object_ptr
    r17 :: object
    r18 :: i32
    r19, r20 :: bit
    r21 :: object
    r22 :: list
    r23, r24, r25 :: object
    r26 :: bit
    r27 :: i32
    r28, r29 :: bit
    r30 :: ptr
    r31 :: native_int
    r32 :: short_int
    r33 :: bit
    r34 :: dict
    r35 :: str
    r36 :: object
    r37 :: ptr
    r38 :: native_int
    r39 :: short_int
    r40 :: bit
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: object
    r45 :: list
    r46 :: object
    r47 :: tuple
    r48 :: dict
    r49, r50 :: object
    r51 :: bool
    r52 :: i32
    r53 :: bit
    r54 :: object
L0:
    r0 = dank_mids._web3.formatters._request_formatters :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_request_formatters" was not set')
    if not r1 goto L39 (error at get_request_formatters:59) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = 'get'
    r3 = [r0, method_name]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r2, r4, 9223372036854775810, 0)
    if is_error(r5) goto L39 (error at get_request_formatters:59) else goto L4
L4:
    formatters = r5
    r6 = load_address _Py_NoneStruct
    r7 = formatters == r6
    if r7 goto L40 else goto L38 :: bool
L5:
    r8 = PyList_New(0)
    if is_error(r8) goto L39 (error at get_request_formatters:61) else goto L6
L6:
    r9 = dank_mids._web3.formatters.REQUEST_FORMATTER_MAPS :: static
    if is_error(r9) goto L41 else goto L9
L7:
    r10 = raise NameError('value for final name "REQUEST_FORMATTER_MAPS" was not set')
    if not r10 goto L39 (error at get_request_formatters:61) else goto L8 :: bool
L8:
    unreachable
L9:
    inc_ref r9
    r11 = box(tuple[object, object, object], r9)
    r12 = PyObject_GetIter(r11)
    dec_ref r11
    if is_error(r12) goto L42 (error at get_request_formatters:61) else goto L10
L10:
    r13 = PyIter_Next(r12)
    if is_error(r13) goto L43 else goto L11
L11:
    r14 = 'get'
    r15 = [r13, method_name]
    r16 = load_address r15
    r17 = PyObject_VectorcallMethod(r14, r16, 9223372036854775810, 0)
    if is_error(r17) goto L44 (error at get_request_formatters:61) else goto L12
L12:
    dec_ref r13
    r18 = PyList_Append(r8, r17)
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L45 (error at get_request_formatters:61) else goto L10 :: bool
L13:
    r20 = CPy_NoErrOccurred()
    if not r20 goto L42 (error at get_request_formatters:61) else goto L14 :: bool
L14:
    r21 = PyObject_GetIter(r8)
    dec_ref r8
    if is_error(r21) goto L39 (error at get_request_formatters:61) else goto L15
L15:
    r22 = PyList_New(0)
    if is_error(r22) goto L46 (error at get_request_formatters:62) else goto L16
L16:
    r23 = PyObject_GetIter(r21)
    if is_error(r23) goto L47 (error at get_request_formatters:62) else goto L17
L17:
    r24 = PyIter_Next(r23)
    if is_error(r24) goto L48 else goto L18
L18:
    r25 = load_address _Py_NoneStruct
    r26 = r24 != r25
    if r26 goto L19 else goto L49 :: bool
L19:
    r27 = PyList_Append(r22, r24)
    dec_ref r24
    r28 = r27 >= 0 :: signed
    if not r28 goto L50 (error at get_request_formatters:62) else goto L17 :: bool
L20:
    r29 = CPy_NoErrOccurred()
    if not r29 goto L47 (error at get_request_formatters:62) else goto L21 :: bool
L21:
    r30 = get_element_ptr r22 ob_size :: PyVarObject
    r31 = load_mem r30 :: native_int*
    r32 = r31 << 1
    r33 = r32 != 0
    if r33 goto L24 else goto L51 :: bool
L22:
    r34 = dank_mids._web3.formatters.globals :: static
    r35 = 'return_as_is'
    r36 = CPyDict_GetItem(r34, r35)
    if is_error(r36) goto L39 (error at get_request_formatters:64) else goto L23
L23:
    formatters = r36
    goto L34
L24:
    r37 = get_element_ptr r22 ob_size :: PyVarObject
    r38 = load_mem r37 :: native_int*
    r39 = r38 << 1
    r40 = r39 == 2
    if r40 goto L52 else goto L53 :: bool
L25:
    r41 = CPyList_GetItemShort(r22, 0)
    dec_ref r22
    if is_error(r41) goto L39 (error at get_request_formatters:66) else goto L26
L26:
    formatters = r41
    goto L34
L27:
    r42 = dank_mids._web3.formatters.globals :: static
    r43 = 'compose'
    r44 = CPyDict_GetItem(r42, r43)
    if is_error(r44) goto L46 (error at get_request_formatters:70) else goto L28
L28:
    r45 = PyList_New(0)
    if is_error(r45) goto L54 (error at get_request_formatters:70) else goto L29
L29:
    r46 = CPyList_Extend(r45, r21)
    dec_ref r21
    if is_error(r46) goto L55 (error at get_request_formatters:70) else goto L56
L30:
    r47 = PyList_AsTuple(r45)
    dec_ref r45
    if is_error(r47) goto L57 (error at get_request_formatters:70) else goto L31
L31:
    r48 = PyDict_New()
    if is_error(r48) goto L58 (error at get_request_formatters:70) else goto L32
L32:
    r49 = PyObject_Call(r44, r47, r48)
    dec_ref r44
    dec_ref r47
    dec_ref r48
    if is_error(r49) goto L39 (error at get_request_formatters:70) else goto L33
L33:
    formatters = r49
L34:
    r50 = dank_mids._web3.formatters._request_formatters :: static
    if is_error(r50) goto L59 else goto L37
L35:
    r51 = raise NameError('value for final name "_request_formatters" was not set')
    if not r51 goto L39 (error at get_request_formatters:71) else goto L36 :: bool
L36:
    unreachable
L37:
    r52 = PyObject_SetItem(r50, method_name, formatters)
    r53 = r52 >= 0 :: signed
    if not r53 goto L60 (error at get_request_formatters:71) else goto L38 :: bool
L38:
    return formatters
L39:
    r54 = <error> :: object
    return r54
L40:
    dec_ref formatters
    goto L5
L41:
    dec_ref r8
    goto L7
L42:
    dec_ref r8
    goto L39
L43:
    dec_ref r12
    goto L13
L44:
    dec_ref r8
    dec_ref r12
    dec_ref r13
    goto L39
L45:
    dec_ref r8
    dec_ref r12
    goto L39
L46:
    dec_ref r21
    goto L39
L47:
    dec_ref r21
    dec_ref r22
    goto L39
L48:
    dec_ref r23
    goto L20
L49:
    dec_ref r24
    goto L17
L50:
    dec_ref r21
    dec_ref r22
    dec_ref r23
    goto L39
L51:
    dec_ref r21
    dec_ref r22
    goto L22
L52:
    dec_ref r21
    goto L25
L53:
    dec_ref r22
    goto L27
L54:
    dec_ref r21
    dec_ref r44
    goto L39
L55:
    dec_ref r44
    dec_ref r45
    goto L39
L56:
    dec_ref r46
    goto L30
L57:
    dec_ref r44
    goto L39
L58:
    dec_ref r44
    dec_ref r47
    goto L39
L59:
    dec_ref formatters
    goto L35
L60:
    dec_ref formatters
    goto L39

def _get_response_formatters(method):
    method :: object
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: dict
    r4 :: str
    r5 :: object
    r6 :: dict
    r7 :: str
    r8 :: object
    r9 :: str
    r10 :: object[3]
    r11 :: object_ptr
    r12 :: object
    r13 :: dict
    r14 :: str
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: object
    r19 :: str
    r20 :: object[3]
    r21 :: object_ptr
    r22 :: object
    r23 :: tuple[object, object, object]
    r24 :: dict
    r25 :: bool
    r26 :: object
    r27 :: i32
    r28 :: bit
    r29 :: tuple[object, object, object]
L0:
    r0 = dank_mids._web3.formatters.globals :: static
    r1 = 'return_as_is'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L12 (error at _get_response_formatters:86) else goto L1
L1:
    r3 = dank_mids._web3.formatters.globals :: static
    r4 = 'ERROR_FORMATTERS'
    r5 = CPyDict_GetItem(r3, r4)
    if is_error(r5) goto L13 (error at _get_response_formatters:87) else goto L2
L2:
    r6 = dank_mids._web3.formatters.globals :: static
    r7 = 'return_as_is'
    r8 = CPyDict_GetItem(r6, r7)
    if is_error(r8) goto L14 (error at _get_response_formatters:87) else goto L3
L3:
    r9 = 'get'
    r10 = [r5, method, r8]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775811, 0)
    if is_error(r12) goto L15 (error at _get_response_formatters:87) else goto L4
L4:
    dec_ref r5
    dec_ref r8
    r13 = dank_mids._web3.formatters.globals :: static
    r14 = 'NULL_RESULT_FORMATTERS'
    r15 = CPyDict_GetItem(r13, r14)
    if is_error(r15) goto L16 (error at _get_response_formatters:88) else goto L5
L5:
    r16 = dank_mids._web3.formatters.globals :: static
    r17 = 'return_as_is'
    r18 = CPyDict_GetItem(r16, r17)
    if is_error(r18) goto L17 (error at _get_response_formatters:88) else goto L6
L6:
    r19 = 'get'
    r20 = [r15, method, r18]
    r21 = load_address r20
    r22 = PyObject_VectorcallMethod(r19, r21, 9223372036854775811, 0)
    if is_error(r22) goto L18 (error at _get_response_formatters:88) else goto L7
L7:
    dec_ref r15
    dec_ref r18
    r23 = (r2, r12, r22)
    inc_ref r23
    r24 = dank_mids._web3.formatters._response_formatters :: static
    if is_error(r24) goto L19 else goto L10
L8:
    r25 = raise NameError('value for final name "_response_formatters" was not set')
    if not r25 goto L12 (error at _get_response_formatters:85) else goto L9 :: bool
L9:
    unreachable
L10:
    r26 = box(tuple[object, object, object], r23)
    r27 = CPyDict_SetItem(r24, method, r26)
    dec_ref r26
    r28 = r27 >= 0 :: signed
    if not r28 goto L20 (error at _get_response_formatters:85) else goto L11 :: bool
L11:
    return r23
L12:
    r29 = <error> :: tuple[object, object, object]
    return r29
L13:
    dec_ref r2
    goto L12
L14:
    dec_ref r2
    dec_ref r5
    goto L12
L15:
    dec_ref r2
    dec_ref r5
    dec_ref r8
    goto L12
L16:
    dec_ref r2
    dec_ref r12
    goto L12
L17:
    dec_ref r2
    dec_ref r12
    dec_ref r15
    goto L12
L18:
    dec_ref r2
    dec_ref r12
    dec_ref r15
    dec_ref r18
    goto L12
L19:
    dec_ref r23
    dec_ref r23
    goto L8
L20:
    dec_ref r23
    goto L12

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24, r25 :: object
    r26 :: str
    r27 :: dict
    r28, r29 :: object
    r30 :: str
    r31 :: dict
    r32, r33 :: object
    r34 :: str
    r35 :: dict
    r36 :: object
    r37 :: str
    r38 :: dict
    r39 :: str
    r40 :: object
    r41 :: object[1]
    r42 :: object_ptr
    r43 :: object
    r44 :: dict
    r45 :: str
    r46 :: i32
    r47 :: bit
    r48 :: dict
    r49 :: str
    r50 :: object
    r51 :: dict
    r52 :: str
    r53 :: object
    r54 :: dict
    r55 :: dank_mids._web3.formatters.abi_request_formatters_gen
    r56, r57 :: dict
    r58 :: str
    r59 :: i32
    r60 :: bit
    r61 :: object
    r62 :: bool
    r63 :: dict
    r64 :: str
    r65 :: object
    r66 :: dict
    r67 :: str
    r68 :: object
    r69 :: tuple[object, object, object]
    r70 :: dict
    r71 :: str
    r72 :: object
    r73 :: i32
    r74 :: bit
    r75, r76 :: dict
    r77 :: str
    r78 :: i32
    r79 :: bit
    r80 :: dict
    r81 :: str
    r82 :: object
    r83 :: dict
    r84 :: str
    r85 :: object
    r86 :: list
    r87, r88 :: ptr
    r89 :: dict
    r90 :: str
    r91 :: object
    r92 :: tuple[list, object]
    r93, r94 :: object
    r95 :: dict
    r96 :: str
    r97 :: i32
    r98 :: bit
    r99 :: dict
    r100 :: str
    r101 :: object
    r102 :: dict
    r103 :: str
    r104 :: object
    r105 :: list
    r106, r107 :: ptr
    r108 :: dict
    r109 :: str
    r110 :: object
    r111 :: tuple[list, object]
    r112, r113 :: object
    r114 :: dict
    r115 :: str
    r116 :: i32
    r117 :: bit
    r118 :: dict
    r119 :: str
    r120 :: object
    r121 :: dict
    r122 :: str
    r123 :: object
    r124 :: list
    r125, r126 :: ptr
    r127 :: dict
    r128 :: str
    r129 :: object
    r130 :: tuple[list, object]
    r131, r132 :: object
    r133 :: dict
    r134 :: str
    r135 :: i32
    r136 :: bit
    r137 :: dict
    r138 :: str
    r139 :: object
    r140 :: dict
    r141 :: str
    r142 :: object
    r143 :: dict
    r144 :: str
    r145 :: object
    r146 :: dict
    r147 :: str
    r148 :: object
    r149 :: tuple[object, object, object]
    r150, r151 :: object
    r152 :: dict
    r153 :: str
    r154 :: i32
    r155 :: bit
    r156, r157 :: dict
    r158 :: str
    r159 :: i32
    r160 :: bit
    r161 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L55 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Callable', 'Dict', 'Final', 'Iterator', 'List', 'Sequence', 'Tuple', 'TypeVar', 'Union')
    r6 = 'typing'
    r7 = dank_mids._web3.formatters.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L55 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('TypeStr',)
    r10 = 'eth_typing'
    r11 = dank_mids._web3.formatters.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L55 (error at <module>:3) else goto L5
L5:
    eth_typing = r12 :: module
    dec_ref r12
    r13 = ('apply_formatter_at_index',)
    r14 = 'faster_eth_utils.curried'
    r15 = dank_mids._web3.formatters.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L55 (error at <module>:4) else goto L6
L6:
    faster_eth_utils.curried = r16 :: module
    dec_ref r16
    r17 = ('compose',)
    r18 = 'faster_eth_utils.toolz'
    r19 = dank_mids._web3.formatters.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L55 (error at <module>:5) else goto L7
L7:
    faster_eth_utils.toolz = r20 :: module
    dec_ref r20
    r21 = ('ERROR_FORMATTERS', 'METHOD_NORMALIZERS', 'NULL_RESULT_FORMATTERS', 'PYTHONIC_REQUEST_FORMATTERS', 'STANDARD_NORMALIZERS')
    r22 = 'web3._utils.method_formatters'
    r23 = dank_mids._web3.formatters.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L55 (error at <module>:6) else goto L8
L8:
    web3._utils.method_formatters = r24 :: module
    dec_ref r24
    r25 = ('RPC_ABIS', 'apply_abi_formatters_to_dict')
    r26 = 'web3._utils.rpc_abi'
    r27 = dank_mids._web3.formatters.globals :: static
    r28 = CPyImport_ImportFromMany(r26, r25, r25, r27)
    if is_error(r28) goto L55 (error at <module>:13) else goto L9
L9:
    web3._utils.rpc_abi = r28 :: module
    dec_ref r28
    r29 = ('Formatters', 'RPCEndpoint', 'RPCResponse')
    r30 = 'web3.types'
    r31 = dank_mids._web3.formatters.globals :: static
    r32 = CPyImport_ImportFromMany(r30, r29, r29, r31)
    if is_error(r32) goto L55 (error at <module>:14) else goto L10
L10:
    web3.types = r32 :: module
    dec_ref r32
    r33 = ('get_formatter',)
    r34 = 'dank_mids._web3.abi'
    r35 = dank_mids._web3.formatters.globals :: static
    r36 = CPyImport_ImportFromMany(r34, r33, r33, r35)
    if is_error(r36) goto L55 (error at <module>:17) else goto L11
L11:
    dank_mids._web3.abi = r36 :: module
    dec_ref r36
    r37 = '_T'
    r38 = dank_mids._web3.formatters.globals :: static
    r39 = 'TypeVar'
    r40 = CPyDict_GetItem(r38, r39)
    if is_error(r40) goto L55 (error at <module>:20) else goto L12
L12:
    r41 = [r37]
    r42 = load_address r41
    r43 = PyObject_Vectorcall(r40, r42, 1, 0)
    dec_ref r40
    if is_error(r43) goto L55 (error at <module>:20) else goto L13
L13:
    r44 = dank_mids._web3.formatters.globals :: static
    r45 = '_T'
    r46 = CPyDict_SetItem(r44, r45, r43)
    dec_ref r43
    r47 = r46 >= 0 :: signed
    if not r47 goto L55 (error at <module>:20) else goto L14 :: bool
L14:
    r48 = dank_mids._web3.formatters.globals :: static
    r49 = 'STANDARD_NORMALIZERS'
    r50 = CPyDict_GetItem(r48, r49)
    if is_error(r50) goto L55 (error at <module>:42) else goto L15
L15:
    r51 = dank_mids._web3.formatters.globals :: static
    r52 = 'RPC_ABIS'
    r53 = CPyDict_GetItem(r51, r52)
    if is_error(r53) goto L56 (error at <module>:42) else goto L16
L16:
    r54 = cast(dict, r53)
    if is_error(r54) goto L56 (error at <module>:42) else goto L17
L17:
    r55 = abi_request_formatters(r50, r54)
    dec_ref r50
    dec_ref r54
    if is_error(r55) goto L55 (error at <module>:42) else goto L18
L18:
    r56 = CPyDict_FromAny(r55)
    dec_ref r55
    if is_error(r56) goto L55 (error at <module>:41) else goto L19
L19:
    dank_mids._web3.formatters.ABI_REQUEST_FORMATTERS = r56 :: static
    r57 = dank_mids._web3.formatters.globals :: static
    r58 = 'ABI_REQUEST_FORMATTERS'
    r59 = CPyDict_SetItem(r57, r58, r56)
    dec_ref r56
    r60 = r59 >= 0 :: signed
    if not r60 goto L55 (error at <module>:41) else goto L20 :: bool
L20:
    r61 = dank_mids._web3.formatters.ABI_REQUEST_FORMATTERS :: static
    if is_error(r61) goto L21 else goto L23
L21:
    r62 = raise NameError('value for final name "ABI_REQUEST_FORMATTERS" was not set')
    if not r62 goto L55 (error at <module>:46) else goto L22 :: bool
L22:
    unreachable
L23:
    r63 = dank_mids._web3.formatters.globals :: static
    r64 = 'METHOD_NORMALIZERS'
    r65 = CPyDict_GetItem(r63, r64)
    if is_error(r65) goto L55 (error at <module>:51) else goto L24
L24:
    r66 = dank_mids._web3.formatters.globals :: static
    r67 = 'PYTHONIC_REQUEST_FORMATTERS'
    r68 = CPyDict_GetItem(r66, r67)
    if is_error(r68) goto L57 (error at <module>:52) else goto L25
L25:
    inc_ref r61
    r69 = (r61, r65, r68)
    dank_mids._web3.formatters.REQUEST_FORMATTER_MAPS = r69 :: static
    r70 = dank_mids._web3.formatters.globals :: static
    r71 = 'REQUEST_FORMATTER_MAPS'
    r72 = box(tuple[object, object, object], r69)
    r73 = CPyDict_SetItem(r70, r71, r72)
    dec_ref r72
    r74 = r73 >= 0 :: signed
    if not r74 goto L55 (error at <module>:45) else goto L26 :: bool
L26:
    r75 = PyDict_New()
    if is_error(r75) goto L55 (error at <module>:55) else goto L27
L27:
    dank_mids._web3.formatters._request_formatters = r75 :: static
    r76 = dank_mids._web3.formatters.globals :: static
    r77 = '_request_formatters'
    r78 = CPyDict_SetItem(r76, r77, r75)
    dec_ref r75
    r79 = r78 >= 0 :: signed
    if not r79 goto L55 (error at <module>:55) else goto L28 :: bool
L28:
    r80 = dank_mids._web3.formatters.globals :: static
    r81 = 'Callable'
    r82 = CPyDict_GetItem(r80, r81)
    if is_error(r82) goto L55 (error at <module>:75) else goto L29
L29:
    r83 = dank_mids._web3.formatters.globals :: static
    r84 = 'RPCResponse'
    r85 = CPyDict_GetItem(r83, r84)
    if is_error(r85) goto L58 (error at <module>:75) else goto L30
L30:
    r86 = PyList_New(1)
    if is_error(r86) goto L59 (error at <module>:75) else goto L31
L31:
    r87 = get_element_ptr r86 ob_item :: PyListObject
    r88 = load_mem r87 :: ptr*
    set_mem r88, r85 :: builtins.object*
    r89 = dank_mids._web3.formatters.globals :: static
    r90 = 'Any'
    r91 = CPyDict_GetItem(r89, r90)
    if is_error(r91) goto L60 (error at <module>:75) else goto L32
L32:
    r92 = (r86, r91)
    r93 = box(tuple[list, object], r92)
    r94 = PyObject_GetItem(r82, r93)
    dec_ref r82
    dec_ref r93
    if is_error(r94) goto L55 (error at <module>:75) else goto L33
L33:
    r95 = dank_mids._web3.formatters.globals :: static
    r96 = 'SuccessFormatter'
    r97 = CPyDict_SetItem(r95, r96, r94)
    dec_ref r94
    r98 = r97 >= 0 :: signed
    if not r98 goto L55 (error at <module>:75) else goto L34 :: bool
L34:
    r99 = dank_mids._web3.formatters.globals :: static
    r100 = 'Callable'
    r101 = CPyDict_GetItem(r99, r100)
    if is_error(r101) goto L55 (error at <module>:76) else goto L35
L35:
    r102 = dank_mids._web3.formatters.globals :: static
    r103 = 'RPCResponse'
    r104 = CPyDict_GetItem(r102, r103)
    if is_error(r104) goto L61 (error at <module>:76) else goto L36
L36:
    r105 = PyList_New(1)
    if is_error(r105) goto L62 (error at <module>:76) else goto L37
L37:
    r106 = get_element_ptr r105 ob_item :: PyListObject
    r107 = load_mem r106 :: ptr*
    set_mem r107, r104 :: builtins.object*
    r108 = dank_mids._web3.formatters.globals :: static
    r109 = 'Any'
    r110 = CPyDict_GetItem(r108, r109)
    if is_error(r110) goto L63 (error at <module>:76) else goto L38
L38:
    r111 = (r105, r110)
    r112 = box(tuple[list, object], r111)
    r113 = PyObject_GetItem(r101, r112)
    dec_ref r101
    dec_ref r112
    if is_error(r113) goto L55 (error at <module>:76) else goto L39
L39:
    r114 = dank_mids._web3.formatters.globals :: static
    r115 = 'ErrorFormatter'
    r116 = CPyDict_SetItem(r114, r115, r113)
    dec_ref r113
    r117 = r116 >= 0 :: signed
    if not r117 goto L55 (error at <module>:76) else goto L40 :: bool
L40:
    r118 = dank_mids._web3.formatters.globals :: static
    r119 = 'Callable'
    r120 = CPyDict_GetItem(r118, r119)
    if is_error(r120) goto L55 (error at <module>:77) else goto L41
L41:
    r121 = dank_mids._web3.formatters.globals :: static
    r122 = 'RPCResponse'
    r123 = CPyDict_GetItem(r121, r122)
    if is_error(r123) goto L64 (error at <module>:77) else goto L42
L42:
    r124 = PyList_New(1)
    if is_error(r124) goto L65 (error at <module>:77) else goto L43
L43:
    r125 = get_element_ptr r124 ob_item :: PyListObject
    r126 = load_mem r125 :: ptr*
    set_mem r126, r123 :: builtins.object*
    r127 = dank_mids._web3.formatters.globals :: static
    r128 = 'Any'
    r129 = CPyDict_GetItem(r127, r128)
    if is_error(r129) goto L66 (error at <module>:77) else goto L44
L44:
    r130 = (r124, r129)
    r131 = box(tuple[list, object], r130)
    r132 = PyObject_GetItem(r120, r131)
    dec_ref r120
    dec_ref r131
    if is_error(r132) goto L55 (error at <module>:77) else goto L45
L45:
    r133 = dank_mids._web3.formatters.globals :: static
    r134 = 'NullFormatter'
    r135 = CPyDict_SetItem(r133, r134, r132)
    dec_ref r132
    r136 = r135 >= 0 :: signed
    if not r136 goto L55 (error at <module>:77) else goto L46 :: bool
L46:
    r137 = dank_mids._web3.formatters.globals :: static
    r138 = 'Tuple'
    r139 = CPyDict_GetItem(r137, r138)
    if is_error(r139) goto L55 (error at <module>:79) else goto L47
L47:
    r140 = dank_mids._web3.formatters.globals :: static
    r141 = 'SuccessFormatter'
    r142 = CPyDict_GetItem(r140, r141)
    if is_error(r142) goto L67 (error at <module>:79) else goto L48
L48:
    r143 = dank_mids._web3.formatters.globals :: static
    r144 = 'ErrorFormatter'
    r145 = CPyDict_GetItem(r143, r144)
    if is_error(r145) goto L68 (error at <module>:79) else goto L49
L49:
    r146 = dank_mids._web3.formatters.globals :: static
    r147 = 'NullFormatter'
    r148 = CPyDict_GetItem(r146, r147)
    if is_error(r148) goto L69 (error at <module>:79) else goto L50
L50:
    r149 = (r142, r145, r148)
    r150 = box(tuple[object, object, object], r149)
    r151 = PyObject_GetItem(r139, r150)
    dec_ref r139
    dec_ref r150
    if is_error(r151) goto L55 (error at <module>:79) else goto L51
L51:
    r152 = dank_mids._web3.formatters.globals :: static
    r153 = 'ResponseFormatters'
    r154 = CPyDict_SetItem(r152, r153, r151)
    dec_ref r151
    r155 = r154 >= 0 :: signed
    if not r155 goto L55 (error at <module>:79) else goto L52 :: bool
L52:
    r156 = PyDict_New()
    if is_error(r156) goto L55 (error at <module>:81) else goto L53
L53:
    dank_mids._web3.formatters._response_formatters = r156 :: static
    r157 = dank_mids._web3.formatters.globals :: static
    r158 = '_response_formatters'
    r159 = CPyDict_SetItem(r157, r158, r156)
    dec_ref r156
    r160 = r159 >= 0 :: signed
    if not r160 goto L55 (error at <module>:81) else goto L54 :: bool
L54:
    return 1
L55:
    r161 = <error> :: None
    return r161
L56:
    dec_ref r50
    goto L55
L57:
    dec_ref r65
    goto L55
L58:
    dec_ref r82
    goto L55
L59:
    dec_ref r82
    dec_ref r85
    goto L55
L60:
    dec_ref r82
    dec_ref r86
    goto L55
L61:
    dec_ref r101
    goto L55
L62:
    dec_ref r101
    dec_ref r104
    goto L55
L63:
    dec_ref r101
    dec_ref r105
    goto L55
L64:
    dec_ref r120
    goto L55
L65:
    dec_ref r120
    dec_ref r123
    goto L55
L66:
    dec_ref r120
    dec_ref r124
    goto L55
L67:
    dec_ref r139
    goto L55
L68:
    dec_ref r139
    dec_ref r142
    goto L55
L69:
    dec_ref r139
    dec_ref r142
    dec_ref r145
    goto L55

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: object_ptr
    r10 :: object_ptr[1]
    r11 :: c_ptr
    r12 :: native_int[1]
    r13 :: c_ptr
    r14 :: object
    r15 :: dict
    r16, r17 :: str
    r18 :: bit
    r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26 :: object
    r27, r28, r29, r30 :: str
    r31 :: set
    r32 :: i32
    r33 :: bit
    r34 :: i32
    r35 :: bit
    r36 :: i32
    r37 :: bit
    r38 :: i32
    r39 :: bit
    r40 :: dict
    r41 :: str
    r42 :: i32
    r43 :: bit
    r44, r45, r46, r47, r48, r49 :: str
    r50 :: set
    r51 :: i32
    r52 :: bit
    r53 :: i32
    r54 :: bit
    r55 :: i32
    r56 :: bit
    r57 :: i32
    r58 :: bit
    r59 :: i32
    r60 :: bit
    r61 :: i32
    r62 :: bit
    r63 :: dict
    r64 :: str
    r65 :: i32
    r66 :: bit
    r67 :: dict
    r68 :: str
    r69 :: object
    r70 :: str
    r71 :: object
    r72 :: str
    r73 :: object
    r74 :: dict
    r75 :: str
    r76 :: i32
    r77 :: bit
    r78 :: dict
    r79 :: str
    r80 :: object
    r81 :: str
    r82 :: object
    r83 :: str
    r84 :: object
    r85 :: dict
    r86 :: str
    r87 :: i32
    r88 :: bit
    r89 :: dict
    r90 :: str
    r91 :: object
    r92 :: str
    r93 :: object
    r94 :: str
    r95 :: object
    r96 :: dict
    r97 :: str
    r98 :: i32
    r99 :: bit
    r100 :: tuple[object, object, object]
    r101 :: object
    r102 :: str
    r103 :: object
    r104 :: bit
    r105 :: dict
    r106 :: str
    r107 :: object
    r108 :: str
    r109 :: object
    r110 :: str
    r111 :: object
    r112 :: dict
    r113 :: str
    r114 :: i32
    r115, r116 :: bit
    r117, r118, r119 :: tuple[object, object, object]
    r120 :: dict
    r121 :: str
    r122 :: object
    r123 :: dict
    r124 :: str
    r125 :: i32
    r126, r127 :: bit
    r128 :: dict
    r129 :: str
    r130 :: object
    r131 :: str
    r132 :: object
    r133 :: dict
    r134 :: str
    r135 :: object
    r136 :: str
    r137 :: object
    r138 :: dict
    r139 :: str
    r140 :: object
    r141 :: str
    r142 :: object
    r143 :: dict
    r144 :: str
    r145 :: object
    r146 :: str
    r147, r148, r149, r150, r151 :: object
    r152, r153 :: dict
    r154 :: str
    r155 :: i32
    r156 :: bit
    r157 :: dict
    r158 :: str
    r159 :: object
    r160 :: str
    r161 :: object
    r162 :: dict
    r163 :: str
    r164 :: object
    r165 :: str
    r166 :: object
    r167 :: dict
    r168 :: str
    r169 :: object
    r170 :: str
    r171 :: object
    r172 :: dict
    r173 :: str
    r174 :: object
    r175 :: str
    r176 :: object
    r177 :: dict
    r178 :: str
    r179 :: object
    r180 :: str
    r181, r182, r183, r184, r185, r186 :: object
    r187, r188 :: dict
    r189 :: str
    r190 :: i32
    r191 :: bit
    r192, r193, r194, r195, r196, r197, r198, r199, r200, r201 :: str
    r202 :: tuple[str, str, str, str, str, str, str, str, str, str]
    r203 :: dict
    r204 :: str
    r205 :: object
    r206 :: i32
    r207 :: bit
    r208, r209 :: bytes
    r210 :: tuple[bytes, bytes]
    r211 :: dict
    r212 :: str
    r213 :: object
    r214 :: i32
    r215 :: bit
    r216 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L80 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Dict', 'Final')
    r6 = 'typing'
    r7 = dank_mids.constants.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L80 (error at <module>:2) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address multicall.constants :: module
    r10 = [r9]
    r11 = load_address r10
    r12 = [4]
    r13 = load_address r12
    r14 = (('multicall.constants', 'multicall', 'multicall'),)
    r15 = dank_mids.constants.globals :: static
    r16 = 'dank_mids/constants.py'
    r17 = '<module>'
    r18 = CPyImport_ImportMany(r14, r11, r15, r16, r17, r13)
    if not r18 goto L80 else goto L5 :: bool
L5:
    r19 = ('BlockNumber',)
    r20 = 'eth_typing'
    r21 = dank_mids.constants.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L80 (error at <module>:5) else goto L6
L6:
    eth_typing = r22 :: module
    dec_ref r22
    r23 = ('Network',)
    r24 = 'multicall.constants'
    r25 = dank_mids.constants.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L80 (error at <module>:6) else goto L7
L7:
    multicall.constants = r26 :: module
    dec_ref r26
    r27 = 'payload too large'
    r28 = 'content length too large'
    r29 = 'request entity too large'
    r30 = 'batch limit exceeded'
    r31 = PySet_New(0)
    if is_error(r31) goto L80 (error at <module>:8) else goto L8
L8:
    r32 = PySet_Add(r31, r27)
    r33 = r32 >= 0 :: signed
    if not r33 goto L81 (error at <module>:8) else goto L9 :: bool
L9:
    r34 = PySet_Add(r31, r28)
    r35 = r34 >= 0 :: signed
    if not r35 goto L81 (error at <module>:8) else goto L10 :: bool
L10:
    r36 = PySet_Add(r31, r29)
    r37 = r36 >= 0 :: signed
    if not r37 goto L81 (error at <module>:8) else goto L11 :: bool
L11:
    r38 = PySet_Add(r31, r30)
    r39 = r38 >= 0 :: signed
    if not r39 goto L81 (error at <module>:8) else goto L12 :: bool
L12:
    dank_mids.constants.TOO_MUCH_DATA_ERRS = r31 :: static
    r40 = dank_mids.constants.globals :: static
    r41 = 'TOO_MUCH_DATA_ERRS'
    r42 = CPyDict_SetItem(r40, r41, r31)
    dec_ref r31
    r43 = r42 >= 0 :: signed
    if not r43 goto L80 (error at <module>:8) else goto L13 :: bool
L13:
    r44 = 'connection reset by peer'
    r45 = 'server disconnected'
    r46 = 'execution aborted (timeout ='
    r47 = 'batch limit exceeded'
    r48 = 'request timed out'
    r49 = 'evm timeout'
    r50 = PySet_New(0)
    if is_error(r50) goto L80 (error at <module>:19) else goto L14
L14:
    r51 = PySet_Add(r50, r44)
    r52 = r51 >= 0 :: signed
    if not r52 goto L82 (error at <module>:19) else goto L15 :: bool
L15:
    r53 = PySet_Add(r50, r45)
    r54 = r53 >= 0 :: signed
    if not r54 goto L82 (error at <module>:19) else goto L16 :: bool
L16:
    r55 = PySet_Add(r50, r46)
    r56 = r55 >= 0 :: signed
    if not r56 goto L82 (error at <module>:19) else goto L17 :: bool
L17:
    r57 = PySet_Add(r50, r47)
    r58 = r57 >= 0 :: signed
    if not r58 goto L82 (error at <module>:19) else goto L18 :: bool
L18:
    r59 = PySet_Add(r50, r48)
    r60 = r59 >= 0 :: signed
    if not r60 goto L82 (error at <module>:19) else goto L19 :: bool
L19:
    r61 = PySet_Add(r50, r49)
    r62 = r61 >= 0 :: signed
    if not r62 goto L82 (error at <module>:19) else goto L20 :: bool
L20:
    dank_mids.constants.RETRY_ERRS = r50 :: static
    r63 = dank_mids.constants.globals :: static
    r64 = 'RETRY_ERRS'
    r65 = CPyDict_SetItem(r63, r64, r50)
    dec_ref r50
    r66 = r65 >= 0 :: signed
    if not r66 goto L80 (error at <module>:19) else goto L21 :: bool
L21:
    r67 = dank_mids.constants.globals :: static
    r68 = 'multicall'
    r69 = CPyDict_GetItem(r67, r68)
    if is_error(r69) goto L80 (error at <module>:32) else goto L22
L22:
    r70 = 'constants'
    r71 = CPyObject_GetAttr(r69, r70)
    dec_ref r69
    if is_error(r71) goto L80 (error at <module>:32) else goto L23
L23:
    r72 = 'GAS_LIMIT'
    r73 = CPyObject_GetAttr(r71, r72)
    dec_ref r71
    if is_error(r73) goto L80 (error at <module>:32) else goto L24
L24:
    dank_mids.constants.GAS_LIMIT = r73 :: static
    r74 = dank_mids.constants.globals :: static
    r75 = 'GAS_LIMIT'
    r76 = CPyDict_SetItem(r74, r75, r73)
    dec_ref r73
    r77 = r76 >= 0 :: signed
    if not r77 goto L80 (error at <module>:32) else goto L25 :: bool
L25:
    r78 = dank_mids.constants.globals :: static
    r79 = 'multicall'
    r80 = CPyDict_GetItem(r78, r79)
    if is_error(r80) goto L80 (error at <module>:38) else goto L26
L26:
    r81 = 'constants'
    r82 = CPyObject_GetAttr(r80, r81)
    dec_ref r80
    if is_error(r82) goto L80 (error at <module>:38) else goto L27
L27:
    r83 = 'MULTICALL2_BYTECODE'
    r84 = CPyObject_GetAttr(r82, r83)
    dec_ref r82
    if is_error(r84) goto L80 (error at <module>:38) else goto L28
L28:
    dank_mids.constants.MULTICALL2_OVERRIDE_CODE = r84 :: static
    r85 = dank_mids.constants.globals :: static
    r86 = 'MULTICALL2_OVERRIDE_CODE'
    r87 = CPyDict_SetItem(r85, r86, r84)
    dec_ref r84
    r88 = r87 >= 0 :: signed
    if not r88 goto L80 (error at <module>:38) else goto L29 :: bool
L29:
    r89 = dank_mids.constants.globals :: static
    r90 = 'multicall'
    r91 = CPyDict_GetItem(r89, r90)
    if is_error(r91) goto L33 (error at <module>:45) else goto L30
L30:
    r92 = 'constants'
    r93 = CPyObject_GetAttr(r91, r92)
    dec_ref r91
    if is_error(r93) goto L33 (error at <module>:45) else goto L31
L31:
    r94 = 'MULTICALL3_BYTECODE'
    r95 = CPyObject_GetAttr(r93, r94)
    dec_ref r93
    if is_error(r95) goto L33 (error at <module>:45) else goto L32
L32:
    r96 = dank_mids.constants.globals :: static
    r97 = '__MULTICALL3_OVERRIDE_CODE'
    r98 = CPyDict_SetItem(r96, r97, r95)
    dec_ref r95
    r99 = r98 >= 0 :: signed
    if not r99 goto L33 (error at <module>:45) else goto L44 :: bool
L33:
    r100 = CPy_CatchError()
    r101 = builtins :: module
    r102 = 'AttributeError'
    r103 = CPyObject_GetAttr(r101, r102)
    if is_error(r103) goto L42 (error at <module>:50) else goto L34
L34:
    r104 = CPy_ExceptionMatches(r103)
    dec_ref r103
    if r104 goto L35 else goto L39 :: bool
L35:
    r105 = dank_mids.constants.globals :: static
    r106 = 'multicall'
    r107 = CPyDict_GetItem(r105, r106)
    if is_error(r107) goto L42 (error at <module>:51) else goto L36
L36:
    r108 = 'constants'
    r109 = CPyObject_GetAttr(r107, r108)
    dec_ref r107
    if is_error(r109) goto L42 (error at <module>:51) else goto L37
L37:
    r110 = 'MULTICALL2_BYTECODE'
    r111 = CPyObject_GetAttr(r109, r110)
    dec_ref r109
    if is_error(r111) goto L42 (error at <module>:51) else goto L38
L38:
    r112 = dank_mids.constants.globals :: static
    r113 = '__MULTICALL3_OVERRIDE_CODE'
    r114 = CPyDict_SetItem(r112, r113, r111)
    dec_ref r111
    r115 = r114 >= 0 :: signed
    if not r115 goto L42 (error at <module>:51) else goto L41 :: bool
L39:
    CPy_Reraise()
    if not 0 goto L42 else goto L83 :: bool
L40:
    unreachable
L41:
    CPy_RestoreExcInfo(r100)
    dec_ref r100
    goto L44
L42:
    CPy_RestoreExcInfo(r100)
    dec_ref r100
    r116 = CPy_KeepPropagating()
    if not r116 goto L45 else goto L43 :: bool
L43:
    unreachable
L44:
    r117 = <error> :: tuple[object, object, object]
    r118 = r117
    goto L46
L45:
    r119 = CPy_CatchError()
    r118 = r119
L46:
    r120 = dank_mids.constants.globals :: static
    r121 = '__MULTICALL3_OVERRIDE_CODE'
    r122 = CPyDict_GetItem(r120, r121)
    if is_error(r122) goto L51 (error at <module>:53) else goto L47
L47:
    dank_mids.constants.MULTICALL3_OVERRIDE_CODE = r122 :: static
    r123 = dank_mids.constants.globals :: static
    r124 = 'MULTICALL3_OVERRIDE_CODE'
    r125 = CPyDict_SetItem(r123, r124, r122)
    dec_ref r122
    r126 = r125 >= 0 :: signed
    if not r126 goto L51 (error at <module>:53) else goto L48 :: bool
L48:
    if is_error(r118) goto L55 else goto L49
L49:
    CPy_Reraise()
    if not 0 goto L51 else goto L84 :: bool
L50:
    unreachable
L51:
    if is_error(r118) goto L53 else goto L52
L52:
    CPy_RestoreExcInfo(r118)
    xdec_ref r118
L53:
    r127 = CPy_KeepPropagating()
    if not r127 goto L80 else goto L54 :: bool
L54:
    unreachable
L55:
    r128 = dank_mids.constants.globals :: static
    r129 = 'Network'
    r130 = CPyDict_GetItem(r128, r129)
    if is_error(r130) goto L80 (error at <module>:56) else goto L56
L56:
    r131 = 'Mainnet'
    r132 = CPyObject_GetAttr(r130, r131)
    dec_ref r130
    if is_error(r132) goto L80 (error at <module>:56) else goto L57
L57:
    r133 = dank_mids.constants.globals :: static
    r134 = 'Network'
    r135 = CPyDict_GetItem(r133, r134)
    if is_error(r135) goto L85 (error at <module>:57) else goto L58
L58:
    r136 = 'Fantom'
    r137 = CPyObject_GetAttr(r135, r136)
    dec_ref r135
    if is_error(r137) goto L85 (error at <module>:57) else goto L59
L59:
    r138 = dank_mids.constants.globals :: static
    r139 = 'Network'
    r140 = CPyDict_GetItem(r138, r139)
    if is_error(r140) goto L86 (error at <module>:58) else goto L60
L60:
    r141 = 'Arbitrum'
    r142 = CPyObject_GetAttr(r140, r141)
    dec_ref r140
    if is_error(r142) goto L86 (error at <module>:58) else goto L61
L61:
    r143 = dank_mids.constants.globals :: static
    r144 = 'Network'
    r145 = CPyDict_GetItem(r143, r144)
    if is_error(r145) goto L87 (error at <module>:59) else goto L62
L62:
    r146 = 'Optimism'
    r147 = CPyObject_GetAttr(r145, r146)
    dec_ref r145
    if is_error(r147) goto L87 (error at <module>:59) else goto L63
L63:
    r148 = object 12336033
    r149 = object 16572242
    r150 = object 821923
    r151 = object 722566
    r152 = CPyDict_Build(4, r132, r148, r137, r149, r142, r150, r147, r151)
    dec_ref r132
    dec_ref r137
    dec_ref r142
    dec_ref r147
    if is_error(r152) goto L80 (error at <module>:55) else goto L64
L64:
    dank_mids.constants.MULTICALL2_DEPLOY_BLOCKS = r152 :: static
    r153 = dank_mids.constants.globals :: static
    r154 = 'MULTICALL2_DEPLOY_BLOCKS'
    r155 = CPyDict_SetItem(r153, r154, r152)
    dec_ref r152
    r156 = r155 >= 0 :: signed
    if not r156 goto L80 (error at <module>:55) else goto L65 :: bool
L65:
    r157 = dank_mids.constants.globals :: static
    r158 = 'Network'
    r159 = CPyDict_GetItem(r157, r158)
    if is_error(r159) goto L80 (error at <module>:64) else goto L66
L66:
    r160 = 'Mainnet'
    r161 = CPyObject_GetAttr(r159, r160)
    dec_ref r159
    if is_error(r161) goto L80 (error at <module>:64) else goto L67
L67:
    r162 = dank_mids.constants.globals :: static
    r163 = 'Network'
    r164 = CPyDict_GetItem(r162, r163)
    if is_error(r164) goto L88 (error at <module>:65) else goto L68
L68:
    r165 = 'Fantom'
    r166 = CPyObject_GetAttr(r164, r165)
    dec_ref r164
    if is_error(r166) goto L88 (error at <module>:65) else goto L69
L69:
    r167 = dank_mids.constants.globals :: static
    r168 = 'Network'
    r169 = CPyDict_GetItem(r167, r168)
    if is_error(r169) goto L89 (error at <module>:66) else goto L70
L70:
    r170 = 'Arbitrum'
    r171 = CPyObject_GetAttr(r169, r170)
    dec_ref r169
    if is_error(r171) goto L89 (error at <module>:66) else goto L71
L71:
    r172 = dank_mids.constants.globals :: static
    r173 = 'Network'
    r174 = CPyDict_GetItem(r172, r173)
    if is_error(r174) goto L90 (error at <module>:67) else goto L72
L72:
    r175 = 'Optimism'
    r176 = CPyObject_GetAttr(r174, r175)
    dec_ref r174
    if is_error(r176) goto L90 (error at <module>:67) else goto L73
L73:
    r177 = dank_mids.constants.globals :: static
    r178 = 'Network'
    r179 = CPyDict_GetItem(r177, r178)
    if is_error(r179) goto L91 (error at <module>:68) else goto L74
L74:
    r180 = 'Base'
    r181 = CPyObject_GetAttr(r179, r180)
    dec_ref r179
    if is_error(r181) goto L91 (error at <module>:68) else goto L75
L75:
    r182 = object 14353601
    r183 = object 33001987
    r184 = object 7654707
    r185 = object 4286263
    r186 = object 5022
    r187 = CPyDict_Build(5, r161, r182, r166, r183, r171, r184, r176, r185, r181, r186)
    dec_ref r161
    dec_ref r166
    dec_ref r171
    dec_ref r176
    dec_ref r181
    if is_error(r187) goto L80 (error at <module>:63) else goto L76
L76:
    dank_mids.constants.MULTICALL3_DEPLOY_BLOCKS = r187 :: static
    r188 = dank_mids.constants.globals :: static
    r189 = 'MULTICALL3_DEPLOY_BLOCKS'
    r190 = CPyDict_SetItem(r188, r189, r187)
    dec_ref r187
    r191 = r190 >= 0 :: signed
    if not r191 goto L80 (error at <module>:63) else goto L77 :: bool
L77:
    r192 = '0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000094e6f206163636573730000000000000000000000000000000000000000000000'
    r193 = '0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e6d696e7420697320706175736564000000000000000000000000000000000000'
    r194 = '0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000016496e76616c6964206574686572207472616e7366657200000000000000000000'
    r195 = '0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e4e4f4e5f454d5054595f44415441000000000000000000000000000000000000'
    r196 = '0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000246d73672e736967206973206e6f742061737369676e656420746f207375626d6f64756c6500000000000000000000000000000000000000000000000000000000'
    r197 = '0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000346f6e6c792077726170706564206e617469766520636f6e747261637420636f756c642073656e64206e617469766520746f6b656e000000000000000000000000'
    r198 = '0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000013434f4e54524f4c4c45525f52454a454354454400000000000000000000000000'
    r199 = '0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000204469616d6f6e643a2046756e6374696f6e20646f6573206e6f74206578697374'
    r200 = '0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001a66756e6374696f6e2073686f756c6420626520616c6c6f776564000000000000'
    r201 = '0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001846756e6374696f6e20646f6573206e6f742065786973742e0000000000000000'
    inc_ref r192
    inc_ref r193
    inc_ref r194
    inc_ref r195
    inc_ref r196
    inc_ref r197
    inc_ref r198
    inc_ref r199
    inc_ref r200
    inc_ref r201
    r202 = (r192, r193, r194, r195, r196, r197, r198, r199, r200, r201)
    dank_mids.constants.BAD_HEXES = r202 :: static
    r203 = dank_mids.constants.globals :: static
    r204 = 'BAD_HEXES'
    r205 = box(tuple[str, str, str, str, str, str, str, str, str, str], r202)
    r206 = CPyDict_SetItem(r203, r204, r205)
    dec_ref r205
    r207 = r206 >= 0 :: signed
    if not r207 goto L80 (error at <module>:75) else goto L78 :: bool
L78:
    r208 = b'\x08\xc3y\xa0'
    r209 = b'4e487b71'
    inc_ref r208
    inc_ref r209
    r210 = (r208, r209)
    dank_mids.constants.REVERT_SELECTORS = r210 :: static
    r211 = dank_mids.constants.globals :: static
    r212 = 'REVERT_SELECTORS'
    r213 = box(tuple[bytes, bytes], r210)
    r214 = CPyDict_SetItem(r211, r212, r213)
    dec_ref r213
    r215 = r214 >= 0 :: signed
    if not r215 goto L80 (error at <module>:101) else goto L79 :: bool
L79:
    return 1
L80:
    r216 = <error> :: None
    return r216
L81:
    dec_ref r31
    goto L80
L82:
    dec_ref r50
    goto L80
L83:
    dec_ref r100
    goto L40
L84:
    xdec_ref r118
    goto L50
L85:
    dec_ref r132
    goto L80
L86:
    dec_ref r132
    dec_ref r137
    goto L80
L87:
    dec_ref r132
    dec_ref r137
    dec_ref r142
    goto L80
L88:
    dec_ref r161
    goto L80
L89:
    dec_ref r161
    dec_ref r166
    goto L80
L90:
    dec_ref r161
    dec_ref r166
    dec_ref r171
    goto L80
L91:
    dec_ref r161
    dec_ref r166
    dec_ref r171
    dec_ref r176
    goto L80

def BadResponse.__init__(self, response):
    self :: dank_mids._exceptions.BadResponse
    response :: object
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    r12 :: str
    r13 :: object[3]
    r14 :: object_ptr
    r15 :: object
    r16 :: None
L0:
    r0 = 'response'
    r1 = PyObject_SetAttr(self, r0, response)
    r2 = r1 >= 0 :: signed
    if not r2 goto L6 (error at __init__:21) else goto L1 :: bool
L1:
    r3 = builtins :: module
    r4 = 'BaseException'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L6 (error at __init__:22) else goto L2
L2:
    r6 = 'error'
    r7 = CPyObject_GetAttr(response, r6)
    if is_error(r7) goto L7 (error at __init__:22) else goto L3
L3:
    r8 = 'to_dict'
    r9 = [r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775809, 0)
    if is_error(r11) goto L8 (error at __init__:22) else goto L4
L4:
    dec_ref r7
    r12 = '__init__'
    r13 = [r5, self, r11]
    r14 = load_address r13
    r15 = PyObject_VectorcallMethod(r12, r14, 9223372036854775811, 0)
    if is_error(r15) goto L9 (error at __init__:22) else goto L10
L5:
    dec_ref r5
    dec_ref r11
    return 1
L6:
    r16 = <error> :: None
    return r16
L7:
    dec_ref r5
    goto L6
L8:
    dec_ref r5
    dec_ref r7
    goto L6
L9:
    dec_ref r5
    dec_ref r11
    goto L6
L10:
    dec_ref r15
    goto L5

def ExecutionReverted.__init__(self, response):
    self :: dank_mids._exceptions.ExecutionReverted
    response :: object
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: str
    r6 :: object
    r7, message, r8 :: str
    r9 :: native_int
    r10, r11, r12 :: bit
    r13, r14, r15 :: int
    r16 :: bit
    r17 :: str
    r18 :: list
    r19 :: object
    r20 :: str
    r21 :: object
    r22 :: str
    r23 :: object
    r24 :: str
    r25 :: object[3]
    r26 :: object_ptr
    r27 :: object
    r28 :: None
L0:
    r0 = 'response'
    r1 = PyObject_SetAttr(self, r0, response)
    r2 = r1 >= 0 :: signed
    if not r2 goto L18 (error at __init__:35) else goto L1 :: bool
L1:
    r3 = 'error'
    r4 = CPyObject_GetAttr(response, r3)
    if is_error(r4) goto L18 (error at __init__:36) else goto L2
L2:
    r5 = 'message'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L18 (error at __init__:36) else goto L3
L3:
    r7 = cast(str, r6)
    if is_error(r7) goto L18 (error at __init__:36) else goto L4
L4:
    message = r7
    r8 = ':'
    r9 = CPyStr_Count(message, r8, 0)
    r10 = r9 >= 0 :: signed
    if not r10 goto L19 (error at __init__:37) else goto L5 :: bool
L5:
    r11 = r9 <= 4611686018427387903 :: signed
    if r11 goto L6 else goto L7 :: bool
L6:
    r12 = r9 >= -4611686018427387904 :: signed
    if r12 goto L9 else goto L7 :: bool
L7:
    r13 = CPyTagged_FromInt64(r9)
    if is_error(r13) goto L19 (error at __init__:37) else goto L8
L8:
    r14 = r13
    goto L10
L9:
    r15 = r9 << 1
    r14 = r15
L10:
    r16 = r14 == 2
    dec_ref r14 :: int
    if r16 goto L11 else goto L15 :: bool
L11:
    r17 = ':'
    r18 = PyUnicode_Split(message, r17, -1)
    dec_ref message
    if is_error(r18) goto L18 (error at __init__:38) else goto L12
L12:
    r19 = CPyList_GetItemShort(r18, 2)
    dec_ref r18
    if is_error(r19) goto L18 (error at __init__:38) else goto L13
L13:
    r20 = cast(str, r19)
    if is_error(r20) goto L18 (error at __init__:38) else goto L14
L14:
    message = r20
L15:
    r21 = builtins :: module
    r22 = 'BaseException'
    r23 = CPyObject_GetAttr(r21, r22)
    if is_error(r23) goto L19 (error at __init__:39) else goto L16
L16:
    r24 = '__init__'
    r25 = [r23, self, message]
    r26 = load_address r25
    r27 = PyObject_VectorcallMethod(r24, r26, 9223372036854775811, 0)
    if is_error(r27) goto L20 (error at __init__:39) else goto L21
L17:
    dec_ref r23
    dec_ref message
    return 1
L18:
    r28 = <error> :: None
    return r28
L19:
    dec_ref message
    goto L18
L20:
    dec_ref message
    dec_ref r23
    goto L18
L21:
    dec_ref r27
    goto L17

def ExceedsMaxBatchSize.limit(self):
    self :: dank_mids._exceptions.ExceedsMaxBatchSize
    r0, r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: str
    r6, r7 :: object
    r8 :: str
    r9 :: object
    r10 :: object[2]
    r11 :: object_ptr
    r12, r13, r14, r15 :: object
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19, r20 :: int
L0:
    r0 = 'batch limit (\\d+) exceeded'
    r1 = 'response'
    r2 = CPyObject_GetAttr(self, r1)
    if is_error(r2) goto L9 (error at limit:59) else goto L1
L1:
    r3 = 'error'
    r4 = CPyObject_GetAttr(r2, r3)
    dec_ref r2
    if is_error(r4) goto L9 (error at limit:59) else goto L2
L2:
    r5 = 'message'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L9 (error at limit:59) else goto L3
L3:
    r7 = re :: module
    r8 = 'search'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L10 (error at limit:59) else goto L4
L4:
    r10 = [r0, r6]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r9, r11, 2, 0)
    dec_ref r9
    if is_error(r12) goto L10 (error at limit:59) else goto L5
L5:
    dec_ref r6
    r13 = object 1
    r14 = PyObject_GetItem(r12, r13)
    dec_ref r12
    if is_error(r14) goto L9 (error at limit:59) else goto L6
L6:
    r15 = load_address PyLong_Type
    r16 = [r14]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r15, r17, 1, 0)
    if is_error(r18) goto L11 (error at limit:59) else goto L7
L7:
    dec_ref r14
    r19 = unbox(int, r18)
    dec_ref r18
    if is_error(r19) goto L9 (error at limit:59) else goto L8
L8:
    return r19
L9:
    r20 = <error> :: int
    return r20
L10:
    dec_ref r6
    goto L9
L11:
    dec_ref r14
    goto L9

def DankMidsClientResponseError.__init__(self, exc, request):
    self :: dank_mids._exceptions.DankMidsClientResponseError
    exc, request :: object
    r0 :: tuple
    r1 :: list
    r2 :: object
    r3 :: i32
    r4 :: bit
    r5 :: tuple
    r6 :: object
    r7 :: str
    r8, r9 :: object
    r10 :: object[2]
    r11 :: object_ptr
    r12 :: object
    r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: object[5]
    r26 :: object_ptr
    r27, r28 :: object
    r29 :: None
L0:
    inc_ref request
    self.request = request
    r0 = self.args
    if is_error(r0) goto L15 (error at __init__:77) else goto L1
L1:
    r1 = PyList_New(0)
    if is_error(r1) goto L16 (error at __init__:77) else goto L2
L2:
    r2 = CPyList_Extend(r1, r0)
    dec_ref r0
    if is_error(r2) goto L17 (error at __init__:77) else goto L18
L3:
    r3 = PyList_Append(r1, request)
    r4 = r3 >= 0 :: signed
    if not r4 goto L17 (error at __init__:77) else goto L4 :: bool
L4:
    r5 = PyList_AsTuple(r1)
    dec_ref r1
    if is_error(r5) goto L15 (error at __init__:77) else goto L5
L5:
    self.args = r5
    inc_ref exc
    self._exception = exc
    r6 = builtins :: module
    r7 = 'super'
    r8 = CPyObject_GetAttr(r6, r7)
    if is_error(r8) goto L15 (error at __init__:85) else goto L6
L6:
    r9 = dank_mids._exceptions.DankMidsClientResponseError :: type
    r10 = [r9, self]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r8, r11, 2, 0)
    dec_ref r8
    if is_error(r12) goto L15 (error at __init__:85) else goto L7
L7:
    r13 = '__init__'
    r14 = CPyObject_GetAttr(r12, r13)
    dec_ref r12
    if is_error(r14) goto L15 (error at __init__:85) else goto L8
L8:
    r15 = 'request_info'
    r16 = CPyObject_GetAttr(exc, r15)
    if is_error(r16) goto L19 (error at __init__:86) else goto L9
L9:
    r17 = 'history'
    r18 = CPyObject_GetAttr(exc, r17)
    if is_error(r18) goto L20 (error at __init__:87) else goto L10
L10:
    r19 = 'status'
    r20 = CPyObject_GetAttr(exc, r19)
    if is_error(r20) goto L21 (error at __init__:88) else goto L11
L11:
    r21 = 'message'
    r22 = CPyObject_GetAttr(exc, r21)
    if is_error(r22) goto L22 (error at __init__:89) else goto L12
L12:
    r23 = 'headers'
    r24 = CPyObject_GetAttr(exc, r23)
    if is_error(r24) goto L23 (error at __init__:90) else goto L13
L13:
    r25 = [r16, r18, r20, r22, r24]
    r26 = load_address r25
    r27 = ('status', 'message', 'headers')
    r28 = PyObject_Vectorcall(r14, r26, 2, r27)
    dec_ref r14
    if is_error(r28) goto L24 (error at __init__:85) else goto L25
L14:
    dec_ref r16
    dec_ref r18
    dec_ref r20
    dec_ref r22
    dec_ref r24
    return 1
L15:
    r29 = <error> :: None
    return r29
L16:
    dec_ref r0
    goto L15
L17:
    dec_ref r1
    goto L15
L18:
    dec_ref r2
    goto L3
L19:
    dec_ref r14
    goto L15
L20:
    dec_ref r14
    dec_ref r16
    goto L15
L21:
    dec_ref r14
    dec_ref r16
    dec_ref r18
    goto L15
L22:
    dec_ref r14
    dec_ref r16
    dec_ref r18
    dec_ref r20
    goto L15
L23:
    dec_ref r14
    dec_ref r16
    dec_ref r18
    dec_ref r20
    dec_ref r22
    goto L15
L24:
    dec_ref r16
    dec_ref r18
    dec_ref r20
    dec_ref r22
    dec_ref r24
    goto L15
L25:
    dec_ref r28
    goto L14

def DankMidsInternalError.__init__(self, exc):
    self :: dank_mids._exceptions.DankMidsInternalError
    exc, r0 :: object
    r1 :: bool
    r2, r3, r4, r5 :: str
    r6 :: object
    r7 :: object[3]
    r8 :: object_ptr
    r9, r10 :: object
    r11 :: str
    r12 :: i32
    r13 :: bit
    r14 :: object
    r15 :: str
    r16, r17 :: object
    r18 :: object[2]
    r19 :: object_ptr
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: str
    r24 :: object[1]
    r25 :: object_ptr
    r26 :: object
    r27 :: None
L0:
    r0 = dank_mids._exceptions.logger :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "logger" was not set')
    if not r1 goto L13 (error at __init__:104) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = 'unhandled exception inside dank mids internals: '
    r3 = PyObject_Str(exc)
    if is_error(r3) goto L13 (error at __init__:104) else goto L4
L4:
    r4 = CPyStr_Build(2, r2, r3)
    dec_ref r3
    if is_error(r4) goto L13 (error at __init__:104) else goto L5
L5:
    r5 = 'warning'
    r6 = box(bool, 1)
    r7 = [r0, r4, r6]
    r8 = load_address r7
    r9 = ('exc_info',)
    r10 = PyObject_VectorcallMethod(r5, r8, 9223372036854775810, r9)
    if is_error(r10) goto L14 (error at __init__:104) else goto L15
L6:
    dec_ref r4
    r11 = '_original_exception'
    r12 = PyObject_SetAttr(self, r11, exc)
    r13 = r12 >= 0 :: signed
    if not r13 goto L13 (error at __init__:106) else goto L7 :: bool
L7:
    r14 = builtins :: module
    r15 = 'super'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L13 (error at __init__:112) else goto L8
L8:
    r17 = dank_mids._exceptions.DankMidsInternalError :: type
    r18 = [r17, self]
    r19 = load_address r18
    r20 = PyObject_Vectorcall(r16, r19, 2, 0)
    dec_ref r16
    if is_error(r20) goto L13 (error at __init__:112) else goto L9
L9:
    r21 = '__init__'
    r22 = CPyObject_GetAttr(r20, r21)
    dec_ref r20
    if is_error(r22) goto L13 (error at __init__:112) else goto L10
L10:
    r23 = PyObject_Repr(exc)
    if is_error(r23) goto L16 (error at __init__:112) else goto L11
L11:
    r24 = [r23]
    r25 = load_address r24
    r26 = PyObject_Vectorcall(r22, r25, 1, 0)
    dec_ref r22
    if is_error(r26) goto L17 (error at __init__:112) else goto L18
L12:
    dec_ref r23
    return 1
L13:
    r27 = <error> :: None
    return r27
L14:
    dec_ref r4
    goto L13
L15:
    dec_ref r10
    goto L6
L16:
    dec_ref r22
    goto L13
L17:
    dec_ref r23
    goto L13
L18:
    dec_ref r26
    goto L12

def BatchResponseSortError.__init__(self, controller, calls, response):
    self :: dank_mids._exceptions.BatchResponseSortError
    controller, calls :: object
    response :: list
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: ptr
    r4 :: native_int
    r5 :: list
    r6 :: native_int
    r7 :: ptr
    r8 :: native_int
    r9 :: bit
    r10, r11 :: ptr
    r12 :: native_int
    r13 :: ptr
    r14 :: object
    r15 :: dank_mids.helpers._codec.RawResponse
    r16 :: bool
    r17 :: object
    r18 :: native_int
    r19 :: str
    r20 :: i32
    r21 :: bit
    r22 :: object
    r23 :: str
    r24, r25 :: object
    r26 :: object[2]
    r27 :: object_ptr
    r28 :: object
    r29 :: str
    r30 :: object
    r31, r32 :: str
    r33 :: object
    r34, r35, r36 :: str
    r37 :: object
    r38, r39 :: str
    r40 :: list
    r41, r42 :: object
    r43 :: str
    r44 :: object
    r45 :: i32
    r46, r47 :: bit
    r48, r49, r50 :: str
    r51 :: object
    r52 :: list
    r53, r54 :: str
    r55 :: object[1]
    r56 :: object_ptr
    r57 :: object
    r58 :: None
L0:
    r0 = 'calls'
    r1 = PyObject_SetAttr(self, r0, calls)
    r2 = r1 >= 0 :: signed
    if not r2 goto L29 (error at __init__:128) else goto L1 :: bool
L1:
    r3 = get_element_ptr response ob_size :: PyVarObject
    r4 = load_mem r3 :: native_int*
    r5 = PyList_New(r4)
    if is_error(r5) goto L29 (error at __init__:134) else goto L2
L2:
    r6 = 0
L3:
    r7 = get_element_ptr response ob_size :: PyVarObject
    r8 = load_mem r7 :: native_int*
    r9 = r6 < r8 :: signed
    if r9 goto L4 else goto L8 :: bool
L4:
    r10 = get_element_ptr response ob_item :: PyListObject
    r11 = load_mem r10 :: ptr*
    r12 = r6 * 8
    r13 = r11 + r12
    r14 = load_mem r13 :: builtins.object*
    r15 = cast(dank_mids.helpers._codec.RawResponse, r14)
    if is_error(r15) goto L30 (error at __init__:134) else goto L5
L5:
    r16 = <error> :: bool
    r17 = r15.decode(r16)
    dec_ref r15
    if is_error(r17) goto L30 (error at __init__:134) else goto L6
L6:
    CPyList_SetItemUnsafe(r5, r6, r17)
L7:
    r18 = r6 + 1
    r6 = r18
    goto L3
L8:
    r19 = 'results'
    r20 = PyObject_SetAttr(self, r19, r5)
    dec_ref r5
    r21 = r20 >= 0 :: signed
    if not r21 goto L29 (error at __init__:134) else goto L9 :: bool
L9:
    r22 = builtins :: module
    r23 = 'super'
    r24 = CPyObject_GetAttr(r22, r23)
    if is_error(r24) goto L29 (error at __init__:140) else goto L10
L10:
    r25 = dank_mids._exceptions.BatchResponseSortError :: type
    r26 = [r25, self]
    r27 = load_address r26
    r28 = PyObject_Vectorcall(r24, r27, 2, 0)
    dec_ref r24
    if is_error(r28) goto L29 (error at __init__:140) else goto L11
L11:
    r29 = '__init__'
    r30 = CPyObject_GetAttr(r28, r29)
    dec_ref r28
    if is_error(r30) goto L29 (error at __init__:140) else goto L12
L12:
    r31 = 'This will not mess up your run but will make things needlessly slow. Please show this to Bob.\nendpoint='
    r32 = 'endpoint'
    r33 = CPyObject_GetAttr(controller, r32)
    if is_error(r33) goto L31 (error at __init__:142) else goto L13
L13:
    r34 = cast(str, r33)
    if is_error(r34) goto L31 (error at __init__:142) else goto L14
L14:
    r35 = '\nclient_version='
    r36 = 'client_version'
    r37 = CPyObject_GetAttr(controller, r36)
    if is_error(r37) goto L32 (error at __init__:143) else goto L15
L15:
    r38 = cast(str, r37)
    if is_error(r38) goto L32 (error at __init__:143) else goto L16
L16:
    r39 = '\ncalls='
    r40 = PyList_New(0)
    if is_error(r40) goto L33 (error at __init__:144) else goto L17
L17:
    r41 = PyObject_GetIter(calls)
    if is_error(r41) goto L34 (error at __init__:144) else goto L18
L18:
    r42 = PyIter_Next(r41)
    if is_error(r42) goto L35 else goto L19
L19:
    r43 = 'uid'
    r44 = CPyObject_GetAttr(r42, r43)
    dec_ref r42
    if is_error(r44) goto L36 (error at __init__:144) else goto L20
L20:
    r45 = PyList_Append(r40, r44)
    dec_ref r44
    r46 = r45 >= 0 :: signed
    if not r46 goto L36 (error at __init__:144) else goto L18 :: bool
L21:
    r47 = CPy_NoErrOccurred()
    if not r47 goto L34 (error at __init__:144) else goto L22 :: bool
L22:
    r48 = PyObject_Str(r40)
    dec_ref r40
    if is_error(r48) goto L33 (error at __init__:141) else goto L23
L23:
    r49 = '\nresponse='
    r50 = 'results'
    r51 = CPyObject_GetAttr(self, r50)
    if is_error(r51) goto L37 (error at __init__:145) else goto L24
L24:
    r52 = cast(list, r51)
    if is_error(r52) goto L37 (error at __init__:145) else goto L25
L25:
    r53 = PyObject_Str(r52)
    dec_ref r52
    if is_error(r53) goto L37 (error at __init__:141) else goto L26
L26:
    r54 = CPyStr_Build(8, r31, r34, r35, r38, r39, r48, r49, r53)
    dec_ref r34
    dec_ref r38
    dec_ref r48
    dec_ref r53
    if is_error(r54) goto L31 (error at __init__:141) else goto L27
L27:
    r55 = [r54]
    r56 = load_address r55
    r57 = PyObject_Vectorcall(r30, r56, 1, 0)
    dec_ref r30
    if is_error(r57) goto L38 (error at __init__:140) else goto L39
L28:
    dec_ref r54
    return 1
L29:
    r58 = <error> :: None
    return r58
L30:
    dec_ref r5
    goto L29
L31:
    dec_ref r30
    goto L29
L32:
    dec_ref r30
    dec_ref r34
    goto L29
L33:
    dec_ref r30
    dec_ref r34
    dec_ref r38
    goto L29
L34:
    dec_ref r30
    dec_ref r34
    dec_ref r38
    dec_ref r40
    goto L29
L35:
    dec_ref r41
    goto L21
L36:
    dec_ref r30
    dec_ref r34
    dec_ref r38
    dec_ref r40
    dec_ref r41
    goto L29
L37:
    dec_ref r30
    dec_ref r34
    dec_ref r38
    dec_ref r48
    goto L29
L38:
    dec_ref r54
    goto L29
L39:
    dec_ref r57
    goto L28

def ChainstackRateLimitError.try_again_in(self):
    self :: dank_mids._exceptions.ChainstackRateLimitError
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: float
    r9 :: bit
    r10 :: object
    r11 :: float
L0:
    r0 = 'response'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L7 (error at try_again_in:168) else goto L1
L1:
    r2 = 'error'
    r3 = CPyObject_GetAttr(r1, r2)
    dec_ref r1
    if is_error(r3) goto L7 (error at try_again_in:168) else goto L2
L2:
    r4 = 'data'
    r5 = CPyObject_GetAttr(r3, r4)
    dec_ref r3
    if is_error(r5) goto L7 (error at try_again_in:168) else goto L3
L3:
    r6 = 'try_again_in'
    r7 = CPyObject_GetAttr(r5, r6)
    dec_ref r5
    if is_error(r7) goto L7 (error at try_again_in:168) else goto L4
L4:
    r8 = unbox(float, r7)
    dec_ref r7
    r9 = r8 == -113.0
    if r9 goto L6 else goto L5 :: bool
L5:
    return r8
L6:
    r10 = PyErr_Occurred()
    if not is_error(r10) goto L7 (error at try_again_in:168) else goto L5
L7:
    r11 = <error> :: float
    return r11

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5, r6 :: object_ptr
    r7 :: object_ptr[2]
    r8 :: c_ptr
    r9 :: native_int[2]
    r10 :: c_ptr
    r11 :: object
    r12 :: dict
    r13, r14 :: str
    r15 :: bit
    r16 :: object
    r17 :: str
    r18 :: dict
    r19, r20 :: object
    r21 :: str
    r22 :: dict
    r23 :: object
    r24 :: str
    r25 :: object
    r26 :: str
    r27 :: object
    r28 :: object[1]
    r29 :: object_ptr
    r30 :: object
    r31 :: dict
    r32 :: str
    r33 :: i32
    r34 :: bit
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: tuple
    r39 :: str
    r40, r41 :: object
    r42, r43 :: str
    r44 :: tuple
    r45 :: i32
    r46 :: bit
    r47 :: dict
    r48 :: str
    r49 :: i32
    r50 :: bit
    r51 :: object
    r52 :: str
    r53 :: object
    r54 :: tuple
    r55 :: str
    r56, r57 :: object
    r58, r59 :: str
    r60 :: tuple
    r61 :: i32
    r62 :: bit
    r63 :: dict
    r64 :: str
    r65 :: i32
    r66 :: bit
    r67 :: object
    r68 :: tuple
    r69 :: str
    r70, r71 :: object
    r72, r73 :: str
    r74 :: tuple
    r75 :: i32
    r76 :: bit
    r77 :: dict
    r78 :: str
    r79 :: i32
    r80 :: bit
    r81 :: object
    r82 :: tuple
    r83 :: str
    r84, r85 :: object
    r86, r87 :: str
    r88 :: tuple
    r89 :: i32
    r90 :: bit
    r91 :: dict
    r92 :: str
    r93 :: i32
    r94 :: bit
    r95 :: object
    r96 :: tuple
    r97 :: str
    r98, r99 :: object
    r100, r101 :: str
    r102 :: tuple
    r103 :: i32
    r104 :: bit
    r105 :: dict
    r106 :: str
    r107 :: i32
    r108 :: bit
    r109 :: object
    r110 :: tuple
    r111 :: str
    r112, r113 :: object
    r114, r115 :: str
    r116 :: tuple
    r117 :: i32
    r118 :: bit
    r119 :: dict
    r120 :: str
    r121 :: i32
    r122 :: bit
    r123 :: dict
    r124 :: str
    r125 :: object
    r126 :: tuple
    r127 :: str
    r128, r129 :: object
    r130 :: bool
    r131, r132, r133, r134 :: str
    r135 :: tuple
    r136 :: i32
    r137 :: bit
    r138 :: dict
    r139 :: str
    r140 :: i32
    r141 :: bit
    r142 :: dict
    r143 :: str
    r144, r145 :: object
    r146 :: str
    r147, r148 :: object
    r149 :: str
    r150, r151 :: object
    r152 :: str
    r153, r154 :: object
    r155 :: str
    r156, r157 :: object
    r158 :: str
    r159, r160 :: object
    r161 :: str
    r162 :: object
    r163 :: tuple[object, object, object, object, object, object]
    r164, r165 :: object
    r166 :: dict
    r167 :: str
    r168 :: i32
    r169 :: bit
    r170 :: dict
    r171 :: str
    r172 :: object
    r173 :: dict
    r174 :: str
    r175 :: i32
    r176 :: bit
    r177 :: object
    r178 :: str
    r179 :: object
    r180 :: tuple
    r181 :: str
    r182, r183 :: object
    r184, r185 :: str
    r186 :: tuple
    r187 :: i32
    r188 :: bit
    r189 :: dict
    r190 :: str
    r191 :: i32
    r192 :: bit
    r193 :: object
    r194 :: str
    r195 :: object
    r196 :: tuple
    r197 :: str
    r198, r199 :: object
    r200, r201 :: str
    r202 :: tuple
    r203 :: i32
    r204 :: bit
    r205 :: dict
    r206 :: str
    r207 :: i32
    r208 :: bit
    r209 :: object
    r210 :: tuple
    r211 :: str
    r212, r213 :: object
    r214, r215 :: str
    r216 :: tuple
    r217 :: i32
    r218 :: bit
    r219 :: dict
    r220 :: str
    r221 :: i32
    r222 :: bit
    r223 :: object
    r224 :: tuple
    r225 :: str
    r226, r227 :: object
    r228, r229 :: str
    r230 :: tuple
    r231 :: i32
    r232 :: bit
    r233 :: dict
    r234 :: str
    r235 :: i32
    r236 :: bit
    r237 :: object
    r238 :: tuple
    r239 :: str
    r240, r241 :: object
    r242, r243 :: str
    r244 :: tuple
    r245 :: i32
    r246 :: bit
    r247 :: dict
    r248 :: str
    r249 :: i32
    r250 :: bit
    r251 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L88 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address logging :: module
    r6 = load_address re :: module
    r7 = [r5, r6]
    r8 = load_address r7
    r9 = [1, 2]
    r10 = load_address r9
    r11 = (('logging', 'logging', 'logging'), ('re', 're', 're'))
    r12 = dank_mids._exceptions.globals :: static
    r13 = 'dank_mids/_exceptions.py'
    r14 = '<module>'
    r15 = CPyImport_ImportMany(r11, r8, r12, r13, r14, r10)
    if not r15 goto L88 else goto L4 :: bool
L4:
    r16 = ('TYPE_CHECKING', 'Final', 'List', 'Sequence', 'Union', 'final')
    r17 = 'typing'
    r18 = dank_mids._exceptions.globals :: static
    r19 = CPyImport_ImportFromMany(r17, r16, r16, r18)
    if is_error(r19) goto L88 (error at <module>:3) else goto L5
L5:
    typing = r19 :: module
    dec_ref r19
    r20 = ('ClientResponseError',)
    r21 = 'aiohttp.client_exceptions'
    r22 = dank_mids._exceptions.globals :: static
    r23 = CPyImport_ImportFromMany(r21, r20, r20, r22)
    if is_error(r23) goto L88 (error at <module>:5) else goto L6
L6:
    aiohttp.client_exceptions = r23 :: module
    dec_ref r23
    if 0 goto L7 else goto L7 :: bool
L7:
    r24 = 'dank_mids.exceptions'
    r25 = logging :: module
    r26 = 'getLogger'
    r27 = CPyObject_GetAttr(r25, r26)
    if is_error(r27) goto L88 (error at <module>:14) else goto L8
L8:
    r28 = [r24]
    r29 = load_address r28
    r30 = PyObject_Vectorcall(r27, r29, 1, 0)
    dec_ref r27
    if is_error(r30) goto L88 (error at <module>:14) else goto L9
L9:
    dank_mids._exceptions.logger = r30 :: static
    r31 = dank_mids._exceptions.globals :: static
    r32 = 'logger'
    r33 = CPyDict_SetItem(r31, r32, r30)
    dec_ref r30
    r34 = r33 >= 0 :: signed
    if not r34 goto L88 (error at <module>:14) else goto L10 :: bool
L10:
    r35 = builtins :: module
    r36 = 'ValueError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L88 (error at <module>:17) else goto L11
L11:
    r38 = PyTuple_Pack(1, r37)
    dec_ref r37
    if is_error(r38) goto L88 (error at <module>:17) else goto L12
L12:
    r39 = 'dank_mids._exceptions'
    r40 = dank_mids._exceptions.BadResponse_template :: type
    r41 = CPyType_FromTemplate(r40, r38, r39)
    dec_ref r38
    if is_error(r41) goto L88 (error at <module>:17) else goto L13
L13:
    r42 = '__mypyc_attrs__'
    r43 = '__dict__'
    r44 = PyTuple_Pack(1, r43)
    if is_error(r44) goto L89 (error at <module>:17) else goto L14
L14:
    r45 = PyObject_SetAttr(r41, r42, r44)
    dec_ref r44
    r46 = r45 >= 0 :: signed
    if not r46 goto L89 (error at <module>:17) else goto L15 :: bool
L15:
    dank_mids._exceptions.BadResponse = r41 :: type
    r47 = dank_mids._exceptions.globals :: static
    r48 = 'BadResponse'
    r49 = CPyDict_SetItem(r47, r48, r41)
    dec_ref r41
    r50 = r49 >= 0 :: signed
    if not r50 goto L88 (error at <module>:17) else goto L16 :: bool
L16:
    r51 = builtins :: module
    r52 = 'ValueError'
    r53 = CPyObject_GetAttr(r51, r52)
    if is_error(r53) goto L88 (error at <module>:26) else goto L17
L17:
    r54 = PyTuple_Pack(1, r53)
    dec_ref r53
    if is_error(r54) goto L88 (error at <module>:26) else goto L18
L18:
    r55 = 'dank_mids._exceptions'
    r56 = dank_mids._exceptions.EmptyBatch_template :: type
    r57 = CPyType_FromTemplate(r56, r54, r55)
    dec_ref r54
    if is_error(r57) goto L88 (error at <module>:26) else goto L19
L19:
    r58 = '__mypyc_attrs__'
    r59 = '__dict__'
    r60 = PyTuple_Pack(1, r59)
    if is_error(r60) goto L90 (error at <module>:26) else goto L20
L20:
    r61 = PyObject_SetAttr(r57, r58, r60)
    dec_ref r60
    r62 = r61 >= 0 :: signed
    if not r62 goto L90 (error at <module>:26) else goto L21 :: bool
L21:
    dank_mids._exceptions.EmptyBatch = r57 :: type
    r63 = dank_mids._exceptions.globals :: static
    r64 = 'EmptyBatch'
    r65 = CPyDict_SetItem(r63, r64, r57)
    dec_ref r57
    r66 = r65 >= 0 :: signed
    if not r66 goto L88 (error at <module>:26) else goto L22 :: bool
L22:
    r67 = dank_mids._exceptions.BadResponse :: type
    r68 = PyTuple_Pack(1, r67)
    if is_error(r68) goto L88 (error at <module>:31) else goto L23
L23:
    r69 = 'dank_mids._exceptions'
    r70 = dank_mids._exceptions.ExecutionReverted_template :: type
    r71 = CPyType_FromTemplate(r70, r68, r69)
    dec_ref r68
    if is_error(r71) goto L88 (error at <module>:31) else goto L24
L24:
    r72 = '__mypyc_attrs__'
    r73 = '__dict__'
    r74 = PyTuple_Pack(1, r73)
    if is_error(r74) goto L91 (error at <module>:31) else goto L25
L25:
    r75 = PyObject_SetAttr(r71, r72, r74)
    dec_ref r74
    r76 = r75 >= 0 :: signed
    if not r76 goto L91 (error at <module>:31) else goto L26 :: bool
L26:
    dank_mids._exceptions.ExecutionReverted = r71 :: type
    r77 = dank_mids._exceptions.globals :: static
    r78 = 'ExecutionReverted'
    r79 = CPyDict_SetItem(r77, r78, r71)
    dec_ref r71
    r80 = r79 >= 0 :: signed
    if not r80 goto L88 (error at <module>:31) else goto L27 :: bool
L27:
    r81 = dank_mids._exceptions.BadResponse :: type
    r82 = PyTuple_Pack(1, r81)
    if is_error(r82) goto L88 (error at <module>:43) else goto L28
L28:
    r83 = 'dank_mids._exceptions'
    r84 = dank_mids._exceptions.OutOfGas_template :: type
    r85 = CPyType_FromTemplate(r84, r82, r83)
    dec_ref r82
    if is_error(r85) goto L88 (error at <module>:43) else goto L29
L29:
    r86 = '__mypyc_attrs__'
    r87 = '__dict__'
    r88 = PyTuple_Pack(1, r87)
    if is_error(r88) goto L92 (error at <module>:43) else goto L30
L30:
    r89 = PyObject_SetAttr(r85, r86, r88)
    dec_ref r88
    r90 = r89 >= 0 :: signed
    if not r90 goto L92 (error at <module>:43) else goto L31 :: bool
L31:
    dank_mids._exceptions.OutOfGas = r85 :: type
    r91 = dank_mids._exceptions.globals :: static
    r92 = 'OutOfGas'
    r93 = CPyDict_SetItem(r91, r92, r85)
    dec_ref r85
    r94 = r93 >= 0 :: signed
    if not r94 goto L88 (error at <module>:43) else goto L32 :: bool
L32:
    r95 = dank_mids._exceptions.BadResponse :: type
    r96 = PyTuple_Pack(1, r95)
    if is_error(r96) goto L88 (error at <module>:48) else goto L33
L33:
    r97 = 'dank_mids._exceptions'
    r98 = dank_mids._exceptions.PayloadTooLarge_template :: type
    r99 = CPyType_FromTemplate(r98, r96, r97)
    dec_ref r96
    if is_error(r99) goto L88 (error at <module>:48) else goto L34
L34:
    r100 = '__mypyc_attrs__'
    r101 = '__dict__'
    r102 = PyTuple_Pack(1, r101)
    if is_error(r102) goto L93 (error at <module>:48) else goto L35
L35:
    r103 = PyObject_SetAttr(r99, r100, r102)
    dec_ref r102
    r104 = r103 >= 0 :: signed
    if not r104 goto L93 (error at <module>:48) else goto L36 :: bool
L36:
    dank_mids._exceptions.PayloadTooLarge = r99 :: type
    r105 = dank_mids._exceptions.globals :: static
    r106 = 'PayloadTooLarge'
    r107 = CPyDict_SetItem(r105, r106, r99)
    dec_ref r99
    r108 = r107 >= 0 :: signed
    if not r108 goto L88 (error at <module>:48) else goto L37 :: bool
L37:
    r109 = dank_mids._exceptions.BadResponse :: type
    r110 = PyTuple_Pack(1, r109)
    if is_error(r110) goto L88 (error at <module>:53) else goto L38
L38:
    r111 = 'dank_mids._exceptions'
    r112 = dank_mids._exceptions.ExceedsMaxBatchSize_template :: type
    r113 = CPyType_FromTemplate(r112, r110, r111)
    dec_ref r110
    if is_error(r113) goto L88 (error at <module>:53) else goto L39
L39:
    r114 = '__mypyc_attrs__'
    r115 = '__dict__'
    r116 = PyTuple_Pack(1, r115)
    if is_error(r116) goto L94 (error at <module>:53) else goto L40
L40:
    r117 = PyObject_SetAttr(r113, r114, r116)
    dec_ref r116
    r118 = r117 >= 0 :: signed
    if not r118 goto L94 (error at <module>:53) else goto L41 :: bool
L41:
    dank_mids._exceptions.ExceedsMaxBatchSize = r113 :: type
    r119 = dank_mids._exceptions.globals :: static
    r120 = 'ExceedsMaxBatchSize'
    r121 = CPyDict_SetItem(r119, r120, r113)
    dec_ref r113
    r122 = r121 >= 0 :: signed
    if not r122 goto L88 (error at <module>:53) else goto L42 :: bool
L42:
    r123 = dank_mids._exceptions.globals :: static
    r124 = 'ClientResponseError'
    r125 = CPyDict_GetItem(r123, r124)
    if is_error(r125) goto L88 (error at <module>:63) else goto L43
L43:
    r126 = PyTuple_Pack(1, r125)
    dec_ref r125
    if is_error(r126) goto L88 (error at <module>:63) else goto L44
L44:
    r127 = 'dank_mids._exceptions'
    r128 = dank_mids._exceptions.DankMidsClientResponseError_template :: type
    r129 = CPyType_FromTemplate(r128, r126, r127)
    dec_ref r126
    if is_error(r129) goto L88 (error at <module>:63) else goto L45
L45:
    r130 = DankMidsClientResponseError_trait_vtable_setup()
    if is_error(r130) goto L95 (error at <module>:-1) else goto L46
L46:
    r131 = '__mypyc_attrs__'
    r132 = 'request'
    r133 = 'args'
    r134 = '_exception'
    r135 = PyTuple_Pack(3, r132, r133, r134)
    if is_error(r135) goto L95 (error at <module>:63) else goto L47
L47:
    r136 = PyObject_SetAttr(r129, r131, r135)
    dec_ref r135
    r137 = r136 >= 0 :: signed
    if not r137 goto L95 (error at <module>:63) else goto L48 :: bool
L48:
    dank_mids._exceptions.DankMidsClientResponseError = r129 :: type
    r138 = dank_mids._exceptions.globals :: static
    r139 = 'DankMidsClientResponseError'
    r140 = CPyDict_SetItem(r138, r139, r129)
    dec_ref r129
    r141 = r140 >= 0 :: signed
    if not r141 goto L88 (error at <module>:63) else goto L49 :: bool
L49:
    r142 = dank_mids._exceptions.globals :: static
    r143 = 'Union'
    r144 = CPyDict_GetItem(r142, r143)
    if is_error(r144) goto L88 (error at <module>:94) else goto L50
L50:
    r145 = builtins :: module
    r146 = 'AttributeError'
    r147 = CPyObject_GetAttr(r145, r146)
    if is_error(r147) goto L96 (error at <module>:95) else goto L51
L51:
    r148 = builtins :: module
    r149 = 'TypeError'
    r150 = CPyObject_GetAttr(r148, r149)
    if is_error(r150) goto L97 (error at <module>:95) else goto L52
L52:
    r151 = builtins :: module
    r152 = 'UnboundLocalError'
    r153 = CPyObject_GetAttr(r151, r152)
    if is_error(r153) goto L98 (error at <module>:95) else goto L53
L53:
    r154 = builtins :: module
    r155 = 'NotImplementedError'
    r156 = CPyObject_GetAttr(r154, r155)
    if is_error(r156) goto L99 (error at <module>:95) else goto L54
L54:
    r157 = builtins :: module
    r158 = 'RuntimeError'
    r159 = CPyObject_GetAttr(r157, r158)
    if is_error(r159) goto L100 (error at <module>:95) else goto L55
L55:
    r160 = builtins :: module
    r161 = 'SyntaxError'
    r162 = CPyObject_GetAttr(r160, r161)
    if is_error(r162) goto L101 (error at <module>:95) else goto L56
L56:
    r163 = (r147, r150, r153, r156, r159, r162)
    r164 = box(tuple[object, object, object, object, object, object], r163)
    r165 = PyObject_GetItem(r144, r164)
    dec_ref r144
    dec_ref r164
    if is_error(r165) goto L88 (error at <module>:94) else goto L57
L57:
    r166 = dank_mids._exceptions.globals :: static
    r167 = '_internal_err_types'
    r168 = CPyDict_SetItem(r166, r167, r165)
    dec_ref r165
    r169 = r168 >= 0 :: signed
    if not r169 goto L88 (error at <module>:94) else goto L58 :: bool
L58:
    r170 = dank_mids._exceptions.globals :: static
    r171 = '_internal_err_types'
    r172 = CPyDict_GetItem(r170, r171)
    if is_error(r172) goto L88 (error at <module>:97) else goto L59
L59:
    dank_mids._exceptions.internal_err_types = r172 :: static
    r173 = dank_mids._exceptions.globals :: static
    r174 = 'internal_err_types'
    r175 = CPyDict_SetItem(r173, r174, r172)
    dec_ref r172
    r176 = r175 >= 0 :: signed
    if not r176 goto L88 (error at <module>:97) else goto L60 :: bool
L60:
    r177 = builtins :: module
    r178 = 'Exception'
    r179 = CPyObject_GetAttr(r177, r178)
    if is_error(r179) goto L88 (error at <module>:100) else goto L61
L61:
    r180 = PyTuple_Pack(1, r179)
    dec_ref r179
    if is_error(r180) goto L88 (error at <module>:100) else goto L62
L62:
    r181 = 'dank_mids._exceptions'
    r182 = dank_mids._exceptions.DankMidsInternalError_template :: type
    r183 = CPyType_FromTemplate(r182, r180, r181)
    dec_ref r180
    if is_error(r183) goto L88 (error at <module>:100) else goto L63
L63:
    r184 = '__mypyc_attrs__'
    r185 = '__dict__'
    r186 = PyTuple_Pack(1, r185)
    if is_error(r186) goto L102 (error at <module>:100) else goto L64
L64:
    r187 = PyObject_SetAttr(r183, r184, r186)
    dec_ref r186
    r188 = r187 >= 0 :: signed
    if not r188 goto L102 (error at <module>:100) else goto L65 :: bool
L65:
    dank_mids._exceptions.DankMidsInternalError = r183 :: type
    r189 = dank_mids._exceptions.globals :: static
    r190 = 'DankMidsInternalError'
    r191 = CPyDict_SetItem(r189, r190, r183)
    dec_ref r183
    r192 = r191 >= 0 :: signed
    if not r192 goto L88 (error at <module>:100) else goto L66 :: bool
L66:
    r193 = builtins :: module
    r194 = 'Exception'
    r195 = CPyObject_GetAttr(r193, r194)
    if is_error(r195) goto L88 (error at <module>:116) else goto L67
L67:
    r196 = PyTuple_Pack(1, r195)
    dec_ref r195
    if is_error(r196) goto L88 (error at <module>:116) else goto L68
L68:
    r197 = 'dank_mids._exceptions'
    r198 = dank_mids._exceptions.BatchResponseSortError_template :: type
    r199 = CPyType_FromTemplate(r198, r196, r197)
    dec_ref r196
    if is_error(r199) goto L88 (error at <module>:116) else goto L69
L69:
    r200 = '__mypyc_attrs__'
    r201 = '__dict__'
    r202 = PyTuple_Pack(1, r201)
    if is_error(r202) goto L103 (error at <module>:116) else goto L70
L70:
    r203 = PyObject_SetAttr(r199, r200, r202)
    dec_ref r202
    r204 = r203 >= 0 :: signed
    if not r204 goto L103 (error at <module>:116) else goto L71 :: bool
L71:
    dank_mids._exceptions.BatchResponseSortError = r199 :: type
    r205 = dank_mids._exceptions.globals :: static
    r206 = 'BatchResponseSortError'
    r207 = CPyDict_SetItem(r205, r206, r199)
    dec_ref r199
    r208 = r207 >= 0 :: signed
    if not r208 goto L88 (error at <module>:116) else goto L72 :: bool
L72:
    r209 = dank_mids._exceptions.BadResponse :: type
    r210 = PyTuple_Pack(1, r209)
    if is_error(r210) goto L88 (error at <module>:149) else goto L73
L73:
    r211 = 'dank_mids._exceptions'
    r212 = dank_mids._exceptions.RateLimitError_template :: type
    r213 = CPyType_FromTemplate(r212, r210, r211)
    dec_ref r210
    if is_error(r213) goto L88 (error at <module>:149) else goto L74
L74:
    r214 = '__mypyc_attrs__'
    r215 = '__dict__'
    r216 = PyTuple_Pack(1, r215)
    if is_error(r216) goto L104 (error at <module>:149) else goto L75
L75:
    r217 = PyObject_SetAttr(r213, r214, r216)
    dec_ref r216
    r218 = r217 >= 0 :: signed
    if not r218 goto L104 (error at <module>:149) else goto L76 :: bool
L76:
    dank_mids._exceptions.RateLimitError = r213 :: type
    r219 = dank_mids._exceptions.globals :: static
    r220 = 'RateLimitError'
    r221 = CPyDict_SetItem(r219, r220, r213)
    dec_ref r213
    r222 = r221 >= 0 :: signed
    if not r222 goto L88 (error at <module>:149) else goto L77 :: bool
L77:
    r223 = dank_mids._exceptions.RateLimitError :: type
    r224 = PyTuple_Pack(1, r223)
    if is_error(r224) goto L88 (error at <module>:153) else goto L78
L78:
    r225 = 'dank_mids._exceptions'
    r226 = dank_mids._exceptions.ChainstackRateLimitError_template :: type
    r227 = CPyType_FromTemplate(r226, r224, r225)
    dec_ref r224
    if is_error(r227) goto L88 (error at <module>:153) else goto L79
L79:
    r228 = '__mypyc_attrs__'
    r229 = '__dict__'
    r230 = PyTuple_Pack(1, r229)
    if is_error(r230) goto L105 (error at <module>:153) else goto L80
L80:
    r231 = PyObject_SetAttr(r227, r228, r230)
    dec_ref r230
    r232 = r231 >= 0 :: signed
    if not r232 goto L105 (error at <module>:153) else goto L81 :: bool
L81:
    dank_mids._exceptions.ChainstackRateLimitError = r227 :: type
    r233 = dank_mids._exceptions.globals :: static
    r234 = 'ChainstackRateLimitError'
    r235 = CPyDict_SetItem(r233, r234, r227)
    dec_ref r227
    r236 = r235 >= 0 :: signed
    if not r236 goto L88 (error at <module>:153) else goto L82 :: bool
L82:
    r237 = dank_mids._exceptions.RateLimitError :: type
    r238 = PyTuple_Pack(1, r237)
    if is_error(r238) goto L88 (error at <module>:172) else goto L83
L83:
    r239 = 'dank_mids._exceptions'
    r240 = dank_mids._exceptions.QuiknodeRateLimitError_template :: type
    r241 = CPyType_FromTemplate(r240, r238, r239)
    dec_ref r238
    if is_error(r241) goto L88 (error at <module>:172) else goto L84
L84:
    r242 = '__mypyc_attrs__'
    r243 = '__dict__'
    r244 = PyTuple_Pack(1, r243)
    if is_error(r244) goto L106 (error at <module>:172) else goto L85
L85:
    r245 = PyObject_SetAttr(r241, r242, r244)
    dec_ref r244
    r246 = r245 >= 0 :: signed
    if not r246 goto L106 (error at <module>:172) else goto L86 :: bool
L86:
    dank_mids._exceptions.QuiknodeRateLimitError = r241 :: type
    r247 = dank_mids._exceptions.globals :: static
    r248 = 'QuiknodeRateLimitError'
    r249 = CPyDict_SetItem(r247, r248, r241)
    dec_ref r241
    r250 = r249 >= 0 :: signed
    if not r250 goto L88 (error at <module>:172) else goto L87 :: bool
L87:
    return 1
L88:
    r251 = <error> :: None
    return r251
L89:
    dec_ref r41
    goto L88
L90:
    dec_ref r57
    goto L88
L91:
    dec_ref r71
    goto L88
L92:
    dec_ref r85
    goto L88
L93:
    dec_ref r99
    goto L88
L94:
    dec_ref r113
    goto L88
L95:
    dec_ref r129
    goto L88
L96:
    dec_ref r144
    goto L88
L97:
    dec_ref r144
    dec_ref r147
    goto L88
L98:
    dec_ref r144
    dec_ref r147
    dec_ref r150
    goto L88
L99:
    dec_ref r144
    dec_ref r147
    dec_ref r150
    dec_ref r153
    goto L88
L100:
    dec_ref r144
    dec_ref r147
    dec_ref r150
    dec_ref r153
    dec_ref r156
    goto L88
L101:
    dec_ref r144
    dec_ref r147
    dec_ref r150
    dec_ref r153
    dec_ref r156
    dec_ref r159
    goto L88
L102:
    dec_ref r183
    goto L88
L103:
    dec_ref r199
    goto L88
L104:
    dec_ref r213
    goto L88
L105:
    dec_ref r227
    goto L88
L106:
    dec_ref r241
    goto L88

def error_logger_log_debug(msg, args):
    msg :: str
    args :: tuple
    r0 :: int
    r1 :: bool
    r2 :: object
    r3 :: bool
    r4 :: object
    r5 :: object[3]
    r6 :: object_ptr
    r7 :: object
    r8 :: None
L0:
    r0 = dank_mids._logging.DEBUG :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "DEBUG" was not set')
    if not r1 goto L8 (error at error_logger_log_debug:21) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = dank_mids.helpers._errors.error_logger_log :: static
    if is_error(r2) goto L4 else goto L6
L4:
    r3 = raise NameError('value for final name "error_logger_log" was not set')
    if not r3 goto L8 (error at error_logger_log_debug:21) else goto L5 :: bool
L5:
    unreachable
L6:
    inc_ref r0 :: int
    r4 = box(int, r0)
    r5 = [r4, msg, args]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r2, r6, 3, 0)
    if is_error(r7) goto L9 (error at error_logger_log_debug:21) else goto L10
L7:
    dec_ref r4
    return 1
L8:
    r8 = <error> :: None
    return r8
L9:
    dec_ref r4
    goto L8
L10:
    dec_ref r7
    goto L7

def revert_logger_log_debug(msg, args):
    msg :: str
    args :: tuple
    r0 :: int
    r1 :: bool
    r2 :: object
    r3 :: bool
    r4 :: object
    r5 :: object[3]
    r6 :: object_ptr
    r7 :: object
    r8 :: None
L0:
    r0 = dank_mids._logging.DEBUG :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "DEBUG" was not set')
    if not r1 goto L8 (error at revert_logger_log_debug:29) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = dank_mids.helpers._errors.revert_logger_log :: static
    if is_error(r2) goto L4 else goto L6
L4:
    r3 = raise NameError('value for final name "revert_logger_log" was not set')
    if not r3 goto L8 (error at revert_logger_log_debug:29) else goto L5 :: bool
L5:
    unreachable
L6:
    inc_ref r0 :: int
    r4 = box(int, r0)
    r5 = [r4, msg, args]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r2, r6, 3, 0)
    if is_error(r7) goto L9 (error at revert_logger_log_debug:29) else goto L10
L7:
    dec_ref r4
    return 1
L8:
    r8 = <error> :: None
    return r8
L9:
    dec_ref r4
    goto L8
L10:
    dec_ref r7
    goto L7

def log_internal_error(logger, batch, exc):
    logger, batch, exc :: object
    r0, batch_objs :: list
    r1 :: tuple[object, object, object]
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: bit
    r6 :: dict
    r7 :: str
    r8 :: object
    r9 :: i32
    r10 :: bit
    r11 :: bool
    r12 :: list
    r13, r14 :: ptr
    r15 :: bit
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: str
    r21 :: ptr
    r22 :: native_int
    r23 :: short_int
    r24 :: object
    r25 :: str
    r26 :: object
    r27, r28 :: str
    r29, r30 :: object
    r31 :: object[8]
    r32 :: object_ptr
    r33, r34 :: object
    r35 :: None
L0:
L1:
    r0 = PySequence_List(batch)
    if is_error(r0) goto L3 (error at log_internal_error:51) else goto L2
L2:
    batch_objs = r0
    goto L16
L3:
    r1 = CPy_CatchError()
    r2 = builtins :: module
    r3 = 'TypeError'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L14 (error at log_internal_error:52) else goto L4
L4:
    r5 = CPy_ExceptionMatches(r4)
    dec_ref r4
    if r5 goto L5 else goto L11 :: bool
L5:
    r6 = dank_mids.helpers._errors.globals :: static
    r7 = 'ContractLogicError'
    r8 = CPyDict_GetItem(r6, r7)
    if is_error(r8) goto L14 (error at log_internal_error:54) else goto L6
L6:
    r9 = PyObject_IsInstance(exc, r8)
    dec_ref r8
    r10 = r9 >= 0 :: signed
    if not r10 goto L14 (error at log_internal_error:54) else goto L7 :: bool
L7:
    r11 = truncate r9: i32 to builtins.bool
    if r11 goto L8 else goto L9 :: bool
L8:
    CPy_RestoreExcInfo(r1)
    dec_ref r1
    return 1
L9:
    r12 = PyList_New(1)
    if is_error(r12) goto L14 (error at log_internal_error:57) else goto L10
L10:
    r13 = get_element_ptr r12 ob_item :: PyListObject
    r14 = load_mem r13 :: ptr*
    inc_ref batch
    set_mem r14, batch :: builtins.object*
    batch_objs = r12
    goto L13
L11:
    CPy_Reraise()
    if not 0 goto L14 else goto L23 :: bool
L12:
    unreachable
L13:
    CPy_RestoreExcInfo(r1)
    dec_ref r1
    goto L16
L14:
    CPy_RestoreExcInfo(r1)
    dec_ref r1
    r15 = CPy_KeepPropagating()
    if not r15 goto L22 else goto L15 :: bool
L15:
    unreachable
L16:
    r16 = "That's not good, there was an exception in a %s (len=%s). These are supposed to be handled.\nExc: %s\n%s contents: %s\n\n"
    r17 = PyObject_Type(batch)
    r18 = '__name__'
    r19 = CPyObject_GetAttr(r17, r18)
    dec_ref r17
    if is_error(r19) goto L24 (error at log_internal_error:62) else goto L17
L17:
    r20 = cast(str, r19)
    if is_error(r20) goto L24 (error at log_internal_error:62) else goto L18
L18:
    r21 = get_element_ptr batch_objs ob_size :: PyVarObject
    r22 = load_mem r21 :: native_int*
    r23 = r22 << 1
    r24 = PyObject_Type(batch)
    r25 = '__name__'
    r26 = CPyObject_GetAttr(r24, r25)
    dec_ref r24
    if is_error(r26) goto L25 (error at log_internal_error:65) else goto L19
L19:
    r27 = cast(str, r26)
    if is_error(r27) goto L25 (error at log_internal_error:65) else goto L20
L20:
    r28 = 'error'
    r29 = box(short_int, r23)
    r30 = box(bool, 1)
    r31 = [logger, r16, r20, r29, exc, r27, batch_objs, r30]
    r32 = load_address r31
    r33 = ('exc_info',)
    r34 = PyObject_VectorcallMethod(r28, r32, 9223372036854775815, r33)
    if is_error(r34) goto L26 (error at log_internal_error:58) else goto L27
L21:
    dec_ref r20
    dec_ref r29
    dec_ref r27
    dec_ref batch_objs
    return 1
L22:
    r35 = <error> :: None
    return r35
L23:
    dec_ref r1
    goto L12
L24:
    dec_ref batch_objs
    goto L22
L25:
    dec_ref batch_objs
    dec_ref r20
    goto L22
L26:
    dec_ref batch_objs
    dec_ref r20
    dec_ref r27
    dec_ref r29
    goto L22
L27:
    dec_ref r34
    goto L21

def needs_full_request_spec(response):
    response :: object
    r0 :: str
    r1, r2 :: object
    r3 :: bit
    r4 :: bool
    r5 :: str
    r6 :: object
    r7 :: str
    r8 :: object
    r9, r10 :: str
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14, r15 :: str
    r16, r17 :: bool
    r18 :: str
    r19 :: object
    r20 :: str
    r21 :: object
    r22, r23 :: str
    r24 :: object[1]
    r25 :: object_ptr
    r26 :: object
    r27, r28 :: str
    r29, r30 :: bool
L0:
    r0 = 'error'
    r1 = CPyObject_GetAttr(response, r0)
    if is_error(r1) goto L18 (error at needs_full_request_spec:84) else goto L1
L1:
    r2 = load_address _Py_NoneStruct
    r3 = r1 != r2
    dec_ref r1
    if r3 goto L3 else goto L2 :: bool
L2:
    r4 = r3
    goto L17
L3:
    r5 = 'error'
    r6 = CPyObject_GetAttr(response, r5)
    if is_error(r6) goto L18 (error at needs_full_request_spec:84) else goto L4
L4:
    r7 = 'message'
    r8 = CPyObject_GetAttr(r6, r7)
    dec_ref r6
    if is_error(r8) goto L18 (error at needs_full_request_spec:84) else goto L5
L5:
    r9 = cast(str, r8)
    if is_error(r9) goto L18 (error at needs_full_request_spec:84) else goto L6
L6:
    r10 = 'lower'
    r11 = [r9]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775809, 0)
    if is_error(r13) goto L19 (error at needs_full_request_spec:84) else goto L7
L7:
    dec_ref r9
    r14 = cast(str, r13)
    if is_error(r14) goto L18 (error at needs_full_request_spec:84) else goto L8
L8:
    r15 = 'invalid request'
    r16 = CPyStr_Equal(r14, r15)
    dec_ref r14
    if r16 goto L9 else goto L10 :: bool
L9:
    r17 = r16
    goto L16
L10:
    r18 = 'error'
    r19 = CPyObject_GetAttr(response, r18)
    if is_error(r19) goto L18 (error at needs_full_request_spec:84) else goto L11
L11:
    r20 = 'message'
    r21 = CPyObject_GetAttr(r19, r20)
    dec_ref r19
    if is_error(r21) goto L18 (error at needs_full_request_spec:84) else goto L12
L12:
    r22 = cast(str, r21)
    if is_error(r22) goto L18 (error at needs_full_request_spec:84) else goto L13
L13:
    r23 = 'lower'
    r24 = [r22]
    r25 = load_address r24
    r26 = PyObject_VectorcallMethod(r23, r25, 9223372036854775809, 0)
    if is_error(r26) goto L20 (error at needs_full_request_spec:84) else goto L14
L14:
    dec_ref r22
    r27 = cast(str, r26)
    if is_error(r27) goto L18 (error at needs_full_request_spec:84) else goto L15
L15:
    r28 = 'parse error'
    r29 = CPyStr_Equal(r27, r28)
    dec_ref r27
    r17 = r29
L16:
    r4 = r17
L17:
    return r4
L18:
    r30 = <error> :: bool
    return r30
L19:
    dec_ref r9
    goto L18
L20:
    dec_ref r22
    goto L18

def is_call_revert(e):
    e :: dank_mids._exceptions.BadResponse
    r0, r1, r2 :: str
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: str
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: bool
    r13 :: set
    r14 :: bool
    r15, r16 :: object
    r17 :: str
    r18 :: i32
    r19 :: bit
    r20 :: bool
    r21 :: bit
    r22 :: bool
L0:
    r0 = '{:{}}'
    r1 = ''
    r2 = 'format'
    r3 = [r0, e, r1]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r2, r4, 9223372036854775811, 0)
    if is_error(r5) goto L15 (error at is_call_revert:100) else goto L1
L1:
    r6 = cast(str, r5)
    if is_error(r6) goto L15 (error at is_call_revert:100) else goto L2
L2:
    r7 = 'lower'
    r8 = [r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775809, 0)
    if is_error(r10) goto L16 (error at is_call_revert:100) else goto L3
L3:
    dec_ref r6
    r11 = cast(str, r10)
    if is_error(r11) goto L15 (error at is_call_revert:100) else goto L4
L4:
    r12 = 0
    r13 = dank_mids.helpers._errors.INDIVIDUAL_CALL_REVERT_STRINGS :: static
    if is_error(r13) goto L17 else goto L7
L5:
    r14 = raise NameError('value for final name "INDIVIDUAL_CALL_REVERT_STRINGS" was not set')
    if not r14 goto L15 (error at is_call_revert:101) else goto L6 :: bool
L6:
    unreachable
L7:
    r15 = PyObject_GetIter(r13)
    if is_error(r15) goto L18 (error at is_call_revert:101) else goto L8
L8:
    r16 = PyIter_Next(r15)
    if is_error(r16) goto L19 else goto L9
L9:
    r17 = cast(str, r16)
    if is_error(r17) goto L20 (error at is_call_revert:101) else goto L10
L10:
    r18 = PyUnicode_Contains(r11, r17)
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L20 (error at is_call_revert:101) else goto L11 :: bool
L11:
    r20 = truncate r18: i32 to builtins.bool
    if r20 goto L21 else goto L8 :: bool
L12:
    r12 = 1
    goto L14
L13:
    r21 = CPy_NoErrOccurred()
    if not r21 goto L15 (error at is_call_revert:101) else goto L14 :: bool
L14:
    return r12
L15:
    r22 = <error> :: bool
    return r22
L16:
    dec_ref r6
    goto L15
L17:
    dec_ref r11
    goto L5
L18:
    dec_ref r11
    goto L15
L19:
    dec_ref r11
    dec_ref r15
    goto L13
L20:
    dec_ref r11
    dec_ref r15
    goto L15
L21:
    dec_ref r11
    dec_ref r15
    goto L12

def is_revert_bytes(data):
    data :: object
    r0 :: bit
    r1, r2 :: bool
    r3 :: tuple[bytes, bytes]
    r4 :: bool
    r5, r6, r7 :: object
    r8, r9 :: bytes
    r10 :: str
    r11 :: object[2]
    r12 :: object_ptr
    r13 :: object
    r14 :: bool
    r15 :: bit
    r16 :: bool
L0:
    r0 = PyBytes_Check(data)
    if r0 goto L2 else goto L1 :: bool
L1:
    r1 = r0
    goto L15
L2:
    r2 = 0
    r3 = dank_mids.constants.REVERT_SELECTORS :: static
    if is_error(r3) goto L3 else goto L5
L3:
    r4 = raise NameError('value for final name "REVERT_SELECTORS" was not set')
    if not r4 goto L16 (error at is_revert_bytes:115) else goto L4 :: bool
L4:
    unreachable
L5:
    inc_ref r3
    r5 = box(tuple[bytes, bytes], r3)
    r6 = PyObject_GetIter(r5)
    dec_ref r5
    if is_error(r6) goto L16 (error at is_revert_bytes:114) else goto L6
L6:
    r7 = PyIter_Next(r6)
    if is_error(r7) goto L17 else goto L7
L7:
    r8 = cast(bytes, r7)
    if is_error(r8) goto L18 (error at is_revert_bytes:114) else goto L8
L8:
    inc_ref data
    r9 = cast(bytes, data)
    if is_error(r9) goto L19 (error at is_revert_bytes:115) else goto L9
L9:
    r10 = 'startswith'
    r11 = [r9, r8]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775810, 0)
    if is_error(r13) goto L20 (error at is_revert_bytes:115) else goto L10
L10:
    dec_ref r9
    dec_ref r8
    r14 = unbox(bool, r13)
    dec_ref r13
    if is_error(r14) goto L18 (error at is_revert_bytes:115) else goto L11
L11:
    if r14 goto L21 else goto L6 :: bool
L12:
    r2 = 1
    goto L14
L13:
    r15 = CPy_NoErrOccurred()
    if not r15 goto L16 (error at is_revert_bytes:114) else goto L14 :: bool
L14:
    r1 = r2
L15:
    return r1
L16:
    r16 = <error> :: bool
    return r16
L17:
    dec_ref r6
    goto L13
L18:
    dec_ref r6
    goto L16
L19:
    dec_ref r6
    dec_ref r8
    goto L16
L20:
    dec_ref r6
    dec_ref r8
    dec_ref r9
    goto L16
L21:
    dec_ref r6
    goto L12

def log_request_type_switch():
    r0 :: str
    r1 :: object
    r2 :: bool
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: None
L0:
    r0 = 'your node says the partial request was invalid but its okay, we can use the full jsonrpc spec instead'
    r1 = dank_mids.helpers._errors.error_logger_debug :: static
    if is_error(r1) goto L1 else goto L3
L1:
    r2 = raise NameError('value for final name "error_logger_debug" was not set')
    if not r2 goto L5 (error at log_request_type_switch:120) else goto L2 :: bool
L2:
    unreachable
L3:
    r3 = [r0]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r1, r4, 1, 0)
    if is_error(r5) goto L5 (error at log_request_type_switch:120) else goto L6
L4:
    return 1
L5:
    r6 = <error> :: None
    return r6
L6:
    dec_ref r5
    goto L4

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24, r25 :: object
    r26 :: str
    r27 :: dict
    r28, r29 :: object
    r30 :: str
    r31 :: dict
    r32 :: object
    r33 :: str
    r34 :: object
    r35 :: bool
    r36 :: object[1]
    r37 :: object_ptr
    r38 :: object
    r39 :: dict
    r40 :: str
    r41 :: i32
    r42 :: bit
    r43 :: object
    r44 :: bool
    r45 :: str
    r46 :: object
    r47 :: dict
    r48 :: str
    r49 :: i32
    r50 :: bit
    r51 :: object
    r52 :: bool
    r53 :: str
    r54 :: object
    r55 :: dict
    r56 :: str
    r57 :: i32
    r58 :: bit
    r59 :: object
    r60 :: bool
    r61, r62 :: str
    r63 :: object[2]
    r64 :: object_ptr
    r65 :: object
    r66 :: dict
    r67 :: str
    r68 :: i32
    r69 :: bit
    r70 :: object
    r71 :: bool
    r72 :: str
    r73 :: object
    r74 :: dict
    r75 :: str
    r76 :: i32
    r77 :: bit
    r78 :: object
    r79 :: bool
    r80, r81 :: str
    r82 :: object[2]
    r83 :: object_ptr
    r84 :: object
    r85 :: dict
    r86 :: str
    r87 :: i32
    r88 :: bit
    r89 :: object
    r90 :: bool
    r91 :: str
    r92 :: object
    r93 :: dict
    r94 :: str
    r95 :: i32
    r96 :: bit
    r97 :: object
    r98 :: bool
    r99 :: str
    r100 :: object
    r101 :: dict
    r102 :: str
    r103 :: i32
    r104 :: bit
    r105 :: object
    r106 :: bool
    r107, r108 :: str
    r109 :: object[2]
    r110 :: object_ptr
    r111 :: object
    r112 :: dict
    r113 :: str
    r114 :: i32
    r115 :: bit
    r116 :: object
    r117 :: bool
    r118 :: str
    r119 :: object
    r120 :: dict
    r121 :: str
    r122 :: i32
    r123 :: bit
    r124, r125, r126, r127, r128 :: str
    r129 :: set
    r130 :: i32
    r131 :: bit
    r132 :: i32
    r133 :: bit
    r134 :: i32
    r135 :: bit
    r136 :: i32
    r137 :: bit
    r138 :: i32
    r139 :: bit
    r140 :: dict
    r141 :: str
    r142 :: i32
    r143 :: bit
    r144 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L69 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Logger',)
    r6 = 'logging'
    r7 = dank_mids.helpers._errors.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L69 (error at <module>:1) else goto L4
L4:
    logging = r8 :: module
    dec_ref r8
    r9 = ('TYPE_CHECKING', 'Any', 'Final')
    r10 = 'typing'
    r11 = dank_mids.helpers._errors.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L69 (error at <module>:2) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = ('ContractLogicError',)
    r14 = 'web3.exceptions'
    r15 = dank_mids.helpers._errors.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L69 (error at <module>:4) else goto L6
L6:
    web3.exceptions = r16 :: module
    dec_ref r16
    r17 = ('BadResponse',)
    r18 = 'dank_mids._exceptions'
    r19 = dank_mids.helpers._errors.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L69 (error at <module>:6) else goto L7
L7:
    dank_mids._exceptions = r20 :: module
    dec_ref r20
    r21 = ('DEBUG', 'getLogger')
    r22 = 'dank_mids._logging'
    r23 = dank_mids.helpers._errors.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L69 (error at <module>:7) else goto L8
L8:
    dank_mids._logging = r24 :: module
    dec_ref r24
    r25 = ('REVERT_SELECTORS',)
    r26 = 'dank_mids.constants'
    r27 = dank_mids.helpers._errors.globals :: static
    r28 = CPyImport_ImportFromMany(r26, r25, r25, r27)
    if is_error(r28) goto L69 (error at <module>:8) else goto L9
L9:
    dank_mids.constants = r28 :: module
    dec_ref r28
    r29 = ('PartialResponse',)
    r30 = 'dank_mids.types'
    r31 = dank_mids.helpers._errors.globals :: static
    r32 = CPyImport_ImportFromMany(r30, r29, r29, r31)
    if is_error(r32) goto L69 (error at <module>:9) else goto L10
L10:
    dank_mids.types = r32 :: module
    dec_ref r32
    if 0 goto L11 else goto L11 :: bool
L11:
    r33 = 'dank_mids.errors'
    r34 = dank_mids._logging.getLogger :: static
    if is_error(r34) goto L12 else goto L14
L12:
    r35 = raise NameError('value for final name "getLogger" was not set')
    if not r35 goto L69 (error at <module>:15) else goto L13 :: bool
L13:
    unreachable
L14:
    r36 = [r33]
    r37 = load_address r36
    r38 = PyObject_Vectorcall(r34, r37, 1, 0)
    if is_error(r38) goto L69 (error at <module>:15) else goto L15
L15:
    dank_mids.helpers._errors.error_logger = r38 :: static
    r39 = dank_mids.helpers._errors.globals :: static
    r40 = 'error_logger'
    r41 = CPyDict_SetItem(r39, r40, r38)
    dec_ref r38
    r42 = r41 >= 0 :: signed
    if not r42 goto L69 (error at <module>:15) else goto L16 :: bool
L16:
    r43 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r43) goto L17 else goto L19
L17:
    r44 = raise NameError('value for final name "error_logger" was not set')
    if not r44 goto L69 (error at <module>:16) else goto L18 :: bool
L18:
    unreachable
L19:
    r45 = 'debug'
    r46 = CPyObject_GetAttr(r43, r45)
    if is_error(r46) goto L69 (error at <module>:16) else goto L20
L20:
    dank_mids.helpers._errors.error_logger_debug = r46 :: static
    r47 = dank_mids.helpers._errors.globals :: static
    r48 = 'error_logger_debug'
    r49 = CPyDict_SetItem(r47, r48, r46)
    dec_ref r46
    r50 = r49 >= 0 :: signed
    if not r50 goto L69 (error at <module>:16) else goto L21 :: bool
L21:
    r51 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r51) goto L22 else goto L24
L22:
    r52 = raise NameError('value for final name "error_logger" was not set')
    if not r52 goto L69 (error at <module>:17) else goto L23 :: bool
L23:
    unreachable
L24:
    r53 = '_log'
    r54 = CPyObject_GetAttr(r51, r53)
    if is_error(r54) goto L69 (error at <module>:17) else goto L25
L25:
    dank_mids.helpers._errors.error_logger_log = r54 :: static
    r55 = dank_mids.helpers._errors.globals :: static
    r56 = 'error_logger_log'
    r57 = CPyDict_SetItem(r55, r56, r54)
    dec_ref r54
    r58 = r57 >= 0 :: signed
    if not r58 goto L69 (error at <module>:17) else goto L26 :: bool
L26:
    r59 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r59) goto L27 else goto L29
L27:
    r60 = raise NameError('value for final name "error_logger" was not set')
    if not r60 goto L69 (error at <module>:24) else goto L28 :: bool
L28:
    unreachable
L29:
    r61 = 'reverts'
    r62 = 'getChild'
    r63 = [r59, r61]
    r64 = load_address r63
    r65 = PyObject_VectorcallMethod(r62, r64, 9223372036854775810, 0)
    if is_error(r65) goto L69 (error at <module>:24) else goto L30
L30:
    dank_mids.helpers._errors.revert_logger = r65 :: static
    r66 = dank_mids.helpers._errors.globals :: static
    r67 = 'revert_logger'
    r68 = CPyDict_SetItem(r66, r67, r65)
    dec_ref r65
    r69 = r68 >= 0 :: signed
    if not r69 goto L69 (error at <module>:24) else goto L31 :: bool
L31:
    r70 = dank_mids.helpers._errors.revert_logger :: static
    if is_error(r70) goto L32 else goto L34
L32:
    r71 = raise NameError('value for final name "revert_logger" was not set')
    if not r71 goto L69 (error at <module>:25) else goto L33 :: bool
L33:
    unreachable
L34:
    r72 = '_log'
    r73 = CPyObject_GetAttr(r70, r72)
    if is_error(r73) goto L69 (error at <module>:25) else goto L35
L35:
    dank_mids.helpers._errors.revert_logger_log = r73 :: static
    r74 = dank_mids.helpers._errors.globals :: static
    r75 = 'revert_logger_log'
    r76 = CPyDict_SetItem(r74, r75, r73)
    dec_ref r73
    r77 = r76 >= 0 :: signed
    if not r77 goto L69 (error at <module>:25) else goto L36 :: bool
L36:
    r78 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r78) goto L37 else goto L39
L37:
    r79 = raise NameError('value for final name "error_logger" was not set')
    if not r79 goto L69 (error at <module>:32) else goto L38 :: bool
L38:
    unreachable
L39:
    r80 = 'timeouts'
    r81 = 'getChild'
    r82 = [r78, r80]
    r83 = load_address r82
    r84 = PyObject_VectorcallMethod(r81, r83, 9223372036854775810, 0)
    if is_error(r84) goto L69 (error at <module>:32) else goto L40
L40:
    dank_mids.helpers._errors.timeout_logger = r84 :: static
    r85 = dank_mids.helpers._errors.globals :: static
    r86 = 'timeout_logger'
    r87 = CPyDict_SetItem(r85, r86, r84)
    dec_ref r84
    r88 = r87 >= 0 :: signed
    if not r88 goto L69 (error at <module>:32) else goto L41 :: bool
L41:
    r89 = dank_mids.helpers._errors.timeout_logger :: static
    if is_error(r89) goto L42 else goto L44
L42:
    r90 = raise NameError('value for final name "timeout_logger" was not set')
    if not r90 goto L69 (error at <module>:33) else goto L43 :: bool
L43:
    unreachable
L44:
    r91 = 'debug'
    r92 = CPyObject_GetAttr(r89, r91)
    if is_error(r92) goto L69 (error at <module>:33) else goto L45
L45:
    dank_mids.helpers._errors.timeout_logger_debug = r92 :: static
    r93 = dank_mids.helpers._errors.globals :: static
    r94 = 'timeout_logger_debug'
    r95 = CPyDict_SetItem(r93, r94, r92)
    dec_ref r92
    r96 = r95 >= 0 :: signed
    if not r96 goto L69 (error at <module>:33) else goto L46 :: bool
L46:
    r97 = dank_mids.helpers._errors.timeout_logger :: static
    if is_error(r97) goto L47 else goto L49
L47:
    r98 = raise NameError('value for final name "timeout_logger" was not set')
    if not r98 goto L69 (error at <module>:34) else goto L48 :: bool
L48:
    unreachable
L49:
    r99 = 'warning'
    r100 = CPyObject_GetAttr(r97, r99)
    if is_error(r100) goto L69 (error at <module>:34) else goto L50
L50:
    dank_mids.helpers._errors.timeout_logger_warning = r100 :: static
    r101 = dank_mids.helpers._errors.globals :: static
    r102 = 'timeout_logger_warning'
    r103 = CPyDict_SetItem(r101, r102, r100)
    dec_ref r100
    r104 = r103 >= 0 :: signed
    if not r104 goto L69 (error at <module>:34) else goto L51 :: bool
L51:
    r105 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r105) goto L52 else goto L54
L52:
    r106 = raise NameError('value for final name "error_logger" was not set')
    if not r106 goto L69 (error at <module>:37) else goto L53 :: bool
L53:
    unreachable
L54:
    r107 = 'gas'
    r108 = 'getChild'
    r109 = [r105, r107]
    r110 = load_address r109
    r111 = PyObject_VectorcallMethod(r108, r110, 9223372036854775810, 0)
    if is_error(r111) goto L69 (error at <module>:37) else goto L55
L55:
    dank_mids.helpers._errors.gas_logger = r111 :: static
    r112 = dank_mids.helpers._errors.globals :: static
    r113 = 'gas_logger'
    r114 = CPyDict_SetItem(r112, r113, r111)
    dec_ref r111
    r115 = r114 >= 0 :: signed
    if not r115 goto L69 (error at <module>:37) else goto L56 :: bool
L56:
    r116 = dank_mids.helpers._errors.gas_logger :: static
    if is_error(r116) goto L57 else goto L59
L57:
    r117 = raise NameError('value for final name "gas_logger" was not set')
    if not r117 goto L69 (error at <module>:38) else goto L58 :: bool
L58:
    unreachable
L59:
    r118 = 'debug'
    r119 = CPyObject_GetAttr(r116, r118)
    if is_error(r119) goto L69 (error at <module>:38) else goto L60
L60:
    dank_mids.helpers._errors.gas_logger_debug = r119 :: static
    r120 = dank_mids.helpers._errors.globals :: static
    r121 = 'gas_logger_debug'
    r122 = CPyDict_SetItem(r120, r121, r119)
    dec_ref r119
    r123 = r122 >= 0 :: signed
    if not r123 goto L69 (error at <module>:38) else goto L61 :: bool
L61:
    r124 = 'invalid opcode'
    r125 = 'missing trie node'
    r126 = 'resource not found'
    r127 = 'invalid ether transfer'
    r128 = 'error processing call revert'
    r129 = PySet_New(0)
    if is_error(r129) goto L69 (error at <module>:40) else goto L62
L62:
    r130 = PySet_Add(r129, r124)
    r131 = r130 >= 0 :: signed
    if not r131 goto L70 (error at <module>:40) else goto L63 :: bool
L63:
    r132 = PySet_Add(r129, r125)
    r133 = r132 >= 0 :: signed
    if not r133 goto L70 (error at <module>:40) else goto L64 :: bool
L64:
    r134 = PySet_Add(r129, r126)
    r135 = r134 >= 0 :: signed
    if not r135 goto L70 (error at <module>:40) else goto L65 :: bool
L65:
    r136 = PySet_Add(r129, r127)
    r137 = r136 >= 0 :: signed
    if not r137 goto L70 (error at <module>:40) else goto L66 :: bool
L66:
    r138 = PySet_Add(r129, r128)
    r139 = r138 >= 0 :: signed
    if not r139 goto L70 (error at <module>:40) else goto L67 :: bool
L67:
    dank_mids.helpers._errors.INDIVIDUAL_CALL_REVERT_STRINGS = r129 :: static
    r140 = dank_mids.helpers._errors.globals :: static
    r141 = 'INDIVIDUAL_CALL_REVERT_STRINGS'
    r142 = CPyDict_SetItem(r140, r141, r129)
    dec_ref r129
    r143 = r142 >= 0 :: signed
    if not r143 goto L69 (error at <module>:40) else goto L68 :: bool
L68:
    return 1
L69:
    r144 = <error> :: None
    return r144
L70:
    dec_ref r129
    goto L69

def make_hashable(obj):
    obj, r0, r1 :: object
    r2 :: tuple[object, object]
    r3 :: object
    r4 :: i32
    r5 :: bit
    r6 :: bool
    r7 :: list
    r8 :: union[list, tuple]
    r9, r10, r11 :: object
    r12 :: i32
    r13, r14 :: bit
    r15 :: tuple
    r16 :: bit
    r17, r18 :: dict
    r19 :: short_int
    r20 :: native_int
    r21 :: object
    r22 :: tuple[bool, short_int, object]
    r23 :: short_int
    r24 :: bool
    r25 :: object
    r26 :: dict
    r27, r28 :: object
    r29 :: i32
    r30, r31, r32 :: bit
    r33 :: tuple
    r34 :: dict
    r35 :: dank_mids.helpers.hashing.AttributeDict
    r36 :: object
L0:
    r0 = load_address PyList_Type
    r1 = load_address PyTuple_Type
    inc_ref r0
    inc_ref r1
    r2 = (r0, r1)
    r3 = box(tuple[object, object], r2)
    r4 = PyObject_IsInstance(obj, r3)
    dec_ref r3
    r5 = r4 >= 0 :: signed
    if not r5 goto L27 (error at make_hashable:36) else goto L1 :: bool
L1:
    r6 = truncate r4: i32 to builtins.bool
    if r6 goto L2 else goto L11 :: bool
L2:
    r7 = PyList_New(0)
    if is_error(r7) goto L27 (error at make_hashable:37) else goto L3
L3:
    inc_ref obj
    r8 = cast(union[list, tuple], obj)
    if is_error(r8) goto L28 (error at make_hashable:37) else goto L4
L4:
    r9 = PyObject_GetIter(r8)
    dec_ref r8
    if is_error(r9) goto L28 (error at make_hashable:37) else goto L5
L5:
    r10 = PyIter_Next(r9)
    if is_error(r10) goto L29 else goto L6
L6:
    r11 = make_hashable(r10)
    dec_ref r10
    if is_error(r11) goto L30 (error at make_hashable:37) else goto L7
L7:
    r12 = PyList_Append(r7, r11)
    dec_ref r11
    r13 = r12 >= 0 :: signed
    if not r13 goto L30 (error at make_hashable:37) else goto L5 :: bool
L8:
    r14 = CPy_NoErrOccurred()
    if not r14 goto L28 (error at make_hashable:37) else goto L9 :: bool
L9:
    r15 = PyList_AsTuple(r7)
    dec_ref r7
    if is_error(r15) goto L27 (error at make_hashable:37) else goto L10
L10:
    return r15
L11:
    r16 = PyDict_Check(obj)
    if r16 goto L12 else goto L26 :: bool
L12:
    r17 = PyDict_New()
    if is_error(r17) goto L27 (error at make_hashable:39) else goto L13
L13:
    inc_ref obj
    r18 = cast(dict, obj)
    if is_error(r18) goto L31 (error at make_hashable:39) else goto L14
L14:
    r19 = 0
    r20 = PyDict_Size(r18)
    r21 = CPyDict_GetKeysIter(r18)
    if is_error(r21) goto L32 (error at make_hashable:39) else goto L15
L15:
    r22 = CPyDict_NextKey(r21, r19)
    r23 = r22[1]
    r19 = r23
    r24 = r22[0]
    if r24 goto L16 else goto L33 :: bool
L16:
    r25 = r22[2]
    dec_ref r22
    inc_ref obj
    r26 = cast(dict, obj)
    if is_error(r26) goto L34 (error at make_hashable:39) else goto L17
L17:
    r27 = CPyDict_GetItem(r26, r25)
    dec_ref r26
    if is_error(r27) goto L34 (error at make_hashable:39) else goto L18
L18:
    r28 = make_hashable(r27)
    dec_ref r27
    if is_error(r28) goto L34 (error at make_hashable:39) else goto L19
L19:
    r29 = CPyDict_SetItem(r17, r25, r28)
    dec_ref r25
    dec_ref r28
    r30 = r29 >= 0 :: signed
    if not r30 goto L35 (error at make_hashable:39) else goto L20 :: bool
L20:
    r31 = CPyDict_CheckSize(r18, r20)
    if not r31 goto L35 (error at make_hashable:39) else goto L15 :: bool
L21:
    r32 = CPy_NoErrOccurred()
    if not r32 goto L31 (error at make_hashable:39) else goto L22 :: bool
L22:
    r33 = PyTuple_Pack(0)
    if is_error(r33) goto L31 (error at make_hashable:39) else goto L23
L23:
    r34 = PyDict_New()
    if is_error(r34) goto L36 (error at make_hashable:39) else goto L24
L24:
    r35 = AttributeDict(r17, r33, r34)
    dec_ref r17
    dec_ref r33
    dec_ref r34
    if is_error(r35) goto L27 (error at make_hashable:39) else goto L25
L25:
    return r35
L26:
    inc_ref obj
    return obj
L27:
    r36 = <error> :: object
    return r36
L28:
    dec_ref r7
    goto L27
L29:
    dec_ref r9
    goto L8
L30:
    dec_ref r7
    dec_ref r9
    goto L27
L31:
    dec_ref r17
    goto L27
L32:
    dec_ref r17
    dec_ref r18
    goto L27
L33:
    dec_ref r18
    dec_ref r21
    dec_ref r22
    goto L21
L34:
    dec_ref r17
    dec_ref r18
    dec_ref r21
    dec_ref r25
    goto L27
L35:
    dec_ref r17
    dec_ref r18
    dec_ref r21
    goto L27
L36:
    dec_ref r17
    dec_ref r33
    goto L27

def AttributeDict.__init__(self, dictionary, args, kwargs):
    self :: dank_mids.helpers.hashing.AttributeDict
    dictionary :: dict
    args :: tuple
    kwargs, r0 :: dict
    r1 :: bool
    r2 :: dict
    r3 :: object
    r4 :: list
    r5 :: object
    r6 :: dict
    r7 :: i32
    r8 :: bit
    r9 :: tuple
    r10 :: object
    r11 :: dict
    r12 :: i32
    r13 :: bit
    r14 :: object
    r15 :: bool
    r16 :: None
L0:
    r0 = PyDict_Copy(dictionary)
    if is_error(r0) goto L13 (error at __init__:50) else goto L1
L1:
    self.__dict__ = r0; r1 = is_error
    if not r1 goto L13 (error at __init__:50) else goto L2 :: bool
L2:
    r2 = self.__dict__
    if is_error(r2) goto L13 (error at __init__:51) else goto L3
L3:
    r3 = load_address PyDict_Type
    r4 = PyList_New(0)
    if is_error(r4) goto L14 (error at __init__:51) else goto L4
L4:
    r5 = CPyList_Extend(r4, args)
    if is_error(r5) goto L15 (error at __init__:51) else goto L16
L5:
    r6 = PyDict_New()
    if is_error(r6) goto L15 (error at __init__:51) else goto L6
L6:
    r7 = CPyDict_UpdateInDisplay(r6, kwargs)
    r8 = r7 >= 0 :: signed
    if not r8 goto L17 (error at __init__:51) else goto L7 :: bool
L7:
    r9 = PyList_AsTuple(r4)
    dec_ref r4
    if is_error(r9) goto L18 (error at __init__:51) else goto L8
L8:
    r10 = PyObject_Call(r3, r9, r6)
    dec_ref r9
    dec_ref r6
    if is_error(r10) goto L14 (error at __init__:51) else goto L9
L9:
    r11 = cast(dict, r10)
    if is_error(r11) goto L14 (error at __init__:51) else goto L10
L10:
    r12 = CPyDict_Update(r2, r11)
    dec_ref r2
    dec_ref r11
    r13 = r12 >= 0 :: signed
    if not r13 goto L13 (error at __init__:51) else goto L11 :: bool
L11:
    r14 = box(None, 1)
    inc_ref r14
    self.__hash = r14; r15 = is_error
    if not r15 goto L13 (error at __init__:52) else goto L12 :: bool
L12:
    return 1
L13:
    r16 = <error> :: None
    return r16
L14:
    dec_ref r2
    goto L13
L15:
    dec_ref r2
    dec_ref r4
    goto L13
L16:
    dec_ref r5
    goto L5
L17:
    dec_ref r2
    dec_ref r4
    dec_ref r6
    goto L13
L18:
    dec_ref r2
    dec_ref r6
    goto L13

def AttributeDict.__hash__(self):
    self :: dank_mids.helpers.hashing.AttributeDict
    r0, retval :: union[int, None]
    r1 :: object
    r2 :: bit
    r3 :: dank_mids.helpers.hashing.AttributeDict
    r4 :: object
    r5 :: list
    r6 :: tuple
    r7 :: int
    r8 :: object
    r9 :: int
    r10 :: object
    r11 :: bool
    r12, r13 :: int
L0:
    r0 = self.__hash
    if is_error(r0) goto L11 (error at __hash__:55) else goto L1
L1:
    retval = r0
    r1 = load_address _Py_NoneStruct
    r2 = retval == r1
    if r2 goto L12 else goto L9 :: bool
L2:
    r3 = tupleize_lists_nested(self)
    if is_error(r3) goto L11 (error at __hash__:57) else goto L3
L3:
    r4 = r3.items()
    dec_ref r3
    if is_error(r4) goto L11 (error at __hash__:57) else goto L4
L4:
    r5 = CPySequence_Sort(r4)
    dec_ref r4
    if is_error(r5) goto L11 (error at __hash__:57) else goto L5
L5:
    r6 = PyList_AsTuple(r5)
    dec_ref r5
    if is_error(r6) goto L11 (error at __hash__:57) else goto L6
L6:
    r7 = CPyObject_Hash(r6)
    dec_ref r6
    if is_error(r7) goto L11 (error at __hash__:57) else goto L7
L7:
    r8 = box(int, r7)
    retval = r8
    r9 = unbox(int, retval)
    if is_error(r9) goto L13 (error at __hash__:58) else goto L8
L8:
    r10 = box(int, r9)
    self.__hash = r10; r11 = is_error
    if not r11 goto L13 (error at __hash__:58) else goto L9 :: bool
L9:
    r12 = unbox(int, retval)
    dec_ref retval
    if is_error(r12) goto L11 (error at __hash__:59) else goto L10
L10:
    return r12
L11:
    r13 = <error> :: int
    return r13
L12:
    dec_ref retval
    goto L2
L13:
    dec_ref retval
    goto L11

def AttributeDict.__eq__(self, other):
    self :: dank_mids.helpers.hashing.AttributeDict
    other, r0 :: object
    r1 :: ptr
    r2 :: object
    r3 :: bit
    r4 :: int
    r5 :: dank_mids.helpers.hashing.AttributeDict
    r6 :: int
    r7 :: native_int
    r8, r9 :: bit
    r10 :: bool
    r11 :: bit
    r12 :: dict
    r13 :: str
    r14 :: object
    r15 :: i32
    r16 :: bit
    r17 :: bool
    r18, r19 :: dict
    r20 :: object
    r21, r22 :: bool
L0:
    r0 = dank_mids.helpers.hashing.AttributeDict :: type
    r1 = get_element_ptr other ob_type :: PyObject
    r2 = borrow load_mem r1 :: builtins.object*
    r3 = r2 == r0
    if r3 goto L1 else goto L8 :: bool
L1:
    r4 = CPyObject_Hash(self)
    if is_error(r4) goto L17 (error at __eq__:63) else goto L2
L2:
    inc_ref other
    r5 = cast(dank_mids.helpers.hashing.AttributeDict, other)
    if is_error(r5) goto L18 (error at __eq__:63) else goto L3
L3:
    r6 = CPyObject_Hash(r5)
    dec_ref r5
    if is_error(r6) goto L18 (error at __eq__:63) else goto L4
L4:
    r7 = r4 & 1
    r8 = r7 != 0
    if r8 goto L5 else goto L6 :: bool
L5:
    r9 = CPyTagged_IsEq_(r4, r6)
    r10 = r9
    goto L7
L6:
    r11 = r4 == r6
    r10 = r11
L7:
    dec_ref r4 :: int
    dec_ref r6 :: int
    return r10
L8:
    r12 = dank_mids.helpers.hashing.globals :: static
    r13 = 'Mapping'
    r14 = CPyDict_GetItem(r12, r13)
    if is_error(r14) goto L17 (error at __eq__:64) else goto L9
L9:
    r15 = PyObject_IsInstance(other, r14)
    dec_ref r14
    r16 = r15 >= 0 :: signed
    if not r16 goto L17 (error at __eq__:64) else goto L10 :: bool
L10:
    r17 = truncate r15: i32 to builtins.bool
    if r17 goto L11 else goto L16 :: bool
L11:
    r18 = self.__dict__
    if is_error(r18) goto L17 (error at __eq__:65) else goto L12
L12:
    r19 = CPyDict_FromAny(other)
    if is_error(r19) goto L19 (error at __eq__:65) else goto L13
L13:
    r20 = PyObject_RichCompare(r18, r19, 2)
    dec_ref r18
    dec_ref r19
    if is_error(r20) goto L17 (error at __eq__:65) else goto L14
L14:
    r21 = unbox(bool, r20)
    dec_ref r20
    if is_error(r21) goto L17 (error at __eq__:65) else goto L15
L15:
    return r21
L16:
    return 0
L17:
    r22 = <error> :: bool
    return r22
L18:
    dec_ref r4 :: int
    goto L17
L19:
    dec_ref r18
    goto L17

def AttributeDict.__setattr__(self, attr, val):
    self :: dank_mids.helpers.hashing.AttributeDict
    attr :: str
    val :: object
    r0 :: str
    r1 :: bool
    r2 :: object
    r3 :: str
    r4, r5 :: object
    r6 :: object[2]
    r7 :: object_ptr
    r8 :: object
    r9 :: str
    r10 :: object
    r11 :: object[2]
    r12 :: object_ptr
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: str
    r17 :: object
    r18 :: object[1]
    r19 :: object_ptr
    r20 :: object
    r21 :: None
L0:
    r0 = '__dict__'
    r1 = CPyStr_Equal(attr, r0)
    if r1 goto L1 else goto L5 :: bool
L1:
    r2 = builtins :: module
    r3 = 'super'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L9 (error at __setattr__:71) else goto L2
L2:
    r5 = dank_mids.helpers.hashing.AttributeDict :: type
    r6 = [r5, self]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r4, r7, 2, 0)
    dec_ref r4
    if is_error(r8) goto L9 (error at __setattr__:71) else goto L3
L3:
    r9 = '__setattr__'
    r10 = CPyObject_GetAttr(r8, r9)
    dec_ref r8
    if is_error(r10) goto L9 (error at __setattr__:71) else goto L4
L4:
    r11 = [attr, val]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r10, r12, 2, 0)
    dec_ref r10
    if is_error(r13) goto L9 (error at __setattr__:71) else goto L10
L5:
    r14 = 'This data is immutable -- create a copy instead of modifying'
    r15 = builtins :: module
    r16 = 'TypeError'
    r17 = CPyObject_GetAttr(r15, r16)
    if is_error(r17) goto L9 (error at __setattr__:72) else goto L6
L6:
    r18 = [r14]
    r19 = load_address r18
    r20 = PyObject_Vectorcall(r17, r19, 1, 0)
    dec_ref r17
    if is_error(r20) goto L9 (error at __setattr__:72) else goto L7
L7:
    CPy_Raise(r20)
    dec_ref r20
    if not 0 goto L9 (error at __setattr__:72) else goto L8 :: bool
L8:
    unreachable
L9:
    r21 = <error> :: None
    return r21
L10:
    dec_ref r13
    goto L5

def AttributeDict.__delattr__(self, key):
    self :: dank_mids.helpers.hashing.AttributeDict
    key, r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: None
L0:
    r0 = 'This data is immutable -- create a copy instead of modifying'
    r1 = builtins :: module
    r2 = 'TypeError'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L4 (error at __delattr__:75) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r3, r5, 1, 0)
    dec_ref r3
    if is_error(r6) goto L4 (error at __delattr__:75) else goto L2
L2:
    CPy_Raise(r6)
    dec_ref r6
    if not 0 goto L4 (error at __delattr__:75) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = <error> :: None
    return r7

def AttributeDict.__getitem__(self, key):
    self :: dank_mids.helpers.hashing.AttributeDict
    key :: object
    r0 :: dict
    r1, r2 :: object
L0:
    r0 = self.__dict__
    if is_error(r0) goto L3 (error at __getitem__:78) else goto L1
L1:
    r1 = CPyDict_GetItem(r0, key)
    dec_ref r0
    if is_error(r1) goto L3 (error at __getitem__:78) else goto L2
L2:
    return r1
L3:
    r2 = <error> :: object
    return r2

def AttributeDict.__iter__(self):
    self :: dank_mids.helpers.hashing.AttributeDict
    r0 :: dict
    r1, r2 :: object
L0:
    r0 = self.__dict__
    if is_error(r0) goto L3 (error at __iter__:81) else goto L1
L1:
    r1 = PyObject_GetIter(r0)
    dec_ref r0
    if is_error(r1) goto L3 (error at __iter__:81) else goto L2
L2:
    return r1
L3:
    r2 = <error> :: object
    return r2

def AttributeDict.__len__(self):
    self :: dank_mids.helpers.hashing.AttributeDict
    r0 :: dict
    r1 :: native_int
    r2 :: short_int
    r3 :: int
L0:
    r0 = self.__dict__
    if is_error(r0) goto L2 (error at __len__:84) else goto L1
L1:
    r1 = PyDict_Size(r0)
    dec_ref r0
    r2 = r1 << 1
    return r2
L2:
    r3 = <error> :: int
    return r3

def AttributeDict.__repr__(self):
    self :: dank_mids.helpers.hashing.AttributeDict
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4, r5, r6, r7 :: str
    r8 :: dict
    r9, r10 :: str
    r11 :: object[3]
    r12 :: object_ptr
    r13 :: object
    r14, r15 :: str
    r16 :: list
    r17, r18, r19, r20 :: ptr
    r21, r22, r23 :: str
L0:
    r0 = '__class__'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L10 (error at __repr__:87) else goto L1
L1:
    r2 = '__name__'
    r3 = CPyObject_GetAttr(r1, r2)
    dec_ref r1
    if is_error(r3) goto L10 (error at __repr__:87) else goto L2
L2:
    r4 = cast(str, r3)
    if is_error(r4) goto L10 (error at __repr__:87) else goto L3
L3:
    r5 = ''
    r6 = '('
    r7 = '{!r:{}}'
    r8 = self.__dict__
    if is_error(r8) goto L11 (error at __repr__:87) else goto L4
L4:
    r9 = ''
    r10 = 'format'
    r11 = [r7, r8, r9]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775811, 0)
    if is_error(r13) goto L12 (error at __repr__:87) else goto L5
L5:
    dec_ref r8
    r14 = cast(str, r13)
    if is_error(r14) goto L11 (error at __repr__:87) else goto L6
L6:
    r15 = ')'
    r16 = PyList_New(3)
    if is_error(r16) goto L13 (error at __repr__:87) else goto L7
L7:
    r17 = get_element_ptr r16 ob_item :: PyListObject
    r18 = load_mem r17 :: ptr*
    inc_ref r6
    set_mem r18, r6 :: builtins.object*
    r19 = r18 + 8
    set_mem r19, r14 :: builtins.object*
    inc_ref r15
    r20 = r18 + 16
    set_mem r20, r15 :: builtins.object*
    r21 = PyUnicode_Join(r5, r16)
    dec_ref r16
    if is_error(r21) goto L11 (error at __repr__:87) else goto L8
L8:
    r22 = PyUnicode_Concat(r4, r21)
    dec_ref r4
    dec_ref r21
    if is_error(r22) goto L10 (error at __repr__:87) else goto L9
L9:
    return r22
L10:
    r23 = <error> :: str
    return r23
L11:
    dec_ref r4
    goto L10
L12:
    dec_ref r4
    dec_ref r8
    goto L10
L13:
    dec_ref r4
    dec_ref r14
    goto L10

def AttributeDict._repr_pretty_(self, builder, cycle):
    self :: dank_mids.helpers.hashing.AttributeDict
    builder :: object
    cycle :: bool
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4, r5, r6, r7 :: str
    r8 :: object[2]
    r9 :: object_ptr
    r10 :: object
    r11, r12 :: str
    r13 :: object[2]
    r14 :: object_ptr
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: object[2]
    r19 :: object_ptr
    r20 :: object
    r21, r22 :: str
    r23 :: object[2]
    r24 :: object_ptr
    r25 :: object
    r26 :: None
L0:
    r0 = '__class__'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L12 (error at _repr_pretty_:94) else goto L1
L1:
    r2 = '__name__'
    r3 = CPyObject_GetAttr(r1, r2)
    dec_ref r1
    if is_error(r3) goto L12 (error at _repr_pretty_:94) else goto L2
L2:
    r4 = cast(str, r3)
    if is_error(r4) goto L12 (error at _repr_pretty_:94) else goto L3
L3:
    r5 = '('
    r6 = PyUnicode_Concat(r4, r5)
    dec_ref r4
    if is_error(r6) goto L12 (error at _repr_pretty_:94) else goto L4
L4:
    r7 = 'text'
    r8 = [builder, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775810, 0)
    if is_error(r10) goto L13 (error at _repr_pretty_:94) else goto L14
L5:
    dec_ref r6
    if cycle goto L6 else goto L7 :: bool
L6:
    r11 = '<cycle>'
    r12 = 'text'
    r13 = [builder, r11]
    r14 = load_address r13
    r15 = PyObject_VectorcallMethod(r12, r14, 9223372036854775810, 0)
    if is_error(r15) goto L12 (error at _repr_pretty_:96) else goto L15
L7:
    r16 = self.__dict__
    if is_error(r16) goto L12 (error at _repr_pretty_:98) else goto L8
L8:
    r17 = 'pretty'
    r18 = [builder, r16]
    r19 = load_address r18
    r20 = PyObject_VectorcallMethod(r17, r19, 9223372036854775810, 0)
    if is_error(r20) goto L16 (error at _repr_pretty_:98) else goto L17
L9:
    dec_ref r16
L10:
    r21 = ')'
    r22 = 'text'
    r23 = [builder, r21]
    r24 = load_address r23
    r25 = PyObject_VectorcallMethod(r22, r24, 9223372036854775810, 0)
    if is_error(r25) goto L12 (error at _repr_pretty_:99) else goto L18
L11:
    return 1
L12:
    r26 = <error> :: None
    return r26
L13:
    dec_ref r6
    goto L12
L14:
    dec_ref r10
    goto L5
L15:
    dec_ref r15
    goto L10
L16:
    dec_ref r16
    goto L12
L17:
    dec_ref r20
    goto L9
L18:
    dec_ref r25
    goto L11

def AttributeDict.recursive(cls, value):
    cls, value :: object
    r0 :: bit
    r1 :: tuple
    r2 :: ptr
    r3 :: native_int
    r4 :: tuple
    r5 :: native_int
    r6 :: ptr
    r7 :: native_int
    r8 :: bit
    r9, r10, r11 :: object
    r12 :: native_int
    r13 :: bit
    r14 :: list
    r15 :: ptr
    r16 :: native_int
    r17 :: list
    r18 :: native_int
    r19 :: ptr
    r20 :: native_int
    r21 :: bit
    r22, r23 :: ptr
    r24 :: native_int
    r25 :: ptr
    r26, r27, r28 :: object
    r29 :: native_int
    r30 :: dict
    r31 :: str
    r32 :: object
    r33 :: i32
    r34 :: bit
    r35 :: bool
    r36 :: dict
    r37 :: str
    r38 :: object[1]
    r39 :: object_ptr
    r40, r41, r42 :: object
    r43 :: tuple[object, object]
    r44, r45, r46, r47 :: object
    r48 :: i32
    r49, r50 :: bit
    r51 :: tuple
    r52 :: dict
    r53 :: dank_mids.helpers.hashing.AttributeDict
    r54 :: bit
    r55, r56 :: set
    r57, r58, r59, r60 :: object
    r61 :: i32
    r62, r63 :: bit
    r64 :: dict
    r65 :: str
    r66 :: object
    r67 :: i32
    r68 :: bit
    r69 :: bool
    r70, r71 :: object
    r72 :: tuple[object, object]
    r73 :: object
    r74 :: i32
    r75 :: bit
    r76 :: bool
    r77 :: object
    r78 :: list
    r79, r80, r81, r82 :: object
    r83 :: i32
    r84, r85 :: bit
    r86 :: object
    r87 :: object[1]
    r88 :: object_ptr
    r89, r90 :: object
L0:
    r0 = PyTuple_Check(value)
    if r0 goto L1 else goto L9 :: bool
L1:
    inc_ref value
    r1 = cast(tuple, value)
    if is_error(r1) goto L57 (error at recursive:108) else goto L2
L2:
    r2 = get_element_ptr r1 ob_size :: PyVarObject
    r3 = load_mem r2 :: native_int*
    r4 = PyTuple_New(r3)
    if is_error(r4) goto L58 (error at recursive:108) else goto L3
L3:
    r5 = 0
L4:
    r6 = get_element_ptr r1 ob_size :: PyVarObject
    r7 = load_mem r6 :: native_int*
    r8 = r5 < r7 :: signed
    if r8 goto L5 else goto L59 :: bool
L5:
    r9 = CPySequenceTuple_GetItemUnsafe(r1, r5)
    r10 = dank_mids.helpers.hashing.AttributeDict :: type
    r11 = AttributeDict.recursive(r10, r9)
    dec_ref r9
    if is_error(r11) goto L60 (error at recursive:108) else goto L6
L6:
    CPySequenceTuple_SetItemUnsafe(r4, r5, r11)
L7:
    r12 = r5 + 1
    r5 = r12
    goto L4
L8:
    return r4
L9:
    r13 = PyList_Check(value)
    if r13 goto L10 else goto L18 :: bool
L10:
    inc_ref value
    r14 = cast(list, value)
    if is_error(r14) goto L57 (error at recursive:110) else goto L11
L11:
    r15 = get_element_ptr r14 ob_size :: PyVarObject
    r16 = load_mem r15 :: native_int*
    r17 = PyList_New(r16)
    if is_error(r17) goto L61 (error at recursive:110) else goto L12
L12:
    r18 = 0
L13:
    r19 = get_element_ptr r14 ob_size :: PyVarObject
    r20 = load_mem r19 :: native_int*
    r21 = r18 < r20 :: signed
    if r21 goto L14 else goto L62 :: bool
L14:
    r22 = get_element_ptr r14 ob_item :: PyListObject
    r23 = load_mem r22 :: ptr*
    r24 = r18 * 8
    r25 = r23 + r24
    r26 = load_mem r25 :: builtins.object*
    r27 = dank_mids.helpers.hashing.AttributeDict :: type
    r28 = AttributeDict.recursive(r27, r26)
    dec_ref r26
    if is_error(r28) goto L63 (error at recursive:110) else goto L15
L15:
    CPyList_SetItemUnsafe(r17, r18, r28)
L16:
    r29 = r18 + 1
    r18 = r29
    goto L13
L17:
    return r17
L18:
    r30 = dank_mids.helpers.hashing.globals :: static
    r31 = 'Mapping'
    r32 = CPyDict_GetItem(r30, r31)
    if is_error(r32) goto L57 (error at recursive:111) else goto L19
L19:
    r33 = PyObject_IsInstance(value, r32)
    dec_ref r32
    r34 = r33 >= 0 :: signed
    if not r34 goto L57 (error at recursive:111) else goto L20 :: bool
L20:
    r35 = truncate r33: i32 to builtins.bool
    if r35 goto L21 else goto L33 :: bool
L21:
    r36 = PyDict_New()
    if is_error(r36) goto L57 (error at recursive:112) else goto L22
L22:
    r37 = 'items'
    r38 = [value]
    r39 = load_address r38
    r40 = PyObject_VectorcallMethod(r37, r39, 9223372036854775809, 0)
    if is_error(r40) goto L64 (error at recursive:112) else goto L23
L23:
    r41 = PyObject_GetIter(r40)
    dec_ref r40
    if is_error(r41) goto L64 (error at recursive:112) else goto L24
L24:
    r42 = PyIter_Next(r41)
    if is_error(r42) goto L65 else goto L25
L25:
    r43 = unbox(tuple[object, object], r42)
    dec_ref r42
    if is_error(r43) goto L66 (error at recursive:112) else goto L26
L26:
    r44 = r43[0]
    r45 = r43[1]
    dec_ref r43
    r46 = dank_mids.helpers.hashing.AttributeDict :: type
    r47 = AttributeDict.recursive(r46, r45)
    dec_ref r45
    if is_error(r47) goto L67 (error at recursive:112) else goto L27
L27:
    r48 = CPyDict_SetItem(r36, r44, r47)
    dec_ref r44
    dec_ref r47
    r49 = r48 >= 0 :: signed
    if not r49 goto L66 (error at recursive:112) else goto L24 :: bool
L28:
    r50 = CPy_NoErrOccurred()
    if not r50 goto L64 (error at recursive:112) else goto L29 :: bool
L29:
    r51 = PyTuple_Pack(0)
    if is_error(r51) goto L64 (error at recursive:112) else goto L30
L30:
    r52 = PyDict_New()
    if is_error(r52) goto L68 (error at recursive:112) else goto L31
L31:
    r53 = AttributeDict(r36, r51, r52)
    dec_ref r36
    dec_ref r51
    dec_ref r52
    if is_error(r53) goto L57 (error at recursive:112) else goto L32
L32:
    return r53
L33:
    r54 = PySet_Check(value)
    if r54 goto L34 else goto L42 :: bool
L34:
    r55 = PySet_New(0)
    if is_error(r55) goto L57 (error at recursive:114) else goto L35
L35:
    inc_ref value
    r56 = cast(set, value)
    if is_error(r56) goto L69 (error at recursive:114) else goto L36
L36:
    r57 = PyObject_GetIter(r56)
    dec_ref r56
    if is_error(r57) goto L69 (error at recursive:114) else goto L37
L37:
    r58 = PyIter_Next(r57)
    if is_error(r58) goto L70 else goto L38
L38:
    r59 = dank_mids.helpers.hashing.AttributeDict :: type
    r60 = AttributeDict.recursive(r59, r58)
    dec_ref r58
    if is_error(r60) goto L71 (error at recursive:114) else goto L39
L39:
    r61 = PySet_Add(r55, r60)
    dec_ref r60
    r62 = r61 >= 0 :: signed
    if not r62 goto L71 (error at recursive:114) else goto L37 :: bool
L40:
    r63 = CPy_NoErrOccurred()
    if not r63 goto L69 (error at recursive:114) else goto L41 :: bool
L41:
    return r55
L42:
    r64 = dank_mids.helpers.hashing.globals :: static
    r65 = 'Sequence'
    r66 = CPyDict_GetItem(r64, r65)
    if is_error(r66) goto L57 (error at recursive:115) else goto L43
L43:
    r67 = PyObject_IsInstance(value, r66)
    dec_ref r66
    r68 = r67 >= 0 :: signed
    if not r68 goto L57 (error at recursive:115) else goto L44 :: bool
L44:
    r69 = truncate r67: i32 to builtins.bool
    if r69 goto L45 else goto L56 :: bool
L45:
    r70 = load_address PyUnicode_Type
    r71 = load_address PyBytes_Type
    inc_ref r70
    inc_ref r71
    r72 = (r70, r71)
    r73 = box(tuple[object, object], r72)
    r74 = PyObject_IsInstance(value, r73)
    dec_ref r73
    r75 = r74 >= 0 :: signed
    if not r75 goto L57 (error at recursive:115) else goto L46 :: bool
L46:
    r76 = truncate r74: i32 to builtins.bool
    if r76 goto L56 else goto L47 :: bool
L47:
    r77 = PyObject_Type(value)
    r78 = PyList_New(0)
    if is_error(r78) goto L72 (error at recursive:116) else goto L48
L48:
    r79 = PyObject_GetIter(value)
    if is_error(r79) goto L73 (error at recursive:116) else goto L49
L49:
    r80 = PyIter_Next(r79)
    if is_error(r80) goto L74 else goto L50
L50:
    r81 = dank_mids.helpers.hashing.AttributeDict :: type
    r82 = AttributeDict.recursive(r81, r80)
    dec_ref r80
    if is_error(r82) goto L75 (error at recursive:116) else goto L51
L51:
    r83 = PyList_Append(r78, r82)
    dec_ref r82
    r84 = r83 >= 0 :: signed
    if not r84 goto L75 (error at recursive:116) else goto L49 :: bool
L52:
    r85 = CPy_NoErrOccurred()
    if not r85 goto L73 (error at recursive:116) else goto L53 :: bool
L53:
    r86 = PyObject_GetIter(r78)
    dec_ref r78
    if is_error(r86) goto L72 (error at recursive:116) else goto L54
L54:
    r87 = [r86]
    r88 = load_address r87
    r89 = PyObject_Vectorcall(r77, r88, 1, 0)
    dec_ref r77
    if is_error(r89) goto L76 (error at recursive:116) else goto L55
L55:
    dec_ref r86
    return r89
L56:
    inc_ref value
    return value
L57:
    r90 = <error> :: object
    return r90
L58:
    dec_ref r1
    goto L57
L59:
    dec_ref r1
    goto L8
L60:
    dec_ref r1
    dec_ref r4
    goto L57
L61:
    dec_ref r14
    goto L57
L62:
    dec_ref r14
    goto L17
L63:
    dec_ref r14
    dec_ref r17
    goto L57
L64:
    dec_ref r36
    goto L57
L65:
    dec_ref r41
    goto L28
L66:
    dec_ref r36
    dec_ref r41
    goto L57
L67:
    dec_ref r36
    dec_ref r41
    dec_ref r44
    goto L57
L68:
    dec_ref r36
    dec_ref r51
    goto L57
L69:
    dec_ref r55
    goto L57
L70:
    dec_ref r57
    goto L40
L71:
    dec_ref r55
    dec_ref r57
    goto L57
L72:
    dec_ref r77
    goto L57
L73:
    dec_ref r77
    dec_ref r78
    goto L57
L74:
    dec_ref r79
    goto L52
L75:
    dec_ref r77
    dec_ref r78
    dec_ref r79
    goto L57
L76:
    dec_ref r86
    goto L57

def AttributeDict.keys(self):
    self :: dank_mids.helpers.hashing.AttributeDict
    r0 :: dict
    r1, r2 :: object
L0:
    r0 = self.__dict__
    if is_error(r0) goto L3 (error at keys:120) else goto L1
L1:
    r1 = CPyDict_KeysView(r0)
    dec_ref r0
    if is_error(r1) goto L3 (error at keys:120) else goto L2
L2:
    return r1
L3:
    r2 = <error> :: object
    return r2

def AttributeDict.values(self):
    self :: dank_mids.helpers.hashing.AttributeDict
    r0 :: dict
    r1, r2 :: object
L0:
    r0 = self.__dict__
    if is_error(r0) goto L3 (error at values:123) else goto L1
L1:
    r1 = CPyDict_ValuesView(r0)
    dec_ref r0
    if is_error(r1) goto L3 (error at values:123) else goto L2
L2:
    return r1
L3:
    r2 = <error> :: object
    return r2

def AttributeDict.items(self):
    self :: dank_mids.helpers.hashing.AttributeDict
    r0 :: dict
    r1, r2 :: object
L0:
    r0 = self.__dict__
    if is_error(r0) goto L3 (error at items:126) else goto L1
L1:
    r1 = CPyDict_ItemsView(r0)
    dec_ref r0
    if is_error(r1) goto L3 (error at items:126) else goto L2
L2:
    return r1
L3:
    r2 = <error> :: object
    return r2

def AttributeDict.__ne__(__mypyc_self__, rhs):
    __mypyc_self__, rhs :: dank_mids.helpers.hashing.AttributeDict
    r0, r1, r2 :: bool
L0:
    r0 = __mypyc_self__.__eq__(rhs)
    if is_error(r0) goto L2 else goto L1
L1:
    r1 = r0 ^ 1
    return r1
L2:
    r2 = <error> :: bool
    return r2

def tupleize_lists_nested(d):
    d :: object
    r0 :: dict
    r1 :: str
    r2 :: object[1]
    r3 :: object_ptr
    r4, r5, r6 :: object
    r7 :: tuple[object, object]
    r8, r9, r10, r11 :: object
    r12 :: tuple[object, object]
    r13 :: object
    r14 :: i32
    r15 :: bit
    r16 :: bool
    r17 :: union[list, tuple]
    r18 :: object
    r19 :: i32
    r20, r21 :: bit
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: i32
    r26 :: bit
    r27 :: bool
    r28 :: dank_mids.helpers.hashing.AttributeDict
    r29 :: i32
    r30 :: bit
    r31 :: dict
    r32 :: str
    r33 :: object
    r34 :: i32
    r35 :: bit
    r36 :: bool
    r37, r38, r39 :: str
    r40 :: object
    r41 :: str
    r42 :: object
    r43, r44 :: str
    r45 :: object[3]
    r46 :: object_ptr
    r47 :: object
    r48, r49, r50, r51 :: str
    r52 :: object[3]
    r53 :: object_ptr
    r54 :: object
    r55 :: list
    r56, r57, r58, r59, r60 :: ptr
    r61 :: str
    r62 :: object
    r63 :: str
    r64 :: object
    r65 :: object[1]
    r66 :: object_ptr
    r67 :: object
    r68 :: i32
    r69, r70 :: bit
    r71 :: tuple
    r72 :: dict
    r73, r74 :: dank_mids.helpers.hashing.AttributeDict
L0:
    r0 = PyDict_New()
    if is_error(r0) goto L34 (error at tupleize_lists_nested:136) else goto L1
L1:
    r1 = 'items'
    r2 = [d]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775809, 0)
    if is_error(r4) goto L35 (error at tupleize_lists_nested:137) else goto L2
L2:
    r5 = PyObject_GetIter(r4)
    dec_ref r4
    if is_error(r5) goto L35 (error at tupleize_lists_nested:137) else goto L3
L3:
    r6 = PyIter_Next(r5)
    if is_error(r6) goto L36 else goto L4
L4:
    r7 = unbox(tuple[object, object], r6)
    dec_ref r6
    if is_error(r7) goto L37 (error at tupleize_lists_nested:137) else goto L5
L5:
    r8 = r7[0]
    r9 = r7[1]
    dec_ref r7
    r10 = load_address PyList_Type
    r11 = load_address PyTuple_Type
    inc_ref r10
    inc_ref r11
    r12 = (r10, r11)
    r13 = box(tuple[object, object], r12)
    r14 = PyObject_IsInstance(r9, r13)
    dec_ref r13
    r15 = r14 >= 0 :: signed
    if not r15 goto L38 (error at tupleize_lists_nested:138) else goto L6 :: bool
L6:
    r16 = truncate r14: i32 to builtins.bool
    if r16 goto L7 else goto L10 :: bool
L7:
    r17 = cast(union[list, tuple], r9)
    if is_error(r17) goto L39 (error at tupleize_lists_nested:139) else goto L8
L8:
    r18 = _to_tuple(r17)
    dec_ref r17
    if is_error(r18) goto L39 (error at tupleize_lists_nested:139) else goto L9
L9:
    r19 = CPyDict_SetItem(r0, r8, r18)
    dec_ref r8
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L37 (error at tupleize_lists_nested:139) else goto L3 :: bool
L10:
    r21 = PyDict_Check(r9)
    if r21 goto L14 else goto L11 :: bool
L11:
    r22 = dank_mids.helpers.hashing.globals :: static
    r23 = 'Mapping'
    r24 = CPyDict_GetItem(r22, r23)
    if is_error(r24) goto L38 (error at tupleize_lists_nested:140) else goto L12
L12:
    r25 = PyObject_IsInstance(r9, r24)
    dec_ref r24
    r26 = r25 >= 0 :: signed
    if not r26 goto L38 (error at tupleize_lists_nested:140) else goto L13 :: bool
L13:
    r27 = truncate r25: i32 to builtins.bool
    if r27 goto L14 else goto L16 :: bool
L14:
    r28 = tupleize_lists_nested(r9)
    dec_ref r9
    if is_error(r28) goto L39 (error at tupleize_lists_nested:141) else goto L15
L15:
    r29 = CPyDict_SetItem(r0, r8, r28)
    dec_ref r8
    dec_ref r28
    r30 = r29 >= 0 :: signed
    if not r30 goto L37 (error at tupleize_lists_nested:141) else goto L3 :: bool
L16:
    r31 = dank_mids.helpers.hashing.globals :: static
    r32 = 'Hashable'
    r33 = CPyDict_GetItem(r31, r32)
    if is_error(r33) goto L38 (error at tupleize_lists_nested:142) else goto L17
L17:
    r34 = PyObject_IsInstance(r9, r33)
    dec_ref r33
    r35 = r34 >= 0 :: signed
    if not r35 goto L38 (error at tupleize_lists_nested:142) else goto L18 :: bool
L18:
    r36 = truncate r34: i32 to builtins.bool
    if r36 goto L28 else goto L40 :: bool
L19:
    r37 = ''
    r38 = "Found unhashable type '"
    r39 = '{:{}}'
    r40 = PyObject_Type(r9)
    r41 = '__name__'
    r42 = CPyObject_GetAttr(r40, r41)
    dec_ref r40
    if is_error(r42) goto L41 (error at tupleize_lists_nested:143) else goto L20
L20:
    r43 = ''
    r44 = 'format'
    r45 = [r39, r42, r43]
    r46 = load_address r45
    r47 = PyObject_VectorcallMethod(r44, r46, 9223372036854775811, 0)
    if is_error(r47) goto L42 (error at tupleize_lists_nested:143) else goto L21
L21:
    dec_ref r42
    r48 = "': "
    r49 = '{:{}}'
    r50 = ''
    r51 = 'format'
    r52 = [r49, r9, r50]
    r53 = load_address r52
    r54 = PyObject_VectorcallMethod(r51, r53, 9223372036854775811, 0)
    if is_error(r54) goto L43 (error at tupleize_lists_nested:143) else goto L22
L22:
    dec_ref r9
    r55 = PyList_New(4)
    if is_error(r55) goto L44 (error at tupleize_lists_nested:143) else goto L23
L23:
    r56 = get_element_ptr r55 ob_item :: PyListObject
    r57 = load_mem r56 :: ptr*
    inc_ref r38
    set_mem r57, r38 :: builtins.object*
    r58 = r57 + 8
    set_mem r58, r47 :: builtins.object*
    inc_ref r48
    r59 = r57 + 16
    set_mem r59, r48 :: builtins.object*
    r60 = r57 + 24
    set_mem r60, r54 :: builtins.object*
    r61 = PyUnicode_Join(r37, r55)
    dec_ref r55
    if is_error(r61) goto L34 (error at tupleize_lists_nested:143) else goto L24
L24:
    r62 = builtins :: module
    r63 = 'TypeError'
    r64 = CPyObject_GetAttr(r62, r63)
    if is_error(r64) goto L45 (error at tupleize_lists_nested:143) else goto L25
L25:
    r65 = [r61]
    r66 = load_address r65
    r67 = PyObject_Vectorcall(r64, r66, 1, 0)
    dec_ref r64
    if is_error(r67) goto L45 (error at tupleize_lists_nested:143) else goto L26
L26:
    dec_ref r61
    CPy_Raise(r67)
    dec_ref r67
    if not 0 goto L34 (error at tupleize_lists_nested:143) else goto L27 :: bool
L27:
    unreachable
L28:
    r68 = CPyDict_SetItem(r0, r8, r9)
    dec_ref r8
    dec_ref r9
    r69 = r68 >= 0 :: signed
    if not r69 goto L37 (error at tupleize_lists_nested:145) else goto L3 :: bool
L29:
    r70 = CPy_NoErrOccurred()
    if not r70 goto L35 (error at tupleize_lists_nested:137) else goto L30 :: bool
L30:
    r71 = PyTuple_Pack(0)
    if is_error(r71) goto L35 (error at tupleize_lists_nested:146) else goto L31
L31:
    r72 = PyDict_New()
    if is_error(r72) goto L46 (error at tupleize_lists_nested:146) else goto L32
L32:
    r73 = AttributeDict(r0, r71, r72)
    dec_ref r0
    dec_ref r71
    dec_ref r72
    if is_error(r73) goto L34 (error at tupleize_lists_nested:146) else goto L33
L33:
    return r73
L34:
    r74 = <error> :: dank_mids.helpers.hashing.AttributeDict
    return r74
L35:
    dec_ref r0
    goto L34
L36:
    dec_ref r5
    goto L29
L37:
    dec_ref r0
    dec_ref r5
    goto L34
L38:
    dec_ref r0
    dec_ref r5
    dec_ref r8
    dec_ref r9
    goto L34
L39:
    dec_ref r0
    dec_ref r5
    dec_ref r8
    goto L34
L40:
    dec_ref r0
    dec_ref r5
    dec_ref r8
    goto L19
L41:
    dec_ref r9
    goto L34
L42:
    dec_ref r9
    dec_ref r42
    goto L34
L43:
    dec_ref r9
    dec_ref r47
    goto L34
L44:
    dec_ref r47
    dec_ref r54
    goto L34
L45:
    dec_ref r61
    goto L34
L46:
    dec_ref r0
    dec_ref r71
    goto L34

def __mypyc_singledispatch_main_function__to_tuple__(value):
    value :: union[list, tuple]
    r0 :: list
    r1, r2, r3, r4 :: object
    r5 :: tuple[object, object]
    r6 :: object
    r7 :: i32
    r8 :: bit
    r9 :: bool
    r10 :: union[list, tuple]
    r11, r12 :: object
    r13 :: i32
    r14, r15 :: bit
    r16 :: tuple
    r17 :: object
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L13 (error at _to_tuple:151) else goto L1
L1:
    r1 = PyObject_GetIter(value)
    if is_error(r1) goto L14 (error at _to_tuple:151) else goto L2
L2:
    r2 = PyIter_Next(r1)
    if is_error(r2) goto L15 else goto L3
L3:
    r3 = load_address PyList_Type
    r4 = load_address PyTuple_Type
    inc_ref r3
    inc_ref r4
    r5 = (r3, r4)
    r6 = box(tuple[object, object], r5)
    r7 = PyObject_IsInstance(r2, r6)
    dec_ref r6
    r8 = r7 >= 0 :: signed
    if not r8 goto L16 (error at _to_tuple:151) else goto L4 :: bool
L4:
    r9 = truncate r7: i32 to builtins.bool
    if r9 goto L5 else goto L8 :: bool
L5:
    r10 = cast(union[list, tuple], r2)
    if is_error(r10) goto L17 (error at _to_tuple:151) else goto L6
L6:
    r11 = _to_tuple(r10)
    dec_ref r10
    if is_error(r11) goto L17 (error at _to_tuple:151) else goto L7
L7:
    r12 = r11
    goto L9
L8:
    r12 = r2
L9:
    r13 = PyList_Append(r0, r12)
    dec_ref r12
    r14 = r13 >= 0 :: signed
    if not r14 goto L17 (error at _to_tuple:151) else goto L2 :: bool
L10:
    r15 = CPy_NoErrOccurred()
    if not r15 goto L14 (error at _to_tuple:151) else goto L11 :: bool
L11:
    r16 = PyList_AsTuple(r0)
    dec_ref r0
    if is_error(r16) goto L13 (error at _to_tuple:151) else goto L12
L12:
    return r16
L13:
    r17 = <error> :: object
    return r17
L14:
    dec_ref r0
    goto L13
L15:
    dec_ref r1
    goto L10
L16:
    dec_ref r0
    dec_ref r1
    dec_ref r2
    goto L13
L17:
    dec_ref r0
    dec_ref r1
    goto L13

def _to_tuple_obj.__init__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers.hashing._to_tuple_obj
    r0, r1 :: dict
    r2 :: str
    r3 :: i32
    r4 :: bit
    r5 :: bool
L0:
    r0 = PyDict_New()
    if is_error(r0) goto L4 else goto L1
L1:
    __mypyc_self__.registry = r0
    r1 = PyDict_New()
    if is_error(r1) goto L4 else goto L2
L2:
    r2 = 'dispatch_cache'
    r3 = PyObject_SetAttr(__mypyc_self__, r2, r1)
    dec_ref r1
    r4 = r3 >= 0 :: signed
    if not r4 goto L4 else goto L3 :: bool
L3:
    return 1
L4:
    r5 = <error> :: bool
    return r5

def _to_tuple_obj.__call__(__mypyc_self__, value):
    __mypyc_self__ :: dank_mids.helpers.hashing._to_tuple_obj
    value :: union[list, tuple]
    r0 :: ptr
    r1 :: object
    r2 :: dict
    r3, r4 :: object
    r5 :: bit
    r6, r7 :: object
    r8 :: str
    r9 :: object
    r10 :: dict
    r11 :: object[2]
    r12 :: object_ptr
    r13 :: object
    r14 :: i32
    r15 :: bit
    r16 :: object
    r17 :: ptr
    r18 :: object
    r19 :: bit
    r20 :: int
    r21 :: bit
    r22 :: list
    r23 :: object
    r24 :: bit
    r25 :: tuple
    r26 :: object
    r27 :: object[1]
    r28 :: object_ptr
    r29, r30 :: object
L0:
    r0 = get_element_ptr value ob_type :: PyObject
    r1 = borrow load_mem r0 :: builtins.object*
    r2 = __mypyc_self__.dispatch_cache
    if is_error(r2) goto L21 (error at _to_tuple:150) else goto L1
L1:
    r3 = CPyDict_GetWithNone(r2, r1)
    if is_error(r3) goto L22 (error at _to_tuple:150) else goto L2
L2:
    r4 = load_address _Py_NoneStruct
    r5 = r3 != r4
    if r5 goto L23 else goto L24 :: bool
L3:
    r6 = r3
    goto L8
L4:
    r7 = functools :: module
    r8 = '_find_impl'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L22 (error at _to_tuple:150) else goto L5
L5:
    r10 = __mypyc_self__.registry
    r11 = [r1, r10]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r9, r12, 2, 0)
    dec_ref r9
    if is_error(r13) goto L25 (error at _to_tuple:150) else goto L6
L6:
    dec_ref r10
    r14 = CPyDict_SetItem(r2, r1, r13)
    dec_ref r2
    r15 = r14 >= 0 :: signed
    if not r15 goto L26 (error at _to_tuple:150) else goto L7 :: bool
L7:
    r6 = r13
L8:
    r16 = load_address PyLong_Type
    r17 = get_element_ptr r6 ob_type :: PyObject
    r18 = borrow load_mem r17 :: builtins.object*
    r19 = r18 == r16
    if r19 goto L9 else goto L19 :: bool
L9:
    r20 = unbox(int, r6)
    dec_ref r6
    if is_error(r20) goto L21 (error at _to_tuple:150) else goto L10
L10:
    r21 = r20 == 0
    if r21 goto L27 else goto L14 :: bool
L11:
    inc_ref value
    r22 = cast(list, value)
    if is_error(r22) goto L21 (error at _to_tuple:150) else goto L12
L12:
    r23 = _(r22)
    dec_ref r22
    if is_error(r23) goto L21 (error at _to_tuple:150) else goto L13
L13:
    return r23
L14:
    r24 = r20 == 2
    dec_ref r20 :: int
    if r24 goto L15 else goto L18 :: bool
L15:
    inc_ref value
    r25 = cast(tuple, value)
    if is_error(r25) goto L21 (error at _to_tuple:150) else goto L16
L16:
    r26 = _(r25)
    dec_ref r25
    if is_error(r26) goto L21 (error at _to_tuple:150) else goto L17
L17:
    return r26
L18:
    unreachable
L19:
    r27 = [value]
    r28 = load_address r27
    r29 = PyObject_Vectorcall(r6, r28, 1, 0)
    dec_ref r6
    if is_error(r29) goto L21 (error at _to_tuple:150) else goto L20
L20:
    return r29
L21:
    r30 = <error> :: object
    return r30
L22:
    dec_ref r2
    goto L21
L23:
    dec_ref r2
    goto L3
L24:
    dec_ref r3
    goto L4
L25:
    dec_ref r2
    dec_ref r10
    goto L21
L26:
    dec_ref r13
    goto L21
L27:
    dec_ref r20 :: int
    goto L11

def _to_tuple_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def _to_tuple_obj.register(__mypyc_self__, cls, func):
    __mypyc_self__ :: dank_mids.helpers.hashing._to_tuple_obj
    cls, func, r0, r1 :: object
L0:
    r0 = CPySingledispatch_RegisterFunction(__mypyc_self__, cls, func)
    if is_error(r0) goto L2 else goto L1
L1:
    return r0
L2:
    r1 = <error> :: object
    return r1

def _to_tuple(value):
    value :: union[list, tuple]
    r0 :: dict
    r1 :: str
    r2, r3, r4 :: object
L0:
    r0 = dank_mids.helpers.hashing.globals :: static
    r1 = '_to_tuple'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L3 else goto L1
L1:
    r3 = _to_tuple_obj.__call__(r2, value)
    dec_ref r2
    if is_error(r3) goto L3 else goto L2
L2:
    return r3
L3:
    r4 = <error> :: object
    return r4

def _(value):
    value :: list
    r0 :: ptr
    r1 :: native_int
    r2 :: tuple
    r3 :: native_int
    r4 :: ptr
    r5 :: native_int
    r6 :: bit
    r7, r8 :: ptr
    r9 :: native_int
    r10 :: ptr
    r11, r12, r13 :: object
    r14 :: tuple[object, object]
    r15 :: object
    r16 :: i32
    r17 :: bit
    r18 :: bool
    r19 :: union[list, tuple]
    r20, r21 :: object
    r22 :: native_int
    r23 :: object
L0:
    r0 = get_element_ptr value ob_size :: PyVarObject
    r1 = load_mem r0 :: native_int*
    r2 = PyTuple_New(r1)
    if is_error(r2) goto L12 (error at _:156) else goto L1
L1:
    r3 = 0
L2:
    r4 = get_element_ptr value ob_size :: PyVarObject
    r5 = load_mem r4 :: native_int*
    r6 = r3 < r5 :: signed
    if r6 goto L3 else goto L11 :: bool
L3:
    r7 = get_element_ptr value ob_item :: PyListObject
    r8 = load_mem r7 :: ptr*
    r9 = r3 * 8
    r10 = r8 + r9
    r11 = load_mem r10 :: builtins.object*
    r12 = load_address PyList_Type
    r13 = load_address PyTuple_Type
    inc_ref r12
    inc_ref r13
    r14 = (r12, r13)
    r15 = box(tuple[object, object], r14)
    r16 = PyObject_IsInstance(r11, r15)
    dec_ref r15
    r17 = r16 >= 0 :: signed
    if not r17 goto L13 (error at _:156) else goto L4 :: bool
L4:
    r18 = truncate r16: i32 to builtins.bool
    if r18 goto L5 else goto L8 :: bool
L5:
    r19 = cast(union[list, tuple], r11)
    if is_error(r19) goto L14 (error at _:156) else goto L6
L6:
    r20 = _to_tuple(r19)
    dec_ref r19
    if is_error(r20) goto L14 (error at _:156) else goto L7
L7:
    r21 = r20
    goto L9
L8:
    r21 = r11
L9:
    CPySequenceTuple_SetItemUnsafe(r2, r3, r21)
L10:
    r22 = r3 + 1
    r3 = r22
    goto L2
L11:
    return r2
L12:
    r23 = <error> :: object
    return r23
L13:
    dec_ref r2
    dec_ref r11
    goto L12
L14:
    dec_ref r2
    goto L12

def _(value):
    value :: tuple
    r0 :: ptr
    r1 :: native_int
    r2 :: tuple
    r3 :: native_int
    r4 :: ptr
    r5 :: native_int
    r6 :: bit
    r7, r8, r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: i32
    r13 :: bit
    r14 :: bool
    r15 :: union[list, tuple]
    r16, r17 :: object
    r18 :: native_int
    r19 :: object
L0:
    r0 = get_element_ptr value ob_size :: PyVarObject
    r1 = load_mem r0 :: native_int*
    r2 = PyTuple_New(r1)
    if is_error(r2) goto L12 (error at _:161) else goto L1
L1:
    r3 = 0
L2:
    r4 = get_element_ptr value ob_size :: PyVarObject
    r5 = load_mem r4 :: native_int*
    r6 = r3 < r5 :: signed
    if r6 goto L3 else goto L11 :: bool
L3:
    r7 = CPySequenceTuple_GetItemUnsafe(value, r3)
    r8 = load_address PyList_Type
    r9 = load_address PyTuple_Type
    inc_ref r8
    inc_ref r9
    r10 = (r8, r9)
    r11 = box(tuple[object, object], r10)
    r12 = PyObject_IsInstance(r7, r11)
    dec_ref r11
    r13 = r12 >= 0 :: signed
    if not r13 goto L13 (error at _:161) else goto L4 :: bool
L4:
    r14 = truncate r12: i32 to builtins.bool
    if r14 goto L5 else goto L8 :: bool
L5:
    r15 = cast(union[list, tuple], r7)
    if is_error(r15) goto L14 (error at _:161) else goto L6
L6:
    r16 = _to_tuple(r15)
    dec_ref r15
    if is_error(r16) goto L14 (error at _:161) else goto L7
L7:
    r17 = r16
    goto L9
L8:
    r17 = r7
L9:
    CPySequenceTuple_SetItemUnsafe(r2, r3, r17)
L10:
    r18 = r3 + 1
    r3 = r18
    goto L2
L11:
    return r2
L12:
    r19 = <error> :: object
    return r19
L13:
    dec_ref r2
    dec_ref r7
    goto L12
L14:
    dec_ref r2
    goto L12

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22 :: object
    r23 :: str
    r24 :: dict
    r25 :: str
    r26 :: object
    r27 :: dict
    r28 :: str
    r29 :: object
    r30 :: object[2]
    r31 :: object_ptr
    r32, r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: i32
    r37 :: bit
    r38 :: str
    r39 :: dict
    r40 :: str
    r41 :: object
    r42 :: object[1]
    r43 :: object_ptr
    r44 :: object
    r45 :: dict
    r46 :: str
    r47 :: i32
    r48 :: bit
    r49 :: dict
    r50 :: str
    r51 :: object
    r52 :: dict
    r53 :: str
    r54 :: object
    r55 :: dict
    r56 :: str
    r57 :: object
    r58 :: tuple[object, object]
    r59, r60 :: object
    r61 :: dict
    r62 :: str
    r63 :: object
    r64 :: tuple
    r65 :: str
    r66, r67 :: object
    r68 :: bool
    r69, r70, r71, r72 :: str
    r73 :: tuple
    r74 :: i32
    r75 :: bit
    r76 :: dict
    r77 :: str
    r78 :: i32
    r79 :: bit
    r80 :: dank_mids.helpers.hashing._to_tuple_obj
    _to_tuple :: object
    r81 :: dict
    r82 :: str
    r83 :: i32
    r84 :: bit
    r85 :: dict
    r86 :: str
    r87, r88 :: object
    r89 :: str
    r90 :: object
    r91, r92 :: dict
    r93 :: str
    r94 :: object
    r95 :: str
    r96 :: i32
    r97 :: bit
    r98 :: object
    r99 :: dict
    r100 :: str
    r101 :: object
    r102 :: str
    r103, r104 :: object
    r105 :: dict
    r106 :: i32
    r107 :: bit
    r108 :: str
    r109 :: object
    r110 :: str
    r111 :: object[1]
    r112 :: object_ptr
    r113, r114 :: object
    r115 :: dict
    r116 :: str
    r117 :: object
    r118 :: str
    r119, r120 :: object
    r121 :: dict
    r122 :: i32
    r123 :: bit
    r124 :: str
    r125 :: object
    r126 :: str
    r127 :: object[1]
    r128 :: object_ptr
    r129 :: object
    r130 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L44 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address functools :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('functools', 'functools', 'functools'),)
    r11 = dank_mids.helpers.hashing.globals :: static
    r12 = 'dank_mids/helpers/hashing.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L44 else goto L4 :: bool
L4:
    r15 = ('Hashable',)
    r16 = 'collections.abc'
    r17 = dank_mids.helpers.hashing.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L44 (error at <module>:2) else goto L5
L5:
    collections.abc = r18 :: module
    dec_ref r18
    r19 = ('Any', 'Dict', 'Final', 'ItemsView', 'Iterator', 'KeysView', 'List', 'Mapping', 'Optional', 'Sequence', 'Tuple', 'TypeVar', 'Union', 'ValuesView', 'final')
    r20 = 'typing'
    r21 = dank_mids.helpers.hashing.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L44 (error at <module>:3) else goto L6
L6:
    typing = r22 :: module
    dec_ref r22
    r23 = 'TKey'
    r24 = dank_mids.helpers.hashing.globals :: static
    r25 = 'Hashable'
    r26 = CPyDict_GetItem(r24, r25)
    if is_error(r26) goto L44 (error at <module>:22) else goto L7
L7:
    r27 = dank_mids.helpers.hashing.globals :: static
    r28 = 'TypeVar'
    r29 = CPyDict_GetItem(r27, r28)
    if is_error(r29) goto L45 (error at <module>:22) else goto L8
L8:
    r30 = [r23, r26]
    r31 = load_address r30
    r32 = ('bound',)
    r33 = PyObject_Vectorcall(r29, r31, 1, r32)
    dec_ref r29
    if is_error(r33) goto L45 (error at <module>:22) else goto L9
L9:
    dec_ref r26
    r34 = dank_mids.helpers.hashing.globals :: static
    r35 = 'TKey'
    r36 = CPyDict_SetItem(r34, r35, r33)
    dec_ref r33
    r37 = r36 >= 0 :: signed
    if not r37 goto L44 (error at <module>:22) else goto L10 :: bool
L10:
    r38 = 'TValue'
    r39 = dank_mids.helpers.hashing.globals :: static
    r40 = 'TypeVar'
    r41 = CPyDict_GetItem(r39, r40)
    if is_error(r41) goto L44 (error at <module>:23) else goto L11
L11:
    r42 = [r38]
    r43 = load_address r42
    r44 = PyObject_Vectorcall(r41, r43, 1, 0)
    dec_ref r41
    if is_error(r44) goto L44 (error at <module>:23) else goto L12
L12:
    r45 = dank_mids.helpers.hashing.globals :: static
    r46 = 'TValue'
    r47 = CPyDict_SetItem(r45, r46, r44)
    dec_ref r44
    r48 = r47 >= 0 :: signed
    if not r48 goto L44 (error at <module>:23) else goto L13 :: bool
L13:
    r49 = dank_mids.helpers.hashing.globals :: static
    r50 = 'Mapping'
    r51 = CPyDict_GetItem(r49, r50)
    if is_error(r51) goto L44 (error at <module>:44) else goto L14
L14:
    r52 = dank_mids.helpers.hashing.globals :: static
    r53 = 'TKey'
    r54 = CPyDict_GetItem(r52, r53)
    if is_error(r54) goto L46 (error at <module>:44) else goto L15
L15:
    r55 = dank_mids.helpers.hashing.globals :: static
    r56 = 'TValue'
    r57 = CPyDict_GetItem(r55, r56)
    if is_error(r57) goto L47 (error at <module>:44) else goto L16
L16:
    r58 = (r54, r57)
    r59 = box(tuple[object, object], r58)
    r60 = PyObject_GetItem(r51, r59)
    dec_ref r51
    dec_ref r59
    if is_error(r60) goto L44 (error at <module>:44) else goto L17
L17:
    r61 = dank_mids.helpers.hashing.globals :: static
    r62 = 'Hashable'
    r63 = CPyDict_GetItem(r61, r62)
    if is_error(r63) goto L48 (error at <module>:44) else goto L18
L18:
    r64 = PyTuple_Pack(2, r60, r63)
    dec_ref r60
    dec_ref r63
    if is_error(r64) goto L44 (error at <module>:44) else goto L19
L19:
    r65 = 'dank_mids.helpers.hashing'
    r66 = dank_mids.helpers.hashing.AttributeDict_template :: type
    r67 = CPyType_FromTemplate(r66, r64, r65)
    dec_ref r64
    if is_error(r67) goto L44 (error at <module>:44) else goto L20
L20:
    r68 = AttributeDict_trait_vtable_setup()
    if is_error(r68) goto L49 (error at <module>:-1) else goto L21
L21:
    r69 = '__mypyc_attrs__'
    r70 = '__dict__'
    r71 = '__hash'
    r72 = '__dict__'
    r73 = PyTuple_Pack(3, r70, r71, r72)
    if is_error(r73) goto L49 (error at <module>:44) else goto L22
L22:
    r74 = PyObject_SetAttr(r67, r69, r73)
    dec_ref r73
    r75 = r74 >= 0 :: signed
    if not r75 goto L49 (error at <module>:44) else goto L23 :: bool
L23:
    dank_mids.helpers.hashing.AttributeDict = r67 :: type
    r76 = dank_mids.helpers.hashing.globals :: static
    r77 = 'AttributeDict'
    r78 = CPyDict_SetItem(r76, r77, r67)
    dec_ref r67
    r79 = r78 >= 0 :: signed
    if not r79 goto L44 (error at <module>:44) else goto L24 :: bool
L24:
    r80 = _to_tuple_obj()
    if is_error(r80) goto L44 (error at <module>:150) else goto L25
L25:
    inc_ref r80
    _to_tuple = r80
    dec_ref _to_tuple
    r81 = dank_mids.helpers.hashing.globals :: static
    r82 = '_to_tuple'
    r83 = CPyDict_SetItem(r81, r82, r80)
    dec_ref r80
    r84 = r83 >= 0 :: signed
    if not r84 goto L44 (error at <module>:150) else goto L26 :: bool
L26:
    r85 = dank_mids.helpers.hashing.globals :: static
    r86 = '__mypyc_singledispatch_main_function__to_tuple__'
    r87 = CPyDict_GetItem(r85, r86)
    if is_error(r87) goto L44 (error at <module>:150) else goto L27
L27:
    r88 = builtins :: module
    r89 = 'object'
    r90 = CPyObject_GetAttr(r88, r89)
    if is_error(r90) goto L50 (error at <module>:150) else goto L28
L28:
    r91 = CPyDict_Build(1, r90, r87)
    dec_ref r90
    dec_ref r87
    if is_error(r91) goto L44 (error at <module>:150) else goto L29
L29:
    r92 = dank_mids.helpers.hashing.globals :: static
    r93 = '_to_tuple'
    r94 = CPyDict_GetItem(r92, r93)
    if is_error(r94) goto L51 (error at <module>:150) else goto L30
L30:
    r95 = 'registry'
    r96 = PyObject_SetAttr(r94, r95, r91)
    dec_ref r94
    dec_ref r91
    r97 = r96 >= 0 :: signed
    if not r97 goto L44 (error at <module>:150) else goto L31 :: bool
L31:
    r98 = object 0
    r99 = dank_mids.helpers.hashing.globals :: static
    r100 = '_to_tuple'
    r101 = CPyDict_GetItem(r99, r100)
    if is_error(r101) goto L44 (error at <module>:155) else goto L32
L32:
    r102 = 'registry'
    r103 = CPyObject_GetAttr(r101, r102)
    if is_error(r103) goto L52 (error at <module>:155) else goto L33
L33:
    r104 = load_address PyList_Type
    r105 = cast(dict, r103)
    if is_error(r105) goto L52 (error at <module>:155) else goto L34
L34:
    r106 = CPyDict_SetItem(r105, r104, r98)
    dec_ref r105
    r107 = r106 >= 0 :: signed
    if not r107 goto L52 (error at <module>:155) else goto L35 :: bool
L35:
    r108 = 'dispatch_cache'
    r109 = CPyObject_GetAttr(r101, r108)
    dec_ref r101
    if is_error(r109) goto L44 (error at <module>:155) else goto L36
L36:
    r110 = 'clear'
    r111 = [r109]
    r112 = load_address r111
    r113 = PyObject_VectorcallMethod(r110, r112, 9223372036854775809, 0)
    if is_error(r113) goto L53 (error at <module>:155) else goto L54
L37:
    dec_ref r109
    r114 = object 1
    r115 = dank_mids.helpers.hashing.globals :: static
    r116 = '_to_tuple'
    r117 = CPyDict_GetItem(r115, r116)
    if is_error(r117) goto L44 (error at <module>:160) else goto L38
L38:
    r118 = 'registry'
    r119 = CPyObject_GetAttr(r117, r118)
    if is_error(r119) goto L55 (error at <module>:160) else goto L39
L39:
    r120 = load_address PyTuple_Type
    r121 = cast(dict, r119)
    if is_error(r121) goto L55 (error at <module>:160) else goto L40
L40:
    r122 = CPyDict_SetItem(r121, r120, r114)
    dec_ref r121
    r123 = r122 >= 0 :: signed
    if not r123 goto L55 (error at <module>:160) else goto L41 :: bool
L41:
    r124 = 'dispatch_cache'
    r125 = CPyObject_GetAttr(r117, r124)
    dec_ref r117
    if is_error(r125) goto L44 (error at <module>:160) else goto L42
L42:
    r126 = 'clear'
    r127 = [r125]
    r128 = load_address r127
    r129 = PyObject_VectorcallMethod(r126, r128, 9223372036854775809, 0)
    if is_error(r129) goto L56 (error at <module>:160) else goto L57
L43:
    dec_ref r125
    return 1
L44:
    r130 = <error> :: None
    return r130
L45:
    dec_ref r26
    goto L44
L46:
    dec_ref r51
    goto L44
L47:
    dec_ref r51
    dec_ref r54
    goto L44
L48:
    dec_ref r60
    goto L44
L49:
    dec_ref r67
    goto L44
L50:
    dec_ref r87
    goto L44
L51:
    dec_ref r91
    goto L44
L52:
    dec_ref r101
    goto L44
L53:
    dec_ref r109
    goto L44
L54:
    dec_ref r113
    goto L37
L55:
    dec_ref r117
    goto L44
L56:
    dec_ref r125
    goto L44
L57:
    dec_ref r129
    goto L43

def Formatter.__init__(self, normalizers, types):
    self :: dank_mids._web3.abi.Formatter
    normalizers, types :: tuple
    r0 :: ptr
    r1 :: native_int
    r2 :: tuple
    r3 :: native_int
    r4 :: ptr
    r5 :: native_int
    r6 :: bit
    r7 :: object
    r8 :: dank_mids._web3.abi.map_to_typed_data
    r9 :: native_int
    r10 :: ptr
    r11 :: native_int
    r12 :: tuple
    r13 :: native_int
    r14 :: ptr
    r15 :: native_int
    r16 :: bit
    r17 :: object
    r18 :: union[str, None]
    r19 :: bit
    r20 :: str
    r21 :: object
    r22 :: bool
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: union[object, None]
    r27 :: object
    r28 :: native_int
    r29 :: None
L0:
    r0 = get_element_ptr normalizers ob_size :: PyVarObject
    r1 = load_mem r0 :: native_int*
    r2 = PyTuple_New(r1)
    if is_error(r2) goto L21 (error at __init__:33) else goto L1
L1:
    r3 = 0
L2:
    r4 = get_element_ptr normalizers ob_size :: PyVarObject
    r5 = load_mem r4 :: native_int*
    r6 = r3 < r5 :: signed
    if r6 goto L3 else goto L6 :: bool
L3:
    r7 = CPySequenceTuple_GetItemUnsafe(normalizers, r3)
    r8 = get_data_tree_map(r7)
    dec_ref r7
    if is_error(r8) goto L22 (error at __init__:33) else goto L4
L4:
    CPySequenceTuple_SetItemUnsafe(r2, r3, r8)
L5:
    r9 = r3 + 1
    r3 = r9
    goto L2
L6:
    self.normalizers = r2
    r10 = get_element_ptr types ob_size :: PyVarObject
    r11 = load_mem r10 :: native_int*
    r12 = PyTuple_New(r11)
    if is_error(r12) goto L21 (error at __init__:34) else goto L7
L7:
    r13 = 0
L8:
    r14 = get_element_ptr types ob_size :: PyVarObject
    r15 = load_mem r14 :: native_int*
    r16 = r13 < r15 :: signed
    if r16 goto L9 else goto L20 :: bool
L9:
    r17 = CPySequenceTuple_GetItemUnsafe(types, r13)
    r18 = cast(union[str, None], r17)
    if is_error(r18) goto L23 (error at __init__:34) else goto L10
L10:
    r19 = PyUnicode_Check(r18)
    if r19 goto L11 else goto L24 :: bool
L11:
    r20 = cast(str, r18)
    if is_error(r20) goto L23 (error at __init__:35) else goto L12
L12:
    r21 = dank_mids._web3.abi.parse :: static
    if is_error(r21) goto L25 else goto L15
L13:
    r22 = raise NameError('value for final name "parse" was not set')
    if not r22 goto L21 (error at __init__:35) else goto L14 :: bool
L14:
    unreachable
L15:
    r23 = [r20]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r21, r24, 1, 0)
    if is_error(r25) goto L26 (error at __init__:35) else goto L16
L16:
    dec_ref r20
    r26 = r25
    goto L18
L17:
    r27 = box(None, 1)
    inc_ref r27
    r26 = r27
L18:
    CPySequenceTuple_SetItemUnsafe(r12, r13, r26)
L19:
    r28 = r13 + 1
    r13 = r28
    goto L8
L20:
    self.types = r12
    return 1
L21:
    r29 = <error> :: None
    return r29
L22:
    dec_ref r2
    goto L21
L23:
    dec_ref r12
    goto L21
L24:
    dec_ref r18
    goto L17
L25:
    dec_ref r12
    dec_ref r20
    goto L13
L26:
    dec_ref r12
    dec_ref r20
    goto L21

def Formatter.__call__(self, data):
    self :: dank_mids._web3.abi.Formatter
    data :: object
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: tuple
    r4 :: object
    r5 :: str
    r6 :: object
    r7 :: object[3]
    r8 :: object_ptr
    r9 :: object
    r10 :: tuple
    r11 :: native_int
    r12 :: ptr
    r13 :: native_int
    r14 :: bit
    r15 :: object
    r16 :: dank_mids._web3.abi.map_to_typed_data
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20 :: native_int
    r21 :: object
    r22, r23 :: list
L0:
    r0 = dank_mids._web3.abi.globals :: static
    r1 = 'abi_sub_tree'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L12 (error at __call__:41) else goto L1
L1:
    r3 = self.types
    r4 = builtins :: module
    r5 = 'map'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L13 (error at __call__:41) else goto L2
L2:
    r7 = [r2, r3, data]
    r8 = load_address r7
    r9 = PyObject_Vectorcall(r6, r8, 3, 0)
    dec_ref r6
    if is_error(r9) goto L13 (error at __call__:41) else goto L3
L3:
    dec_ref r2
    dec_ref r3
    data = r9
    r10 = self.normalizers
    r11 = 0
L4:
    r12 = get_element_ptr r10 ob_size :: PyVarObject
    r13 = load_mem r12 :: native_int*
    r14 = r11 < r13 :: signed
    if r14 goto L5 else goto L14 :: bool
L5:
    r15 = CPySequenceTuple_GetItemUnsafe(r10, r11)
    r16 = cast(dank_mids._web3.abi.map_to_typed_data, r15)
    if is_error(r16) goto L15 (error at __call__:43) else goto L6
L6:
    r17 = [data]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r16, r18, 1, 0)
    dec_ref r16
    if is_error(r19) goto L15 (error at __call__:44) else goto L7
L7:
    dec_ref data
    data = r19
L8:
    r20 = r11 + 1
    r11 = r20
    goto L4
L9:
    r21 = strip_abi_types(data)
    dec_ref data
    if is_error(r21) goto L12 (error at __call__:46) else goto L10
L10:
    r22 = PySequence_List(r21)
    dec_ref r21
    if is_error(r22) goto L12 (error at __call__:46) else goto L11
L11:
    return r22
L12:
    r23 = <error> :: list
    return r23
L13:
    dec_ref r2
    dec_ref r3
    goto L12
L14:
    dec_ref r10
    goto L9
L15:
    dec_ref data
    dec_ref r10
    goto L12

def get_formatter(normalizers, types):
    normalizers, types :: tuple
    r0 :: dict
    r1 :: bool
    r2 :: tuple[tuple, tuple]
    r3, r4 :: object
    r5, mapper :: union[dank_mids._web3.abi.Formatter, None]
    r6 :: object
    r7 :: bit
    r8 :: dank_mids._web3.abi.Formatter
    r9 :: dict
    r10 :: bool
    r11 :: tuple[tuple, tuple]
    r12 :: object
    r13 :: i32
    r14 :: bit
    r15, r16 :: dank_mids._web3.abi.Formatter
L0:
    r0 = dank_mids._web3.abi._formatters :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_formatters" was not set')
    if not r1 goto L13 (error at get_formatter:58) else goto L2 :: bool
L2:
    unreachable
L3:
    inc_ref normalizers
    inc_ref types
    r2 = (normalizers, types)
    r3 = box(tuple[tuple, tuple], r2)
    r4 = CPyDict_GetWithNone(r0, r3)
    dec_ref r3
    if is_error(r4) goto L13 (error at get_formatter:58) else goto L4
L4:
    r5 = cast(union[dank_mids._web3.abi.Formatter, None], r4)
    if is_error(r5) goto L13 (error at get_formatter:58) else goto L5
L5:
    mapper = r5
    r6 = load_address _Py_NoneStruct
    r7 = mapper == r6
    if r7 goto L14 else goto L11 :: bool
L6:
    r8 = Formatter(normalizers, types)
    if is_error(r8) goto L13 (error at get_formatter:60) else goto L7
L7:
    inc_ref r8
    mapper = r8
    r9 = dank_mids._web3.abi._formatters :: static
    if is_error(r9) goto L15 else goto L10
L8:
    r10 = raise NameError('value for final name "_formatters" was not set')
    if not r10 goto L13 (error at get_formatter:60) else goto L9 :: bool
L9:
    unreachable
L10:
    inc_ref normalizers
    inc_ref types
    r11 = (normalizers, types)
    r12 = box(tuple[tuple, tuple], r11)
    r13 = CPyDict_SetItem(r9, r12, r8)
    dec_ref r12
    dec_ref r8
    r14 = r13 >= 0 :: signed
    if not r14 goto L16 (error at get_formatter:60) else goto L11 :: bool
L11:
    r15 = cast(dank_mids._web3.abi.Formatter, mapper)
    if is_error(r15) goto L13 (error at get_formatter:61) else goto L12
L12:
    return r15
L13:
    r16 = <error> :: dank_mids._web3.abi.Formatter
    return r16
L14:
    dec_ref mapper
    goto L6
L15:
    dec_ref mapper
    dec_ref r8
    goto L8
L16:
    dec_ref mapper
    goto L13

def get_data_tree_map(func):
    func :: object
    r0 :: dict
    r1 :: bool
    r2 :: object
    r3, f :: union[dank_mids._web3.abi.map_to_typed_data, None]
    r4 :: object
    r5 :: bit
    r6 :: dank_mids._web3.abi.map_to_typed_data
    r7 :: dict
    r8 :: bool
    r9 :: i32
    r10 :: bit
    r11, r12 :: dank_mids._web3.abi.map_to_typed_data
L0:
    r0 = dank_mids._web3.abi._data_tree_maps :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_data_tree_maps" was not set')
    if not r1 goto L13 (error at get_data_tree_map:70) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = CPyDict_GetWithNone(r0, func)
    if is_error(r2) goto L13 (error at get_data_tree_map:70) else goto L4
L4:
    r3 = cast(union[dank_mids._web3.abi.map_to_typed_data, None], r2)
    if is_error(r3) goto L13 (error at get_data_tree_map:70) else goto L5
L5:
    f = r3
    r4 = load_address _Py_NoneStruct
    r5 = f == r4
    if r5 goto L14 else goto L11 :: bool
L6:
    r6 = map_to_typed_data(func)
    if is_error(r6) goto L13 (error at get_data_tree_map:72) else goto L7
L7:
    inc_ref r6
    f = r6
    r7 = dank_mids._web3.abi._data_tree_maps :: static
    if is_error(r7) goto L15 else goto L10
L8:
    r8 = raise NameError('value for final name "_data_tree_maps" was not set')
    if not r8 goto L13 (error at get_data_tree_map:72) else goto L9 :: bool
L9:
    unreachable
L10:
    r9 = CPyDict_SetItem(r7, func, r6)
    dec_ref r6
    r10 = r9 >= 0 :: signed
    if not r10 goto L16 (error at get_data_tree_map:72) else goto L11 :: bool
L11:
    r11 = cast(dank_mids._web3.abi.map_to_typed_data, f)
    if is_error(r11) goto L13 (error at get_data_tree_map:73) else goto L12
L12:
    return r11
L13:
    r12 = <error> :: dank_mids._web3.abi.map_to_typed_data
    return r12
L14:
    dec_ref f
    goto L6
L15:
    dec_ref f
    dec_ref r6
    goto L8
L16:
    dec_ref f
    goto L13

def map_to_typed_data.__init__(self, func):
    self :: dank_mids._web3.abi.map_to_typed_data
    func :: object
L0:
    inc_ref func
    self.func = func
    return 1

def map_to_typed_data.__call__(self, elements):
    self :: dank_mids._web3.abi.map_to_typed_data
    elements, r0, r1 :: object
    r2 :: bit
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: bit
    r7 :: list
    r8, r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: i32
    r14, r15 :: bit
    r16 :: object
    r17 :: bit
    r18 :: list
    r19, r20 :: object
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: i32
    r25, r26 :: bit
    r27 :: tuple
    r28 :: object
    r29 :: bool
    r30 :: i32
    r31 :: bit
    r32 :: bool
    r33 :: list
    r34 :: str
    r35 :: object[1]
    r36 :: object_ptr
    r37, r38, r39 :: object
    r40 :: tuple[object, object]
    r41, r42 :: object
    r43 :: object[1]
    r44 :: object_ptr
    r45 :: object
    r46 :: tuple[object, object]
    r47 :: object
    r48 :: i32
    r49, r50 :: bit
    r51 :: object
    r52 :: object[1]
    r53 :: object_ptr
    r54, r55, r56, r57 :: object
    r58 :: str
    r59 :: object
    r60 :: tuple[object, object, object]
    r61 :: object
    r62 :: i32
    r63 :: bit
    r64 :: bool
    r65 :: object
    r66 :: bool
    r67 :: i32
    r68 :: bit
    r69 :: bool
    r70 :: object
    r71 :: str
    r72 :: object
    r73 :: object[2]
    r74 :: object_ptr
    r75 :: object
    r76 :: object[1]
    r77 :: object_ptr
    r78, r79 :: object
    r80 :: ptr
    r81 :: object
    r82 :: bit
    r83 :: dank_mids._web3.abi.ABITypedData
    r84 :: union[str, None]
    r85 :: object
    r86 :: bit
    r87 :: dank_mids._web3.abi.ABITypedData
    r88 :: str
    r89 :: object
    r90 :: list
    r91 :: object
    r92 :: tuple
    r93 :: dict
    r94 :: object
    r95 :: tuple[str, object]
    r96 :: object
    r97 :: list
    r98, r99 :: object
    r100 :: tuple
    r101 :: dict
    r102 :: object
    r103 :: dank_mids._web3.abi.ABITypedData
    r104 :: object
L0:
    r0 = PyObject_Type(elements)
    r1 = load_address PyList_Type
    r2 = r0 == r1
    if r2 goto L68 else goto L1 :: bool
L1:
    r3 = builtins :: module
    r4 = 'map'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L69 (error at __call__:83) else goto L2
L2:
    r6 = r0 == r5
    dec_ref r5
    if r6 goto L68 else goto L10 :: bool
L3:
    r7 = PyList_New(0)
    if is_error(r7) goto L67 (error at __call__:84) else goto L4
L4:
    r8 = PyObject_GetIter(elements)
    if is_error(r8) goto L70 (error at __call__:84) else goto L5
L5:
    r9 = PyIter_Next(r8)
    if is_error(r9) goto L71 else goto L6
L6:
    r10 = [r9]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(self, r11, 1, 0)
    if is_error(r12) goto L72 (error at __call__:84) else goto L7
L7:
    dec_ref r9
    r13 = PyList_Append(r7, r12)
    dec_ref r12
    r14 = r13 >= 0 :: signed
    if not r14 goto L73 (error at __call__:84) else goto L5 :: bool
L8:
    r15 = CPy_NoErrOccurred()
    if not r15 goto L70 (error at __call__:84) else goto L9 :: bool
L9:
    return r7
L10:
    r16 = load_address PyTuple_Type
    r17 = r0 == r16
    if r17 goto L74 else goto L19 :: bool
L11:
    r18 = PyList_New(0)
    if is_error(r18) goto L67 (error at __call__:86) else goto L12
L12:
    r19 = PyObject_GetIter(elements)
    if is_error(r19) goto L75 (error at __call__:86) else goto L13
L13:
    r20 = PyIter_Next(r19)
    if is_error(r20) goto L76 else goto L14
L14:
    r21 = [r20]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(self, r22, 1, 0)
    if is_error(r23) goto L77 (error at __call__:86) else goto L15
L15:
    dec_ref r20
    r24 = PyList_Append(r18, r23)
    dec_ref r23
    r25 = r24 >= 0 :: signed
    if not r25 goto L78 (error at __call__:86) else goto L13 :: bool
L16:
    r26 = CPy_NoErrOccurred()
    if not r26 goto L75 (error at __call__:86) else goto L17 :: bool
L17:
    r27 = PyList_AsTuple(r18)
    dec_ref r18
    if is_error(r27) goto L67 (error at __call__:86) else goto L18
L18:
    return r27
L19:
    r28 = dank_mids._web3.abi.Mapping :: static
    if is_error(r28) goto L79 else goto L22
L20:
    r29 = raise NameError('value for final name "Mapping" was not set')
    if not r29 goto L67 (error at __call__:87) else goto L21 :: bool
L21:
    unreachable
L22:
    r30 = PyObject_IsInstance(elements, r28)
    r31 = r30 >= 0 :: signed
    if not r31 goto L69 (error at __call__:87) else goto L23 :: bool
L23:
    r32 = truncate r30: i32 to builtins.bool
    if r32 goto L24 else goto L35 :: bool
L24:
    r33 = PyList_New(0)
    if is_error(r33) goto L69 (error at __call__:88) else goto L25
L25:
    r34 = 'items'
    r35 = [elements]
    r36 = load_address r35
    r37 = PyObject_VectorcallMethod(r34, r36, 9223372036854775809, 0)
    if is_error(r37) goto L80 (error at __call__:88) else goto L26
L26:
    r38 = PyObject_GetIter(r37)
    dec_ref r37
    if is_error(r38) goto L80 (error at __call__:88) else goto L27
L27:
    r39 = PyIter_Next(r38)
    if is_error(r39) goto L81 else goto L28
L28:
    r40 = unbox(tuple[object, object], r39)
    dec_ref r39
    if is_error(r40) goto L82 (error at __call__:88) else goto L29
L29:
    r41 = r40[0]
    r42 = r40[1]
    dec_ref r40
    r43 = [r42]
    r44 = load_address r43
    r45 = PyObject_Vectorcall(self, r44, 1, 0)
    if is_error(r45) goto L83 (error at __call__:88) else goto L30
L30:
    dec_ref r42
    r46 = (r41, r45)
    r47 = box(tuple[object, object], r46)
    r48 = PyList_Append(r33, r47)
    dec_ref r47
    r49 = r48 >= 0 :: signed
    if not r49 goto L82 (error at __call__:88) else goto L27 :: bool
L31:
    r50 = CPy_NoErrOccurred()
    if not r50 goto L80 (error at __call__:88) else goto L32 :: bool
L32:
    r51 = PyObject_GetIter(r33)
    dec_ref r33
    if is_error(r51) goto L69 (error at __call__:88) else goto L33
L33:
    r52 = [r51]
    r53 = load_address r52
    r54 = PyObject_Vectorcall(r0, r53, 1, 0)
    dec_ref r0
    if is_error(r54) goto L84 (error at __call__:88) else goto L34
L34:
    dec_ref r51
    return r54
L35:
    r55 = load_address PyBytes_Type
    r56 = load_address PyUnicode_Type
    r57 = builtins :: module
    r58 = 'bytearray'
    r59 = CPyObject_GetAttr(r57, r58)
    if is_error(r59) goto L69 (error at __call__:89) else goto L36
L36:
    inc_ref r55
    inc_ref r56
    r60 = (r55, r56, r59)
    r61 = box(tuple[object, object, object], r60)
    r62 = PyObject_IsInstance(elements, r61)
    dec_ref r61
    r63 = r62 >= 0 :: signed
    if not r63 goto L69 (error at __call__:89) else goto L37 :: bool
L37:
    r64 = truncate r62: i32 to builtins.bool
    if r64 goto L85 else goto L38 :: bool
L38:
    r65 = dank_mids._web3.abi.Iterable :: static
    if is_error(r65) goto L86 else goto L41
L39:
    r66 = raise NameError('value for final name "Iterable" was not set')
    if not r66 goto L67 (error at __call__:89) else goto L40 :: bool
L40:
    unreachable
L41:
    r67 = PyObject_IsInstance(elements, r65)
    r68 = r67 >= 0 :: signed
    if not r68 goto L69 (error at __call__:89) else goto L42 :: bool
L42:
    r69 = truncate r67: i32 to builtins.bool
    if r69 goto L43 else goto L85 :: bool
L43:
    r70 = builtins :: module
    r71 = 'map'
    r72 = CPyObject_GetAttr(r70, r71)
    if is_error(r72) goto L69 (error at __call__:90) else goto L44
L44:
    r73 = [self, elements]
    r74 = load_address r73
    r75 = PyObject_Vectorcall(r72, r74, 2, 0)
    dec_ref r72
    if is_error(r75) goto L69 (error at __call__:90) else goto L45
L45:
    r76 = [r75]
    r77 = load_address r76
    r78 = PyObject_Vectorcall(r0, r77, 1, 0)
    dec_ref r0
    if is_error(r78) goto L87 (error at __call__:90) else goto L46
L46:
    dec_ref r75
    return r78
L47:
    r79 = dank_mids._web3.abi.ABITypedData :: type
    r80 = get_element_ptr elements ob_type :: PyObject
    r81 = borrow load_mem r80 :: builtins.object*
    r82 = r81 == r79
    if r82 goto L48 else goto L66 :: bool
L48:
    r83 = borrow cast(dank_mids._web3.abi.ABITypedData, elements)
    if is_error(r83) goto L67 (error at __call__:91) else goto L49
L49:
    r84 = borrow r83.abi_type
    if is_error(r84) goto L67 (error at __call__:91) else goto L50
L50:
    r85 = load_address _Py_NoneStruct
    r86 = r84 != r85
    if r86 goto L51 else goto L66 :: bool
L51:
    inc_ref elements
    r87 = cast(dank_mids._web3.abi.ABITypedData, elements)
    if is_error(r87) goto L67 (error at __call__:92) else goto L52
L52:
    r88 = 'func'
    r89 = CPyObject_GetAttr(self, r88)
    if is_error(r89) goto L88 (error at __call__:92) else goto L53
L53:
    r90 = PyList_New(0)
    if is_error(r90) goto L89 (error at __call__:92) else goto L54
L54:
    r91 = CPyList_Extend(r90, r87)
    dec_ref r87
    if is_error(r91) goto L90 (error at __call__:92) else goto L91
L55:
    r92 = PyList_AsTuple(r90)
    dec_ref r90
    if is_error(r92) goto L92 (error at __call__:92) else goto L56
L56:
    r93 = PyDict_New()
    if is_error(r93) goto L93 (error at __call__:92) else goto L57
L57:
    r94 = PyObject_Call(r89, r92, r93)
    dec_ref r89
    dec_ref r92
    dec_ref r93
    if is_error(r94) goto L67 (error at __call__:92) else goto L58
L58:
    r95 = unbox(tuple[str, object], r94)
    dec_ref r94
    if is_error(r95) goto L67 (error at __call__:92) else goto L59
L59:
    r96 = dank_mids._web3.abi.ABITypedData :: type
    r97 = PyList_New(0)
    if is_error(r97) goto L94 (error at __call__:92) else goto L60
L60:
    r98 = box(tuple[str, object], r95)
    r99 = CPyList_Extend(r97, r98)
    dec_ref r98
    if is_error(r99) goto L95 (error at __call__:92) else goto L96
L61:
    r100 = PyList_AsTuple(r97)
    dec_ref r97
    if is_error(r100) goto L67 (error at __call__:92) else goto L62
L62:
    r101 = PyDict_New()
    if is_error(r101) goto L97 (error at __call__:92) else goto L63
L63:
    r102 = PyObject_Call(r96, r100, r101)
    dec_ref r100
    dec_ref r101
    if is_error(r102) goto L67 (error at __call__:92) else goto L64
L64:
    r103 = cast(dank_mids._web3.abi.ABITypedData, r102)
    if is_error(r103) goto L67 (error at __call__:92) else goto L65
L65:
    return r103
L66:
    inc_ref elements
    return elements
L67:
    r104 = <error> :: object
    return r104
L68:
    dec_ref r0
    goto L3
L69:
    dec_ref r0
    goto L67
L70:
    dec_ref r7
    goto L67
L71:
    dec_ref r8
    goto L8
L72:
    dec_ref r7
    dec_ref r8
    dec_ref r9
    goto L67
L73:
    dec_ref r7
    dec_ref r8
    goto L67
L74:
    dec_ref r0
    goto L11
L75:
    dec_ref r18
    goto L67
L76:
    dec_ref r19
    goto L16
L77:
    dec_ref r18
    dec_ref r19
    dec_ref r20
    goto L67
L78:
    dec_ref r18
    dec_ref r19
    goto L67
L79:
    dec_ref r0
    goto L20
L80:
    dec_ref r0
    dec_ref r33
    goto L67
L81:
    dec_ref r38
    goto L31
L82:
    dec_ref r0
    dec_ref r33
    dec_ref r38
    goto L67
L83:
    dec_ref r0
    dec_ref r33
    dec_ref r38
    dec_ref r41
    dec_ref r42
    goto L67
L84:
    dec_ref r51
    goto L67
L85:
    dec_ref r0
    goto L47
L86:
    dec_ref r0
    goto L39
L87:
    dec_ref r75
    goto L67
L88:
    dec_ref r87
    goto L67
L89:
    dec_ref r87
    dec_ref r89
    goto L67
L90:
    dec_ref r89
    dec_ref r90
    goto L67
L91:
    dec_ref r91
    goto L55
L92:
    dec_ref r89
    goto L67
L93:
    dec_ref r89
    dec_ref r92
    goto L67
L94:
    dec_ref r95
    goto L67
L95:
    dec_ref r97
    goto L67
L96:
    dec_ref r99
    goto L61
L97:
    dec_ref r100
    goto L67

def strip_abi_types(data):
    data, r0, r1 :: object
    r2 :: bit
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: bit
    r7 :: list
    r8, r9, r10 :: object
    r11 :: i32
    r12, r13, r14 :: bit
    r15 :: tuple
    r16 :: ptr
    r17 :: native_int
    r18 :: tuple
    r19 :: native_int
    r20 :: ptr
    r21 :: native_int
    r22 :: bit
    r23, r24 :: object
    r25 :: native_int
    r26 :: object
    r27 :: bool
    r28 :: i32
    r29 :: bit
    r30 :: bool
    r31 :: list
    r32 :: str
    r33 :: object[1]
    r34 :: object_ptr
    r35, r36, r37 :: object
    r38 :: tuple[object, object]
    r39, r40, r41 :: object
    r42 :: tuple[object, object]
    r43 :: object
    r44 :: i32
    r45, r46 :: bit
    r47 :: object
    r48 :: object[1]
    r49 :: object_ptr
    r50, r51, r52, r53 :: object
    r54 :: str
    r55 :: object
    r56 :: tuple[object, object, object]
    r57 :: object
    r58 :: i32
    r59 :: bit
    r60 :: bool
    r61 :: object
    r62 :: bool
    r63 :: i32
    r64 :: bit
    r65 :: bool
    r66 :: dict
    r67 :: str
    r68, r69 :: object
    r70 :: str
    r71 :: object
    r72 :: object[2]
    r73 :: object_ptr
    r74 :: object
    r75 :: object[1]
    r76 :: object_ptr
    r77, r78 :: object
    r79 :: ptr
    r80 :: object
    r81 :: bit
    r82 :: dank_mids._web3.abi.ABITypedData
    r83, r84 :: object
L0:
    r0 = PyObject_Type(data)
    r1 = load_address PyList_Type
    r2 = r0 == r1
    if r2 goto L54 else goto L1 :: bool
L1:
    r3 = builtins :: module
    r4 = 'map'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L55 (error at strip_abi_types:99) else goto L2
L2:
    r6 = r0 == r5
    dec_ref r5
    if r6 goto L54 else goto L10 :: bool
L3:
    r7 = PyList_New(0)
    if is_error(r7) goto L53 (error at strip_abi_types:100) else goto L4
L4:
    r8 = PyObject_GetIter(data)
    if is_error(r8) goto L56 (error at strip_abi_types:100) else goto L5
L5:
    r9 = PyIter_Next(r8)
    if is_error(r9) goto L57 else goto L6
L6:
    r10 = strip_abi_types(r9)
    dec_ref r9
    if is_error(r10) goto L58 (error at strip_abi_types:100) else goto L7
L7:
    r11 = PyList_Append(r7, r10)
    dec_ref r10
    r12 = r11 >= 0 :: signed
    if not r12 goto L58 (error at strip_abi_types:100) else goto L5 :: bool
L8:
    r13 = CPy_NoErrOccurred()
    if not r13 goto L56 (error at strip_abi_types:100) else goto L9 :: bool
L9:
    return r7
L10:
    r14 = PyTuple_Check(data)
    if r14 goto L59 else goto L19 :: bool
L11:
    inc_ref data
    r15 = cast(tuple, data)
    if is_error(r15) goto L53 (error at strip_abi_types:102) else goto L12
L12:
    r16 = get_element_ptr r15 ob_size :: PyVarObject
    r17 = load_mem r16 :: native_int*
    r18 = PyTuple_New(r17)
    if is_error(r18) goto L60 (error at strip_abi_types:102) else goto L13
L13:
    r19 = 0
L14:
    r20 = get_element_ptr r15 ob_size :: PyVarObject
    r21 = load_mem r20 :: native_int*
    r22 = r19 < r21 :: signed
    if r22 goto L15 else goto L61 :: bool
L15:
    r23 = CPySequenceTuple_GetItemUnsafe(r15, r19)
    r24 = strip_abi_types(r23)
    dec_ref r23
    if is_error(r24) goto L62 (error at strip_abi_types:102) else goto L16
L16:
    CPySequenceTuple_SetItemUnsafe(r18, r19, r24)
L17:
    r25 = r19 + 1
    r19 = r25
    goto L14
L18:
    return r18
L19:
    r26 = dank_mids._web3.abi.Mapping :: static
    if is_error(r26) goto L63 else goto L22
L20:
    r27 = raise NameError('value for final name "Mapping" was not set')
    if not r27 goto L53 (error at strip_abi_types:103) else goto L21 :: bool
L21:
    unreachable
L22:
    r28 = PyObject_IsInstance(data, r26)
    r29 = r28 >= 0 :: signed
    if not r29 goto L55 (error at strip_abi_types:103) else goto L23 :: bool
L23:
    r30 = truncate r28: i32 to builtins.bool
    if r30 goto L24 else goto L35 :: bool
L24:
    r31 = PyList_New(0)
    if is_error(r31) goto L55 (error at strip_abi_types:104) else goto L25
L25:
    r32 = 'items'
    r33 = [data]
    r34 = load_address r33
    r35 = PyObject_VectorcallMethod(r32, r34, 9223372036854775809, 0)
    if is_error(r35) goto L64 (error at strip_abi_types:104) else goto L26
L26:
    r36 = PyObject_GetIter(r35)
    dec_ref r35
    if is_error(r36) goto L64 (error at strip_abi_types:104) else goto L27
L27:
    r37 = PyIter_Next(r36)
    if is_error(r37) goto L65 else goto L28
L28:
    r38 = unbox(tuple[object, object], r37)
    dec_ref r37
    if is_error(r38) goto L66 (error at strip_abi_types:104) else goto L29
L29:
    r39 = r38[0]
    r40 = r38[1]
    dec_ref r38
    r41 = strip_abi_types(r40)
    dec_ref r40
    if is_error(r41) goto L67 (error at strip_abi_types:104) else goto L30
L30:
    r42 = (r39, r41)
    r43 = box(tuple[object, object], r42)
    r44 = PyList_Append(r31, r43)
    dec_ref r43
    r45 = r44 >= 0 :: signed
    if not r45 goto L66 (error at strip_abi_types:104) else goto L27 :: bool
L31:
    r46 = CPy_NoErrOccurred()
    if not r46 goto L64 (error at strip_abi_types:104) else goto L32 :: bool
L32:
    r47 = PyObject_GetIter(r31)
    dec_ref r31
    if is_error(r47) goto L55 (error at strip_abi_types:104) else goto L33
L33:
    r48 = [r47]
    r49 = load_address r48
    r50 = PyObject_Vectorcall(r0, r49, 1, 0)
    dec_ref r0
    if is_error(r50) goto L68 (error at strip_abi_types:104) else goto L34
L34:
    dec_ref r47
    return r50
L35:
    r51 = load_address PyBytes_Type
    r52 = load_address PyUnicode_Type
    r53 = builtins :: module
    r54 = 'bytearray'
    r55 = CPyObject_GetAttr(r53, r54)
    if is_error(r55) goto L55 (error at strip_abi_types:105) else goto L36
L36:
    inc_ref r51
    inc_ref r52
    r56 = (r51, r52, r55)
    r57 = box(tuple[object, object, object], r56)
    r58 = PyObject_IsInstance(data, r57)
    dec_ref r57
    r59 = r58 >= 0 :: signed
    if not r59 goto L55 (error at strip_abi_types:105) else goto L37 :: bool
L37:
    r60 = truncate r58: i32 to builtins.bool
    if r60 goto L69 else goto L38 :: bool
L38:
    r61 = dank_mids._web3.abi.Iterable :: static
    if is_error(r61) goto L70 else goto L41
L39:
    r62 = raise NameError('value for final name "Iterable" was not set')
    if not r62 goto L53 (error at strip_abi_types:105) else goto L40 :: bool
L40:
    unreachable
L41:
    r63 = PyObject_IsInstance(data, r61)
    r64 = r63 >= 0 :: signed
    if not r64 goto L55 (error at strip_abi_types:105) else goto L42 :: bool
L42:
    r65 = truncate r63: i32 to builtins.bool
    if r65 goto L43 else goto L69 :: bool
L43:
    r66 = dank_mids._web3.abi.globals :: static
    r67 = 'strip_abi_types'
    r68 = CPyDict_GetItem(r66, r67)
    if is_error(r68) goto L55 (error at strip_abi_types:106) else goto L44
L44:
    r69 = builtins :: module
    r70 = 'map'
    r71 = CPyObject_GetAttr(r69, r70)
    if is_error(r71) goto L71 (error at strip_abi_types:106) else goto L45
L45:
    r72 = [r68, data]
    r73 = load_address r72
    r74 = PyObject_Vectorcall(r71, r73, 2, 0)
    dec_ref r71
    if is_error(r74) goto L71 (error at strip_abi_types:106) else goto L46
L46:
    dec_ref r68
    r75 = [r74]
    r76 = load_address r75
    r77 = PyObject_Vectorcall(r0, r76, 1, 0)
    dec_ref r0
    if is_error(r77) goto L72 (error at strip_abi_types:106) else goto L47
L47:
    dec_ref r74
    return r77
L48:
    r78 = dank_mids._web3.abi.ABITypedData :: type
    r79 = get_element_ptr data ob_type :: PyObject
    r80 = borrow load_mem r79 :: builtins.object*
    r81 = r80 == r78
    if r81 goto L49 else goto L52 :: bool
L49:
    r82 = borrow cast(dank_mids._web3.abi.ABITypedData, data)
    if is_error(r82) goto L53 (error at strip_abi_types:108) else goto L50
L50:
    r83 = r82.data
    if is_error(r83) goto L53 (error at strip_abi_types:108) else goto L51
L51:
    return r83
L52:
    inc_ref data
    return data
L53:
    r84 = <error> :: object
    return r84
L54:
    dec_ref r0
    goto L3
L55:
    dec_ref r0
    goto L53
L56:
    dec_ref r7
    goto L53
L57:
    dec_ref r8
    goto L8
L58:
    dec_ref r7
    dec_ref r8
    goto L53
L59:
    dec_ref r0
    goto L11
L60:
    dec_ref r15
    goto L53
L61:
    dec_ref r15
    goto L18
L62:
    dec_ref r15
    dec_ref r18
    goto L53
L63:
    dec_ref r0
    goto L20
L64:
    dec_ref r0
    dec_ref r31
    goto L53
L65:
    dec_ref r36
    goto L31
L66:
    dec_ref r0
    dec_ref r31
    dec_ref r36
    goto L53
L67:
    dec_ref r0
    dec_ref r31
    dec_ref r36
    dec_ref r39
    goto L53
L68:
    dec_ref r47
    goto L53
L69:
    dec_ref r0
    goto L48
L70:
    dec_ref r0
    goto L39
L71:
    dec_ref r0
    dec_ref r68
    goto L53
L72:
    dec_ref r74
    goto L53

def abi_sub_tree(abi_type, data_value):
    abi_type :: union[object, None]
    data_value, r0 :: object
    r1 :: bit
    r2 :: object
    r3 :: tuple
    r4 :: dict
    r5 :: dank_mids._web3.abi.ABITypedData
    r6 :: object
    r7 :: str
    r8 :: object
    r9 :: i32
    r10 :: bit
    r11 :: bool
    r12 :: object
    r13 :: str
    r14 :: object
    r15 :: list
    r16, r17 :: object
    r18 :: dank_mids._web3.abi.ABITypedData
    r19 :: i32
    r20, r21 :: bit
    value_to_annotate :: list
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: i32
    r26 :: bit
    r27 :: bool
    r28 :: object
    r29 :: list
    r30 :: object
    r31 :: str
    r32, r33, r34, r35, r36 :: object
    r37 :: dank_mids._web3.abi.ABITypedData
    r38 :: i32
    r39, r40, r41 :: bit
    r42 :: object
    r43 :: object[1]
    r44 :: object_ptr
    r45 :: object
    r46, r47 :: list
    r48 :: object
    r49 :: str
    r50 :: object[1]
    r51 :: object_ptr
    r52 :: object
    r53 :: tuple
    r54 :: dict
    r55, r56 :: dank_mids._web3.abi.ABITypedData
L0:
    r0 = load_address _Py_NoneStruct
    r1 = abi_type == r0
    if r1 goto L1 else goto L5 :: bool
L1:
    r2 = box(None, 1)
    r3 = PyTuple_Pack(2, r2, data_value)
    if is_error(r3) goto L44 (error at abi_sub_tree:147) else goto L2
L2:
    r4 = PyDict_New()
    if is_error(r4) goto L45 (error at abi_sub_tree:147) else goto L3
L3:
    r5 = ABITypedData(r3, r4)
    dec_ref r3
    dec_ref r4
    if is_error(r5) goto L44 (error at abi_sub_tree:147) else goto L4
L4:
    return r5
L5:
    inc_ref abi_type
    r6 = abi_type
    r7 = 'is_array'
    r8 = CPyObject_GetAttr(r6, r7)
    dec_ref r6
    if is_error(r8) goto L44 (error at abi_sub_tree:151) else goto L6
L6:
L7:
    r9 = PyObject_IsTrue(r8)
    dec_ref r8
    r10 = r9 >= 0 :: signed
    if not r10 goto L44 (error at abi_sub_tree:-1) else goto L8 :: bool
L8:
    r11 = truncate r9: i32 to builtins.bool
    if r11 goto L9 else goto L18 :: bool
L9:
    inc_ref abi_type
    r12 = abi_type
    r13 = 'item_type'
    r14 = CPyObject_GetAttr(r12, r13)
    dec_ref r12
    if is_error(r14) goto L44 (error at abi_sub_tree:154) else goto L10
L10:
L11:
    r15 = PyList_New(0)
    if is_error(r15) goto L46 (error at abi_sub_tree:155) else goto L12
L12:
    r16 = PyObject_GetIter(data_value)
    if is_error(r16) goto L47 (error at abi_sub_tree:155) else goto L13
L13:
    r17 = PyIter_Next(r16)
    if is_error(r17) goto L48 else goto L14
L14:
    r18 = abi_sub_tree(r14, r17)
    dec_ref r17
    if is_error(r18) goto L49 (error at abi_sub_tree:155) else goto L15
L15:
    r19 = PyList_Append(r15, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L49 (error at abi_sub_tree:155) else goto L13 :: bool
L16:
    r21 = CPy_NoErrOccurred()
    if not r21 goto L50 (error at abi_sub_tree:155) else goto L17 :: bool
L17:
    value_to_annotate = r15
    goto L38
L18:
    r22 = dank_mids._web3.abi.globals :: static
    r23 = 'TupleType'
    r24 = CPyDict_GetItem(r22, r23)
    if is_error(r24) goto L44 (error at abi_sub_tree:156) else goto L19
L19:
    r25 = PyObject_IsInstance(abi_type, r24)
    dec_ref r24
    r26 = r25 >= 0 :: signed
    if not r26 goto L44 (error at abi_sub_tree:156) else goto L20 :: bool
L20:
    r27 = truncate r25: i32 to builtins.bool
    if r27 goto L21 else goto L36 :: bool
L21:
    r28 = PyObject_Type(data_value)
    r29 = PyList_New(0)
    if is_error(r29) goto L51 (error at abi_sub_tree:159) else goto L22
L22:
    inc_ref abi_type
    r30 = abi_type
    r31 = 'components'
    r32 = CPyObject_GetAttr(r30, r31)
    dec_ref r30
    if is_error(r32) goto L52 (error at abi_sub_tree:161) else goto L23
L23:
L24:
    r33 = PyObject_GetIter(r32)
    dec_ref r32
    if is_error(r33) goto L52 (error at abi_sub_tree:159) else goto L25
L25:
    r34 = PyObject_GetIter(data_value)
    if is_error(r34) goto L53 (error at abi_sub_tree:159) else goto L26
L26:
    r35 = PyIter_Next(r33)
    if is_error(r35) goto L54 else goto L27
L27:
    r36 = PyIter_Next(r34)
    if is_error(r36) goto L55 else goto L28
L28:
    r37 = abi_sub_tree(r35, r36)
    dec_ref r35
    dec_ref r36
    if is_error(r37) goto L56 (error at abi_sub_tree:160) else goto L29
L29:
    r38 = PyList_Append(r29, r37)
    dec_ref r37
    r39 = r38 >= 0 :: signed
    if not r39 goto L56 (error at abi_sub_tree:159) else goto L26 :: bool
L30:
    r40 = CPy_NoErrOccurred()
    if not r40 goto L52 (error at abi_sub_tree:159) else goto L31 :: bool
L31:
    r41 = CPy_NoErrOccurred()
    if not r41 goto L52 (error at abi_sub_tree:159) else goto L32 :: bool
L32:
    r42 = PyObject_GetIter(r29)
    dec_ref r29
    if is_error(r42) goto L51 (error at abi_sub_tree:159) else goto L33
L33:
    r43 = [r42]
    r44 = load_address r43
    r45 = PyObject_Vectorcall(r28, r44, 1, 0)
    dec_ref r28
    if is_error(r45) goto L57 (error at abi_sub_tree:159) else goto L34
L34:
    dec_ref r42
    r46 = cast(list, r45)
    if is_error(r46) goto L44 (error at abi_sub_tree:159) else goto L35
L35:
    value_to_annotate = r46
    goto L38
L36:
    inc_ref data_value
    r47 = cast(list, data_value)
    if is_error(r47) goto L44 (error at abi_sub_tree:164) else goto L37
L37:
    value_to_annotate = r47
L38:
    inc_ref abi_type
    r48 = abi_type
    r49 = 'to_type_str'
    r50 = [r48]
    r51 = load_address r50
    r52 = PyObject_VectorcallMethod(r49, r51, 9223372036854775809, 0)
    if is_error(r52) goto L58 (error at abi_sub_tree:166) else goto L39
L39:
    dec_ref r48
L40:
    r53 = PyTuple_Pack(2, r52, value_to_annotate)
    dec_ref r52
    dec_ref value_to_annotate
    if is_error(r53) goto L44 (error at abi_sub_tree:166) else goto L41
L41:
    r54 = PyDict_New()
    if is_error(r54) goto L59 (error at abi_sub_tree:166) else goto L42
L42:
    r55 = ABITypedData(r53, r54)
    dec_ref r53
    dec_ref r54
    if is_error(r55) goto L44 (error at abi_sub_tree:166) else goto L43
L43:
    return r55
L44:
    r56 = <error> :: dank_mids._web3.abi.ABITypedData
    return r56
L45:
    dec_ref r3
    goto L44
L46:
    dec_ref r14
    goto L44
L47:
    dec_ref r14
    dec_ref r15
    goto L44
L48:
    dec_ref r14
    dec_ref r16
    goto L16
L49:
    dec_ref r14
    dec_ref r15
    dec_ref r16
    goto L44
L50:
    dec_ref r15
    goto L44
L51:
    dec_ref r28
    goto L44
L52:
    dec_ref r28
    dec_ref r29
    goto L44
L53:
    dec_ref r28
    dec_ref r29
    dec_ref r33
    goto L44
L54:
    dec_ref r33
    dec_ref r34
    goto L30
L55:
    dec_ref r33
    dec_ref r34
    dec_ref r35
    goto L30
L56:
    dec_ref r28
    dec_ref r29
    dec_ref r33
    dec_ref r34
    goto L44
L57:
    dec_ref r42
    goto L44
L58:
    dec_ref value_to_annotate
    dec_ref r48
    goto L44
L59:
    dec_ref r53
    goto L44

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: dict
    r30, r31 :: object
    r32 :: str
    r33 :: dict
    r34 :: object
    r35 :: str
    r36 :: dict
    r37 :: str
    r38 :: object
    r39 :: object[1]
    r40 :: object_ptr
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: dict
    r47 :: str
    r48 :: object
    r49 :: dict
    r50 :: str
    r51 :: object
    r52 :: dict
    r53 :: str
    r54 :: object
    r55 :: list
    r56, r57, r58 :: ptr
    r59 :: dict
    r60 :: str
    r61 :: object
    r62 :: dict
    r63 :: str
    r64 :: object
    r65 :: dict
    r66 :: str
    r67 :: object
    r68 :: tuple[object, object]
    r69, r70 :: object
    r71 :: tuple[list, object]
    r72, r73 :: object
    r74 :: dict
    r75 :: str
    r76 :: i32
    r77 :: bit
    r78 :: dict
    r79 :: str
    r80 :: object
    r81 :: dict
    r82 :: str
    r83 :: object
    r84 :: dict
    r85 :: str
    r86, r87 :: object
    r88 :: tuple[object, object]
    r89, r90 :: object
    r91 :: dict
    r92 :: str
    r93 :: object
    r94 :: dict
    r95 :: str
    r96, r97 :: object
    r98 :: tuple[object, object]
    r99, r100 :: object
    r101 :: tuple[object, object]
    r102, r103 :: object
    r104 :: dict
    r105 :: str
    r106 :: i32
    r107 :: bit
    r108 :: dict
    r109 :: str
    r110 :: object
    r111 :: dict
    r112 :: str
    r113 :: object
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: list
    r118, r119, r120 :: ptr
    r121 :: dict
    r122 :: str
    r123 :: object
    r124 :: dict
    r125 :: str
    r126 :: object
    r127 :: dict
    r128 :: str
    r129 :: object
    r130 :: tuple[object, object]
    r131, r132 :: object
    r133 :: tuple[list, object]
    r134, r135 :: object
    r136 :: dict
    r137 :: str
    r138 :: i32
    r139 :: bit
    r140 :: object
    r141 :: str
    r142 :: object
    r143 :: dict
    r144 :: str
    r145 :: i32
    r146 :: bit
    r147 :: object
    r148 :: str
    r149 :: object
    r150 :: dict
    r151 :: str
    r152 :: i32
    r153 :: bit
    r154 :: dict
    r155 :: str
    r156 :: object
    r157 :: str
    r158 :: object
    r159 :: dict
    r160 :: str
    r161 :: i32
    r162 :: bit
    r163 :: object
    r164 :: str
    r165, r166 :: object
    r167 :: bool
    r168, r169, r170 :: str
    r171 :: tuple
    r172 :: i32
    r173 :: bit
    r174 :: dict
    r175 :: str
    r176 :: i32
    r177 :: bit
    r178, r179 :: dict
    r180 :: str
    r181 :: i32
    r182 :: bit
    r183, r184 :: dict
    r185 :: str
    r186 :: i32
    r187 :: bit
    r188 :: object
    r189 :: str
    r190, r191 :: object
    r192 :: bool
    r193, r194 :: str
    r195 :: tuple
    r196 :: i32
    r197 :: bit
    r198 :: dict
    r199 :: str
    r200 :: i32
    r201 :: bit
    r202 :: object
    r203 :: str
    r204, r205 :: object
    r206 :: bool
    r207, r208, r209 :: str
    r210 :: tuple
    r211 :: i32
    r212 :: bit
    r213 :: dict
    r214 :: str
    r215 :: i32
    r216 :: bit
    r217 :: dict
    r218 :: tuple[]
    r219 :: dict
    r220, r221 :: object
    r222 :: str
    r223 :: i32
    r224 :: bit
    r225 :: object
    r226 :: str
    r227 :: i32
    r228 :: bit
    r229 :: str
    r230 :: i32
    r231 :: bit
    r232, r233 :: str
    r234 :: i32
    r235 :: bit
    r236, r237 :: str
    r238 :: i32
    r239 :: bit
    r240 :: dict
    r241 :: str
    r242, r243 :: object
    r244 :: object[1]
    r245 :: object_ptr
    r246, r247 :: object
    r248 :: str
    r249 :: bit
    r250 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L78 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address typing :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('typing', 'typing', 'typing'),)
    r11 = dank_mids._web3.abi.globals :: static
    r12 = 'dank_mids/_web3/abi.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L78 else goto L4 :: bool
L4:
    r15 = ('dataclass',)
    r16 = 'dataclasses'
    r17 = dank_mids._web3.abi.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L78 (error at <module>:2) else goto L5
L5:
    dataclasses = r18 :: module
    dec_ref r18
    r19 = ('Any', 'Callable', 'Dict', 'Final', 'List', 'Optional', 'Tuple', 'TypeVar', 'final')
    r20 = 'typing'
    r21 = dank_mids._web3.abi.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L78 (error at <module>:3) else goto L6
L6:
    typing = r22 :: module
    dec_ref r22
    r23 = ('TypeStr',)
    r24 = 'eth_typing'
    r25 = dank_mids._web3.abi.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L78 (error at <module>:5) else goto L7
L7:
    eth_typing = r26 :: module
    dec_ref r26
    r27 = ('grammar',)
    r28 = 'faster_eth_abi'
    r29 = dank_mids._web3.abi.globals :: static
    r30 = CPyImport_ImportFromMany(r28, r27, r27, r29)
    if is_error(r30) goto L78 (error at <module>:6) else goto L8
L8:
    faster_eth_abi = r30 :: module
    dec_ref r30
    r31 = ('ABIType', 'TupleType')
    r32 = 'faster_eth_abi.grammar'
    r33 = dank_mids._web3.abi.globals :: static
    r34 = CPyImport_ImportFromMany(r32, r31, r31, r33)
    if is_error(r34) goto L78 (error at <module>:7) else goto L9
L9:
    faster_eth_abi.grammar = r34 :: module
    dec_ref r34
    r35 = '_T'
    r36 = dank_mids._web3.abi.globals :: static
    r37 = 'TypeVar'
    r38 = CPyDict_GetItem(r36, r37)
    if is_error(r38) goto L78 (error at <module>:10) else goto L10
L10:
    r39 = [r35]
    r40 = load_address r39
    r41 = PyObject_Vectorcall(r38, r40, 1, 0)
    dec_ref r38
    if is_error(r41) goto L78 (error at <module>:10) else goto L11
L11:
    r42 = dank_mids._web3.abi.globals :: static
    r43 = '_T'
    r44 = CPyDict_SetItem(r42, r43, r41)
    dec_ref r41
    r45 = r44 >= 0 :: signed
    if not r45 goto L78 (error at <module>:10) else goto L12 :: bool
L12:
    r46 = dank_mids._web3.abi.globals :: static
    r47 = 'Callable'
    r48 = CPyDict_GetItem(r46, r47)
    if is_error(r48) goto L78 (error at <module>:13) else goto L13
L13:
    r49 = dank_mids._web3.abi.globals :: static
    r50 = 'TypeStr'
    r51 = CPyDict_GetItem(r49, r50)
    if is_error(r51) goto L79 (error at <module>:13) else goto L14
L14:
    r52 = dank_mids._web3.abi.globals :: static
    r53 = 'Any'
    r54 = CPyDict_GetItem(r52, r53)
    if is_error(r54) goto L80 (error at <module>:13) else goto L15
L15:
    r55 = PyList_New(2)
    if is_error(r55) goto L81 (error at <module>:13) else goto L16
L16:
    r56 = get_element_ptr r55 ob_item :: PyListObject
    r57 = load_mem r56 :: ptr*
    set_mem r57, r51 :: builtins.object*
    r58 = r57 + 8
    set_mem r58, r54 :: builtins.object*
    r59 = dank_mids._web3.abi.globals :: static
    r60 = 'Tuple'
    r61 = CPyDict_GetItem(r59, r60)
    if is_error(r61) goto L82 (error at <module>:13) else goto L17
L17:
    r62 = dank_mids._web3.abi.globals :: static
    r63 = 'TypeStr'
    r64 = CPyDict_GetItem(r62, r63)
    if is_error(r64) goto L83 (error at <module>:13) else goto L18
L18:
    r65 = dank_mids._web3.abi.globals :: static
    r66 = 'Any'
    r67 = CPyDict_GetItem(r65, r66)
    if is_error(r67) goto L84 (error at <module>:13) else goto L19
L19:
    r68 = (r64, r67)
    r69 = box(tuple[object, object], r68)
    r70 = PyObject_GetItem(r61, r69)
    dec_ref r61
    dec_ref r69
    if is_error(r70) goto L82 (error at <module>:13) else goto L20
L20:
    r71 = (r55, r70)
    r72 = box(tuple[list, object], r71)
    r73 = PyObject_GetItem(r48, r72)
    dec_ref r48
    dec_ref r72
    if is_error(r73) goto L78 (error at <module>:13) else goto L21
L21:
    r74 = dank_mids._web3.abi.globals :: static
    r75 = 'Normalizer'
    r76 = CPyDict_SetItem(r74, r75, r73)
    dec_ref r73
    r77 = r76 >= 0 :: signed
    if not r77 goto L78 (error at <module>:13) else goto L22 :: bool
L22:
    r78 = dank_mids._web3.abi.globals :: static
    r79 = 'Tuple'
    r80 = CPyDict_GetItem(r78, r79)
    if is_error(r80) goto L78 (error at <module>:14) else goto L23
L23:
    r81 = dank_mids._web3.abi.globals :: static
    r82 = 'Tuple'
    r83 = CPyDict_GetItem(r81, r82)
    if is_error(r83) goto L85 (error at <module>:14) else goto L24
L24:
    r84 = dank_mids._web3.abi.globals :: static
    r85 = 'Normalizer'
    r86 = CPyDict_GetItem(r84, r85)
    if is_error(r86) goto L86 (error at <module>:14) else goto L25
L25:
    r87 = load_address _Py_EllipsisObject
    inc_ref r87
    r88 = (r86, r87)
    r89 = box(tuple[object, object], r88)
    r90 = PyObject_GetItem(r83, r89)
    dec_ref r83
    dec_ref r89
    if is_error(r90) goto L85 (error at <module>:14) else goto L26
L26:
    r91 = dank_mids._web3.abi.globals :: static
    r92 = 'Tuple'
    r93 = CPyDict_GetItem(r91, r92)
    if is_error(r93) goto L87 (error at <module>:14) else goto L27
L27:
    r94 = dank_mids._web3.abi.globals :: static
    r95 = 'TypeStr'
    r96 = CPyDict_GetItem(r94, r95)
    if is_error(r96) goto L88 (error at <module>:14) else goto L28
L28:
    r97 = load_address _Py_EllipsisObject
    inc_ref r97
    r98 = (r96, r97)
    r99 = box(tuple[object, object], r98)
    r100 = PyObject_GetItem(r93, r99)
    dec_ref r93
    dec_ref r99
    if is_error(r100) goto L87 (error at <module>:14) else goto L29
L29:
    r101 = (r90, r100)
    r102 = box(tuple[object, object], r101)
    r103 = PyObject_GetItem(r80, r102)
    dec_ref r80
    dec_ref r102
    if is_error(r103) goto L78 (error at <module>:14) else goto L30
L30:
    r104 = dank_mids._web3.abi.globals :: static
    r105 = 'MapperKey'
    r106 = CPyDict_SetItem(r104, r105, r103)
    dec_ref r103
    r107 = r106 >= 0 :: signed
    if not r107 goto L78 (error at <module>:14) else goto L31 :: bool
L31:
    r108 = dank_mids._web3.abi.globals :: static
    r109 = 'Callable'
    r110 = CPyDict_GetItem(r108, r109)
    if is_error(r110) goto L78 (error at <module>:15) else goto L32
L32:
    r111 = dank_mids._web3.abi.globals :: static
    r112 = 'TypeStr'
    r113 = CPyDict_GetItem(r111, r112)
    if is_error(r113) goto L89 (error at <module>:15) else goto L33
L33:
    r114 = dank_mids._web3.abi.globals :: static
    r115 = 'Any'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L90 (error at <module>:15) else goto L34
L34:
    r117 = PyList_New(2)
    if is_error(r117) goto L91 (error at <module>:15) else goto L35
L35:
    r118 = get_element_ptr r117 ob_item :: PyListObject
    r119 = load_mem r118 :: ptr*
    set_mem r119, r113 :: builtins.object*
    r120 = r119 + 8
    set_mem r120, r116 :: builtins.object*
    r121 = dank_mids._web3.abi.globals :: static
    r122 = 'Tuple'
    r123 = CPyDict_GetItem(r121, r122)
    if is_error(r123) goto L92 (error at <module>:15) else goto L36
L36:
    r124 = dank_mids._web3.abi.globals :: static
    r125 = 'TypeStr'
    r126 = CPyDict_GetItem(r124, r125)
    if is_error(r126) goto L93 (error at <module>:15) else goto L37
L37:
    r127 = dank_mids._web3.abi.globals :: static
    r128 = 'Any'
    r129 = CPyDict_GetItem(r127, r128)
    if is_error(r129) goto L94 (error at <module>:15) else goto L38
L38:
    r130 = (r126, r129)
    r131 = box(tuple[object, object], r130)
    r132 = PyObject_GetItem(r123, r131)
    dec_ref r123
    dec_ref r131
    if is_error(r132) goto L92 (error at <module>:15) else goto L39
L39:
    r133 = (r117, r132)
    r134 = box(tuple[list, object], r133)
    r135 = PyObject_GetItem(r110, r134)
    dec_ref r110
    dec_ref r134
    if is_error(r135) goto L78 (error at <module>:15) else goto L40
L40:
    r136 = dank_mids._web3.abi.globals :: static
    r137 = 'DataTreeFunc'
    r138 = CPyDict_SetItem(r136, r137, r135)
    dec_ref r135
    r139 = r138 >= 0 :: signed
    if not r139 goto L78 (error at <module>:15) else goto L41 :: bool
L41:
    r140 = typing :: module
    r141 = 'Iterable'
    r142 = CPyObject_GetAttr(r140, r141)
    if is_error(r142) goto L78 (error at <module>:19) else goto L42
L42:
    dank_mids._web3.abi.Iterable = r142 :: static
    r143 = dank_mids._web3.abi.globals :: static
    r144 = 'Iterable'
    r145 = CPyDict_SetItem(r143, r144, r142)
    dec_ref r142
    r146 = r145 >= 0 :: signed
    if not r146 goto L78 (error at <module>:19) else goto L43 :: bool
L43:
    r147 = typing :: module
    r148 = 'Mapping'
    r149 = CPyObject_GetAttr(r147, r148)
    if is_error(r149) goto L78 (error at <module>:20) else goto L44
L44:
    dank_mids._web3.abi.Mapping = r149 :: static
    r150 = dank_mids._web3.abi.globals :: static
    r151 = 'Mapping'
    r152 = CPyDict_SetItem(r150, r151, r149)
    dec_ref r149
    r153 = r152 >= 0 :: signed
    if not r153 goto L78 (error at <module>:20) else goto L45 :: bool
L45:
    r154 = dank_mids._web3.abi.globals :: static
    r155 = 'grammar'
    r156 = CPyDict_GetItem(r154, r155)
    if is_error(r156) goto L78 (error at <module>:23) else goto L46
L46:
    r157 = 'parse'
    r158 = CPyObject_GetAttr(r156, r157)
    dec_ref r156
    if is_error(r158) goto L78 (error at <module>:23) else goto L47
L47:
    dank_mids._web3.abi.parse = r158 :: static
    r159 = dank_mids._web3.abi.globals :: static
    r160 = 'parse'
    r161 = CPyDict_SetItem(r159, r160, r158)
    dec_ref r158
    r162 = r161 >= 0 :: signed
    if not r162 goto L78 (error at <module>:23) else goto L48 :: bool
L48:
    r163 = <error> :: object
    r164 = 'dank_mids._web3.abi'
    r165 = dank_mids._web3.abi.Formatter_template :: type
    r166 = CPyType_FromTemplate(r165, r163, r164)
    if is_error(r166) goto L78 (error at <module>:27) else goto L49
L49:
    r167 = Formatter_trait_vtable_setup()
    if is_error(r167) goto L95 (error at <module>:-1) else goto L50
L50:
    r168 = '__mypyc_attrs__'
    r169 = 'normalizers'
    r170 = 'types'
    r171 = PyTuple_Pack(2, r169, r170)
    if is_error(r171) goto L95 (error at <module>:27) else goto L51
L51:
    r172 = PyObject_SetAttr(r166, r168, r171)
    dec_ref r171
    r173 = r172 >= 0 :: signed
    if not r173 goto L95 (error at <module>:27) else goto L52 :: bool
L52:
    dank_mids._web3.abi.Formatter = r166 :: type
    r174 = dank_mids._web3.abi.globals :: static
    r175 = 'Formatter'
    r176 = CPyDict_SetItem(r174, r175, r166)
    dec_ref r166
    r177 = r176 >= 0 :: signed
    if not r177 goto L78 (error at <module>:27) else goto L53 :: bool
L53:
    r178 = PyDict_New()
    if is_error(r178) goto L78 (error at <module>:49) else goto L54
L54:
    dank_mids._web3.abi._formatters = r178 :: static
    r179 = dank_mids._web3.abi.globals :: static
    r180 = '_formatters'
    r181 = CPyDict_SetItem(r179, r180, r178)
    dec_ref r178
    r182 = r181 >= 0 :: signed
    if not r182 goto L78 (error at <module>:49) else goto L55 :: bool
L55:
    r183 = PyDict_New()
    if is_error(r183) goto L78 (error at <module>:64) else goto L56
L56:
    dank_mids._web3.abi._data_tree_maps = r183 :: static
    r184 = dank_mids._web3.abi.globals :: static
    r185 = '_data_tree_maps'
    r186 = CPyDict_SetItem(r184, r185, r183)
    dec_ref r183
    r187 = r186 >= 0 :: signed
    if not r187 goto L78 (error at <module>:64) else goto L57 :: bool
L57:
    r188 = <error> :: object
    r189 = 'dank_mids._web3.abi'
    r190 = dank_mids._web3.abi.map_to_typed_data_template :: type
    r191 = CPyType_FromTemplate(r190, r188, r189)
    if is_error(r191) goto L78 (error at <module>:77) else goto L58
L58:
    r192 = map_to_typed_data_trait_vtable_setup()
    if is_error(r192) goto L96 (error at <module>:-1) else goto L59
L59:
    r193 = '__mypyc_attrs__'
    r194 = 'func'
    r195 = PyTuple_Pack(1, r194)
    if is_error(r195) goto L96 (error at <module>:77) else goto L60
L60:
    r196 = PyObject_SetAttr(r191, r193, r195)
    dec_ref r195
    r197 = r196 >= 0 :: signed
    if not r197 goto L96 (error at <module>:77) else goto L61 :: bool
L61:
    dank_mids._web3.abi.map_to_typed_data = r191 :: type
    r198 = dank_mids._web3.abi.globals :: static
    r199 = 'map_to_typed_data'
    r200 = CPyDict_SetItem(r198, r199, r191)
    dec_ref r191
    r201 = r200 >= 0 :: signed
    if not r201 goto L78 (error at <module>:77) else goto L62 :: bool
L62:
    r202 = <error> :: object
    r203 = 'dank_mids._web3.abi'
    r204 = dank_mids._web3.abi.ABITypedData_template :: type
    r205 = CPyType_FromTemplate(r204, r202, r203)
    if is_error(r205) goto L78 (error at <module>:118) else goto L63
L63:
    r206 = ABITypedData_trait_vtable_setup()
    if is_error(r206) goto L97 (error at <module>:-1) else goto L64
L64:
    r207 = '__mypyc_attrs__'
    r208 = 'abi_type'
    r209 = 'data'
    r210 = PyTuple_Pack(2, r208, r209)
    if is_error(r210) goto L97 (error at <module>:118) else goto L65
L65:
    r211 = PyObject_SetAttr(r205, r207, r210)
    dec_ref r210
    r212 = r211 >= 0 :: signed
    if not r212 goto L97 (error at <module>:118) else goto L66 :: bool
L66:
    dank_mids._web3.abi.ABITypedData = r205 :: type
    r213 = dank_mids._web3.abi.globals :: static
    r214 = 'ABITypedData'
    r215 = CPyDict_SetItem(r213, r214, r205)
    r216 = r215 >= 0 :: signed
    if not r216 goto L97 (error at <module>:118) else goto L67 :: bool
L67:
    r217 = PyDict_New()
    if is_error(r217) goto L97 (error at <module>:118) else goto L68
L68:
    r218 = ()
    r219 = PyDict_New()
    if is_error(r219) goto L98 (error at <module>:118) else goto L69
L69:
    r220 = load_address PyType_Type
    r221 = load_address PyType_Type
    r222 = 'abi_type'
    r223 = CPyDict_SetItem(r219, r222, r221)
    r224 = r223 >= 0 :: signed
    if not r224 goto L99 (error at <module>:139) else goto L70 :: bool
L70:
    r225 = load_address PyType_Type
    r226 = 'data'
    r227 = CPyDict_SetItem(r219, r226, r225)
    r228 = r227 >= 0 :: signed
    if not r228 goto L99 (error at <module>:140) else goto L71 :: bool
L71:
    r229 = '__annotations__'
    r230 = CPyDict_SetItem(r217, r229, r219)
    r231 = r230 >= 0 :: signed
    if not r231 goto L99 (error at <module>:118) else goto L72 :: bool
L72:
    r232 = 'mypyc filler docstring'
    r233 = '__doc__'
    r234 = CPyDict_SetItem(r217, r233, r232)
    r235 = r234 >= 0 :: signed
    if not r235 goto L99 (error at <module>:118) else goto L73 :: bool
L73:
    r236 = 'dank_mids._web3.abi'
    r237 = '__module__'
    r238 = CPyDict_SetItem(r217, r237, r236)
    r239 = r238 >= 0 :: signed
    if not r239 goto L99 (error at <module>:118) else goto L74 :: bool
L74:
    r240 = dank_mids._web3.abi.globals :: static
    r241 = 'dataclass'
    r242 = CPyDict_GetItem(r240, r241)
    if is_error(r242) goto L99 (error at <module>:117) else goto L75
L75:
    r243 = box(bool, 1)
    r244 = [r243]
    r245 = load_address r244
    r246 = ('frozen',)
    r247 = PyObject_Vectorcall(r242, r245, 0, r246)
    dec_ref r242
    if is_error(r247) goto L99 (error at <module>:117) else goto L76
L76:
    r248 = 'dataclasses'
    r249 = CPyDataclass_SleightOfHand(r247, r205, r217, r219, r248)
    dec_ref r247
    dec_ref r205
    dec_ref r217
    dec_ref r219
    if not r249 goto L78 (error at <module>:118) else goto L77 :: bool
L77:
    return 1
L78:
    r250 = <error> :: None
    return r250
L79:
    dec_ref r48
    goto L78
L80:
    dec_ref r48
    dec_ref r51
    goto L78
L81:
    dec_ref r48
    dec_ref r51
    dec_ref r54
    goto L78
L82:
    dec_ref r48
    dec_ref r55
    goto L78
L83:
    dec_ref r48
    dec_ref r55
    dec_ref r61
    goto L78
L84:
    dec_ref r48
    dec_ref r55
    dec_ref r61
    dec_ref r64
    goto L78
L85:
    dec_ref r80
    goto L78
L86:
    dec_ref r80
    dec_ref r83
    goto L78
L87:
    dec_ref r80
    dec_ref r90
    goto L78
L88:
    dec_ref r80
    dec_ref r90
    dec_ref r93
    goto L78
L89:
    dec_ref r110
    goto L78
L90:
    dec_ref r110
    dec_ref r113
    goto L78
L91:
    dec_ref r110
    dec_ref r113
    dec_ref r116
    goto L78
L92:
    dec_ref r110
    dec_ref r117
    goto L78
L93:
    dec_ref r110
    dec_ref r117
    dec_ref r123
    goto L78
L94:
    dec_ref r110
    dec_ref r117
    dec_ref r123
    dec_ref r126
    goto L78
L95:
    dec_ref r166
    goto L78
L96:
    dec_ref r191
    goto L78
L97:
    dec_ref r205
    goto L78
L98:
    dec_ref r205
    dec_ref r217
    goto L78
L99:
    dec_ref r205
    dec_ref r217
    dec_ref r219
    goto L78

def lru_cache_lite_wrap_lru_cache_lite_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def lru_cache_lite_wrap_lru_cache_lite_obj.__call__(__mypyc_self__, args):
    __mypyc_self__ :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_obj
    args :: tuple
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_env
    r1 :: dict
    r2, r3, retval, r4 :: object
    r5 :: bit
    r6 :: object
    r7 :: list
    r8 :: object
    r9 :: tuple
    r10 :: dict
    r11 :: object
    r12 :: dict
    r13 :: i32
    r14 :: bit
    r15 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L15 (error at lru_cache_lite_wrap:41) else goto L1
L1:
    r1 = r0.cache
    if is_error(r1) goto L16 (error at lru_cache_lite_wrap:42) else goto L2
L2:
    r2 = r0.cache_miss
    if is_error(r2) goto L17 (error at lru_cache_lite_wrap:42) else goto L3
L3:
    r3 = CPyDict_Get(r1, args, r2)
    dec_ref r1
    dec_ref r2
    if is_error(r3) goto L16 (error at lru_cache_lite_wrap:42) else goto L4
L4:
    retval = r3
    r4 = r0.cache_miss
    if is_error(r4) goto L18 (error at lru_cache_lite_wrap:43) else goto L5
L5:
    r5 = retval == r4
    dec_ref r4
    if r5 goto L19 else goto L20 :: bool
L6:
    r6 = r0.func
    if is_error(r6) goto L16 (error at lru_cache_lite_wrap:44) else goto L7
L7:
    r7 = PyList_New(0)
    if is_error(r7) goto L21 (error at lru_cache_lite_wrap:44) else goto L8
L8:
    r8 = CPyList_Extend(r7, args)
    if is_error(r8) goto L22 (error at lru_cache_lite_wrap:44) else goto L23
L9:
    r9 = PyList_AsTuple(r7)
    dec_ref r7
    if is_error(r9) goto L21 (error at lru_cache_lite_wrap:44) else goto L10
L10:
    r10 = PyDict_New()
    if is_error(r10) goto L24 (error at lru_cache_lite_wrap:44) else goto L11
L11:
    r11 = PyObject_Call(r6, r9, r10)
    dec_ref r6
    dec_ref r9
    dec_ref r10
    if is_error(r11) goto L16 (error at lru_cache_lite_wrap:44) else goto L12
L12:
    retval = r11
    r12 = r0.cache
    dec_ref r0
    if is_error(r12) goto L25 (error at lru_cache_lite_wrap:45) else goto L13
L13:
    r13 = CPyDict_SetItem(r12, args, retval)
    dec_ref r12
    r14 = r13 >= 0 :: signed
    if not r14 goto L25 (error at lru_cache_lite_wrap:45) else goto L14 :: bool
L14:
    return retval
L15:
    r15 = <error> :: object
    return r15
L16:
    dec_ref r0
    goto L15
L17:
    dec_ref r0
    dec_ref r1
    goto L15
L18:
    dec_ref r0
    dec_ref retval
    goto L15
L19:
    dec_ref retval
    goto L6
L20:
    dec_ref r0
    goto L14
L21:
    dec_ref r0
    dec_ref r6
    goto L15
L22:
    dec_ref r0
    dec_ref r6
    dec_ref r7
    goto L15
L23:
    dec_ref r8
    goto L9
L24:
    dec_ref r0
    dec_ref r6
    dec_ref r9
    goto L15
L25:
    dec_ref retval
    goto L15

def lru_cache_lite(func):
    func :: object
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_env
    r1 :: bool
    r2 :: dict
    r3 :: bool
    r4 :: object
    r5 :: str
    r6, r7 :: object
    r8 :: bool
    r9 :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_obj
    r10 :: bool
    r11 :: object
    r12 :: dict
    r13 :: str
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: object[1]
    r19 :: object_ptr
    r20 :: object
    r21 :: dict
    r22 :: str
    r23 :: i32
    r24 :: bit
    r25 :: dict
    r26 :: str
    r27 :: i32
    r28 :: bit
    r29 :: object
L0:
    r0 = lru_cache_lite_env()
    if is_error(r0) goto L17 (error at lru_cache_lite:11) else goto L1
L1:
    inc_ref func
    r0.func = func; r1 = is_error
    if not r1 goto L18 (error at lru_cache_lite:11) else goto L2 :: bool
L2:
    r2 = PyDict_New()
    if is_error(r2) goto L18 (error at lru_cache_lite:37) else goto L3
L3:
    r0.cache = r2; r3 = is_error
    if not r3 goto L18 (error at lru_cache_lite:37) else goto L4 :: bool
L4:
    r4 = builtins :: module
    r5 = 'object'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L18 (error at lru_cache_lite:38) else goto L5
L5:
    r7 = PyObject_Vectorcall(r6, 0, 0, 0)
    dec_ref r6
    if is_error(r7) goto L18 (error at lru_cache_lite:38) else goto L6
L6:
    r0.cache_miss = r7; r8 = is_error
    if not r8 goto L18 (error at lru_cache_lite:38) else goto L7 :: bool
L7:
    r9 = lru_cache_lite_wrap_lru_cache_lite_obj()
    if is_error(r9) goto L18 (error at lru_cache_lite:41) else goto L8
L8:
    inc_ref r0
    r9.__mypyc_env__ = r0; r10 = is_error
    if not r10 goto L19 (error at lru_cache_lite:41) else goto L9 :: bool
L9:
    r11 = r0.func
    if is_error(r11) goto L19 (error at lru_cache_lite:40) else goto L10
L10:
    r12 = dank_mids.helpers.lru_cache.globals :: static
    r13 = 'wraps'
    r14 = CPyDict_GetItem(r12, r13)
    if is_error(r14) goto L20 (error at lru_cache_lite:40) else goto L11
L11:
    r15 = [r11]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L20 (error at lru_cache_lite:40) else goto L12
L12:
    dec_ref r11
    r18 = [r9]
    r19 = load_address r18
    r20 = PyObject_Vectorcall(r17, r19, 1, 0)
    dec_ref r17
    if is_error(r20) goto L19 (error at lru_cache_lite:41) else goto L13
L13:
    dec_ref r9
    inc_ref r20
    r21 = dank_mids.helpers.lru_cache.globals :: static
    r22 = 'lru_cache_lite_wrap'
    r23 = CPyDict_SetItem(r21, r22, r20)
    dec_ref r20
    r24 = r23 >= 0 :: signed
    if not r24 goto L21 (error at lru_cache_lite:41) else goto L14 :: bool
L14:
    r25 = r0.cache
    dec_ref r0
    if is_error(r25) goto L22 (error at lru_cache_lite:48) else goto L15
L15:
    r26 = 'cache'
    r27 = PyObject_SetAttr(r20, r26, r25)
    dec_ref r25
    r28 = r27 >= 0 :: signed
    if not r28 goto L22 (error at lru_cache_lite:48) else goto L16 :: bool
L16:
    return r20
L17:
    r29 = <error> :: object
    return r29
L18:
    dec_ref r0
    goto L17
L19:
    dec_ref r0
    dec_ref r9
    goto L17
L20:
    dec_ref r0
    dec_ref r9
    dec_ref r11
    goto L17
L21:
    dec_ref r0
    dec_ref r20
    goto L17
L22:
    dec_ref r20
    goto L17

def lru_cache_lite_wrap_lru_cache_lite_nonull_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def lru_cache_lite_wrap_lru_cache_lite_nonull_obj.__call__(__mypyc_self__, args):
    __mypyc_self__ :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_nonull_obj
    args :: tuple
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_nonull_env
    r1 :: dict
    r2 :: object
    retval :: union[object, None]
    r3 :: object
    r4 :: bit
    r5 :: object
    r6 :: list
    r7 :: object
    r8 :: tuple
    r9 :: dict
    r10 :: object
    r11 :: dict
    r12 :: i32
    r13 :: bit
    r14 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L13 (error at lru_cache_lite_wrap:89) else goto L1
L1:
    r1 = r0.cache
    if is_error(r1) goto L14 (error at lru_cache_lite_wrap:90) else goto L2
L2:
    r2 = CPyDict_GetWithNone(r1, args)
    dec_ref r1
    if is_error(r2) goto L14 (error at lru_cache_lite_wrap:90) else goto L3
L3:
    retval = r2
    r3 = load_address _Py_NoneStruct
    r4 = retval == r3
    if r4 goto L15 else goto L16 :: bool
L4:
    r5 = r0.func
    if is_error(r5) goto L14 (error at lru_cache_lite_wrap:92) else goto L5
L5:
    r6 = PyList_New(0)
    if is_error(r6) goto L17 (error at lru_cache_lite_wrap:92) else goto L6
L6:
    r7 = CPyList_Extend(r6, args)
    if is_error(r7) goto L18 (error at lru_cache_lite_wrap:92) else goto L19
L7:
    r8 = PyList_AsTuple(r6)
    dec_ref r6
    if is_error(r8) goto L17 (error at lru_cache_lite_wrap:92) else goto L8
L8:
    r9 = PyDict_New()
    if is_error(r9) goto L20 (error at lru_cache_lite_wrap:92) else goto L9
L9:
    r10 = PyObject_Call(r5, r8, r9)
    dec_ref r5
    dec_ref r8
    dec_ref r9
    if is_error(r10) goto L14 (error at lru_cache_lite_wrap:92) else goto L10
L10:
    retval = r10
    r11 = r0.cache
    dec_ref r0
    if is_error(r11) goto L21 (error at lru_cache_lite_wrap:93) else goto L11
L11:
    r12 = CPyDict_SetItem(r11, args, retval)
    dec_ref r11
    r13 = r12 >= 0 :: signed
    if not r13 goto L21 (error at lru_cache_lite_wrap:93) else goto L12 :: bool
L12:
    return retval
L13:
    r14 = <error> :: object
    return r14
L14:
    dec_ref r0
    goto L13
L15:
    dec_ref retval
    goto L4
L16:
    dec_ref r0
    goto L12
L17:
    dec_ref r0
    dec_ref r5
    goto L13
L18:
    dec_ref r0
    dec_ref r5
    dec_ref r6
    goto L13
L19:
    dec_ref r7
    goto L7
L20:
    dec_ref r0
    dec_ref r5
    dec_ref r8
    goto L13
L21:
    dec_ref retval
    goto L13

def lru_cache_lite_nonull(func):
    func :: object
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_nonull_env
    r1 :: bool
    r2 :: dict
    r3 :: bool
    r4 :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_nonull_obj
    r5 :: bool
    r6 :: object
    r7 :: dict
    r8 :: str
    r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: i32
    r19 :: bit
    r20 :: dict
    r21 :: str
    r22 :: i32
    r23 :: bit
    r24 :: object
L0:
    r0 = lru_cache_lite_nonull_env()
    if is_error(r0) goto L14 (error at lru_cache_lite_nonull:52) else goto L1
L1:
    inc_ref func
    r0.func = func; r1 = is_error
    if not r1 goto L15 (error at lru_cache_lite_nonull:52) else goto L2 :: bool
L2:
    r2 = PyDict_New()
    if is_error(r2) goto L15 (error at lru_cache_lite_nonull:86) else goto L3
L3:
    r0.cache = r2; r3 = is_error
    if not r3 goto L15 (error at lru_cache_lite_nonull:86) else goto L4 :: bool
L4:
    r4 = lru_cache_lite_wrap_lru_cache_lite_nonull_obj()
    if is_error(r4) goto L15 (error at lru_cache_lite_nonull:89) else goto L5
L5:
    inc_ref r0
    r4.__mypyc_env__ = r0; r5 = is_error
    if not r5 goto L16 (error at lru_cache_lite_nonull:89) else goto L6 :: bool
L6:
    r6 = r0.func
    if is_error(r6) goto L16 (error at lru_cache_lite_nonull:88) else goto L7
L7:
    r7 = dank_mids.helpers.lru_cache.globals :: static
    r8 = 'wraps'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L17 (error at lru_cache_lite_nonull:88) else goto L8
L8:
    r10 = [r6]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r9, r11, 1, 0)
    dec_ref r9
    if is_error(r12) goto L17 (error at lru_cache_lite_nonull:88) else goto L9
L9:
    dec_ref r6
    r13 = [r4]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L16 (error at lru_cache_lite_nonull:89) else goto L10
L10:
    dec_ref r4
    inc_ref r15
    r16 = dank_mids.helpers.lru_cache.globals :: static
    r17 = 'lru_cache_lite_wrap'
    r18 = CPyDict_SetItem(r16, r17, r15)
    dec_ref r15
    r19 = r18 >= 0 :: signed
    if not r19 goto L18 (error at lru_cache_lite_nonull:89) else goto L11 :: bool
L11:
    r20 = r0.cache
    dec_ref r0
    if is_error(r20) goto L19 (error at lru_cache_lite_nonull:96) else goto L12
L12:
    r21 = 'cache'
    r22 = PyObject_SetAttr(r15, r21, r20)
    dec_ref r20
    r23 = r22 >= 0 :: signed
    if not r23 goto L19 (error at lru_cache_lite_nonull:96) else goto L13 :: bool
L13:
    return r15
L14:
    r24 = <error> :: object
    return r24
L15:
    dec_ref r0
    goto L14
L16:
    dec_ref r0
    dec_ref r4
    goto L14
L17:
    dec_ref r0
    dec_ref r4
    dec_ref r6
    goto L14
L18:
    dec_ref r0
    dec_ref r15
    goto L14
L19:
    dec_ref r15
    goto L14

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: str
    r18 :: dict
    r19 :: str
    r20 :: object
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: dict
    r25 :: str
    r26 :: i32
    r27 :: bit
    r28 :: str
    r29 :: dict
    r30 :: str
    r31 :: object
    r32 :: object[1]
    r33 :: object_ptr
    r34 :: object
    r35 :: dict
    r36 :: str
    r37 :: i32
    r38 :: bit
    r39, r40 :: str
    r41 :: list
    r42, r43, r44 :: ptr
    r45 :: dict
    r46 :: str
    r47 :: i32
    r48 :: bit
    r49 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L15 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('wraps',)
    r6 = 'functools'
    r7 = dank_mids.helpers.lru_cache.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L15 (error at <module>:1) else goto L4
L4:
    functools = r8 :: module
    dec_ref r8
    r9 = ('Callable', 'Dict', 'TypeVar')
    r10 = 'typing'
    r11 = dank_mids.helpers.lru_cache.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L15 (error at <module>:2) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = ('ParamSpec',)
    r14 = 'typing_extensions'
    r15 = dank_mids.helpers.lru_cache.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L15 (error at <module>:4) else goto L6
L6:
    typing_extensions = r16 :: module
    dec_ref r16
    r17 = '__P'
    r18 = dank_mids.helpers.lru_cache.globals :: static
    r19 = 'ParamSpec'
    r20 = CPyDict_GetItem(r18, r19)
    if is_error(r20) goto L15 (error at <module>:7) else goto L7
L7:
    r21 = [r17]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(r20, r22, 1, 0)
    dec_ref r20
    if is_error(r23) goto L15 (error at <module>:7) else goto L8
L8:
    r24 = dank_mids.helpers.lru_cache.globals :: static
    r25 = '__P'
    r26 = CPyDict_SetItem(r24, r25, r23)
    dec_ref r23
    r27 = r26 >= 0 :: signed
    if not r27 goto L15 (error at <module>:7) else goto L9 :: bool
L9:
    r28 = '__T'
    r29 = dank_mids.helpers.lru_cache.globals :: static
    r30 = 'TypeVar'
    r31 = CPyDict_GetItem(r29, r30)
    if is_error(r31) goto L15 (error at <module>:8) else goto L10
L10:
    r32 = [r28]
    r33 = load_address r32
    r34 = PyObject_Vectorcall(r31, r33, 1, 0)
    dec_ref r31
    if is_error(r34) goto L15 (error at <module>:8) else goto L11
L11:
    r35 = dank_mids.helpers.lru_cache.globals :: static
    r36 = '__T'
    r37 = CPyDict_SetItem(r35, r36, r34)
    dec_ref r34
    r38 = r37 >= 0 :: signed
    if not r38 goto L15 (error at <module>:8) else goto L12 :: bool
L12:
    r39 = 'lru_cache_lite'
    r40 = 'lru_cache_lite_nonull'
    r41 = PyList_New(2)
    if is_error(r41) goto L15 (error at <module>:100) else goto L13
L13:
    r42 = get_element_ptr r41 ob_item :: PyListObject
    r43 = load_mem r42 :: ptr*
    inc_ref r39
    set_mem r43, r39 :: builtins.object*
    inc_ref r40
    r44 = r43 + 8
    set_mem r44, r40 :: builtins.object*
    r45 = dank_mids.helpers.lru_cache.globals :: static
    r46 = '__all__'
    r47 = CPyDict_SetItem(r45, r46, r41)
    dec_ref r41
    r48 = r47 >= 0 :: signed
    if not r48 goto L15 (error at <module>:100) else goto L14 :: bool
L14:
    return 1
L15:
    r49 = <error> :: None
    return r49

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24 :: object
    r25, r26, r27, r28, r29, r30, r31 :: str
    r32 :: list
    r33, r34, r35, r36, r37, r38, r39, r40 :: ptr
    r41 :: dict
    r42 :: str
    r43 :: i32
    r44 :: bit
    r45 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L11 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('gatherish',)
    r6 = 'dank_mids.helpers._gather'
    r7 = dank_mids.helpers.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L11 (error at <module>:1) else goto L4
L4:
    dank_mids.helpers._gather = r8 :: module
    dec_ref r8
    r9 = ('setup_dank_w3', 'setup_dank_w3_from_sync')
    r10 = 'dank_mids.helpers._helpers'
    r11 = dank_mids.helpers.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L11 (error at <module>:2) else goto L5
L5:
    dank_mids.helpers._helpers = r12 :: module
    dec_ref r12
    r13 = ('DebuggableFuture',)
    r14 = 'dank_mids.helpers.future'
    r15 = dank_mids.helpers.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L11 (error at <module>:3) else goto L6
L6:
    dank_mids.helpers.future = r16 :: module
    dec_ref r16
    r17 = ('make_hashable',)
    r18 = 'dank_mids.helpers.hashing'
    r19 = dank_mids.helpers.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L11 (error at <module>:4) else goto L7
L7:
    dank_mids.helpers.hashing = r20 :: module
    dec_ref r20
    r21 = ('lru_cache_lite', 'lru_cache_lite_nonull')
    r22 = 'dank_mids.helpers.lru_cache'
    r23 = dank_mids.helpers.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L11 (error at <module>:5) else goto L8
L8:
    dank_mids.helpers.lru_cache = r24 :: module
    dec_ref r24
    r25 = 'setup_dank_w3'
    r26 = 'setup_dank_w3_from_sync'
    r27 = 'DebuggableFuture'
    r28 = 'lru_cache_lite'
    r29 = 'lru_cache_lite_nonull'
    r30 = 'make_hashable'
    r31 = 'gatherish'
    r32 = PyList_New(7)
    if is_error(r32) goto L11 (error at <module>:7) else goto L9
L9:
    r33 = get_element_ptr r32 ob_item :: PyListObject
    r34 = load_mem r33 :: ptr*
    inc_ref r25
    set_mem r34, r25 :: builtins.object*
    inc_ref r26
    r35 = r34 + 8
    set_mem r35, r26 :: builtins.object*
    inc_ref r27
    r36 = r34 + 16
    set_mem r36, r27 :: builtins.object*
    inc_ref r28
    r37 = r34 + 24
    set_mem r37, r28 :: builtins.object*
    inc_ref r29
    r38 = r34 + 32
    set_mem r38, r29 :: builtins.object*
    inc_ref r30
    r39 = r34 + 40
    set_mem r39, r30 :: builtins.object*
    inc_ref r31
    r40 = r34 + 48
    set_mem r40, r31 :: builtins.object*
    r41 = dank_mids.helpers.globals :: static
    r42 = '__all__'
    r43 = CPyDict_SetItem(r41, r42, r32)
    dec_ref r32
    r44 = r43 >= 0 :: signed
    if not r44 goto L11 (error at <module>:7) else goto L10 :: bool
L10:
    return 1
L11:
    r45 = <error> :: None
    return r45

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: object
    r22 :: dict
    r23 :: str
    r24 :: i32
    r25 :: bit
    r26 :: dict
    r27 :: str
    r28 :: object
    r29 :: i32
    r30 :: bit
    r31 :: dict
    r32 :: str
    r33 :: object
    r34 :: i32
    r35 :: bit
    r36 :: dict
    r37 :: str
    r38 :: object
    r39 :: i32
    r40 :: bit
    r41 :: dict
    r42 :: str
    r43 :: object
    r44 :: i32
    r45 :: bit
    r46 :: dict
    r47 :: str
    r48 :: object
    r49 :: i32
    r50 :: bit
    r51 :: dict
    r52 :: str
    r53 :: object
    r54 :: i32
    r55 :: bit
    r56 :: dict
    r57 :: str
    r58 :: object
    r59 :: i32
    r60 :: bit
    r61 :: dict
    r62 :: str
    r63 :: object
    r64 :: i32
    r65 :: bit
    r66 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L16 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address logging :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('logging', 'logging', 'logging'),)
    r11 = dank_mids._logging.globals :: static
    r12 = 'dank_mids/_logging.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L16 else goto L4 :: bool
L4:
    r15 = ('Final',)
    r16 = 'typing'
    r17 = dank_mids._logging.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L16 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = logging :: module
    r20 = 'getLogger'
    r21 = CPyObject_GetAttr(r19, r20)
    if is_error(r21) goto L16 (error at <module>:5) else goto L6
L6:
    dank_mids._logging.getLogger = r21 :: static
    r22 = dank_mids._logging.globals :: static
    r23 = 'getLogger'
    r24 = CPyDict_SetItem(r22, r23, r21)
    dec_ref r21
    r25 = r24 >= 0 :: signed
    if not r25 goto L16 (error at <module>:5) else goto L7 :: bool
L7:
    dank_mids._logging.CRITICAL = 100 :: static
    r26 = dank_mids._logging.globals :: static
    r27 = 'CRITICAL'
    r28 = object 50
    r29 = CPyDict_SetItem(r26, r27, r28)
    r30 = r29 >= 0 :: signed
    if not r30 goto L16 (error at <module>:6) else goto L8 :: bool
L8:
    dank_mids._logging.FATAL = 100 :: static
    r31 = dank_mids._logging.globals :: static
    r32 = 'FATAL'
    r33 = object 50
    r34 = CPyDict_SetItem(r31, r32, r33)
    r35 = r34 >= 0 :: signed
    if not r35 goto L16 (error at <module>:7) else goto L9 :: bool
L9:
    dank_mids._logging.ERROR = 80 :: static
    r36 = dank_mids._logging.globals :: static
    r37 = 'ERROR'
    r38 = object 40
    r39 = CPyDict_SetItem(r36, r37, r38)
    r40 = r39 >= 0 :: signed
    if not r40 goto L16 (error at <module>:8) else goto L10 :: bool
L10:
    dank_mids._logging.WARN = 60 :: static
    r41 = dank_mids._logging.globals :: static
    r42 = 'WARN'
    r43 = object 30
    r44 = CPyDict_SetItem(r41, r42, r43)
    r45 = r44 >= 0 :: signed
    if not r45 goto L16 (error at <module>:9) else goto L11 :: bool
L11:
    dank_mids._logging.WARNING = 60 :: static
    r46 = dank_mids._logging.globals :: static
    r47 = 'WARNING'
    r48 = object 30
    r49 = CPyDict_SetItem(r46, r47, r48)
    r50 = r49 >= 0 :: signed
    if not r50 goto L16 (error at <module>:10) else goto L12 :: bool
L12:
    dank_mids._logging.INFO = 40 :: static
    r51 = dank_mids._logging.globals :: static
    r52 = 'INFO'
    r53 = object 20
    r54 = CPyDict_SetItem(r51, r52, r53)
    r55 = r54 >= 0 :: signed
    if not r55 goto L16 (error at <module>:11) else goto L13 :: bool
L13:
    dank_mids._logging.DEBUG = 20 :: static
    r56 = dank_mids._logging.globals :: static
    r57 = 'DEBUG'
    r58 = object 10
    r59 = CPyDict_SetItem(r56, r57, r58)
    r60 = r59 >= 0 :: signed
    if not r60 goto L16 (error at <module>:12) else goto L14 :: bool
L14:
    dank_mids._logging.NOTSET = 0 :: static
    r61 = dank_mids._logging.globals :: static
    r62 = 'NOTSET'
    r63 = object 0
    r64 = CPyDict_SetItem(r61, r62, r63)
    r65 = r64 >= 0 :: signed
    if not r65 goto L16 (error at <module>:13) else goto L15 :: bool
L15:
    return 1
L16:
    r66 = <error> :: None
    return r66

def get_len(method):
    method, r0 :: str
    r1 :: bool
    r2 :: set
    r3 :: i32
    r4 :: bit
    r5 :: bool
    r6 :: str
    r7 :: i32
    r8 :: bit
    r9 :: bool
    r10 :: int
L0:
    r0 = 'eth_getTransactionReceipt'
    r1 = CPyStr_Equal(method, r0)
    if r1 goto L1 else goto L2 :: bool
L1:
    return 10
L2:
    r2 = frozenset({'eth_getCode', 'eth_getTransaction'})
    r3 = PySet_Contains(r2, method)
    r4 = r3 >= 0 :: signed
    if not r4 goto L8 (error at get_len:18) else goto L3 :: bool
L3:
    r5 = truncate r3: i32 to builtins.bool
    if r5 goto L6 else goto L4 :: bool
L4:
    r6 = 'eth_getBlockBy'
    r7 = PyUnicode_Contains(method, r6)
    r8 = r7 >= 0 :: signed
    if not r8 goto L8 (error at get_len:18) else goto L5 :: bool
L5:
    r9 = truncate r7: i32 to builtins.bool
    if r9 goto L6 else goto L7 :: bool
L6:
    return 6
L7:
    return 2
L8:
    r10 = <error> :: int
    return r10

def should_batch(method):
    method :: str
    r0 :: bool
    r1 :: tuple[str, str, str, str]
    r2 :: bool
    r3, r4, r5 :: object
    r6 :: str
    r7 :: i32
    r8 :: bit
    r9, r10, r11 :: bool
    r12 :: bit
    r13 :: bool
L0:
    r0 = 1
    r1 = dank_mids.helpers.method.BYPASS_METHODS :: static
    if is_error(r1) goto L1 else goto L3
L1:
    r2 = raise NameError('value for final name "BYPASS_METHODS" was not set')
    if not r2 goto L11 (error at should_batch:25) else goto L2 :: bool
L2:
    unreachable
L3:
    inc_ref r1
    r3 = box(tuple[str, str, str, str], r1)
    r4 = PyObject_GetIter(r3)
    dec_ref r3
    if is_error(r4) goto L11 (error at should_batch:25) else goto L4
L4:
    r5 = PyIter_Next(r4)
    if is_error(r5) goto L12 else goto L5
L5:
    r6 = cast(str, r5)
    if is_error(r6) goto L13 (error at should_batch:25) else goto L6
L6:
    r7 = PyUnicode_Contains(method, r6)
    dec_ref r6
    r8 = r7 >= 0 :: signed
    if not r8 goto L13 (error at should_batch:25) else goto L7 :: bool
L7:
    r9 = truncate r7: i32 to builtins.bool
    r10 = r9 ^ 1
    r11 = r10 ^ 1
    if r11 goto L14 else goto L4 :: bool
L8:
    r0 = 0
    goto L10
L9:
    r12 = CPy_NoErrOccurred()
    if not r12 goto L11 (error at should_batch:25) else goto L10 :: bool
L10:
    return r0
L11:
    r13 = <error> :: bool
    return r13
L12:
    dec_ref r4
    goto L9
L13:
    dec_ref r4
    goto L11
L14:
    dec_ref r4
    goto L8

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13, r14, r15, r16 :: str
    r17 :: tuple[str, str, str, str]
    r18 :: dict
    r19 :: str
    r20 :: object
    r21 :: i32
    r22 :: bit
    r23 :: dict
    r24 :: str
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: object
    r29 :: object[1]
    r30 :: object_ptr
    r31 :: object
    r32 :: dict
    r33 :: str
    r34 :: i32
    r35 :: bit
    r36 :: dict
    r37 :: str
    r38 :: object
    r39 :: dict
    r40 :: str
    r41 :: object
    r42 :: object[1]
    r43 :: object_ptr
    r44 :: object
    r45 :: dict
    r46 :: str
    r47 :: i32
    r48 :: bit
    r49 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L15 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = dank_mids.helpers.method.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L15 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('lru_cache_lite_nonull',)
    r10 = 'dank_mids.helpers.lru_cache'
    r11 = dank_mids.helpers.method.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L15 (error at <module>:3) else goto L5
L5:
    dank_mids.helpers.lru_cache = r12 :: module
    dec_ref r12
    r13 = 'eth_blockNumber'
    r14 = 'eth_getLogs'
    r15 = 'trace_'
    r16 = 'debug_'
    inc_ref r13
    inc_ref r14
    inc_ref r15
    inc_ref r16
    r17 = (r13, r14, r15, r16)
    dank_mids.helpers.method.BYPASS_METHODS = r17 :: static
    r18 = dank_mids.helpers.method.globals :: static
    r19 = 'BYPASS_METHODS'
    r20 = box(tuple[str, str, str, str], r17)
    r21 = CPyDict_SetItem(r18, r19, r20)
    dec_ref r20
    r22 = r21 >= 0 :: signed
    if not r22 goto L15 (error at <module>:6) else goto L6 :: bool
L6:
    r23 = dank_mids.helpers.method.globals :: static
    r24 = 'get_len'
    r25 = CPyDict_GetItem(r23, r24)
    if is_error(r25) goto L15 (error at <module>:13) else goto L7
L7:
    r26 = dank_mids.helpers.method.globals :: static
    r27 = 'lru_cache_lite_nonull'
    r28 = CPyDict_GetItem(r26, r27)
    if is_error(r28) goto L16 (error at <module>:13) else goto L8
L8:
    r29 = [r25]
    r30 = load_address r29
    r31 = PyObject_Vectorcall(r28, r30, 1, 0)
    dec_ref r28
    if is_error(r31) goto L16 (error at <module>:13) else goto L9
L9:
    dec_ref r25
    r32 = dank_mids.helpers.method.globals :: static
    r33 = 'get_len'
    r34 = CPyDict_SetItem(r32, r33, r31)
    dec_ref r31
    r35 = r34 >= 0 :: signed
    if not r35 goto L15 (error at <module>:13) else goto L10 :: bool
L10:
    r36 = dank_mids.helpers.method.globals :: static
    r37 = 'should_batch'
    r38 = CPyDict_GetItem(r36, r37)
    if is_error(r38) goto L15 (error at <module>:23) else goto L11
L11:
    r39 = dank_mids.helpers.method.globals :: static
    r40 = 'lru_cache_lite_nonull'
    r41 = CPyDict_GetItem(r39, r40)
    if is_error(r41) goto L17 (error at <module>:23) else goto L12
L12:
    r42 = [r38]
    r43 = load_address r42
    r44 = PyObject_Vectorcall(r41, r43, 1, 0)
    dec_ref r41
    if is_error(r44) goto L17 (error at <module>:23) else goto L13
L13:
    dec_ref r38
    r45 = dank_mids.helpers.method.globals :: static
    r46 = 'should_batch'
    r47 = CPyDict_SetItem(r45, r46, r44)
    dec_ref r44
    r48 = r47 >= 0 :: signed
    if not r48 goto L15 (error at <module>:23) else goto L14 :: bool
L14:
    return 1
L15:
    r49 = <error> :: None
    return r49
L16:
    dec_ref r25
    goto L15
L17:
    dec_ref r38
    goto L15

def __mypyc_lambda__0_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__0_obj.__call__(__mypyc_self__, self, args):
    __mypyc_self__ :: dank_mids.brownie_patch.call.__mypyc_lambda__0_obj
    self, args :: object
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: list
    r15, r16, r17, r18 :: ptr
    r19 :: object
    r20 :: tuple
    r21 :: dict
    r22, r23 :: object
L0:
    r0 = dank_mids.brownie_patch.call.globals :: static
    r1 = 'ENVS'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L12 (error at <lambda>:82) else goto L1
L1:
    r3 = 'BROWNIE_ENCODER_PROCESSES'
    r4 = CPyObject_GetAttr(r2, r3)
    dec_ref r2
    if is_error(r4) goto L12 (error at <lambda>:82) else goto L2
L2:
    r5 = dank_mids.brownie_patch.call.globals :: static
    r6 = '__encode_input'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L13 (error at <lambda>:82) else goto L3
L3:
    r8 = 'abi'
    r9 = CPyObject_GetAttr(self, r8)
    if is_error(r9) goto L14 (error at <lambda>:82) else goto L4
L4:
    r10 = 'signature'
    r11 = CPyObject_GetAttr(self, r10)
    if is_error(r11) goto L15 (error at <lambda>:82) else goto L5
L5:
    r12 = 'run'
    r13 = CPyObject_GetAttr(r4, r12)
    dec_ref r4
    if is_error(r13) goto L16 (error at <lambda>:82) else goto L6
L6:
    r14 = PyList_New(3)
    if is_error(r14) goto L17 (error at <lambda>:82) else goto L7
L7:
    r15 = get_element_ptr r14 ob_item :: PyListObject
    r16 = load_mem r15 :: ptr*
    set_mem r16, r7 :: builtins.object*
    r17 = r16 + 8
    set_mem r17, r9 :: builtins.object*
    r18 = r16 + 16
    set_mem r18, r11 :: builtins.object*
    r19 = CPyList_Extend(r14, args)
    if is_error(r19) goto L18 (error at <lambda>:82) else goto L19
L8:
    r20 = PyList_AsTuple(r14)
    dec_ref r14
    if is_error(r20) goto L20 (error at <lambda>:82) else goto L9
L9:
    r21 = PyDict_New()
    if is_error(r21) goto L21 (error at <lambda>:82) else goto L10
L10:
    r22 = PyObject_Call(r13, r20, r21)
    dec_ref r13
    dec_ref r20
    dec_ref r21
    if is_error(r22) goto L12 (error at <lambda>:82) else goto L11
L11:
    return r22
L12:
    r23 = <error> :: object
    return r23
L13:
    dec_ref r4
    goto L12
L14:
    dec_ref r4
    dec_ref r7
    goto L12
L15:
    dec_ref r4
    dec_ref r7
    dec_ref r9
    goto L12
L16:
    dec_ref r7
    dec_ref r9
    dec_ref r11
    goto L12
L17:
    dec_ref r7
    dec_ref r9
    dec_ref r11
    dec_ref r13
    goto L12
L18:
    dec_ref r13
    dec_ref r14
    goto L12
L19:
    dec_ref r19
    goto L8
L20:
    dec_ref r13
    goto L12
L21:
    dec_ref r13
    dec_ref r20
    goto L12

def __mypyc_lambda__1_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__1_obj.__call__(__mypyc_self__, self, data):
    __mypyc_self__ :: dank_mids.brownie_patch.call.__mypyc_lambda__1_obj
    self :: object
    data :: bytes
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: str
    r11 :: object[4]
    r12 :: object_ptr
    r13, r14 :: object
L0:
    r0 = dank_mids.brownie_patch.call.globals :: static
    r1 = 'ENVS'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L6 (error at <lambda>:101) else goto L1
L1:
    r3 = 'BROWNIE_DECODER_PROCESSES'
    r4 = CPyObject_GetAttr(r2, r3)
    dec_ref r2
    if is_error(r4) goto L6 (error at <lambda>:101) else goto L2
L2:
    r5 = dank_mids.brownie_patch.call.globals :: static
    r6 = '__decode_output'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L7 (error at <lambda>:101) else goto L3
L3:
    r8 = 'abi'
    r9 = CPyObject_GetAttr(self, r8)
    if is_error(r9) goto L8 (error at <lambda>:101) else goto L4
L4:
    r10 = 'run'
    r11 = [r4, r7, data, r9]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775812, 0)
    if is_error(r13) goto L9 (error at <lambda>:101) else goto L5
L5:
    dec_ref r4
    dec_ref r7
    dec_ref r9
    return r13
L6:
    r14 = <error> :: object
    return r14
L7:
    dec_ref r4
    goto L6
L8:
    dec_ref r4
    dec_ref r7
    goto L6
L9:
    dec_ref r4
    dec_ref r7
    dec_ref r9
    goto L6

def _patch_call(call, w3):
    call, w3 :: object
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: set
    r6 :: i32
    r7 :: bit
    r8 :: bool
    r9 :: str
    r10 :: object
    r11 :: i32
    r12 :: bit
    r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: int
    r18 :: dict
    r19 :: str
    r20, r21 :: object
    r22 :: object[2]
    r23 :: object_ptr
    r24 :: object
    r25 :: dict
    r26 :: str
    r27 :: object
    r28 :: object[2]
    r29 :: object_ptr
    r30 :: object
    r31 :: str
    r32 :: i32
    r33 :: bit
    r34 :: dict
    r35 :: str
    r36 :: object
    r37 :: dict
    r38 :: str
    r39 :: object
    r40 :: object[2]
    r41 :: object_ptr
    r42 :: object
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: None
L0:
    r0 = '_address'
    r1 = CPyObject_GetAttr(call, r0)
    if is_error(r1) goto L18 (error at _patch_call:135) else goto L1
L1:
    r2 = dank_mids.brownie_patch.call.globals :: static
    r3 = '_skip_proc_pool'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L19 (error at _patch_call:135) else goto L2
L2:
    r5 = cast(set, r4)
    if is_error(r5) goto L19 (error at _patch_call:135) else goto L3
L3:
    r6 = PySet_Contains(r5, r1)
    dec_ref r5
    dec_ref r1
    r7 = r6 >= 0 :: signed
    if not r7 goto L18 (error at _patch_call:135) else goto L4 :: bool
L4:
    r8 = truncate r6: i32 to builtins.bool
    r9 = '_skip_decoder_proc_pool'
    r10 = box(bool, r8)
    r11 = PyObject_SetAttr(call, r9, r10)
    r12 = r11 >= 0 :: signed
    if not r12 goto L18 (error at _patch_call:135) else goto L5 :: bool
L5:
    r13 = 'abi'
    r14 = CPyObject_GetAttr(call, r13)
    if is_error(r14) goto L18 (error at _patch_call:136) else goto L6
L6:
    r15 = 'inputs'
    r16 = PyObject_GetItem(r14, r15)
    dec_ref r14
    if is_error(r16) goto L18 (error at _patch_call:136) else goto L7
L7:
    r17 = CPyObject_Size(r16)
    dec_ref r16
    if is_error(r17) goto L18 (error at _patch_call:136) else goto L8
L8:
    r18 = dank_mids.brownie_patch.call.globals :: static
    r19 = '_get_coroutine_fn'
    r20 = CPyDict_GetItem(r18, r19)
    if is_error(r20) goto L20 (error at _patch_call:136) else goto L9
L9:
    r21 = box(int, r17)
    r22 = [w3, r21]
    r23 = load_address r22
    r24 = PyObject_Vectorcall(r20, r23, 2, 0)
    dec_ref r20
    if is_error(r24) goto L21 (error at _patch_call:136) else goto L10
L10:
    dec_ref r21
    r25 = dank_mids.brownie_patch.call.globals :: static
    r26 = 'MethodType'
    r27 = CPyDict_GetItem(r25, r26)
    if is_error(r27) goto L22 (error at _patch_call:136) else goto L11
L11:
    r28 = [r24, call]
    r29 = load_address r28
    r30 = PyObject_Vectorcall(r27, r29, 2, 0)
    dec_ref r27
    if is_error(r30) goto L22 (error at _patch_call:136) else goto L12
L12:
    dec_ref r24
    r31 = 'coroutine'
    r32 = PyObject_SetAttr(call, r31, r30)
    dec_ref r30
    r33 = r32 >= 0 :: signed
    if not r33 goto L18 (error at _patch_call:136) else goto L13 :: bool
L13:
    r34 = dank_mids.brownie_patch.call.globals :: static
    r35 = '_call_no_args'
    r36 = CPyDict_GetItem(r34, r35)
    if is_error(r36) goto L18 (error at _patch_call:137) else goto L14
L14:
    r37 = dank_mids.brownie_patch.call.globals :: static
    r38 = 'MethodType'
    r39 = CPyDict_GetItem(r37, r38)
    if is_error(r39) goto L23 (error at _patch_call:137) else goto L15
L15:
    r40 = [r36, call]
    r41 = load_address r40
    r42 = PyObject_Vectorcall(r39, r41, 2, 0)
    dec_ref r39
    if is_error(r42) goto L23 (error at _patch_call:137) else goto L16
L16:
    dec_ref r36
    r43 = '__await__'
    r44 = PyObject_SetAttr(call, r43, r42)
    dec_ref r42
    r45 = r44 >= 0 :: signed
    if not r45 goto L18 (error at _patch_call:137) else goto L17 :: bool
L17:
    return 1
L18:
    r46 = <error> :: None
    return r46
L19:
    dec_ref r1
    goto L18
L20:
    dec_ref r17 :: int
    goto L18
L21:
    dec_ref r21
    goto L18
L22:
    dec_ref r24
    goto L18
L23:
    dec_ref r36
    goto L18

def coroutine__get_coroutine_fn_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def coroutine_gen___147.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine_gen___147
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11 :: object
    r12, r13 :: tuple[object, object, object]
    r14, r15, r16, r17 :: object
    r18, r19 :: tuple[object, object, object]
    r20, r21, r22, r23 :: object
    r24 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_env
    r25 :: i32
    r26 :: dank_mids.brownie_patch.call._get_coroutine_fn_env
    r27 :: object
    r28 :: bit
    r29 :: union[dict, None]
    r30 :: object
    r31 :: bit
    r32 :: dict
    r33 :: native_int
    r34 :: short_int
    r35 :: bit
    r36 :: str
    r37 :: object
    r38 :: str
    r39 :: object
    r40 :: object[1]
    r41 :: object_ptr
    r42, r43 :: object
    r44 :: bool
    r45 :: union[object, None]
    r46, r47 :: object
    r48 :: str
    r49 :: object
    r50 :: bool
    r51 :: str
    r52 :: object
    r53 :: object[1]
    r54 :: object_ptr
    r55 :: object
    r56, r57 :: bool
    r58 :: object
    r59 :: bool
    r60, r61, r62, r63, r64 :: object
    r65 :: bool
    r66 :: object
    r67 :: bool
    r68 :: object
    r69 :: bit
    r70 :: tuple[object, object, object]
    r71 :: bool
    r72 :: object_ptr
    r73 :: object
    r74 :: bool
    r75, r76, r77 :: tuple[object, object, object]
    r78 :: bit
    r79, r80, r81, r82 :: object
    r83 :: int
    r84 :: object
    r85 :: tuple
    r86 :: dict
    r87 :: str
    r88 :: object
    r89 :: list
    r90 :: object
    r91, r92, r93, r94 :: ptr
    r95 :: object
    r96 :: tuple
    r97 :: dict
    r98, r99 :: object
    r100 :: bool
    r101, r102, r103, r104, r105 :: object
    r106 :: bool
    r107 :: object
    r108 :: bool
    r109 :: object
    r110 :: bit
    r111 :: tuple[object, object, object]
    r112 :: bool
    r113 :: object_ptr
    r114 :: object
    r115 :: bool
    r116, r117, r118 :: tuple[object, object, object]
    r119 :: bit
    r120, r121, r122 :: object
    r123 :: bool
    r124 :: object
    r125 :: bool
    r126 :: union[object, None]
    r127, r128 :: object
    r129 :: str
    r130 :: object
    r131 :: bool
    r132 :: str
    r133 :: object
    r134 :: object[1]
    r135 :: object_ptr
    r136 :: object
    r137, r138 :: bool
    r139 :: object
    r140 :: bool
    r141, r142, r143, r144, r145 :: object
    r146 :: bool
    r147 :: object
    r148 :: bool
    r149 :: object
    r150 :: bit
    r151 :: tuple[object, object, object]
    r152 :: bool
    r153 :: object_ptr
    r154 :: object
    r155 :: bool
    r156, r157, r158 :: tuple[object, object, object]
    r159 :: bit
    r160, r161, r162, r163 :: object
    r164 :: str
    r165 :: object
    r166 :: str
    r167 :: object
    r168 :: str
    r169 :: object
    r170 :: str
    r171 :: object
    r172 :: dict
    r173 :: union[object, None]
    r174 :: str
    r175 :: object[3]
    r176 :: object_ptr
    r177, r178 :: object
    r179 :: bool
    r180, r181, r182, r183, r184 :: object
    r185 :: bool
    r186 :: object
    r187 :: bool
    r188 :: object
    r189 :: bit
    r190 :: tuple[object, object, object]
    r191 :: bool
    r192 :: object_ptr
    r193 :: object
    r194 :: bool
    r195, r196, r197 :: tuple[object, object, object]
    r198 :: bit
    r199, r200, r201 :: object
    r202 :: bool
    r203 :: tuple[object, object, object]
    r204, r205 :: bool
    r206 :: tuple[object, object, object]
    r207, r208, r209, r210, r211 :: object
    r212 :: object[4]
    r213 :: object_ptr
    r214, r215 :: object
    r216 :: bool
    r217, r218, r219, r220, r221 :: object
    r222 :: bool
    r223 :: object
    r224 :: bool
    r225 :: object
    r226 :: bit
    r227 :: tuple[object, object, object]
    r228 :: bool
    r229 :: object_ptr
    r230 :: object
    r231 :: bool
    r232, r233, r234 :: tuple[object, object, object]
    r235 :: bit
    r236, r237, r238 :: object
    r239 :: i32
    r240 :: bit
    r241 :: bool
    r242, r243 :: tuple[object, object, object]
    r244 :: bit
    r245, r246 :: tuple[object, object, object]
    r247 :: bool
    r248, r249, r250 :: object
    r251 :: object[4]
    r252 :: object_ptr
    r253, r254 :: object
    r255 :: bool
    r256, r257, r258, r259, r260 :: object
    r261 :: bool
    r262 :: object
    r263 :: bool
    r264 :: object
    r265 :: bit
    r266 :: tuple[object, object, object]
    r267 :: bool
    r268 :: object_ptr
    r269 :: object
    r270 :: bool
    r271, r272, r273 :: tuple[object, object, object]
    r274 :: bit
    r275, r276, r277 :: object
    r278 :: bit
    r279 :: tuple[object, object, object]
    r280, r281 :: bool
    r282 :: tuple[object, object, object]
    r283, r284, r285, r286, r287 :: object
    r288 :: object[4]
    r289 :: object_ptr
    r290, r291 :: object
    r292 :: bool
    r293, r294, r295, r296, r297 :: object
    r298 :: bool
    r299 :: object
    r300 :: bool
    r301 :: object
    r302 :: bit
    r303 :: tuple[object, object, object]
    r304 :: bool
    r305 :: object_ptr
    r306 :: object
    r307 :: bool
    r308, r309, r310 :: tuple[object, object, object]
    r311 :: bit
    r312, r313, r314 :: object
    r315 :: i32
    r316 :: bit
    r317 :: bool
    r318, r319 :: tuple[object, object, object]
    r320 :: bit
    r321, r322 :: tuple[object, object, object]
    r323 :: bool
    r324, r325, r326 :: object
    r327 :: object[4]
    r328 :: object_ptr
    r329, r330 :: object
    r331 :: bool
    r332, r333, r334, r335, r336 :: object
    r337 :: bool
    r338 :: object
    r339 :: bool
    r340 :: object
    r341 :: bit
    r342 :: tuple[object, object, object]
    r343 :: bool
    r344 :: object_ptr
    r345 :: object
    r346 :: bool
    r347, r348, r349 :: tuple[object, object, object]
    r350 :: bit
    r351, r352, r353 :: object
    r354 :: bit
    r355, r356 :: object
    r357 :: bytes
    r358 :: dank_mids.brownie_patch.call.decode_output_gen
    r359 :: bool
    r360 :: dank_mids.brownie_patch.call.decode_output_gen
    r361, r362 :: object
    r363 :: object_ptr
    r364 :: object
    r365 :: bit
    r366 :: object
    r367 :: dank_mids.brownie_patch.call.decode_output_gen
    r368 :: bool
    r369 :: object
    r370 :: bool
    r371 :: object
    r372 :: bit
    r373 :: tuple[object, object, object]
    r374 :: bool
    r375 :: object_ptr
    r376 :: dank_mids.brownie_patch.call.decode_output_gen
    r377 :: bool
    r378, r379, r380 :: tuple[object, object, object]
    r381 :: bit
    r382 :: dank_mids.brownie_patch.call.decode_output_gen
    r383, r384 :: object
    r385 :: bool
    r386 :: tuple[object, object, object]
    r387 :: bool
    r388 :: dict
    r389 :: str
    r390 :: object
    r391 :: bit
    r392 :: object
    r393 :: bool
    r394 :: str
    r395 :: object
    r396, r397, r398, r399 :: str
    r400 :: object
    r401 :: str
    r402 :: object
    r403 :: str
    r404 :: object
    r405 :: str
    r406 :: tuple
    r407 :: str
    r408 :: union[object, None]
    r409 :: str
    r410 :: object
    r411, r412 :: dict
    r413 :: str
    r414 :: object
    r415 :: object[1]
    r416 :: object_ptr
    r417 :: object
    r418 :: tuple[object, object, object]
    r419 :: bit
    r420 :: union[int, None]
    r421 :: object
    r422 :: bit
    r423, r424, r425 :: object
    r426 :: union[int, None]
    r427 :: int
    r428 :: object
    r429 :: bool
    r430 :: object
    r431 :: object[1]
    r432 :: object_ptr
    r433, r434, r435, r436 :: object
    r437 :: bool
    r438, r439, r440, r441, r442, r443, r444, r445, r446, r447 :: bit
    r448 :: bool
    r449 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = <error> :: object
    r5 = r4
    r6 = <error> :: object
    r7 = r6
    r8 = <error> :: object
    r9 = r8
    r10 = <error> :: object
    r11 = r10
    r12 = <error> :: tuple[object, object, object]
    r13 = r12
    r14 = <error> :: object
    r15 = r14
    r16 = <error> :: object
    r17 = r16
    r18 = <error> :: tuple[object, object, object]
    r19 = r18
    r20 = <error> :: object
    r21 = r20
    xdec_ref r21
    r22 = <error> :: object
    r23 = r22
    r24 = __mypyc_self__.__mypyc_env__
    if is_error(r24) goto L422 (error at coroutine:147) else goto L1
L1:
    r25 = r24.__mypyc_next_label__
    r26 = r24.__mypyc_env__
    if is_error(r26) goto L423 (error at coroutine:147) else goto L409
L2:
    r27 = load_address _Py_NoneStruct
    r28 = type != r27
    if r28 goto L424 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L421 (error at coroutine:147) else goto L4 :: bool
L4:
    unreachable
L5:
    r29 = r24.override
    if is_error(r29) goto L425 (error at coroutine:154) else goto L6
L6:
    r30 = load_address _Py_NoneStruct
    r31 = r29 != r30
    if r31 goto L7 else goto L426 :: bool
L7:
    r32 = cast(dict, r29)
    if is_error(r32) goto L425 (error at coroutine:154) else goto L8
L8:
    r33 = PyDict_Size(r32)
    dec_ref r32
    r34 = r33 << 1
    r35 = r34 != 0
    if r35 goto L427 else goto L13 :: bool
L9:
    r36 = 'Cannot use state override with `coroutine`.'
    r37 = builtins :: module
    r38 = 'ValueError'
    r39 = CPyObject_GetAttr(r37, r38)
    if is_error(r39) goto L421 (error at coroutine:155) else goto L10
L10:
    r40 = [r36]
    r41 = load_address r40
    r42 = PyObject_Vectorcall(r39, r41, 1, 0)
    dec_ref r39
    if is_error(r42) goto L421 (error at coroutine:155) else goto L11
L11:
    CPy_Raise(r42)
    dec_ref r42
    if not 0 goto L421 (error at coroutine:155) else goto L12 :: bool
L12:
    unreachable
L13:
    r43 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_ENCODER_SEMAPHORE :: static
    if is_error(r43) goto L428 else goto L16
L14:
    r44 = raise NameError('value for final name "BROWNIE_ENCODER_SEMAPHORE" was not set')
    if not r44 goto L421 (error at coroutine:156) else goto L15 :: bool
L15:
    unreachable
L16:
    r45 = r24.block_identifier
    if is_error(r45) goto L425 (error at coroutine:156) else goto L17
L17:
    r46 = PyObject_GetItem(r43, r45)
    dec_ref r45
    if is_error(r46) goto L425 (error at coroutine:156) else goto L18
L18:
    r47 = PyObject_Type(r46)
    r48 = '__aexit__'
    r49 = CPyObject_GetAttr(r47, r48)
    if is_error(r49) goto L429 (error at coroutine:156) else goto L19
L19:
    r24.__mypyc_temp__0 = r49; r50 = is_error
    if not r50 goto L429 (error at coroutine:-1) else goto L20 :: bool
L20:
    r51 = '__aenter__'
    r52 = CPyObject_GetAttr(r47, r51)
    dec_ref r47
    if is_error(r52) goto L430 (error at coroutine:156) else goto L21
L21:
    r53 = [r46]
    r54 = load_address r53
    r55 = PyObject_Vectorcall(r52, r54, 1, 0)
    dec_ref r52
    if is_error(r55) goto L430 (error at coroutine:156) else goto L22
L22:
    r24.__mypyc_temp__1 = r46; r56 = is_error
    if not r56 goto L431 (error at coroutine:-1) else goto L23 :: bool
L23:
    r24.__mypyc_temp__2 = 1; r57 = is_error
    if not r57 goto L431 (error at coroutine:-1) else goto L24 :: bool
L24:
    r58 = CPy_GetCoro(r55)
    dec_ref r55
    if is_error(r58) goto L425 (error at coroutine:156) else goto L25
L25:
    r24.__mypyc_temp__3 = r58; r59 = is_error
    if not r59 goto L425 (error at coroutine:-1) else goto L26 :: bool
L26:
    r60 = r24.__mypyc_temp__3
    if is_error(r60) goto L425 (error at coroutine:-1) else goto L27
L27:
    r61 = CPyIter_Next(r60)
    dec_ref r60
    if is_error(r61) goto L28 else goto L432
L28:
    r62 = CPy_FetchStopIterationValue()
    if is_error(r62) goto L425 (error at coroutine:156) else goto L29
L29:
    r63 = r62
    dec_ref r63
    r64 = <error> :: object
    r24.__mypyc_temp__3 = r64; r65 = is_error
    if not r65 goto L425 (error at coroutine:156) else goto L52 :: bool
L30:
    r66 = r61
L31:
    r24.__mypyc_next_label__ = 1
    dec_ref r24
    return r66
L32:
    r68 = load_address _Py_NoneStruct
    r69 = type != r68
    if r69 goto L33 else goto L433 :: bool
L33:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L36 (error at coroutine:156) else goto L434 :: bool
L34:
    unreachable
L35:
    inc_ref arg
    goto L47
L36:
    r70 = CPy_CatchError()
    r24.__mypyc_temp__4 = r70; r71 = is_error
    if not r71 goto L435 (error at coroutine:-1) else goto L37 :: bool
L37:
    r72 = load_address r1
    r73 = r24.__mypyc_temp__3
    if is_error(r73) goto L435 (error at coroutine:-1) else goto L38
L38:
    r74 = CPy_YieldFromErrorHandle(r73, r72)
    dec_ref r73
    if is_error(r74) goto L435 (error at coroutine:156) else goto L39
L39:
    if r74 goto L42 else goto L436 :: bool
L40:
    r66 = r1
    r75 = r24.__mypyc_temp__4
    if is_error(r75) goto L437 (error at coroutine:-1) else goto L41
L41:
    CPy_RestoreExcInfo(r75)
    dec_ref r75
    goto L31
L42:
    r63 = r1
    dec_ref r63
    r76 = r24.__mypyc_temp__4
    if is_error(r76) goto L438 (error at coroutine:-1) else goto L43
L43:
    CPy_RestoreExcInfo(r76)
    dec_ref r76
    goto L52
L44:
    r77 = r24.__mypyc_temp__4
    dec_ref r24
    if is_error(r77) goto L421 (error at coroutine:-1) else goto L45
L45:
    CPy_RestoreExcInfo(r77)
    dec_ref r77
    r78 = CPy_KeepPropagating()
    if not r78 goto L421 else goto L46 :: bool
L46:
    unreachable
L47:
    r79 = r24.__mypyc_temp__3
    if is_error(r79) goto L439 (error at coroutine:-1) else goto L48
L48:
    r80 = CPyIter_Send(r79, arg)
    dec_ref r79
    dec_ref arg
    if is_error(r80) goto L50 else goto L440
L49:
    r66 = r80
    goto L31
L50:
    r81 = CPy_FetchStopIterationValue()
    if is_error(r81) goto L425 (error at coroutine:156) else goto L51
L51:
    r63 = r81
    dec_ref r63
L52:
    r82 = r24.self
    if is_error(r82) goto L441 (error at coroutine:157) else goto L53
L53:
    r83 = r26.len_inputs
    if is_error(r83) goto L442 (error at coroutine:157) else goto L54
L54:
    r84 = r26.get_request_data
    if is_error(r84) goto L443 (error at coroutine:157) else goto L55
L55:
    r85 = r24.args
    if is_error(r85) goto L444 (error at coroutine:157) else goto L56
L56:
    r86 = dank_mids.brownie_patch.call.globals :: static
    r87 = 'encode_input'
    r88 = CPyDict_GetItem(r86, r87)
    if is_error(r88) goto L445 (error at coroutine:157) else goto L57
L57:
    r89 = PyList_New(3)
    if is_error(r89) goto L446 (error at coroutine:157) else goto L58
L58:
    r90 = box(int, r83)
    r91 = get_element_ptr r89 ob_item :: PyListObject
    r92 = load_mem r91 :: ptr*
    set_mem r92, r82 :: builtins.object*
    r93 = r92 + 8
    set_mem r93, r90 :: builtins.object*
    r94 = r92 + 16
    set_mem r94, r84 :: builtins.object*
    r95 = CPyList_Extend(r89, r85)
    dec_ref r85
    if is_error(r95) goto L447 (error at coroutine:157) else goto L448
L59:
    r96 = PyList_AsTuple(r89)
    dec_ref r89
    if is_error(r96) goto L449 (error at coroutine:157) else goto L60
L60:
    r97 = PyDict_New()
    if is_error(r97) goto L450 (error at coroutine:157) else goto L61
L61:
    r98 = PyObject_Call(r88, r96, r97)
    dec_ref r88
    dec_ref r96
    dec_ref r97
    if is_error(r98) goto L441 (error at coroutine:157) else goto L62
L62:
    r99 = CPy_GetCoro(r98)
    dec_ref r98
    if is_error(r99) goto L441 (error at coroutine:157) else goto L63
L63:
    r24.__mypyc_temp__5 = r99; r100 = is_error
    if not r100 goto L441 (error at coroutine:-1) else goto L64 :: bool
L64:
    r101 = r24.__mypyc_temp__5
    if is_error(r101) goto L441 (error at coroutine:-1) else goto L65
L65:
    r102 = CPyIter_Next(r101)
    dec_ref r101
    if is_error(r102) goto L66 else goto L451
L66:
    r103 = CPy_FetchStopIterationValue()
    if is_error(r103) goto L441 (error at coroutine:157) else goto L67
L67:
    r104 = r103
    r105 = <error> :: object
    r24.__mypyc_temp__5 = r105; r106 = is_error
    if not r106 goto L452 (error at coroutine:157) else goto L90 :: bool
L68:
    r107 = r102
L69:
    r24.__mypyc_next_label__ = 2
    dec_ref r24
    return r107
L70:
    r109 = load_address _Py_NoneStruct
    r110 = type != r109
    if r110 goto L71 else goto L453 :: bool
L71:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L74 (error at coroutine:157) else goto L454 :: bool
L72:
    unreachable
L73:
    inc_ref arg
    goto L85
L74:
    r111 = CPy_CatchError()
    r24.__mypyc_temp__6 = r111; r112 = is_error
    if not r112 goto L455 (error at coroutine:-1) else goto L75 :: bool
L75:
    r113 = load_address r3
    r114 = r24.__mypyc_temp__5
    if is_error(r114) goto L455 (error at coroutine:-1) else goto L76
L76:
    r115 = CPy_YieldFromErrorHandle(r114, r113)
    dec_ref r114
    if is_error(r115) goto L455 (error at coroutine:157) else goto L77
L77:
    if r115 goto L80 else goto L456 :: bool
L78:
    r107 = r3
    r116 = r24.__mypyc_temp__6
    if is_error(r116) goto L457 (error at coroutine:-1) else goto L79
L79:
    CPy_RestoreExcInfo(r116)
    dec_ref r116
    goto L69
L80:
    r104 = r3
    r117 = r24.__mypyc_temp__6
    if is_error(r117) goto L458 (error at coroutine:-1) else goto L81
L81:
    CPy_RestoreExcInfo(r117)
    dec_ref r117
    goto L90
L82:
    r118 = r24.__mypyc_temp__6
    if is_error(r118) goto L251 (error at coroutine:-1) else goto L83
L83:
    CPy_RestoreExcInfo(r118)
    dec_ref r118
    r119 = CPy_KeepPropagating()
    if not r119 goto L251 else goto L459 :: bool
L84:
    unreachable
L85:
    r120 = r24.__mypyc_temp__5
    if is_error(r120) goto L460 (error at coroutine:-1) else goto L86
L86:
    r121 = CPyIter_Send(r120, arg)
    dec_ref r120
    dec_ref arg
    if is_error(r121) goto L88 else goto L461
L87:
    r107 = r121
    goto L69
L88:
    r122 = CPy_FetchStopIterationValue()
    if is_error(r122) goto L441 (error at coroutine:157) else goto L89
L89:
    r104 = r122
L90:
    r24.data = r104; r123 = is_error
    if not r123 goto L441 (error at coroutine:157) else goto L91 :: bool
L91:
    r124 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE :: static
    if is_error(r124) goto L462 else goto L94
L92:
    r125 = raise NameError('value for final name "BROWNIE_CALL_SEMAPHORE" was not set')
    if not r125 goto L251 (error at coroutine:158) else goto L463 :: bool
L93:
    unreachable
L94:
    r126 = r24.block_identifier
    if is_error(r126) goto L441 (error at coroutine:158) else goto L95
L95:
    r127 = PyObject_GetItem(r124, r126)
    dec_ref r126
    if is_error(r127) goto L441 (error at coroutine:158) else goto L96
L96:
    r128 = PyObject_Type(r127)
    r129 = '__aexit__'
    r130 = CPyObject_GetAttr(r128, r129)
    if is_error(r130) goto L464 (error at coroutine:158) else goto L97
L97:
    r24.__mypyc_temp__7 = r130; r131 = is_error
    if not r131 goto L464 (error at coroutine:-1) else goto L98 :: bool
L98:
    r132 = '__aenter__'
    r133 = CPyObject_GetAttr(r128, r132)
    dec_ref r128
    if is_error(r133) goto L465 (error at coroutine:158) else goto L99
L99:
    r134 = [r127]
    r135 = load_address r134
    r136 = PyObject_Vectorcall(r133, r135, 1, 0)
    dec_ref r133
    if is_error(r136) goto L465 (error at coroutine:158) else goto L100
L100:
    r24.__mypyc_temp__8 = r127; r137 = is_error
    if not r137 goto L466 (error at coroutine:-1) else goto L101 :: bool
L101:
    r24.__mypyc_temp__9 = 1; r138 = is_error
    if not r138 goto L466 (error at coroutine:-1) else goto L102 :: bool
L102:
    r139 = CPy_GetCoro(r136)
    dec_ref r136
    if is_error(r139) goto L441 (error at coroutine:158) else goto L103
L103:
    r24.__mypyc_temp__10 = r139; r140 = is_error
    if not r140 goto L441 (error at coroutine:-1) else goto L104 :: bool
L104:
    r141 = r24.__mypyc_temp__10
    if is_error(r141) goto L441 (error at coroutine:-1) else goto L105
L105:
    r142 = CPyIter_Next(r141)
    dec_ref r141
    if is_error(r142) goto L106 else goto L467
L106:
    r143 = CPy_FetchStopIterationValue()
    if is_error(r143) goto L441 (error at coroutine:158) else goto L107
L107:
    r144 = r143
    dec_ref r144
    r145 = <error> :: object
    r24.__mypyc_temp__10 = r145; r146 = is_error
    if not r146 goto L441 (error at coroutine:158) else goto L130 :: bool
L108:
    r147 = r142
L109:
    r24.__mypyc_next_label__ = 3
    dec_ref r24
    return r147
L110:
    r149 = load_address _Py_NoneStruct
    r150 = type != r149
    if r150 goto L111 else goto L468 :: bool
L111:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L114 (error at coroutine:158) else goto L469 :: bool
L112:
    unreachable
L113:
    inc_ref arg
    goto L125
L114:
    r151 = CPy_CatchError()
    r24.__mypyc_temp__11 = r151; r152 = is_error
    if not r152 goto L470 (error at coroutine:-1) else goto L115 :: bool
L115:
    r153 = load_address r5
    r154 = r24.__mypyc_temp__10
    if is_error(r154) goto L470 (error at coroutine:-1) else goto L116
L116:
    r155 = CPy_YieldFromErrorHandle(r154, r153)
    dec_ref r154
    if is_error(r155) goto L470 (error at coroutine:158) else goto L117
L117:
    if r155 goto L120 else goto L471 :: bool
L118:
    r147 = r5
    r156 = r24.__mypyc_temp__11
    if is_error(r156) goto L472 (error at coroutine:-1) else goto L119
L119:
    CPy_RestoreExcInfo(r156)
    dec_ref r156
    goto L109
L120:
    r144 = r5
    dec_ref r144
    r157 = r24.__mypyc_temp__11
    if is_error(r157) goto L473 (error at coroutine:-1) else goto L121
L121:
    CPy_RestoreExcInfo(r157)
    dec_ref r157
    goto L130
L122:
    r158 = r24.__mypyc_temp__11
    if is_error(r158) goto L251 (error at coroutine:-1) else goto L123
L123:
    CPy_RestoreExcInfo(r158)
    dec_ref r158
    r159 = CPy_KeepPropagating()
    if not r159 goto L251 else goto L474 :: bool
L124:
    unreachable
L125:
    r160 = r24.__mypyc_temp__10
    if is_error(r160) goto L475 (error at coroutine:-1) else goto L126
L126:
    r161 = CPyIter_Send(r160, arg)
    dec_ref r160
    dec_ref arg
    if is_error(r161) goto L128 else goto L476
L127:
    r147 = r161
    goto L109
L128:
    r162 = CPy_FetchStopIterationValue()
    if is_error(r162) goto L441 (error at coroutine:158) else goto L129
L129:
    r144 = r162
    dec_ref r144
L130:
    r163 = r26.w3
    dec_ref r26
    if is_error(r163) goto L167 (error at coroutine:159) else goto L131
L131:
    r164 = 'eth'
    r165 = CPyObject_GetAttr(r163, r164)
    dec_ref r163
    if is_error(r165) goto L167 (error at coroutine:159) else goto L132
L132:
    r166 = 'to'
    r167 = r24.self
    if is_error(r167) goto L477 (error at coroutine:159) else goto L133
L133:
    r168 = '_address'
    r169 = CPyObject_GetAttr(r167, r168)
    dec_ref r167
    if is_error(r169) goto L477 (error at coroutine:159) else goto L134
L134:
    r170 = 'data'
    r171 = r24.data
    if is_error(r171) goto L478 (error at coroutine:159) else goto L135
L135:
    r172 = CPyDict_Build(2, r166, r169, r170, r171)
    dec_ref r169
    dec_ref r171
    if is_error(r172) goto L477 (error at coroutine:159) else goto L136
L136:
    r173 = r24.block_identifier
    if is_error(r173) goto L479 (error at coroutine:159) else goto L137
L137:
    r174 = 'call'
    r175 = [r165, r172, r173]
    r176 = load_address r175
    r177 = PyObject_VectorcallMethod(r174, r176, 9223372036854775811, 0)
    if is_error(r177) goto L480 (error at coroutine:159) else goto L138
L138:
    dec_ref r165
    dec_ref r172
    dec_ref r173
    r178 = CPy_GetCoro(r177)
    dec_ref r177
    if is_error(r178) goto L167 (error at coroutine:159) else goto L139
L139:
    r24.__mypyc_temp__12 = r178; r179 = is_error
    if not r179 goto L167 (error at coroutine:-1) else goto L140 :: bool
L140:
    r180 = r24.__mypyc_temp__12
    if is_error(r180) goto L167 (error at coroutine:-1) else goto L141
L141:
    r181 = CPyIter_Next(r180)
    dec_ref r180
    if is_error(r181) goto L142 else goto L144
L142:
    r182 = CPy_FetchStopIterationValue()
    if is_error(r182) goto L167 (error at coroutine:159) else goto L143
L143:
    r183 = r182
    r184 = <error> :: object
    r24.__mypyc_temp__12 = r184; r185 = is_error
    if not r185 goto L481 (error at coroutine:159) else goto L166 :: bool
L144:
    r186 = r181
L145:
    r24.__mypyc_next_label__ = 4
    dec_ref r24
    return r186
L146:
    r188 = load_address _Py_NoneStruct
    r189 = type != r188
    if r189 goto L147 else goto L482 :: bool
L147:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L150 (error at coroutine:159) else goto L483 :: bool
L148:
    unreachable
L149:
    inc_ref arg
    goto L161
L150:
    r190 = CPy_CatchError()
    r24.__mypyc_temp__13 = r190; r191 = is_error
    if not r191 goto L484 (error at coroutine:-1) else goto L151 :: bool
L151:
    r192 = load_address r7
    r193 = r24.__mypyc_temp__12
    if is_error(r193) goto L484 (error at coroutine:-1) else goto L152
L152:
    r194 = CPy_YieldFromErrorHandle(r193, r192)
    dec_ref r193
    if is_error(r194) goto L484 (error at coroutine:159) else goto L153
L153:
    if r194 goto L156 else goto L154 :: bool
L154:
    r186 = r7
    r195 = r24.__mypyc_temp__13
    if is_error(r195) goto L485 (error at coroutine:-1) else goto L155
L155:
    CPy_RestoreExcInfo(r195)
    dec_ref r195
    goto L145
L156:
    r183 = r7
    r196 = r24.__mypyc_temp__13
    if is_error(r196) goto L486 (error at coroutine:-1) else goto L157
L157:
    CPy_RestoreExcInfo(r196)
    dec_ref r196
    goto L166
L158:
    r197 = r24.__mypyc_temp__13
    if is_error(r197) goto L167 (error at coroutine:-1) else goto L159
L159:
    CPy_RestoreExcInfo(r197)
    dec_ref r197
    r198 = CPy_KeepPropagating()
    if not r198 goto L167 else goto L487 :: bool
L160:
    unreachable
L161:
    r199 = r24.__mypyc_temp__12
    if is_error(r199) goto L488 (error at coroutine:-1) else goto L162
L162:
    r200 = CPyIter_Send(r199, arg)
    dec_ref r199
    dec_ref arg
    if is_error(r200) goto L164 else goto L163
L163:
    r186 = r200
    goto L145
L164:
    r201 = CPy_FetchStopIterationValue()
    if is_error(r201) goto L167 (error at coroutine:159) else goto L165
L165:
    r183 = r201
L166:
    r24.output = r183; r202 = is_error
    if not r202 goto L167 (error at coroutine:159) else goto L209 :: bool
L167:
    r203 = CPy_CatchError()
    r24.__mypyc_temp__14 = r203; r204 = is_error
    if not r204 goto L206 (error at coroutine:-1) else goto L168 :: bool
L168:
    r24.__mypyc_temp__9 = 0; r205 = is_error
    if not r205 goto L206 (error at coroutine:158) else goto L169 :: bool
L169:
    r206 = CPy_GetExcInfo()
    r207 = r206[0]
    r208 = r206[1]
    r209 = r206[2]
    dec_ref r206
    r210 = r24.__mypyc_temp__7
    if is_error(r210) goto L489 (error at coroutine:-1) else goto L170
L170:
    r211 = r24.__mypyc_temp__8
    if is_error(r211) goto L490 (error at coroutine:-1) else goto L171
L171:
    r212 = [r211, r207, r208, r209]
    r213 = load_address r212
    r214 = PyObject_Vectorcall(r210, r213, 4, 0)
    dec_ref r210
    if is_error(r214) goto L491 (error at coroutine:158) else goto L172
L172:
    dec_ref r211
    dec_ref r207
    dec_ref r208
    dec_ref r209
    r215 = CPy_GetCoro(r214)
    dec_ref r214
    if is_error(r215) goto L206 (error at coroutine:158) else goto L173
L173:
    r24.__mypyc_temp__15 = r215; r216 = is_error
    if not r216 goto L206 (error at coroutine:-1) else goto L174 :: bool
L174:
    r217 = r24.__mypyc_temp__15
    if is_error(r217) goto L206 (error at coroutine:-1) else goto L175
L175:
    r218 = CPyIter_Next(r217)
    dec_ref r217
    if is_error(r218) goto L176 else goto L178
L176:
    r219 = CPy_FetchStopIterationValue()
    if is_error(r219) goto L206 (error at coroutine:158) else goto L177
L177:
    r220 = r219
    r221 = <error> :: object
    r24.__mypyc_temp__15 = r221; r222 = is_error
    if not r222 goto L492 (error at coroutine:158) else goto L200 :: bool
L178:
    r223 = r218
L179:
    r24.__mypyc_next_label__ = 5
    dec_ref r24
    return r223
L180:
    r225 = load_address _Py_NoneStruct
    r226 = type != r225
    if r226 goto L181 else goto L493 :: bool
L181:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L184 (error at coroutine:158) else goto L494 :: bool
L182:
    unreachable
L183:
    inc_ref arg
    goto L195
L184:
    r227 = CPy_CatchError()
    r24.__mypyc_temp__16 = r227; r228 = is_error
    if not r228 goto L495 (error at coroutine:-1) else goto L185 :: bool
L185:
    r229 = load_address r9
    r230 = r24.__mypyc_temp__15
    if is_error(r230) goto L495 (error at coroutine:-1) else goto L186
L186:
    r231 = CPy_YieldFromErrorHandle(r230, r229)
    dec_ref r230
    if is_error(r231) goto L495 (error at coroutine:158) else goto L187
L187:
    if r231 goto L190 else goto L188 :: bool
L188:
    r223 = r9
    r232 = r24.__mypyc_temp__16
    if is_error(r232) goto L496 (error at coroutine:-1) else goto L189
L189:
    CPy_RestoreExcInfo(r232)
    dec_ref r232
    goto L179
L190:
    r220 = r9
    r233 = r24.__mypyc_temp__16
    if is_error(r233) goto L497 (error at coroutine:-1) else goto L191
L191:
    CPy_RestoreExcInfo(r233)
    dec_ref r233
    goto L200
L192:
    r234 = r24.__mypyc_temp__16
    if is_error(r234) goto L206 (error at coroutine:-1) else goto L193
L193:
    CPy_RestoreExcInfo(r234)
    dec_ref r234
    r235 = CPy_KeepPropagating()
    if not r235 goto L206 else goto L498 :: bool
L194:
    unreachable
L195:
    r236 = r24.__mypyc_temp__15
    if is_error(r236) goto L499 (error at coroutine:-1) else goto L196
L196:
    r237 = CPyIter_Send(r236, arg)
    dec_ref r236
    dec_ref arg
    if is_error(r237) goto L198 else goto L197
L197:
    r223 = r237
    goto L179
L198:
    r238 = CPy_FetchStopIterationValue()
    if is_error(r238) goto L206 (error at coroutine:158) else goto L199
L199:
    r220 = r238
L200:
    r239 = PyObject_IsTrue(r220)
    dec_ref r220
    r240 = r239 >= 0 :: signed
    if not r240 goto L206 (error at coroutine:-1) else goto L201 :: bool
L201:
    r241 = truncate r239: i32 to builtins.bool
    if r241 goto L204 else goto L202 :: bool
L202:
    CPy_Reraise()
    if not 0 goto L206 else goto L500 :: bool
L203:
    unreachable
L204:
    r242 = r24.__mypyc_temp__14
    if is_error(r242) goto L210 (error at coroutine:-1) else goto L205
L205:
    CPy_RestoreExcInfo(r242)
    dec_ref r242
    goto L209
L206:
    r243 = r24.__mypyc_temp__14
    if is_error(r243) goto L210 (error at coroutine:-1) else goto L207
L207:
    CPy_RestoreExcInfo(r243)
    dec_ref r243
    r244 = CPy_KeepPropagating()
    if not r244 goto L210 else goto L501 :: bool
L208:
    unreachable
L209:
    r245 = <error> :: tuple[object, object, object]
    r13 = r245
    goto L211
L210:
    r246 = CPy_CatchError()
    r13 = r246
L211:
    r247 = r24.__mypyc_temp__9
    if is_error(r247) goto L247 (error at coroutine:-1) else goto L212
L212:
    if r247 goto L213 else goto L244 :: bool
L213:
    r248 = load_address _Py_NoneStruct
    r249 = r24.__mypyc_temp__7
    if is_error(r249) goto L247 (error at coroutine:-1) else goto L214
L214:
    r250 = r24.__mypyc_temp__8
    if is_error(r250) goto L502 (error at coroutine:-1) else goto L215
L215:
    r251 = [r250, r248, r248, r248]
    r252 = load_address r251
    r253 = PyObject_Vectorcall(r249, r252, 4, 0)
    dec_ref r249
    if is_error(r253) goto L503 (error at coroutine:158) else goto L216
L216:
    dec_ref r250
    r254 = CPy_GetCoro(r253)
    dec_ref r253
    if is_error(r254) goto L247 (error at coroutine:158) else goto L217
L217:
    r24.__mypyc_temp__17 = r254; r255 = is_error
    if not r255 goto L247 (error at coroutine:-1) else goto L218 :: bool
L218:
    r256 = r24.__mypyc_temp__17
    if is_error(r256) goto L247 (error at coroutine:-1) else goto L219
L219:
    r257 = CPyIter_Next(r256)
    dec_ref r256
    if is_error(r257) goto L220 else goto L504
L220:
    r258 = CPy_FetchStopIterationValue()
    if is_error(r258) goto L247 (error at coroutine:158) else goto L221
L221:
    r259 = r258
    dec_ref r259
    r260 = <error> :: object
    r24.__mypyc_temp__17 = r260; r261 = is_error
    if not r261 goto L247 (error at coroutine:158) else goto L244 :: bool
L222:
    r262 = r257
L223:
    r24.__mypyc_next_label__ = 6
    dec_ref r24
    return r262
L224:
    r264 = load_address _Py_NoneStruct
    r265 = type != r264
    if r265 goto L225 else goto L505 :: bool
L225:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L228 (error at coroutine:158) else goto L506 :: bool
L226:
    unreachable
L227:
    inc_ref arg
    goto L239
L228:
    r266 = CPy_CatchError()
    r24.__mypyc_temp__18 = r266; r267 = is_error
    if not r267 goto L507 (error at coroutine:-1) else goto L229 :: bool
L229:
    r268 = load_address r11
    r269 = r24.__mypyc_temp__17
    if is_error(r269) goto L507 (error at coroutine:-1) else goto L230
L230:
    r270 = CPy_YieldFromErrorHandle(r269, r268)
    dec_ref r269
    if is_error(r270) goto L507 (error at coroutine:158) else goto L231
L231:
    if r270 goto L234 else goto L232 :: bool
L232:
    r262 = r11
    r271 = r24.__mypyc_temp__18
    if is_error(r271) goto L508 (error at coroutine:-1) else goto L509
L233:
    CPy_RestoreExcInfo(r271)
    dec_ref r271
    goto L223
L234:
    r259 = r11
    dec_ref r259
    r272 = r24.__mypyc_temp__18
    if is_error(r272) goto L236 (error at coroutine:-1) else goto L235
L235:
    CPy_RestoreExcInfo(r272)
    dec_ref r272
    goto L244
L236:
    r273 = r24.__mypyc_temp__18
    if is_error(r273) goto L247 (error at coroutine:-1) else goto L237
L237:
    CPy_RestoreExcInfo(r273)
    dec_ref r273
    r274 = CPy_KeepPropagating()
    if not r274 goto L247 else goto L510 :: bool
L238:
    unreachable
L239:
    r275 = r24.__mypyc_temp__17
    if is_error(r275) goto L511 (error at coroutine:-1) else goto L240
L240:
    r276 = CPyIter_Send(r275, arg)
    dec_ref r275
    dec_ref arg
    if is_error(r276) goto L242 else goto L512
L241:
    r262 = r276
    goto L223
L242:
    r277 = CPy_FetchStopIterationValue()
    if is_error(r277) goto L247 (error at coroutine:158) else goto L243
L243:
    r259 = r277
    dec_ref r259
L244:
    if is_error(r13) goto L293 else goto L245
L245:
    CPy_Reraise()
    if not 0 goto L247 else goto L513 :: bool
L246:
    unreachable
L247:
    if is_error(r13) goto L249 else goto L248
L248:
    CPy_RestoreExcInfo(r13)
    xdec_ref r13
L249:
    r278 = CPy_KeepPropagating()
    if not r278 goto L251 else goto L514 :: bool
L250:
    unreachable
L251:
    r279 = CPy_CatchError()
    r24.__mypyc_temp__19 = r279; r280 = is_error
    if not r280 goto L290 (error at coroutine:-1) else goto L252 :: bool
L252:
    r24.__mypyc_temp__2 = 0; r281 = is_error
    if not r281 goto L290 (error at coroutine:156) else goto L253 :: bool
L253:
    r282 = CPy_GetExcInfo()
    r283 = r282[0]
    r284 = r282[1]
    r285 = r282[2]
    dec_ref r282
    r286 = r24.__mypyc_temp__0
    if is_error(r286) goto L515 (error at coroutine:-1) else goto L254
L254:
    r287 = r24.__mypyc_temp__1
    if is_error(r287) goto L516 (error at coroutine:-1) else goto L255
L255:
    r288 = [r287, r283, r284, r285]
    r289 = load_address r288
    r290 = PyObject_Vectorcall(r286, r289, 4, 0)
    dec_ref r286
    if is_error(r290) goto L517 (error at coroutine:156) else goto L256
L256:
    dec_ref r287
    dec_ref r283
    dec_ref r284
    dec_ref r285
    r291 = CPy_GetCoro(r290)
    dec_ref r290
    if is_error(r291) goto L290 (error at coroutine:156) else goto L257
L257:
    r24.__mypyc_temp__20 = r291; r292 = is_error
    if not r292 goto L290 (error at coroutine:-1) else goto L258 :: bool
L258:
    r293 = r24.__mypyc_temp__20
    if is_error(r293) goto L290 (error at coroutine:-1) else goto L259
L259:
    r294 = CPyIter_Next(r293)
    dec_ref r293
    if is_error(r294) goto L260 else goto L262
L260:
    r295 = CPy_FetchStopIterationValue()
    if is_error(r295) goto L290 (error at coroutine:156) else goto L261
L261:
    r296 = r295
    r297 = <error> :: object
    r24.__mypyc_temp__20 = r297; r298 = is_error
    if not r298 goto L518 (error at coroutine:156) else goto L284 :: bool
L262:
    r299 = r294
L263:
    r24.__mypyc_next_label__ = 7
    dec_ref r24
    return r299
L264:
    r301 = load_address _Py_NoneStruct
    r302 = type != r301
    if r302 goto L265 else goto L519 :: bool
L265:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L268 (error at coroutine:156) else goto L520 :: bool
L266:
    unreachable
L267:
    inc_ref arg
    goto L279
L268:
    r303 = CPy_CatchError()
    r24.__mypyc_temp__21 = r303; r304 = is_error
    if not r304 goto L521 (error at coroutine:-1) else goto L269 :: bool
L269:
    r305 = load_address r15
    r306 = r24.__mypyc_temp__20
    if is_error(r306) goto L521 (error at coroutine:-1) else goto L270
L270:
    r307 = CPy_YieldFromErrorHandle(r306, r305)
    dec_ref r306
    if is_error(r307) goto L521 (error at coroutine:156) else goto L271
L271:
    if r307 goto L274 else goto L272 :: bool
L272:
    r299 = r15
    r308 = r24.__mypyc_temp__21
    if is_error(r308) goto L522 (error at coroutine:-1) else goto L273
L273:
    CPy_RestoreExcInfo(r308)
    dec_ref r308
    goto L263
L274:
    r296 = r15
    r309 = r24.__mypyc_temp__21
    if is_error(r309) goto L523 (error at coroutine:-1) else goto L275
L275:
    CPy_RestoreExcInfo(r309)
    dec_ref r309
    goto L284
L276:
    r310 = r24.__mypyc_temp__21
    if is_error(r310) goto L290 (error at coroutine:-1) else goto L277
L277:
    CPy_RestoreExcInfo(r310)
    dec_ref r310
    r311 = CPy_KeepPropagating()
    if not r311 goto L290 else goto L524 :: bool
L278:
    unreachable
L279:
    r312 = r24.__mypyc_temp__20
    if is_error(r312) goto L525 (error at coroutine:-1) else goto L280
L280:
    r313 = CPyIter_Send(r312, arg)
    dec_ref r312
    dec_ref arg
    if is_error(r313) goto L282 else goto L281
L281:
    r299 = r313
    goto L263
L282:
    r314 = CPy_FetchStopIterationValue()
    if is_error(r314) goto L290 (error at coroutine:156) else goto L283
L283:
    r296 = r314
L284:
    r315 = PyObject_IsTrue(r296)
    dec_ref r296
    r316 = r315 >= 0 :: signed
    if not r316 goto L290 (error at coroutine:-1) else goto L285 :: bool
L285:
    r317 = truncate r315: i32 to builtins.bool
    if r317 goto L288 else goto L286 :: bool
L286:
    CPy_Reraise()
    if not 0 goto L290 else goto L526 :: bool
L287:
    unreachable
L288:
    r318 = r24.__mypyc_temp__19
    if is_error(r318) goto L294 (error at coroutine:-1) else goto L289
L289:
    CPy_RestoreExcInfo(r318)
    dec_ref r318
    goto L293
L290:
    r319 = r24.__mypyc_temp__19
    if is_error(r319) goto L294 (error at coroutine:-1) else goto L291
L291:
    CPy_RestoreExcInfo(r319)
    dec_ref r319
    r320 = CPy_KeepPropagating()
    if not r320 goto L294 else goto L527 :: bool
L292:
    unreachable
L293:
    r321 = <error> :: tuple[object, object, object]
    r19 = r321
    goto L295
L294:
    r322 = CPy_CatchError()
    r19 = r322
L295:
    r323 = r24.__mypyc_temp__2
    if is_error(r323) goto L528 (error at coroutine:-1) else goto L296
L296:
    if r323 goto L297 else goto L328 :: bool
L297:
    r324 = load_address _Py_NoneStruct
    r325 = r24.__mypyc_temp__0
    if is_error(r325) goto L528 (error at coroutine:-1) else goto L298
L298:
    r326 = r24.__mypyc_temp__1
    if is_error(r326) goto L529 (error at coroutine:-1) else goto L299
L299:
    r327 = [r326, r324, r324, r324]
    r328 = load_address r327
    r329 = PyObject_Vectorcall(r325, r328, 4, 0)
    dec_ref r325
    if is_error(r329) goto L530 (error at coroutine:156) else goto L300
L300:
    dec_ref r326
    r330 = CPy_GetCoro(r329)
    dec_ref r329
    if is_error(r330) goto L528 (error at coroutine:156) else goto L301
L301:
    r24.__mypyc_temp__22 = r330; r331 = is_error
    if not r331 goto L528 (error at coroutine:-1) else goto L302 :: bool
L302:
    r332 = r24.__mypyc_temp__22
    if is_error(r332) goto L528 (error at coroutine:-1) else goto L303
L303:
    r333 = CPyIter_Next(r332)
    dec_ref r332
    if is_error(r333) goto L304 else goto L531
L304:
    r334 = CPy_FetchStopIterationValue()
    if is_error(r334) goto L528 (error at coroutine:156) else goto L305
L305:
    r335 = r334
    dec_ref r335
    r336 = <error> :: object
    r24.__mypyc_temp__22 = r336; r337 = is_error
    if not r337 goto L528 (error at coroutine:156) else goto L328 :: bool
L306:
    r338 = r333
L307:
    r24.__mypyc_next_label__ = 8
    dec_ref r24
    return r338
L308:
    r340 = load_address _Py_NoneStruct
    r341 = type != r340
    if r341 goto L309 else goto L532 :: bool
L309:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L312 (error at coroutine:156) else goto L533 :: bool
L310:
    unreachable
L311:
    inc_ref arg
    goto L323
L312:
    r342 = CPy_CatchError()
    r24.__mypyc_temp__23 = r342; r343 = is_error
    if not r343 goto L534 (error at coroutine:-1) else goto L313 :: bool
L313:
    r344 = load_address r17
    r345 = r24.__mypyc_temp__22
    if is_error(r345) goto L534 (error at coroutine:-1) else goto L314
L314:
    r346 = CPy_YieldFromErrorHandle(r345, r344)
    dec_ref r345
    if is_error(r346) goto L534 (error at coroutine:156) else goto L315
L315:
    if r346 goto L318 else goto L316 :: bool
L316:
    r338 = r17
    r347 = r24.__mypyc_temp__23
    if is_error(r347) goto L535 (error at coroutine:-1) else goto L536
L317:
    CPy_RestoreExcInfo(r347)
    dec_ref r347
    goto L307
L318:
    r335 = r17
    dec_ref r335
    r348 = r24.__mypyc_temp__23
    if is_error(r348) goto L320 (error at coroutine:-1) else goto L319
L319:
    CPy_RestoreExcInfo(r348)
    dec_ref r348
    goto L328
L320:
    r349 = r24.__mypyc_temp__23
    dec_ref r24
    if is_error(r349) goto L331 (error at coroutine:-1) else goto L321
L321:
    CPy_RestoreExcInfo(r349)
    dec_ref r349
    r350 = CPy_KeepPropagating()
    if not r350 goto L331 else goto L537 :: bool
L322:
    unreachable
L323:
    r351 = r24.__mypyc_temp__22
    if is_error(r351) goto L538 (error at coroutine:-1) else goto L324
L324:
    r352 = CPyIter_Send(r351, arg)
    dec_ref r351
    dec_ref arg
    if is_error(r352) goto L326 else goto L539
L325:
    r338 = r352
    goto L307
L326:
    r353 = CPy_FetchStopIterationValue()
    if is_error(r353) goto L528 (error at coroutine:156) else goto L327
L327:
    r335 = r353
    dec_ref r335
L328:
    if is_error(r19) goto L335 else goto L540
L329:
    CPy_Reraise()
    if not 0 goto L331 else goto L541 :: bool
L330:
    unreachable
L331:
    if is_error(r19) goto L333 else goto L332
L332:
    CPy_RestoreExcInfo(r19)
    xdec_ref r19
L333:
    r354 = CPy_KeepPropagating()
    if not r354 goto L421 else goto L334 :: bool
L334:
    unreachable
L335:
    r355 = r24.self
    if is_error(r355) goto L367 (error at coroutine:161) else goto L336
L336:
    r356 = r24.output
    if is_error(r356) goto L542 (error at coroutine:161) else goto L337
L337:
    r357 = cast(bytes, r356)
    if is_error(r357) goto L542 (error at coroutine:161) else goto L338
L338:
    r358 = decode_output(r355, r357)
    dec_ref r355
    dec_ref r357
    if is_error(r358) goto L367 (error at coroutine:161) else goto L339
L339:
    r24.__mypyc_temp__24 = r358; r359 = is_error
    if not r359 goto L367 (error at coroutine:-1) else goto L340 :: bool
L340:
    r360 = r24.__mypyc_temp__24
    if is_error(r360) goto L367 (error at coroutine:-1) else goto L341
L341:
    r361 = load_address _Py_NoneStruct
    r362 = <error> :: object
    r21 = r362
    r363 = load_address r21
    r364 = r360.__mypyc_generator_helper__(r361, r361, r361, r361, r363)
    dec_ref r360
    if is_error(r364) goto L342 else goto L543
L342:
    r365 = r21 != 0
    if not r365 goto L544 (error at coroutine:-1) else goto L343 :: bool
L343:
    r366 = r21
    r367 = <error> :: dank_mids.brownie_patch.call.decode_output_gen
    r24.__mypyc_temp__24 = r367; r368 = is_error
    if not r368 goto L545 (error at coroutine:161) else goto L366 :: bool
L344:
    r369 = r364
L345:
    r24.__mypyc_next_label__ = 9
    dec_ref r24
    return r369
L346:
    r371 = load_address _Py_NoneStruct
    r372 = type != r371
    if r372 goto L347 else goto L546 :: bool
L347:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L350 (error at coroutine:161) else goto L547 :: bool
L348:
    unreachable
L349:
    inc_ref arg
    goto L361
L350:
    r373 = CPy_CatchError()
    r24.__mypyc_temp__25 = r373; r374 = is_error
    if not r374 goto L548 (error at coroutine:-1) else goto L351 :: bool
L351:
    r375 = load_address r23
    r376 = r24.__mypyc_temp__24
    if is_error(r376) goto L548 (error at coroutine:-1) else goto L352
L352:
    r377 = CPy_YieldFromErrorHandle(r376, r375)
    dec_ref r376
    if is_error(r377) goto L548 (error at coroutine:161) else goto L353
L353:
    if r377 goto L356 else goto L354 :: bool
L354:
    r369 = r23
    r378 = r24.__mypyc_temp__25
    if is_error(r378) goto L549 (error at coroutine:-1) else goto L355
L355:
    CPy_RestoreExcInfo(r378)
    dec_ref r378
    goto L345
L356:
    r366 = r23
    r379 = r24.__mypyc_temp__25
    if is_error(r379) goto L550 (error at coroutine:-1) else goto L357
L357:
    CPy_RestoreExcInfo(r379)
    dec_ref r379
    goto L366
L358:
    r380 = r24.__mypyc_temp__25
    if is_error(r380) goto L367 (error at coroutine:-1) else goto L359
L359:
    CPy_RestoreExcInfo(r380)
    dec_ref r380
    r381 = CPy_KeepPropagating()
    if not r381 goto L367 else goto L551 :: bool
L360:
    unreachable
L361:
    r382 = r24.__mypyc_temp__24
    if is_error(r382) goto L552 (error at coroutine:-1) else goto L362
L362:
    r383 = CPyIter_Send(r382, arg)
    dec_ref r382
    dec_ref arg
    if is_error(r383) goto L364 else goto L363
L363:
    r369 = r383
    goto L345
L364:
    r384 = CPy_FetchStopIterationValue()
    if is_error(r384) goto L367 (error at coroutine:161) else goto L365
L365:
    r366 = r384
L366:
    r24.decoded = r366; r385 = is_error
    if not r385 goto L367 (error at coroutine:161) else goto L390 :: bool
L367:
    r386 = CPy_CatchError()
    r24.__mypyc_temp__26 = r386; r387 = is_error
    if not r387 goto L387 (error at coroutine:-1) else goto L368 :: bool
L368:
    r388 = dank_mids.brownie_patch.call.globals :: static
    r389 = 'InsufficientDataBytes'
    r390 = CPyDict_GetItem(r388, r389)
    if is_error(r390) goto L387 (error at coroutine:162) else goto L369
L369:
    r391 = CPy_ExceptionMatches(r390)
    dec_ref r390
    if r391 goto L370 else goto L385 :: bool
L370:
    r392 = CPy_GetExcValue()
    r24.e = r392; r393 = is_error
    if not r393 goto L387 (error at coroutine:162) else goto L371 :: bool
L371:
    r394 = 'error'
    r395 = r24.e
    if is_error(r395) goto L387 (error at coroutine:165) else goto L372
L372:
    r396 = PyObject_Str(r395)
    dec_ref r395
    if is_error(r396) goto L387 (error at coroutine:165) else goto L373
L373:
    r397 = ' when decoding response'
    r398 = CPyStr_Build(2, r396, r397)
    dec_ref r396
    if is_error(r398) goto L387 (error at coroutine:165) else goto L374
L374:
    r399 = 'method'
    r400 = r24.self
    if is_error(r400) goto L553 (error at coroutine:166) else goto L375
L375:
    r401 = 'contract'
    r402 = r24.self
    if is_error(r402) goto L554 (error at coroutine:167) else goto L376
L376:
    r403 = '_address'
    r404 = CPyObject_GetAttr(r402, r403)
    dec_ref r402
    if is_error(r404) goto L554 (error at coroutine:167) else goto L377
L377:
    r405 = 'args'
    r406 = r24.args
    if is_error(r406) goto L555 (error at coroutine:168) else goto L378
L378:
    r407 = 'block'
    r408 = r24.block_identifier
    if is_error(r408) goto L556 (error at coroutine:169) else goto L379
L379:
    r409 = 'response'
    r410 = r24.output
    if is_error(r410) goto L557 (error at coroutine:170) else goto L380
L380:
    r411 = CPyDict_Build(6, r394, r398, r399, r400, r401, r404, r405, r406, r407, r408, r409, r410)
    dec_ref r398
    dec_ref r400
    dec_ref r404
    dec_ref r406
    dec_ref r408
    dec_ref r410
    if is_error(r411) goto L387 (error at coroutine:164) else goto L381
L381:
    r412 = dank_mids.brownie_patch.call.globals :: static
    r413 = 'InsufficientDataBytes'
    r414 = CPyDict_GetItem(r412, r413)
    if is_error(r414) goto L558 (error at coroutine:163) else goto L382
L382:
    r415 = [r411]
    r416 = load_address r415
    r417 = PyObject_Vectorcall(r414, r416, 1, 0)
    dec_ref r414
    if is_error(r417) goto L558 (error at coroutine:163) else goto L383
L383:
    dec_ref r411
    CPy_Raise(r417)
    dec_ref r417
    if not 0 goto L387 (error at coroutine:163) else goto L559 :: bool
L384:
    unreachable
L385:
    CPy_Reraise()
    if not 0 goto L387 else goto L560 :: bool
L386:
    unreachable
L387:
    r418 = r24.__mypyc_temp__26
    dec_ref r24
    if is_error(r418) goto L421 (error at coroutine:-1) else goto L388
L388:
    CPy_RestoreExcInfo(r418)
    dec_ref r418
    r419 = CPy_KeepPropagating()
    if not r419 goto L421 else goto L389 :: bool
L389:
    unreachable
L390:
    r420 = r24.decimals
    if is_error(r420) goto L561 (error at coroutine:174) else goto L391
L391:
    r421 = load_address _Py_NoneStruct
    r422 = r420 == r421
    dec_ref r420
    if r422 goto L392 else goto L394 :: bool
L392:
    r423 = r24.decoded
    if is_error(r423) goto L561 (error at coroutine:174) else goto L393
L393:
    r424 = r423
    goto L404
L394:
    r425 = r24.decoded
    if is_error(r425) goto L561 (error at coroutine:174) else goto L395
L395:
    r426 = r24.decimals
    if is_error(r426) goto L562 (error at coroutine:174) else goto L396
L396:
    r427 = unbox(int, r426)
    dec_ref r426
    if is_error(r427) goto L562 (error at coroutine:174) else goto L397
L397:
    r428 = dank_mids.brownie_patch.call.Decimal :: static
    if is_error(r428) goto L563 else goto L400
L398:
    r429 = raise NameError('value for final name "Decimal" was not set')
    if not r429 goto L421 (error at coroutine:174) else goto L399 :: bool
L399:
    unreachable
L400:
    r430 = box(int, r427)
    r431 = [r430]
    r432 = load_address r431
    r433 = PyObject_Vectorcall(r428, r432, 1, 0)
    if is_error(r433) goto L564 (error at coroutine:174) else goto L401
L401:
    dec_ref r430
    r434 = object 10
    r435 = CPyNumber_Power(r434, r433)
    dec_ref r433
    if is_error(r435) goto L562 (error at coroutine:174) else goto L402
L402:
    r436 = PyNumber_TrueDivide(r425, r435)
    dec_ref r425
    dec_ref r435
    if is_error(r436) goto L561 (error at coroutine:174) else goto L403
L403:
    r424 = r436
L404:
    r24.__mypyc_next_label__ = -1
    dec_ref r24
L405:
    if is_error(stop_iter_ptr) goto L406 else goto L408
L406:
    CPyGen_SetStopIterationValue(r424)
    dec_ref r424
    if not 0 goto L421 else goto L407 :: bool
L407:
    unreachable
L408:
    set_mem stop_iter_ptr, r424 :: builtins.object*
    return 0
L409:
    r438 = r25 == 0
    if r438 goto L565 else goto L410 :: bool
L410:
    r439 = r25 == 1
    if r439 goto L566 else goto L567 :: bool
L411:
    r440 = r25 == 2
    if r440 goto L568 else goto L569 :: bool
L412:
    r441 = r25 == 3
    if r441 goto L570 else goto L571 :: bool
L413:
    r442 = r25 == 4
    if r442 goto L572 else goto L573 :: bool
L414:
    r443 = r25 == 5
    if r443 goto L574 else goto L575 :: bool
L415:
    r444 = r25 == 6
    if r444 goto L576 else goto L577 :: bool
L416:
    r445 = r25 == 7
    if r445 goto L578 else goto L579 :: bool
L417:
    r446 = r25 == 8
    if r446 goto L580 else goto L581 :: bool
L418:
    r447 = r25 == 9
    if r447 goto L346 else goto L582 :: bool
L419:
    r448 = raise StopIteration
    if not r448 goto L421 (error at coroutine:147) else goto L420 :: bool
L420:
    unreachable
L421:
    r449 = <error> :: object
    return r449
L422:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r23
    goto L421
L423:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r23
    dec_ref r24
    goto L421
L424:
    dec_ref r24
    dec_ref r26
    goto L3
L425:
    dec_ref r24
    dec_ref r26
    goto L421
L426:
    dec_ref r29
    goto L13
L427:
    dec_ref r24
    dec_ref r26
    goto L9
L428:
    dec_ref r24
    dec_ref r26
    goto L14
L429:
    dec_ref r24
    dec_ref r26
    dec_ref r46
    dec_ref r47
    goto L421
L430:
    dec_ref r24
    dec_ref r26
    dec_ref r46
    goto L421
L431:
    dec_ref r24
    dec_ref r26
    dec_ref r55
    goto L421
L432:
    dec_ref r26
    goto L30
L433:
    xdec_ref r1
    goto L35
L434:
    xdec_ref r1
    dec_ref r24
    dec_ref r26
    goto L34
L435:
    xdec_ref r1
    dec_ref r26
    goto L44
L436:
    dec_ref r26
    goto L40
L437:
    dec_ref r66
    goto L44
L438:
    dec_ref r26
    goto L44
L439:
    dec_ref r24
    dec_ref r26
    dec_ref arg
    goto L421
L440:
    dec_ref r26
    goto L49
L441:
    dec_ref r26
    goto L251
L442:
    dec_ref r26
    dec_ref r82
    goto L251
L443:
    dec_ref r26
    dec_ref r82
    dec_ref r83 :: int
    goto L251
L444:
    dec_ref r26
    dec_ref r82
    dec_ref r83 :: int
    dec_ref r84
    goto L251
L445:
    dec_ref r26
    dec_ref r82
    dec_ref r83 :: int
    dec_ref r84
    dec_ref r85
    goto L251
L446:
    dec_ref r26
    dec_ref r82
    dec_ref r83 :: int
    dec_ref r84
    dec_ref r85
    dec_ref r88
    goto L251
L447:
    dec_ref r26
    dec_ref r88
    dec_ref r89
    goto L251
L448:
    dec_ref r95
    goto L59
L449:
    dec_ref r26
    dec_ref r88
    goto L251
L450:
    dec_ref r26
    dec_ref r88
    dec_ref r96
    goto L251
L451:
    dec_ref r26
    goto L68
L452:
    dec_ref r26
    dec_ref r104
    goto L251
L453:
    xdec_ref r3
    goto L73
L454:
    xdec_ref r3
    dec_ref r24
    dec_ref r26
    goto L72
L455:
    xdec_ref r3
    dec_ref r26
    goto L82
L456:
    dec_ref r26
    goto L78
L457:
    dec_ref r107
    goto L82
L458:
    dec_ref r26
    dec_ref r104
    goto L82
L459:
    dec_ref r24
    goto L84
L460:
    dec_ref r26
    dec_ref arg
    goto L251
L461:
    dec_ref r26
    goto L87
L462:
    dec_ref r26
    goto L92
L463:
    dec_ref r24
    goto L93
L464:
    dec_ref r26
    dec_ref r127
    dec_ref r128
    goto L251
L465:
    dec_ref r26
    dec_ref r127
    goto L251
L466:
    dec_ref r26
    dec_ref r136
    goto L251
L467:
    dec_ref r26
    goto L108
L468:
    xdec_ref r5
    goto L113
L469:
    xdec_ref r5
    dec_ref r24
    dec_ref r26
    goto L112
L470:
    xdec_ref r5
    dec_ref r26
    goto L122
L471:
    dec_ref r26
    goto L118
L472:
    dec_ref r147
    goto L122
L473:
    dec_ref r26
    goto L122
L474:
    dec_ref r24
    goto L124
L475:
    dec_ref r26
    dec_ref arg
    goto L251
L476:
    dec_ref r26
    goto L127
L477:
    dec_ref r165
    goto L167
L478:
    dec_ref r165
    dec_ref r169
    goto L167
L479:
    dec_ref r165
    dec_ref r172
    goto L167
L480:
    dec_ref r165
    dec_ref r172
    dec_ref r173
    goto L167
L481:
    dec_ref r183
    goto L167
L482:
    xdec_ref r7
    goto L149
L483:
    xdec_ref r7
    dec_ref r24
    goto L148
L484:
    xdec_ref r7
    goto L158
L485:
    dec_ref r186
    goto L158
L486:
    dec_ref r183
    goto L158
L487:
    dec_ref r24
    goto L160
L488:
    dec_ref arg
    goto L167
L489:
    dec_ref r207
    dec_ref r208
    dec_ref r209
    goto L206
L490:
    dec_ref r207
    dec_ref r208
    dec_ref r209
    dec_ref r210
    goto L206
L491:
    dec_ref r207
    dec_ref r208
    dec_ref r209
    dec_ref r211
    goto L206
L492:
    dec_ref r220
    goto L206
L493:
    xdec_ref r9
    goto L183
L494:
    xdec_ref r9
    dec_ref r24
    goto L182
L495:
    xdec_ref r9
    goto L192
L496:
    dec_ref r223
    goto L192
L497:
    dec_ref r220
    goto L192
L498:
    dec_ref r24
    goto L194
L499:
    dec_ref arg
    goto L206
L500:
    dec_ref r24
    goto L203
L501:
    dec_ref r24
    goto L208
L502:
    dec_ref r249
    goto L247
L503:
    dec_ref r250
    goto L247
L504:
    xdec_ref r13
    goto L222
L505:
    xdec_ref r11
    goto L227
L506:
    xdec_ref r11
    xdec_ref r13
    dec_ref r24
    goto L226
L507:
    xdec_ref r11
    goto L236
L508:
    dec_ref r262
    goto L236
L509:
    xdec_ref r13
    goto L233
L510:
    xdec_ref r13
    dec_ref r24
    goto L238
L511:
    dec_ref arg
    goto L247
L512:
    xdec_ref r13
    goto L241
L513:
    xdec_ref r13
    dec_ref r24
    goto L246
L514:
    dec_ref r24
    goto L250
L515:
    dec_ref r283
    dec_ref r284
    dec_ref r285
    goto L290
L516:
    dec_ref r283
    dec_ref r284
    dec_ref r285
    dec_ref r286
    goto L290
L517:
    dec_ref r283
    dec_ref r284
    dec_ref r285
    dec_ref r287
    goto L290
L518:
    dec_ref r296
    goto L290
L519:
    xdec_ref r15
    goto L267
L520:
    xdec_ref r15
    dec_ref r24
    goto L266
L521:
    xdec_ref r15
    goto L276
L522:
    dec_ref r299
    goto L276
L523:
    dec_ref r296
    goto L276
L524:
    dec_ref r24
    goto L278
L525:
    dec_ref arg
    goto L290
L526:
    dec_ref r24
    goto L287
L527:
    dec_ref r24
    goto L292
L528:
    dec_ref r24
    goto L331
L529:
    dec_ref r24
    dec_ref r325
    goto L331
L530:
    dec_ref r24
    dec_ref r326
    goto L331
L531:
    xdec_ref r19
    goto L306
L532:
    xdec_ref r17
    goto L311
L533:
    xdec_ref r17
    xdec_ref r19
    dec_ref r24
    goto L310
L534:
    xdec_ref r17
    goto L320
L535:
    dec_ref r338
    goto L320
L536:
    xdec_ref r19
    goto L317
L537:
    xdec_ref r19
    goto L322
L538:
    dec_ref r24
    dec_ref arg
    goto L331
L539:
    xdec_ref r19
    goto L325
L540:
    dec_ref r24
    goto L329
L541:
    xdec_ref r19
    goto L330
L542:
    dec_ref r355
    goto L367
L543:
    xdec_ref r21
    goto L344
L544:
    xdec_ref r21
    goto L367
L545:
    dec_ref r366
    goto L367
L546:
    xdec_ref r23
    goto L349
L547:
    xdec_ref r23
    dec_ref r24
    goto L348
L548:
    xdec_ref r23
    goto L358
L549:
    dec_ref r369
    goto L358
L550:
    dec_ref r366
    goto L358
L551:
    dec_ref r24
    goto L360
L552:
    dec_ref arg
    goto L367
L553:
    dec_ref r398
    goto L387
L554:
    dec_ref r398
    dec_ref r400
    goto L387
L555:
    dec_ref r398
    dec_ref r400
    dec_ref r404
    goto L387
L556:
    dec_ref r398
    dec_ref r400
    dec_ref r404
    dec_ref r406
    goto L387
L557:
    dec_ref r398
    dec_ref r400
    dec_ref r404
    dec_ref r406
    dec_ref r408
    goto L387
L558:
    dec_ref r411
    goto L387
L559:
    dec_ref r24
    goto L384
L560:
    dec_ref r24
    goto L386
L561:
    dec_ref r24
    goto L421
L562:
    dec_ref r24
    dec_ref r425
    goto L421
L563:
    dec_ref r24
    dec_ref r425
    dec_ref r427 :: int
    goto L398
L564:
    dec_ref r24
    dec_ref r425
    dec_ref r430
    goto L421
L565:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r23
    goto L2
L566:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r23
    goto L32
L567:
    xdec_ref r1
    goto L411
L568:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r23
    goto L70
L569:
    xdec_ref r3
    goto L412
L570:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r23
    goto L110
L571:
    xdec_ref r5
    dec_ref r26
    goto L413
L572:
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r23
    goto L146
L573:
    xdec_ref r7
    goto L414
L574:
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r23
    goto L180
L575:
    xdec_ref r9
    goto L415
L576:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r23
    goto L224
L577:
    xdec_ref r11
    xdec_ref r13
    goto L416
L578:
    xdec_ref r17
    xdec_ref r19
    xdec_ref r23
    goto L264
L579:
    xdec_ref r15
    goto L417
L580:
    xdec_ref r23
    goto L308
L581:
    xdec_ref r17
    xdec_ref r19
    goto L418
L582:
    xdec_ref r23
    dec_ref r24
    goto L419

def coroutine_gen___147.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine_gen___147
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine_gen___147.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine_gen___147.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine_gen___147
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine_gen___147.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine_gen___147.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine_gen___147
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine_gen___147.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine_gen___147
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutine_gen___147.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutine_gen___147.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine_gen___147
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def coroutine_gen___147.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine_gen___147
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine__get_coroutine_fn_obj.__call__(__mypyc_self__, self, args, block_identifier, decimals, override):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_obj
    self :: object
    args :: tuple
    block_identifier :: union[object, None]
    decimals :: union[int, None]
    override :: union[dict, None]
    r0 :: dank_mids.brownie_patch.call._get_coroutine_fn_env
    r1, r2, r3 :: object
    r4 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_env
    r5, r6, r7, r8, r9, r10 :: bool
    r11 :: dank_mids.brownie_patch.call.coroutine_gen___147
    r12, r13 :: bool
    r14 :: dank_mids.brownie_patch.call.coroutine_gen___147
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L17 (error at coroutine:147) else goto L1
L1:
    if is_error(block_identifier) goto L2 else goto L18
L2:
    r1 = box(None, 1)
    inc_ref r1
    block_identifier = r1
L3:
    if is_error(decimals) goto L4 else goto L19
L4:
    r2 = box(None, 1)
    inc_ref r2
    decimals = r2
L5:
    if is_error(override) goto L6 else goto L20
L6:
    r3 = box(None, 1)
    inc_ref r3
    override = r3
L7:
    r4 = coroutine__get_coroutine_fn_env()
    if is_error(r4) goto L21 (error at coroutine:147) else goto L8
L8:
    r4.__mypyc_env__ = r0; r5 = is_error
    if not r5 goto L22 (error at coroutine:147) else goto L9 :: bool
L9:
    inc_ref self
    r4.self = self; r6 = is_error
    if not r6 goto L22 (error at coroutine:147) else goto L10 :: bool
L10:
    inc_ref args
    r4.args = args; r7 = is_error
    if not r7 goto L22 (error at coroutine:147) else goto L11 :: bool
L11:
    r4.block_identifier = block_identifier; r8 = is_error
    if not r8 goto L23 (error at coroutine:147) else goto L12 :: bool
L12:
    r4.decimals = decimals; r9 = is_error
    if not r9 goto L24 (error at coroutine:147) else goto L13 :: bool
L13:
    r4.override = override; r10 = is_error
    if not r10 goto L25 (error at coroutine:147) else goto L14 :: bool
L14:
    r11 = coroutine_gen___147()
    if is_error(r11) goto L25 (error at coroutine:147) else goto L15
L15:
    inc_ref r4
    r11.__mypyc_env__ = r4; r12 = is_error
    if not r12 goto L26 (error at coroutine:147) else goto L16 :: bool
L16:
    r4.__mypyc_next_label__ = 0
    dec_ref r4
    return r11
L17:
    r14 = <error> :: dank_mids.brownie_patch.call.coroutine_gen___147
    return r14
L18:
    inc_ref block_identifier
    goto L3
L19:
    inc_ref decimals
    goto L5
L20:
    inc_ref override
    goto L7
L21:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r0
    goto L17
L22:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L17
L23:
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L17
L24:
    dec_ref override
    dec_ref r4
    goto L17
L25:
    dec_ref r4
    goto L17
L26:
    dec_ref r4
    dec_ref r11
    goto L17

def _get_coroutine_fn(w3, len_inputs):
    w3 :: object
    len_inputs :: int
    r0 :: dank_mids.brownie_patch.call._get_coroutine_fn_env
    r1, r2, r3, r4 :: bool
    r5 :: int
    r6 :: bit
    r7 :: object
    r8, r9 :: bool
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: bool
    r14 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_obj
    r15 :: bool
    coroutine, r16 :: object
L0:
    r0 = _get_coroutine_fn_env()
    if is_error(r0) goto L18 (error at _get_coroutine_fn:141) else goto L1
L1:
    inc_ref w3
    r0.w3 = w3; r1 = is_error
    if not r1 goto L19 (error at _get_coroutine_fn:141) else goto L2 :: bool
L2:
    inc_ref len_inputs :: int
    r0.len_inputs = len_inputs; r2 = is_error
    if not r2 goto L19 (error at _get_coroutine_fn:141) else goto L3 :: bool
L3:
    r3 = dank_mids.brownie_patch.call.APPLICATION_MODE :: static
    if is_error(r3) goto L20 else goto L6
L4:
    r4 = raise NameError('value for final name "APPLICATION_MODE" was not set')
    if not r4 goto L18 (error at _get_coroutine_fn:142) else goto L5 :: bool
L5:
    unreachable
L6:
    if r3 goto L9 else goto L7 :: bool
L7:
    r5 = r0.len_inputs
    if is_error(r5) goto L19 (error at _get_coroutine_fn:142) else goto L8
L8:
    r6 = r5 != 0
    dec_ref r5 :: int
    if r6 goto L9 else goto L13 :: bool
L9:
    r7 = dank_mids.brownie_patch.call.encode :: static
    if is_error(r7) goto L21 else goto L12
L10:
    r8 = raise NameError('value for final name "encode" was not set')
    if not r8 goto L18 (error at _get_coroutine_fn:143) else goto L11 :: bool
L11:
    unreachable
L12:
    inc_ref r7
    r0.get_request_data = r7; r9 = is_error
    if not r9 goto L19 (error at _get_coroutine_fn:143) else goto L15 :: bool
L13:
    r10 = dank_mids.brownie_patch.call.globals :: static
    r11 = '_request_data_no_args'
    r12 = CPyDict_GetItem(r10, r11)
    if is_error(r12) goto L19 (error at _get_coroutine_fn:145) else goto L14
L14:
    r0.get_request_data = r12; r13 = is_error
    if not r13 goto L19 (error at _get_coroutine_fn:145) else goto L15 :: bool
L15:
    r14 = coroutine__get_coroutine_fn_obj()
    if is_error(r14) goto L19 (error at _get_coroutine_fn:147) else goto L16
L16:
    r14.__mypyc_env__ = r0; r15 = is_error
    if not r15 goto L22 (error at _get_coroutine_fn:147) else goto L17 :: bool
L17:
    coroutine = r14
    return coroutine
L18:
    r16 = <error> :: object
    return r16
L19:
    dec_ref r0
    goto L18
L20:
    dec_ref r0
    goto L4
L21:
    dec_ref r0
    goto L10
L22:
    dec_ref r14
    goto L18

def _call_no_args(self):
    self :: object
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4 :: str
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
L0:
    r0 = 'coroutine'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L3 (error at _call_no_args:181) else goto L1
L1:
    r4 = '__await__'
    r5 = [r3]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r4, r6, 9223372036854775809, 0)
    if is_error(r7) goto L4 (error at _call_no_args:181) else goto L2
L2:
    dec_ref r3
    return r7
L3:
    r8 = <error> :: object
    return r8
L4:
    dec_ref r3
    goto L3

def encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1 :: object
    r2 :: i32
    r3 :: object
    r4 :: bit
    r5 :: bool
    r6 :: tuple
    r7, r8 :: bool
    r9 :: tuple
    r10 :: ptr
    r11, r12 :: native_int
    r13 :: bit
    r14 :: tuple
    r15 :: native_int
    r16 :: object
    r17 :: bool
    r18, r19 :: object
    r20 :: bool
    r21 :: i32
    r22 :: bit
    r23 :: bool
    r24 :: object
    r25 :: str
    r26 :: bool
    r27, r28 :: native_int
    r29 :: bool
    r30 :: object
    r31 :: str
    r32, r33 :: object
    r34 :: str
    r35 :: object
    r36 :: tuple
    r37 :: dict
    r38 :: str
    r39 :: object
    r40 :: list
    r41, r42, r43 :: ptr
    r44 :: object
    r45 :: tuple
    r46 :: dict
    r47 :: object
    r48 :: bool
    r49 :: object
    r50 :: tuple
    r51 :: object
    r52 :: list
    r53, r54 :: ptr
    r55 :: object
    r56 :: tuple
    r57 :: dict
    r58, r59 :: object
    r60 :: bool
    r61, r62, r63, r64, r65 :: object
    r66 :: bool
    r67 :: object
    r68 :: bool
    r69 :: object
    r70 :: bit
    r71 :: tuple[object, object, object]
    r72 :: bool
    r73 :: object_ptr
    r74 :: object
    r75 :: bool
    r76, r77, r78 :: tuple[object, object, object]
    r79 :: bit
    r80, r81, r82 :: object
    r83 :: bool
    r84 :: tuple[object, object, object]
    r85 :: bool
    r86 :: object
    r87 :: str
    r88, r89 :: object
    r90 :: str
    r91 :: object
    r92 :: tuple[object, object]
    r93 :: object
    r94 :: bit
    r95 :: object
    r96 :: str
    r97, r98 :: object
    r99 :: str
    r100 :: object
    r101 :: tuple
    r102 :: dict
    r103 :: str
    r104 :: object
    r105 :: list
    r106, r107, r108 :: ptr
    r109 :: object
    r110 :: tuple
    r111 :: dict
    r112 :: object
    r113 :: bool
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: bit
    r118 :: object
    r119 :: bool
    r120 :: str
    r121 :: dict
    r122 :: str
    r123 :: object
    r124 :: str
    r125, r126, r127 :: object
    r128 :: str
    r129 :: object
    r130 :: str
    r131 :: object[5]
    r132 :: object_ptr
    r133 :: object
    r134 :: dict
    r135 :: str
    r136 :: object
    r137 :: str
    r138 :: object
    r139 :: str
    r140 :: object
    r141 :: dict
    r142 :: str
    r143 :: object
    r144 :: object[1]
    r145 :: object_ptr
    r146 :: object
    r147 :: dict
    r148 :: str
    r149 :: object
    r150 :: str
    r151 :: i32
    r152 :: bit
    r153 :: int
    r154 :: bit
    r155 :: object
    r156 :: str
    r157, r158 :: object
    r159 :: str
    r160 :: object
    r161 :: tuple
    r162 :: dict
    r163 :: str
    r164 :: object
    r165 :: list
    r166, r167, r168 :: ptr
    r169 :: object
    r170 :: tuple
    r171 :: dict
    r172, r173, r174 :: object
    r175 :: str
    r176 :: object
    r177 :: bool
    r178 :: dict
    r179 :: str
    r180 :: object
    r181 :: bit
    r182 :: int
    r183 :: bit
    r184 :: object
    r185 :: str
    r186, r187 :: object
    r188 :: str
    r189 :: object
    r190 :: tuple
    r191 :: dict
    r192 :: str
    r193 :: object
    r194 :: list
    r195, r196, r197 :: ptr
    r198 :: object
    r199 :: tuple
    r200 :: dict
    r201, r202, r203 :: object
    r204 :: str
    r205 :: object
    r206 :: bool
    r207, r208 :: tuple[object, object, object]
    r209 :: bit
    r210, r211 :: object
    r212 :: str
    r213 :: object
    r214 :: i32
    r215 :: bit
    r216 :: bool
    r217 :: object
    r218 :: str
    r219 :: object
    r220 :: tuple
    r221 :: ptr
    r222 :: native_int
    r223 :: short_int
    r224 :: bit
    r225, r226 :: object
    r227 :: str
    r228 :: bool
    r229 :: str
    r230 :: object
    r231 :: str
    r232 :: object
    r233 :: str
    r234 :: object[2]
    r235 :: object_ptr
    r236 :: object
    r237 :: bool
    r238, r239 :: str
    r240 :: list
    r241 :: object
    r242 :: str
    r243 :: bool
    r244, r245, r246 :: str
    r247 :: bool
    r248, r249 :: object
    r250 :: str
    r251 :: object
    r252 :: str
    r253 :: object
    r254, r255 :: str
    r256 :: object
    r257 :: str
    r258 :: object
    r259, r260, r261, r262 :: str
    r263 :: object[1]
    r264 :: object_ptr
    r265, r266 :: object
    r267 :: bool
    r268, r269 :: bit
    r270 :: bool
    r271 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_next_label__
    goto L200
L1:
    r3 = load_address _Py_NoneStruct
    r4 = type != r3
    if r4 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L204 (error at encode_input:184) else goto L3 :: bool
L3:
    unreachable
L4:
    r5 = 0
    r6 = __mypyc_self__.args
    if is_error(r6) goto L204 (error at encode_input:186) else goto L5
L5:
    __mypyc_self__.__mypyc_temp__27 = r6; r7 = is_error
    if not r7 goto L204 (error at encode_input:-1) else goto L6 :: bool
L6:
    __mypyc_self__.__mypyc_temp__28 = 0; r8 = is_error
    if not r8 goto L204 (error at encode_input:-1) else goto L7 :: bool
L7:
    r9 = __mypyc_self__.__mypyc_temp__27
    if is_error(r9) goto L204 (error at encode_input:186) else goto L8
L8:
    r10 = get_element_ptr r9 ob_size :: PyVarObject
    r11 = load_mem r10 :: native_int*
    dec_ref r9
    r12 = __mypyc_self__.__mypyc_temp__28
    if is_error(r12) goto L204 (error at encode_input:186) else goto L9
L9:
    r13 = r12 < r11 :: signed
    if r13 goto L10 else goto L25 :: bool
L10:
    r14 = __mypyc_self__.__mypyc_temp__27
    if is_error(r14) goto L204 (error at encode_input:186) else goto L11
L11:
    r15 = __mypyc_self__.__mypyc_temp__28
    if is_error(r15) goto L205 (error at encode_input:186) else goto L12
L12:
    r16 = CPySequenceTuple_GetItemUnsafe(r14, r15)
    dec_ref r14
    __mypyc_self__.arg = r16; r17 = is_error
    if not r17 goto L204 (error at encode_input:186) else goto L13 :: bool
L13:
    r18 = __mypyc_self__.arg
    if is_error(r18) goto L204 (error at encode_input:186) else goto L14
L14:
    r19 = dank_mids.brownie_patch.call.Contract :: static
    if is_error(r19) goto L206 else goto L17
L15:
    r20 = raise NameError('value for final name "Contract" was not set')
    if not r20 goto L204 (error at encode_input:186) else goto L16 :: bool
L16:
    unreachable
L17:
    r21 = PyObject_IsInstance(r18, r19)
    dec_ref r18
    r22 = r21 >= 0 :: signed
    if not r22 goto L204 (error at encode_input:186) else goto L18 :: bool
L18:
    r23 = truncate r21: i32 to builtins.bool
    if r23 goto L19 else goto L20 :: bool
L19:
    if r23 goto L22 else goto L23 :: bool
L20:
    r24 = __mypyc_self__.arg
    if is_error(r24) goto L204 (error at encode_input:186) else goto L21
L21:
    r25 = '__contains__'
    r26 = PyObject_HasAttr(r24, r25)
    dec_ref r24
    if r26 goto L22 else goto L23 :: bool
L22:
    r5 = 1
    goto L25
L23:
    r27 = __mypyc_self__.__mypyc_temp__28
    if is_error(r27) goto L204 (error at encode_input:186) else goto L24
L24:
    r28 = r27 + 1
    __mypyc_self__.__mypyc_temp__28 = r28; r29 = is_error
    if not r29 goto L204 (error at encode_input:186) else goto L7 :: bool
L25:
    if r5 goto L26 else goto L38 :: bool
L26:
    r30 = __mypyc_self__.call
    if is_error(r30) goto L204 (error at encode_input:188) else goto L27
L27:
    r31 = 'abi'
    r32 = CPyObject_GetAttr(r30, r31)
    dec_ref r30
    if is_error(r32) goto L204 (error at encode_input:188) else goto L28
L28:
    r33 = __mypyc_self__.call
    if is_error(r33) goto L207 (error at encode_input:188) else goto L29
L29:
    r34 = 'signature'
    r35 = CPyObject_GetAttr(r33, r34)
    dec_ref r33
    if is_error(r35) goto L207 (error at encode_input:188) else goto L30
L30:
    r36 = __mypyc_self__.args
    if is_error(r36) goto L208 (error at encode_input:188) else goto L31
L31:
    r37 = dank_mids.brownie_patch.call.globals :: static
    r38 = '__encode_input'
    r39 = CPyDict_GetItem(r37, r38)
    if is_error(r39) goto L209 (error at encode_input:188) else goto L32
L32:
    r40 = PyList_New(2)
    if is_error(r40) goto L210 (error at encode_input:188) else goto L33
L33:
    r41 = get_element_ptr r40 ob_item :: PyListObject
    r42 = load_mem r41 :: ptr*
    set_mem r42, r32 :: builtins.object*
    r43 = r42 + 8
    set_mem r43, r35 :: builtins.object*
    r44 = CPyList_Extend(r40, r36)
    dec_ref r36
    if is_error(r44) goto L211 (error at encode_input:188) else goto L212
L34:
    r45 = PyList_AsTuple(r40)
    dec_ref r40
    if is_error(r45) goto L213 (error at encode_input:188) else goto L35
L35:
    r46 = PyDict_New()
    if is_error(r46) goto L214 (error at encode_input:188) else goto L36
L36:
    r47 = PyObject_Call(r39, r45, r46)
    dec_ref r39
    dec_ref r45
    dec_ref r46
    if is_error(r47) goto L204 (error at encode_input:188) else goto L37
L37:
    __mypyc_self__.data = r47; r48 = is_error
    if not r48 goto L204 (error at encode_input:188) else goto L154 :: bool
L38:
    r49 = __mypyc_self__.call
    if is_error(r49) goto L75 (error at encode_input:191) else goto L39
L39:
    r50 = __mypyc_self__.args
    if is_error(r50) goto L215 (error at encode_input:191) else goto L40
L40:
    r51 = __mypyc_self__.get_request_data
    if is_error(r51) goto L216 (error at encode_input:191) else goto L41
L41:
    r52 = PyList_New(1)
    if is_error(r52) goto L217 (error at encode_input:191) else goto L42
L42:
    r53 = get_element_ptr r52 ob_item :: PyListObject
    r54 = load_mem r53 :: ptr*
    set_mem r54, r49 :: builtins.object*
    r55 = CPyList_Extend(r52, r50)
    dec_ref r50
    if is_error(r55) goto L218 (error at encode_input:191) else goto L219
L43:
    r56 = PyList_AsTuple(r52)
    dec_ref r52
    if is_error(r56) goto L220 (error at encode_input:191) else goto L44
L44:
    r57 = PyDict_New()
    if is_error(r57) goto L221 (error at encode_input:191) else goto L45
L45:
    r58 = PyObject_Call(r51, r56, r57)
    dec_ref r51
    dec_ref r56
    dec_ref r57
    if is_error(r58) goto L75 (error at encode_input:191) else goto L46
L46:
    r59 = CPy_GetCoro(r58)
    dec_ref r58
    if is_error(r59) goto L75 (error at encode_input:191) else goto L47
L47:
    __mypyc_self__.__mypyc_temp__29 = r59; r60 = is_error
    if not r60 goto L75 (error at encode_input:-1) else goto L48 :: bool
L48:
    r61 = __mypyc_self__.__mypyc_temp__29
    if is_error(r61) goto L75 (error at encode_input:-1) else goto L49
L49:
    r62 = CPyIter_Next(r61)
    dec_ref r61
    if is_error(r62) goto L50 else goto L52
L50:
    r63 = CPy_FetchStopIterationValue()
    if is_error(r63) goto L75 (error at encode_input:191) else goto L51
L51:
    r64 = r63
    r65 = <error> :: object
    __mypyc_self__.__mypyc_temp__29 = r65; r66 = is_error
    if not r66 goto L222 (error at encode_input:191) else goto L74 :: bool
L52:
    r67 = r62
L53:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r67
L54:
    r69 = load_address _Py_NoneStruct
    r70 = type != r69
    if r70 goto L55 else goto L223 :: bool
L55:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L58 (error at encode_input:191) else goto L224 :: bool
L56:
    unreachable
L57:
    inc_ref arg
    goto L69
L58:
    r71 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__30 = r71; r72 = is_error
    if not r72 goto L225 (error at encode_input:-1) else goto L59 :: bool
L59:
    r73 = load_address r1
    r74 = __mypyc_self__.__mypyc_temp__29
    if is_error(r74) goto L225 (error at encode_input:-1) else goto L60
L60:
    r75 = CPy_YieldFromErrorHandle(r74, r73)
    dec_ref r74
    if is_error(r75) goto L225 (error at encode_input:191) else goto L61
L61:
    if r75 goto L64 else goto L62 :: bool
L62:
    r67 = r1
    r76 = __mypyc_self__.__mypyc_temp__30
    if is_error(r76) goto L226 (error at encode_input:-1) else goto L63
L63:
    CPy_RestoreExcInfo(r76)
    dec_ref r76
    goto L53
L64:
    r64 = r1
    r77 = __mypyc_self__.__mypyc_temp__30
    if is_error(r77) goto L227 (error at encode_input:-1) else goto L65
L65:
    CPy_RestoreExcInfo(r77)
    dec_ref r77
    goto L74
L66:
    r78 = __mypyc_self__.__mypyc_temp__30
    if is_error(r78) goto L75 (error at encode_input:-1) else goto L67
L67:
    CPy_RestoreExcInfo(r78)
    dec_ref r78
    r79 = CPy_KeepPropagating()
    if not r79 goto L75 else goto L68 :: bool
L68:
    unreachable
L69:
    r80 = __mypyc_self__.__mypyc_temp__29
    if is_error(r80) goto L228 (error at encode_input:-1) else goto L70
L70:
    r81 = CPyIter_Send(r80, arg)
    dec_ref r80
    dec_ref arg
    if is_error(r81) goto L72 else goto L71
L71:
    r67 = r81
    goto L53
L72:
    r82 = CPy_FetchStopIterationValue()
    if is_error(r82) goto L75 (error at encode_input:191) else goto L73
L73:
    r64 = r82
L74:
    __mypyc_self__.data = r64; r83 = is_error
    if not r83 goto L75 (error at encode_input:191) else goto L154 :: bool
L75:
    r84 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__31 = r84; r85 = is_error
    if not r85 goto L151 (error at encode_input:-1) else goto L76 :: bool
L76:
    r86 = builtins :: module
    r87 = 'AttributeError'
    r88 = CPyObject_GetAttr(r86, r87)
    if is_error(r88) goto L151 (error at encode_input:192) else goto L77
L77:
    r89 = builtins :: module
    r90 = 'TypeError'
    r91 = CPyObject_GetAttr(r89, r90)
    if is_error(r91) goto L229 (error at encode_input:192) else goto L78
L78:
    r92 = (r88, r91)
    r93 = box(tuple[object, object], r92)
    r94 = CPy_ExceptionMatches(r93)
    dec_ref r93
    if r94 goto L79 else goto L91 :: bool
L79:
    r95 = __mypyc_self__.call
    if is_error(r95) goto L151 (error at encode_input:194) else goto L80
L80:
    r96 = 'abi'
    r97 = CPyObject_GetAttr(r95, r96)
    dec_ref r95
    if is_error(r97) goto L151 (error at encode_input:194) else goto L81
L81:
    r98 = __mypyc_self__.call
    if is_error(r98) goto L230 (error at encode_input:194) else goto L82
L82:
    r99 = 'signature'
    r100 = CPyObject_GetAttr(r98, r99)
    dec_ref r98
    if is_error(r100) goto L230 (error at encode_input:194) else goto L83
L83:
    r101 = __mypyc_self__.args
    if is_error(r101) goto L231 (error at encode_input:194) else goto L84
L84:
    r102 = dank_mids.brownie_patch.call.globals :: static
    r103 = '__encode_input'
    r104 = CPyDict_GetItem(r102, r103)
    if is_error(r104) goto L232 (error at encode_input:194) else goto L85
L85:
    r105 = PyList_New(2)
    if is_error(r105) goto L233 (error at encode_input:194) else goto L86
L86:
    r106 = get_element_ptr r105 ob_item :: PyListObject
    r107 = load_mem r106 :: ptr*
    set_mem r107, r97 :: builtins.object*
    r108 = r107 + 8
    set_mem r108, r100 :: builtins.object*
    r109 = CPyList_Extend(r105, r101)
    dec_ref r101
    if is_error(r109) goto L234 (error at encode_input:194) else goto L235
L87:
    r110 = PyList_AsTuple(r105)
    dec_ref r105
    if is_error(r110) goto L236 (error at encode_input:194) else goto L88
L88:
    r111 = PyDict_New()
    if is_error(r111) goto L237 (error at encode_input:194) else goto L89
L89:
    r112 = PyObject_Call(r104, r110, r111)
    dec_ref r104
    dec_ref r110
    dec_ref r111
    if is_error(r112) goto L151 (error at encode_input:194) else goto L90
L90:
    __mypyc_self__.data = r112; r113 = is_error
    if not r113 goto L151 (error at encode_input:194) else goto L149 :: bool
L91:
    r114 = dank_mids.brownie_patch.call.globals :: static
    r115 = 'BrokenProcessPool'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L151 (error at encode_input:196) else goto L92
L92:
    r117 = CPy_ExceptionMatches(r116)
    dec_ref r116
    if r117 goto L93 else goto L127 :: bool
L93:
    r118 = dank_mids.brownie_patch.call.logger :: static
    if is_error(r118) goto L94 else goto L96
L94:
    r119 = raise NameError('value for final name "logger" was not set')
    if not r119 goto L151 (error at encode_input:197) else goto L95 :: bool
L95:
    unreachable
L96:
    r120 = 'Oh fuck, you broke the %s while decoding %s with abi %s'
    r121 = dank_mids.brownie_patch.call.globals :: static
    r122 = 'ENVS'
    r123 = CPyDict_GetItem(r121, r122)
    if is_error(r123) goto L151 (error at encode_input:197) else goto L97
L97:
    r124 = 'BROWNIE_ENCODER_PROCESSES'
    r125 = CPyObject_GetAttr(r123, r124)
    dec_ref r123
    if is_error(r125) goto L151 (error at encode_input:197) else goto L98
L98:
    r126 = __mypyc_self__.data
    if is_error(r126) goto L238 (error at encode_input:197) else goto L99
L99:
    r127 = __mypyc_self__.call
    if is_error(r127) goto L239 (error at encode_input:197) else goto L100
L100:
    r128 = 'abi'
    r129 = CPyObject_GetAttr(r127, r128)
    dec_ref r127
    if is_error(r129) goto L239 (error at encode_input:197) else goto L101
L101:
    r130 = 'critical'
    r131 = [r118, r120, r125, r126, r129]
    r132 = load_address r131
    r133 = PyObject_VectorcallMethod(r130, r132, 9223372036854775813, 0)
    if is_error(r133) goto L240 (error at encode_input:197) else goto L241
L102:
    dec_ref r125
    dec_ref r126
    dec_ref r129
    r134 = dank_mids.brownie_patch.call.globals :: static
    r135 = 'ENVS'
    r136 = CPyDict_GetItem(r134, r135)
    if is_error(r136) goto L151 (error at encode_input:199) else goto L103
L103:
    r137 = 'BROWNIE_ENCODER_PROCESSES'
    r138 = CPyObject_GetAttr(r136, r137)
    dec_ref r136
    if is_error(r138) goto L151 (error at encode_input:199) else goto L104
L104:
    r139 = '_max_workers'
    r140 = CPyObject_GetAttr(r138, r139)
    dec_ref r138
    if is_error(r140) goto L151 (error at encode_input:199) else goto L105
L105:
    r141 = dank_mids.brownie_patch.call.globals :: static
    r142 = 'AsyncProcessPoolExecutor'
    r143 = CPyDict_GetItem(r141, r142)
    if is_error(r143) goto L242 (error at encode_input:199) else goto L106
L106:
    r144 = [r140]
    r145 = load_address r144
    r146 = PyObject_Vectorcall(r143, r145, 1, 0)
    dec_ref r143
    if is_error(r146) goto L242 (error at encode_input:199) else goto L107
L107:
    dec_ref r140
    r147 = dank_mids.brownie_patch.call.globals :: static
    r148 = 'ENVS'
    r149 = CPyDict_GetItem(r147, r148)
    if is_error(r149) goto L243 (error at encode_input:199) else goto L108
L108:
    r150 = 'BROWNIE_ENCODER_PROCESSES'
    r151 = PyObject_SetAttr(r149, r150, r146)
    dec_ref r149
    dec_ref r146
    r152 = r151 >= 0 :: signed
    if not r152 goto L151 (error at encode_input:199) else goto L109 :: bool
L109:
    r153 = __mypyc_self__.len_inputs
    if is_error(r153) goto L151 (error at encode_input:200) else goto L110
L110:
    r154 = r153 != 0
    dec_ref r153 :: int
    if r154 goto L111 else goto L123 :: bool
L111:
    r155 = __mypyc_self__.call
    if is_error(r155) goto L151 (error at encode_input:200) else goto L112
L112:
    r156 = 'abi'
    r157 = CPyObject_GetAttr(r155, r156)
    dec_ref r155
    if is_error(r157) goto L151 (error at encode_input:200) else goto L113
L113:
    r158 = __mypyc_self__.call
    if is_error(r158) goto L244 (error at encode_input:200) else goto L114
L114:
    r159 = 'signature'
    r160 = CPyObject_GetAttr(r158, r159)
    dec_ref r158
    if is_error(r160) goto L244 (error at encode_input:200) else goto L115
L115:
    r161 = __mypyc_self__.args
    if is_error(r161) goto L245 (error at encode_input:200) else goto L116
L116:
    r162 = dank_mids.brownie_patch.call.globals :: static
    r163 = '__encode_input'
    r164 = CPyDict_GetItem(r162, r163)
    if is_error(r164) goto L246 (error at encode_input:200) else goto L117
L117:
    r165 = PyList_New(2)
    if is_error(r165) goto L247 (error at encode_input:200) else goto L118
L118:
    r166 = get_element_ptr r165 ob_item :: PyListObject
    r167 = load_mem r166 :: ptr*
    set_mem r167, r157 :: builtins.object*
    r168 = r167 + 8
    set_mem r168, r160 :: builtins.object*
    r169 = CPyList_Extend(r165, r161)
    dec_ref r161
    if is_error(r169) goto L248 (error at encode_input:200) else goto L249
L119:
    r170 = PyList_AsTuple(r165)
    dec_ref r165
    if is_error(r170) goto L250 (error at encode_input:200) else goto L120
L120:
    r171 = PyDict_New()
    if is_error(r171) goto L251 (error at encode_input:200) else goto L121
L121:
    r172 = PyObject_Call(r164, r170, r171)
    dec_ref r164
    dec_ref r170
    dec_ref r171
    if is_error(r172) goto L151 (error at encode_input:200) else goto L122
L122:
    r173 = r172
    goto L126
L123:
    r174 = __mypyc_self__.call
    if is_error(r174) goto L151 (error at encode_input:200) else goto L124
L124:
    r175 = 'signature'
    r176 = CPyObject_GetAttr(r174, r175)
    dec_ref r174
    if is_error(r176) goto L151 (error at encode_input:200) else goto L125
L125:
    r173 = r176
L126:
    __mypyc_self__.data = r173; r177 = is_error
    if not r177 goto L151 (error at encode_input:200) else goto L149 :: bool
L127:
    r178 = dank_mids.brownie_patch.call.globals :: static
    r179 = 'PicklingError'
    r180 = CPyDict_GetItem(r178, r179)
    if is_error(r180) goto L151 (error at encode_input:201) else goto L128
L128:
    r181 = CPy_ExceptionMatches(r180)
    dec_ref r180
    if r181 goto L129 else goto L147 :: bool
L129:
    r182 = __mypyc_self__.len_inputs
    if is_error(r182) goto L151 (error at encode_input:202) else goto L130
L130:
    r183 = r182 != 0
    dec_ref r182 :: int
    if r183 goto L131 else goto L143 :: bool
L131:
    r184 = __mypyc_self__.call
    if is_error(r184) goto L151 (error at encode_input:202) else goto L132
L132:
    r185 = 'abi'
    r186 = CPyObject_GetAttr(r184, r185)
    dec_ref r184
    if is_error(r186) goto L151 (error at encode_input:202) else goto L133
L133:
    r187 = __mypyc_self__.call
    if is_error(r187) goto L252 (error at encode_input:202) else goto L134
L134:
    r188 = 'signature'
    r189 = CPyObject_GetAttr(r187, r188)
    dec_ref r187
    if is_error(r189) goto L252 (error at encode_input:202) else goto L135
L135:
    r190 = __mypyc_self__.args
    if is_error(r190) goto L253 (error at encode_input:202) else goto L136
L136:
    r191 = dank_mids.brownie_patch.call.globals :: static
    r192 = '__encode_input'
    r193 = CPyDict_GetItem(r191, r192)
    if is_error(r193) goto L254 (error at encode_input:202) else goto L137
L137:
    r194 = PyList_New(2)
    if is_error(r194) goto L255 (error at encode_input:202) else goto L138
L138:
    r195 = get_element_ptr r194 ob_item :: PyListObject
    r196 = load_mem r195 :: ptr*
    set_mem r196, r186 :: builtins.object*
    r197 = r196 + 8
    set_mem r197, r189 :: builtins.object*
    r198 = CPyList_Extend(r194, r190)
    dec_ref r190
    if is_error(r198) goto L256 (error at encode_input:202) else goto L257
L139:
    r199 = PyList_AsTuple(r194)
    dec_ref r194
    if is_error(r199) goto L258 (error at encode_input:202) else goto L140
L140:
    r200 = PyDict_New()
    if is_error(r200) goto L259 (error at encode_input:202) else goto L141
L141:
    r201 = PyObject_Call(r193, r199, r200)
    dec_ref r193
    dec_ref r199
    dec_ref r200
    if is_error(r201) goto L151 (error at encode_input:202) else goto L142
L142:
    r202 = r201
    goto L146
L143:
    r203 = __mypyc_self__.call
    if is_error(r203) goto L151 (error at encode_input:202) else goto L144
L144:
    r204 = 'signature'
    r205 = CPyObject_GetAttr(r203, r204)
    dec_ref r203
    if is_error(r205) goto L151 (error at encode_input:202) else goto L145
L145:
    r202 = r205
L146:
    __mypyc_self__.data = r202; r206 = is_error
    if not r206 goto L151 (error at encode_input:202) else goto L149 :: bool
L147:
    CPy_Reraise()
    if not 0 goto L151 else goto L148 :: bool
L148:
    unreachable
L149:
    r207 = __mypyc_self__.__mypyc_temp__31
    if is_error(r207) goto L204 (error at encode_input:-1) else goto L150
L150:
    CPy_RestoreExcInfo(r207)
    dec_ref r207
    goto L154
L151:
    r208 = __mypyc_self__.__mypyc_temp__31
    if is_error(r208) goto L204 (error at encode_input:-1) else goto L152
L152:
    CPy_RestoreExcInfo(r208)
    dec_ref r208
    r209 = CPy_KeepPropagating()
    if not r209 goto L204 else goto L153 :: bool
L153:
    unreachable
L154:
    r210 = __mypyc_self__.data
    if is_error(r210) goto L204 (error at encode_input:204) else goto L155
L155:
    r211 = builtins :: module
    r212 = 'Exception'
    r213 = CPyObject_GetAttr(r211, r212)
    if is_error(r213) goto L260 (error at encode_input:204) else goto L156
L156:
    r214 = PyObject_IsInstance(r210, r213)
    dec_ref r210
    dec_ref r213
    r215 = r214 >= 0 :: signed
    if not r215 goto L204 (error at encode_input:204) else goto L157 :: bool
L157:
    r216 = truncate r214: i32 to builtins.bool
    if r216 goto L158 else goto L194 :: bool
L158:
    r217 = __mypyc_self__.data
    if is_error(r217) goto L204 (error at encode_input:205) else goto L159
L159:
    r218 = 'args'
    r219 = CPyObject_GetAttr(r217, r218)
    dec_ref r217
    if is_error(r219) goto L204 (error at encode_input:205) else goto L160
L160:
    r220 = cast(tuple, r219)
    if is_error(r220) goto L204 (error at encode_input:205) else goto L161
L161:
    r221 = get_element_ptr r220 ob_size :: PyVarObject
    r222 = load_mem r221 :: native_int*
    dec_ref r220
    r223 = r222 << 1
    r224 = r223 != 2
    if r224 goto L162 else goto L165 :: bool
L162:
    r225 = __mypyc_self__.data
    if is_error(r225) goto L204 (error at encode_input:206) else goto L163
L163:
    CPy_Raise(r225)
    dec_ref r225
    if not 0 goto L204 (error at encode_input:206) else goto L164 :: bool
L164:
    unreachable
L165:
    r226 = __mypyc_self__.data
    if is_error(r226) goto L204 (error at encode_input:207) else goto L166
L166:
    r227 = PyObject_Str(r226)
    dec_ref r226
    if is_error(r227) goto L204 (error at encode_input:207) else goto L167
L167:
    __mypyc_self__.exc_str = r227; r228 = is_error
    if not r228 goto L204 (error at encode_input:207) else goto L168 :: bool
L168:
    r229 = __mypyc_self__.exc_str
    if is_error(r229) goto L204 (error at encode_input:208) else goto L169
L169:
    r230 = __mypyc_self__.call
    if is_error(r230) goto L261 (error at encode_input:208) else goto L170
L170:
    r231 = '_name'
    r232 = CPyObject_GetAttr(r230, r231)
    dec_ref r230
    if is_error(r232) goto L261 (error at encode_input:208) else goto L171
L171:
    r233 = 'startswith'
    r234 = [r229, r232]
    r235 = load_address r234
    r236 = PyObject_VectorcallMethod(r233, r235, 9223372036854775810, 0)
    if is_error(r236) goto L262 (error at encode_input:208) else goto L172
L172:
    dec_ref r229
    dec_ref r232
    r237 = unbox(bool, r236)
    dec_ref r236
    if is_error(r237) goto L204 (error at encode_input:208) else goto L173
L173:
    if r237 goto L174 else goto L179 :: bool
L174:
    r238 = __mypyc_self__.exc_str
    if is_error(r238) goto L204 (error at encode_input:209) else goto L175
L175:
    r239 = ' '
    r240 = CPyStr_Split(r238, r239, 2)
    dec_ref r238
    if is_error(r240) goto L204 (error at encode_input:209) else goto L176
L176:
    r241 = CPyList_GetItemShort(r240, 2)
    dec_ref r240
    if is_error(r241) goto L204 (error at encode_input:209) else goto L177
L177:
    r242 = cast(str, r241)
    if is_error(r242) goto L204 (error at encode_input:209) else goto L178
L178:
    __mypyc_self__.exc_str = r242; r243 = is_error
    if not r243 goto L204 (error at encode_input:209) else goto L182 :: bool
L179:
    r244 = ': '
    r245 = __mypyc_self__.exc_str
    if is_error(r245) goto L204 (error at encode_input:211) else goto L180
L180:
    r246 = CPyStr_Build(2, r244, r245)
    dec_ref r245
    if is_error(r246) goto L204 (error at encode_input:211) else goto L181
L181:
    __mypyc_self__.exc_str = r246; r247 = is_error
    if not r247 goto L204 (error at encode_input:211) else goto L182 :: bool
L182:
    r248 = __mypyc_self__.data
    if is_error(r248) goto L204 (error at encode_input:212) else goto L183
L183:
    r249 = PyObject_Type(r248)
    dec_ref r248
    r250 = "Contract('"
    r251 = __mypyc_self__.call
    if is_error(r251) goto L263 (error at encode_input:212) else goto L184
L184:
    r252 = '_address'
    r253 = CPyObject_GetAttr(r251, r252)
    dec_ref r251
    if is_error(r253) goto L263 (error at encode_input:212) else goto L185
L185:
    r254 = PyObject_Str(r253)
    dec_ref r253
    if is_error(r254) goto L263 (error at encode_input:212) else goto L186
L186:
    r255 = "')."
    r256 = __mypyc_self__.call
    if is_error(r256) goto L264 (error at encode_input:212) else goto L187
L187:
    r257 = '_name'
    r258 = CPyObject_GetAttr(r256, r257)
    dec_ref r256
    if is_error(r258) goto L264 (error at encode_input:212) else goto L188
L188:
    r259 = PyObject_Str(r258)
    dec_ref r258
    if is_error(r259) goto L264 (error at encode_input:212) else goto L189
L189:
    r260 = ': '
    r261 = __mypyc_self__.exc_str
    if is_error(r261) goto L265 (error at encode_input:212) else goto L190
L190:
    r262 = CPyStr_Build(6, r250, r254, r255, r259, r260, r261)
    dec_ref r254
    dec_ref r259
    dec_ref r261
    if is_error(r262) goto L263 (error at encode_input:212) else goto L191
L191:
    r263 = [r262]
    r264 = load_address r263
    r265 = PyObject_Vectorcall(r249, r264, 1, 0)
    dec_ref r249
    if is_error(r265) goto L266 (error at encode_input:212) else goto L192
L192:
    dec_ref r262
    CPy_Raise(r265)
    dec_ref r265
    if not 0 goto L204 (error at encode_input:212) else goto L193 :: bool
L193:
    unreachable
L194:
    r266 = __mypyc_self__.data
    if is_error(r266) goto L204 (error at encode_input:213) else goto L195
L195:
    __mypyc_self__.__mypyc_next_label__ = -1
L196:
    if is_error(stop_iter_ptr) goto L197 else goto L199
L197:
    CPyGen_SetStopIterationValue(r266)
    dec_ref r266
    if not 0 goto L204 else goto L198 :: bool
L198:
    unreachable
L199:
    set_mem stop_iter_ptr, r266 :: builtins.object*
    return 0
L200:
    r268 = r2 == 0
    if r268 goto L267 else goto L201 :: bool
L201:
    r269 = r2 == 1
    if r269 goto L54 else goto L268 :: bool
L202:
    r270 = raise StopIteration
    if not r270 goto L204 (error at encode_input:184) else goto L203 :: bool
L203:
    unreachable
L204:
    r271 = <error> :: object
    return r271
L205:
    dec_ref r14
    goto L204
L206:
    dec_ref r18
    goto L15
L207:
    dec_ref r32
    goto L204
L208:
    dec_ref r32
    dec_ref r35
    goto L204
L209:
    dec_ref r32
    dec_ref r35
    dec_ref r36
    goto L204
L210:
    dec_ref r32
    dec_ref r35
    dec_ref r36
    dec_ref r39
    goto L204
L211:
    dec_ref r39
    dec_ref r40
    goto L204
L212:
    dec_ref r44
    goto L34
L213:
    dec_ref r39
    goto L204
L214:
    dec_ref r39
    dec_ref r45
    goto L204
L215:
    dec_ref r49
    goto L75
L216:
    dec_ref r49
    dec_ref r50
    goto L75
L217:
    dec_ref r49
    dec_ref r50
    dec_ref r51
    goto L75
L218:
    dec_ref r51
    dec_ref r52
    goto L75
L219:
    dec_ref r55
    goto L43
L220:
    dec_ref r51
    goto L75
L221:
    dec_ref r51
    dec_ref r56
    goto L75
L222:
    dec_ref r64
    goto L75
L223:
    xdec_ref r1
    goto L57
L224:
    xdec_ref r1
    goto L56
L225:
    xdec_ref r1
    goto L66
L226:
    dec_ref r67
    goto L66
L227:
    dec_ref r64
    goto L66
L228:
    dec_ref arg
    goto L75
L229:
    dec_ref r88
    goto L151
L230:
    dec_ref r97
    goto L151
L231:
    dec_ref r97
    dec_ref r100
    goto L151
L232:
    dec_ref r97
    dec_ref r100
    dec_ref r101
    goto L151
L233:
    dec_ref r97
    dec_ref r100
    dec_ref r101
    dec_ref r104
    goto L151
L234:
    dec_ref r104
    dec_ref r105
    goto L151
L235:
    dec_ref r109
    goto L87
L236:
    dec_ref r104
    goto L151
L237:
    dec_ref r104
    dec_ref r110
    goto L151
L238:
    dec_ref r125
    goto L151
L239:
    dec_ref r125
    dec_ref r126
    goto L151
L240:
    dec_ref r125
    dec_ref r126
    dec_ref r129
    goto L151
L241:
    dec_ref r133
    goto L102
L242:
    dec_ref r140
    goto L151
L243:
    dec_ref r146
    goto L151
L244:
    dec_ref r157
    goto L151
L245:
    dec_ref r157
    dec_ref r160
    goto L151
L246:
    dec_ref r157
    dec_ref r160
    dec_ref r161
    goto L151
L247:
    dec_ref r157
    dec_ref r160
    dec_ref r161
    dec_ref r164
    goto L151
L248:
    dec_ref r164
    dec_ref r165
    goto L151
L249:
    dec_ref r169
    goto L119
L250:
    dec_ref r164
    goto L151
L251:
    dec_ref r164
    dec_ref r170
    goto L151
L252:
    dec_ref r186
    goto L151
L253:
    dec_ref r186
    dec_ref r189
    goto L151
L254:
    dec_ref r186
    dec_ref r189
    dec_ref r190
    goto L151
L255:
    dec_ref r186
    dec_ref r189
    dec_ref r190
    dec_ref r193
    goto L151
L256:
    dec_ref r193
    dec_ref r194
    goto L151
L257:
    dec_ref r198
    goto L139
L258:
    dec_ref r193
    goto L151
L259:
    dec_ref r193
    dec_ref r199
    goto L151
L260:
    dec_ref r210
    goto L204
L261:
    dec_ref r229
    goto L204
L262:
    dec_ref r229
    dec_ref r232
    goto L204
L263:
    dec_ref r249
    goto L204
L264:
    dec_ref r249
    dec_ref r254
    goto L204
L265:
    dec_ref r249
    dec_ref r254
    dec_ref r259
    goto L204
L266:
    dec_ref r262
    goto L204
L267:
    xdec_ref r1
    goto L1
L268:
    xdec_ref r1
    goto L202

def encode_input_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def encode_input_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def encode_input_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def encode_input_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def encode_input_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def encode_input_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def encode_input(call, len_inputs, get_request_data, args):
    call :: object
    len_inputs :: int
    get_request_data :: object
    args :: tuple
    r0 :: dank_mids.brownie_patch.call.encode_input_gen
    r1, r2, r3, r4, r5 :: bool
    r6 :: dank_mids.brownie_patch.call.encode_input_gen
L0:
    r0 = encode_input_gen()
    if is_error(r0) goto L6 (error at encode_input:184) else goto L1
L1:
    r0.__mypyc_next_label__ = 0
    inc_ref call
    r0.call = call; r2 = is_error
    if not r2 goto L7 (error at encode_input:184) else goto L2 :: bool
L2:
    inc_ref len_inputs :: int
    r0.len_inputs = len_inputs; r3 = is_error
    if not r3 goto L7 (error at encode_input:184) else goto L3 :: bool
L3:
    inc_ref get_request_data
    r0.get_request_data = get_request_data; r4 = is_error
    if not r4 goto L7 (error at encode_input:184) else goto L4 :: bool
L4:
    inc_ref args
    r0.args = args; r5 = is_error
    if not r5 goto L7 (error at encode_input:184) else goto L5 :: bool
L5:
    return r0
L6:
    r6 = <error> :: dank_mids.brownie_patch.call.encode_input_gen
    return r6
L7:
    dec_ref r0
    goto L6

def decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1, r2, r3, r4, r5 :: object
    r6 :: i32
    r7 :: object
    r8 :: bit
    r9 :: object
    r10 :: str
    r11 :: object
    r12 :: bytes
    r13 :: dict
    r14 :: None
    r15 :: object
    r16 :: str
    r17 :: object
    r18 :: i32
    r19 :: bit
    r20 :: bool
    r21, r22 :: bytes
    r23 :: i32
    r24 :: bit
    r25 :: bool
    r26 :: bytes
    r27 :: object
    r28 :: str
    r29 :: object
    r30 :: dict
    r31 :: object
    r32 :: bool
    r33 :: object
    r34 :: bytes
    r35 :: object
    r36 :: bool
    r37 :: object[2]
    r38 :: object_ptr
    r39, r40 :: object
    r41 :: bool
    r42, r43, r44, r45, r46 :: object
    r47 :: bool
    r48 :: object
    r49 :: bool
    r50 :: object
    r51 :: bit
    r52 :: tuple[object, object, object]
    r53 :: bool
    r54 :: object_ptr
    r55 :: object
    r56 :: bool
    r57, r58, r59 :: tuple[object, object, object]
    r60 :: bit
    r61, r62, r63 :: object
    r64 :: bool
    r65 :: tuple[object, object, object]
    r66 :: bool
    r67 :: dict
    r68 :: str
    r69 :: object
    r70 :: bit
    r71 :: object
    r72 :: bool
    r73 :: str
    r74 :: dict
    r75 :: str
    r76 :: object
    r77 :: str
    r78 :: object
    r79 :: bytes
    r80 :: object
    r81 :: str
    r82 :: object
    r83 :: str
    r84 :: object[5]
    r85 :: object_ptr
    r86 :: object
    r87 :: dict
    r88 :: str
    r89 :: object
    r90 :: str
    r91 :: object
    r92 :: str
    r93 :: object
    r94 :: dict
    r95 :: str
    r96 :: object
    r97 :: object[1]
    r98 :: object_ptr
    r99 :: object
    r100 :: dict
    r101 :: str
    r102 :: object
    r103 :: str
    r104 :: i32
    r105 :: bit
    r106 :: bytes
    r107 :: object
    r108 :: str
    r109 :: object
    r110 :: dict
    r111 :: object
    r112 :: bool
    r113, r114 :: tuple[object, object, object]
    r115 :: bit
    r116, r117 :: object
    r118 :: str
    r119 :: object
    r120 :: i32
    r121 :: bit
    r122 :: bool
    r123, r124 :: object
    r125 :: bool
    r126 :: tuple[object, object, object]
    r127 :: bool
    r128 :: dict
    r129 :: str
    r130 :: object
    r131 :: bit
    r132 :: object
    r133 :: bool
    r134 :: object
    r135 :: str
    r136, r137, r138 :: object
    r139 :: str
    r140 :: object
    r141 :: bytes
    r142 :: list
    r143 :: object
    r144 :: i32
    r145 :: bit
    r146 :: i32
    r147 :: bit
    r148 :: i32
    r149 :: bit
    r150 :: tuple
    r151 :: object
    r152 :: str
    r153 :: i32
    r154 :: bit
    r155 :: object
    r156 :: str
    r157 :: object
    r158 :: bit
    r159 :: object
    r160 :: bool
    r161 :: object
    r162, r163 :: str
    r164 :: i32
    r165 :: bool
    r166 :: object
    r167 :: bool
    r168 :: str
    r169 :: object
    r170 :: str
    r171 :: object[3]
    r172 :: object_ptr
    r173, r174 :: object
    r175 :: str
    r176 :: object
    r177 :: dict
    r178 :: str
    r179 :: object
    r180 :: set
    r181 :: i32
    r182 :: bit
    r183 :: bool
    r184 :: object
    r185 :: str
    r186 :: object
    r187 :: i32
    r188 :: bit
    r189 :: object
    r190 :: bytes
    r191 :: dank_mids.brownie_patch.call.decode_output_gen
    r192 :: bool
    r193 :: dank_mids.brownie_patch.call.decode_output_gen
    r194, r195 :: object
    r196 :: object_ptr
    r197 :: object
    r198 :: bit
    r199 :: object
    r200 :: dank_mids.brownie_patch.call.decode_output_gen
    r201 :: bool
    r202 :: object
    r203 :: bool
    r204 :: object
    r205 :: bit
    r206 :: tuple[object, object, object]
    r207 :: bool
    r208 :: object_ptr
    r209 :: dank_mids.brownie_patch.call.decode_output_gen
    r210 :: bool
    r211, r212, r213 :: tuple[object, object, object]
    r214 :: bit
    r215 :: dank_mids.brownie_patch.call.decode_output_gen
    r216, r217 :: object
    r218 :: tuple[object, object, object]
    r219 :: bool
    r220 :: tuple[object, object, object]
    r221, r222, r223, r224 :: bit
    r225 :: bool
    r226 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    xdec_ref r3
    r4 = <error> :: object
    r5 = r4
    r6 = __mypyc_self__.__mypyc_next_label__
    goto L183
L1:
    r7 = load_address _Py_NoneStruct
    r8 = type != r7
    if r8 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L188 (error at decode_output:216) else goto L3 :: bool
L3:
    unreachable
L4:
    r9 = __mypyc_self__.call
    if is_error(r9) goto L188 (error at decode_output:217) else goto L5
L5:
    r10 = 'abi'
    r11 = CPyObject_GetAttr(r9, r10)
    dec_ref r9
    if is_error(r11) goto L188 (error at decode_output:217) else goto L6
L6:
    r12 = __mypyc_self__.data
    if is_error(r12) goto L189 (error at decode_output:217) else goto L7
L7:
    r13 = cast(dict, r11)
    if is_error(r13) goto L190 (error at decode_output:217) else goto L8
L8:
    r14 = __validate_output(r13, r12)
    dec_ref r13
    dec_ref r12
    if is_error(r14) goto L188 (error at decode_output:217) else goto L9
L9:
    r15 = __mypyc_self__.call
    if is_error(r15) goto L102 (error at decode_output:219) else goto L10
L10:
    r16 = '_skip_decoder_proc_pool'
    r17 = CPyObject_GetAttr(r15, r16)
    dec_ref r15
    if is_error(r17) goto L102 (error at decode_output:219) else goto L11
L11:
    r18 = PyObject_IsTrue(r17)
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L102 (error at decode_output:219) else goto L12 :: bool
L12:
    r20 = truncate r18: i32 to builtins.bool
    if r20 goto L16 else goto L13 :: bool
L13:
    r21 = b'Unexpected error'
    r22 = __mypyc_self__.data
    if is_error(r22) goto L102 (error at decode_output:219) else goto L14
L14:
    r23 = PySequence_Contains(r22, r21)
    dec_ref r22
    r24 = r23 >= 0 :: signed
    if not r24 goto L102 (error at decode_output:219) else goto L15 :: bool
L15:
    r25 = truncate r23: i32 to builtins.bool
    if r25 goto L16 else goto L22 :: bool
L16:
    r26 = __mypyc_self__.data
    if is_error(r26) goto L102 (error at decode_output:221) else goto L17
L17:
    r27 = __mypyc_self__.call
    if is_error(r27) goto L191 (error at decode_output:221) else goto L18
L18:
    r28 = 'abi'
    r29 = CPyObject_GetAttr(r27, r28)
    dec_ref r27
    if is_error(r29) goto L191 (error at decode_output:221) else goto L19
L19:
    r30 = cast(dict, r29)
    if is_error(r30) goto L191 (error at decode_output:221) else goto L20
L20:
    r31 = __decode_output(r26, r30)
    dec_ref r26
    dec_ref r30
    if is_error(r31) goto L102 (error at decode_output:221) else goto L21
L21:
    __mypyc_self__.decoded = r31; r32 = is_error
    if not r32 goto L102 (error at decode_output:221) else goto L89 :: bool
L22:
    r33 = __mypyc_self__.call
    if is_error(r33) goto L57 (error at decode_output:224) else goto L23
L23:
    r34 = __mypyc_self__.data
    if is_error(r34) goto L192 (error at decode_output:224) else goto L24
L24:
    r35 = dank_mids.brownie_patch.call.decode :: static
    if is_error(r35) goto L193 else goto L27
L25:
    r36 = raise NameError('value for final name "decode" was not set')
    if not r36 goto L57 (error at decode_output:224) else goto L26 :: bool
L26:
    unreachable
L27:
    r37 = [r33, r34]
    r38 = load_address r37
    r39 = PyObject_Vectorcall(r35, r38, 2, 0)
    if is_error(r39) goto L194 (error at decode_output:224) else goto L28
L28:
    dec_ref r33
    dec_ref r34
    r40 = CPy_GetCoro(r39)
    dec_ref r39
    if is_error(r40) goto L57 (error at decode_output:224) else goto L29
L29:
    __mypyc_self__.__mypyc_temp__32 = r40; r41 = is_error
    if not r41 goto L57 (error at decode_output:-1) else goto L30 :: bool
L30:
    r42 = __mypyc_self__.__mypyc_temp__32
    if is_error(r42) goto L57 (error at decode_output:-1) else goto L31
L31:
    r43 = CPyIter_Next(r42)
    dec_ref r42
    if is_error(r43) goto L32 else goto L34
L32:
    r44 = CPy_FetchStopIterationValue()
    if is_error(r44) goto L57 (error at decode_output:224) else goto L33
L33:
    r45 = r44
    r46 = <error> :: object
    __mypyc_self__.__mypyc_temp__32 = r46; r47 = is_error
    if not r47 goto L195 (error at decode_output:224) else goto L56 :: bool
L34:
    r48 = r43
L35:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r48
L36:
    r50 = load_address _Py_NoneStruct
    r51 = type != r50
    if r51 goto L37 else goto L196 :: bool
L37:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L40 (error at decode_output:224) else goto L197 :: bool
L38:
    unreachable
L39:
    inc_ref arg
    goto L51
L40:
    r52 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__33 = r52; r53 = is_error
    if not r53 goto L198 (error at decode_output:-1) else goto L41 :: bool
L41:
    r54 = load_address r1
    r55 = __mypyc_self__.__mypyc_temp__32
    if is_error(r55) goto L198 (error at decode_output:-1) else goto L42
L42:
    r56 = CPy_YieldFromErrorHandle(r55, r54)
    dec_ref r55
    if is_error(r56) goto L198 (error at decode_output:224) else goto L43
L43:
    if r56 goto L46 else goto L44 :: bool
L44:
    r48 = r1
    r57 = __mypyc_self__.__mypyc_temp__33
    if is_error(r57) goto L199 (error at decode_output:-1) else goto L45
L45:
    CPy_RestoreExcInfo(r57)
    dec_ref r57
    goto L35
L46:
    r45 = r1
    r58 = __mypyc_self__.__mypyc_temp__33
    if is_error(r58) goto L200 (error at decode_output:-1) else goto L47
L47:
    CPy_RestoreExcInfo(r58)
    dec_ref r58
    goto L56
L48:
    r59 = __mypyc_self__.__mypyc_temp__33
    if is_error(r59) goto L57 (error at decode_output:-1) else goto L49
L49:
    CPy_RestoreExcInfo(r59)
    dec_ref r59
    r60 = CPy_KeepPropagating()
    if not r60 goto L57 else goto L50 :: bool
L50:
    unreachable
L51:
    r61 = __mypyc_self__.__mypyc_temp__32
    if is_error(r61) goto L201 (error at decode_output:-1) else goto L52
L52:
    r62 = CPyIter_Send(r61, arg)
    dec_ref r61
    dec_ref arg
    if is_error(r62) goto L54 else goto L53
L53:
    r48 = r62
    goto L35
L54:
    r63 = CPy_FetchStopIterationValue()
    if is_error(r63) goto L57 (error at decode_output:224) else goto L55
L55:
    r45 = r63
L56:
    __mypyc_self__.decoded = r45; r64 = is_error
    if not r64 goto L57 (error at decode_output:224) else goto L89 :: bool
L57:
    r65 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__34 = r65; r66 = is_error
    if not r66 goto L86 (error at decode_output:-1) else goto L58 :: bool
L58:
    r67 = dank_mids.brownie_patch.call.globals :: static
    r68 = 'BrokenProcessPool'
    r69 = CPyDict_GetItem(r67, r68)
    if is_error(r69) goto L86 (error at decode_output:226) else goto L59
L59:
    r70 = CPy_ExceptionMatches(r69)
    dec_ref r69
    if r70 goto L60 else goto L82 :: bool
L60:
    r71 = dank_mids.brownie_patch.call.logger :: static
    if is_error(r71) goto L61 else goto L63
L61:
    r72 = raise NameError('value for final name "logger" was not set')
    if not r72 goto L86 (error at decode_output:228) else goto L62 :: bool
L62:
    unreachable
L63:
    r73 = 'Oh fuck, you broke the %s while decoding %s with abi %s'
    r74 = dank_mids.brownie_patch.call.globals :: static
    r75 = 'ENVS'
    r76 = CPyDict_GetItem(r74, r75)
    if is_error(r76) goto L86 (error at decode_output:228) else goto L64
L64:
    r77 = 'BROWNIE_DECODER_PROCESSES'
    r78 = CPyObject_GetAttr(r76, r77)
    dec_ref r76
    if is_error(r78) goto L86 (error at decode_output:228) else goto L65
L65:
    r79 = __mypyc_self__.data
    if is_error(r79) goto L202 (error at decode_output:228) else goto L66
L66:
    r80 = __mypyc_self__.call
    if is_error(r80) goto L203 (error at decode_output:228) else goto L67
L67:
    r81 = 'abi'
    r82 = CPyObject_GetAttr(r80, r81)
    dec_ref r80
    if is_error(r82) goto L203 (error at decode_output:228) else goto L68
L68:
    r83 = 'critical'
    r84 = [r71, r73, r78, r79, r82]
    r85 = load_address r84
    r86 = PyObject_VectorcallMethod(r83, r85, 9223372036854775813, 0)
    if is_error(r86) goto L204 (error at decode_output:228) else goto L205
L69:
    dec_ref r78
    dec_ref r79
    dec_ref r82
    r87 = dank_mids.brownie_patch.call.globals :: static
    r88 = 'ENVS'
    r89 = CPyDict_GetItem(r87, r88)
    if is_error(r89) goto L86 (error at decode_output:229) else goto L70
L70:
    r90 = 'BROWNIE_DECODER_PROCESSES'
    r91 = CPyObject_GetAttr(r89, r90)
    dec_ref r89
    if is_error(r91) goto L86 (error at decode_output:229) else goto L71
L71:
    r92 = '_max_workers'
    r93 = CPyObject_GetAttr(r91, r92)
    dec_ref r91
    if is_error(r93) goto L86 (error at decode_output:229) else goto L72
L72:
    r94 = dank_mids.brownie_patch.call.globals :: static
    r95 = 'AsyncProcessPoolExecutor'
    r96 = CPyDict_GetItem(r94, r95)
    if is_error(r96) goto L206 (error at decode_output:229) else goto L73
L73:
    r97 = [r93]
    r98 = load_address r97
    r99 = PyObject_Vectorcall(r96, r98, 1, 0)
    dec_ref r96
    if is_error(r99) goto L206 (error at decode_output:229) else goto L74
L74:
    dec_ref r93
    r100 = dank_mids.brownie_patch.call.globals :: static
    r101 = 'ENVS'
    r102 = CPyDict_GetItem(r100, r101)
    if is_error(r102) goto L207 (error at decode_output:229) else goto L75
L75:
    r103 = 'BROWNIE_DECODER_PROCESSES'
    r104 = PyObject_SetAttr(r102, r103, r99)
    dec_ref r102
    dec_ref r99
    r105 = r104 >= 0 :: signed
    if not r105 goto L86 (error at decode_output:229) else goto L76 :: bool
L76:
    r106 = __mypyc_self__.data
    if is_error(r106) goto L86 (error at decode_output:230) else goto L77
L77:
    r107 = __mypyc_self__.call
    if is_error(r107) goto L208 (error at decode_output:230) else goto L78
L78:
    r108 = 'abi'
    r109 = CPyObject_GetAttr(r107, r108)
    dec_ref r107
    if is_error(r109) goto L208 (error at decode_output:230) else goto L79
L79:
    r110 = cast(dict, r109)
    if is_error(r110) goto L208 (error at decode_output:230) else goto L80
L80:
    r111 = __decode_output(r106, r110)
    dec_ref r106
    dec_ref r110
    if is_error(r111) goto L86 (error at decode_output:230) else goto L81
L81:
    __mypyc_self__.decoded = r111; r112 = is_error
    if not r112 goto L86 (error at decode_output:230) else goto L84 :: bool
L82:
    CPy_Reraise()
    if not 0 goto L86 else goto L83 :: bool
L83:
    unreachable
L84:
    r113 = __mypyc_self__.__mypyc_temp__34
    if is_error(r113) goto L102 (error at decode_output:-1) else goto L85
L85:
    CPy_RestoreExcInfo(r113)
    dec_ref r113
    goto L89
L86:
    r114 = __mypyc_self__.__mypyc_temp__34
    if is_error(r114) goto L102 (error at decode_output:-1) else goto L87
L87:
    CPy_RestoreExcInfo(r114)
    dec_ref r114
    r115 = CPy_KeepPropagating()
    if not r115 goto L102 else goto L88 :: bool
L88:
    unreachable
L89:
    r116 = __mypyc_self__.decoded
    if is_error(r116) goto L102 (error at decode_output:232) else goto L90
L90:
    r117 = builtins :: module
    r118 = 'Exception'
    r119 = CPyObject_GetAttr(r117, r118)
    if is_error(r119) goto L209 (error at decode_output:232) else goto L91
L91:
    r120 = PyObject_IsInstance(r116, r119)
    dec_ref r116
    dec_ref r119
    r121 = r120 >= 0 :: signed
    if not r121 goto L102 (error at decode_output:232) else goto L92 :: bool
L92:
    r122 = truncate r120: i32 to builtins.bool
    if r122 goto L93 else goto L96 :: bool
L93:
    r123 = __mypyc_self__.decoded
    if is_error(r123) goto L102 (error at decode_output:233) else goto L94
L94:
    CPy_Raise(r123)
    dec_ref r123
    if not 0 goto L102 (error at decode_output:233) else goto L95 :: bool
L95:
    unreachable
L96:
    r124 = __mypyc_self__.decoded
    if is_error(r124) goto L102 (error at decode_output:234) else goto L97
L97:
    __mypyc_self__.__mypyc_next_label__ = -1
L98:
    if is_error(stop_iter_ptr) goto L99 else goto L101
L99:
    CPyGen_SetStopIterationValue(r124)
    dec_ref r124
    if not 0 goto L188 else goto L100 :: bool
L100:
    unreachable
L101:
    set_mem stop_iter_ptr, r124 :: builtins.object*
    return 0
L102:
    r126 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__35 = r126; r127 = is_error
    if not r127 goto L180 (error at decode_output:-1) else goto L103 :: bool
L103:
    r128 = dank_mids.brownie_patch.call.globals :: static
    r129 = 'InsufficientDataBytes'
    r130 = CPyDict_GetItem(r128, r129)
    if is_error(r130) goto L180 (error at decode_output:235) else goto L104
L104:
    r131 = CPy_ExceptionMatches(r130)
    dec_ref r130
    if r131 goto L105 else goto L122 :: bool
L105:
    r132 = CPy_GetExcValue()
    __mypyc_self__.e = r132; r133 = is_error
    if not r133 goto L180 (error at decode_output:235) else goto L106 :: bool
L106:
    r134 = __mypyc_self__.e
    if is_error(r134) goto L180 (error at decode_output:237) else goto L107
L107:
    r135 = 'args'
    r136 = CPyObject_GetAttr(r134, r135)
    dec_ref r134
    if is_error(r136) goto L180 (error at decode_output:237) else goto L108
L108:
    r137 = __mypyc_self__.call
    if is_error(r137) goto L210 (error at decode_output:237) else goto L109
L109:
    r138 = __mypyc_self__.call
    if is_error(r138) goto L211 (error at decode_output:237) else goto L110
L110:
    r139 = '_address'
    r140 = CPyObject_GetAttr(r138, r139)
    dec_ref r138
    if is_error(r140) goto L211 (error at decode_output:237) else goto L111
L111:
    r141 = __mypyc_self__.data
    if is_error(r141) goto L212 (error at decode_output:237) else goto L112
L112:
    r142 = PyList_New(0)
    if is_error(r142) goto L213 (error at decode_output:237) else goto L113
L113:
    r143 = CPyList_Extend(r142, r136)
    dec_ref r136
    if is_error(r143) goto L214 (error at decode_output:237) else goto L215
L114:
    r144 = PyList_Append(r142, r137)
    dec_ref r137
    r145 = r144 >= 0 :: signed
    if not r145 goto L216 (error at decode_output:237) else goto L115 :: bool
L115:
    r146 = PyList_Append(r142, r140)
    dec_ref r140
    r147 = r146 >= 0 :: signed
    if not r147 goto L217 (error at decode_output:237) else goto L116 :: bool
L116:
    r148 = PyList_Append(r142, r141)
    dec_ref r141
    r149 = r148 >= 0 :: signed
    if not r149 goto L218 (error at decode_output:237) else goto L117 :: bool
L117:
    r150 = PyList_AsTuple(r142)
    dec_ref r142
    if is_error(r150) goto L180 (error at decode_output:237) else goto L118
L118:
    r151 = __mypyc_self__.e
    if is_error(r151) goto L219 (error at decode_output:237) else goto L119
L119:
    r152 = 'args'
    r153 = PyObject_SetAttr(r151, r152, r150)
    dec_ref r151
    dec_ref r150
    r154 = r153 >= 0 :: signed
    if not r154 goto L180 (error at decode_output:237) else goto L120 :: bool
L120:
    CPy_Reraise()
    if not 0 goto L180 else goto L121 :: bool
L121:
    unreachable
L122:
    r155 = builtins :: module
    r156 = 'AttributeError'
    r157 = CPyObject_GetAttr(r155, r156)
    if is_error(r157) goto L180 (error at decode_output:239) else goto L123
L123:
    r158 = CPy_ExceptionMatches(r157)
    dec_ref r157
    if r158 goto L124 else goto L178 :: bool
L124:
    r159 = CPy_GetExcValue()
    __mypyc_self__.e = r159; r160 = is_error
    if not r160 goto L180 (error at decode_output:239) else goto L125 :: bool
L125:
    r161 = __mypyc_self__.e
    if is_error(r161) goto L180 (error at decode_output:241) else goto L126
L126:
    r162 = PyObject_Str(r161)
    dec_ref r161
    if is_error(r162) goto L180 (error at decode_output:241) else goto L127
L127:
    r163 = " object has no attribute '_skip_decoder_proc_pool'"
    r164 = CPyStr_Endswith(r162, r163)
    dec_ref r162
    r165 = truncate r164: i32 to builtins.bool
    if r165 goto L130 else goto L128 :: bool
L128:
    CPy_Reraise()
    if not 0 goto L180 else goto L129 :: bool
L129:
    unreachable
L130:
    r166 = dank_mids.brownie_patch.call.logger :: static
    if is_error(r166) goto L131 else goto L133
L131:
    r167 = raise NameError('value for final name "logger" was not set')
    if not r167 goto L180 (error at decode_output:243) else goto L132 :: bool
L132:
    unreachable
L133:
    r168 = 'DEBUG ME BRO: %s'
    r169 = __mypyc_self__.e
    if is_error(r169) goto L180 (error at decode_output:243) else goto L134
L134:
    r170 = 'debug'
    r171 = [r166, r168, r169]
    r172 = load_address r171
    r173 = PyObject_VectorcallMethod(r170, r172, 9223372036854775811, 0)
    if is_error(r173) goto L220 (error at decode_output:243) else goto L221
L135:
    dec_ref r169
    r174 = __mypyc_self__.call
    if is_error(r174) goto L180 (error at decode_output:244) else goto L136
L136:
    r175 = '_address'
    r176 = CPyObject_GetAttr(r174, r175)
    dec_ref r174
    if is_error(r176) goto L180 (error at decode_output:244) else goto L137
L137:
    r177 = dank_mids.brownie_patch.call.globals :: static
    r178 = '_skip_proc_pool'
    r179 = CPyDict_GetItem(r177, r178)
    if is_error(r179) goto L222 (error at decode_output:244) else goto L138
L138:
    r180 = cast(set, r179)
    if is_error(r180) goto L222 (error at decode_output:244) else goto L139
L139:
    r181 = PySet_Contains(r180, r176)
    dec_ref r180
    dec_ref r176
    r182 = r181 >= 0 :: signed
    if not r182 goto L180 (error at decode_output:244) else goto L140 :: bool
L140:
    r183 = truncate r181: i32 to builtins.bool
    r184 = __mypyc_self__.call
    if is_error(r184) goto L180 (error at decode_output:244) else goto L141
L141:
    r185 = '_skip_decoder_proc_pool'
    r186 = box(bool, r183)
    r187 = PyObject_SetAttr(r184, r185, r186)
    dec_ref r184
    r188 = r187 >= 0 :: signed
    if not r188 goto L180 (error at decode_output:244) else goto L142 :: bool
L142:
    r189 = __mypyc_self__.call
    if is_error(r189) goto L180 (error at decode_output:245) else goto L143
L143:
    r190 = __mypyc_self__.data
    if is_error(r190) goto L223 (error at decode_output:245) else goto L144
L144:
    r191 = decode_output(r189, r190)
    dec_ref r189
    dec_ref r190
    if is_error(r191) goto L180 (error at decode_output:245) else goto L145
L145:
    __mypyc_self__.__mypyc_temp__36 = r191; r192 = is_error
    if not r192 goto L180 (error at decode_output:-1) else goto L146 :: bool
L146:
    r193 = __mypyc_self__.__mypyc_temp__36
    if is_error(r193) goto L180 (error at decode_output:-1) else goto L147
L147:
    r194 = load_address _Py_NoneStruct
    r195 = <error> :: object
    r3 = r195
    r196 = load_address r3
    r197 = r193.__mypyc_generator_helper__(r194, r194, r194, r194, r196)
    dec_ref r193
    if is_error(r197) goto L148 else goto L224
L148:
    r198 = r3 != 0
    if not r198 goto L225 (error at decode_output:-1) else goto L149 :: bool
L149:
    r199 = r3
    r200 = <error> :: dank_mids.brownie_patch.call.decode_output_gen
    __mypyc_self__.__mypyc_temp__36 = r200; r201 = is_error
    if not r201 goto L226 (error at decode_output:245) else goto L172 :: bool
L150:
    r202 = r197
L151:
    __mypyc_self__.__mypyc_next_label__ = 2
    return r202
L152:
    r204 = load_address _Py_NoneStruct
    r205 = type != r204
    if r205 goto L153 else goto L227 :: bool
L153:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L156 (error at decode_output:245) else goto L228 :: bool
L154:
    unreachable
L155:
    inc_ref arg
    goto L167
L156:
    r206 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__37 = r206; r207 = is_error
    if not r207 goto L229 (error at decode_output:-1) else goto L157 :: bool
L157:
    r208 = load_address r5
    r209 = __mypyc_self__.__mypyc_temp__36
    if is_error(r209) goto L229 (error at decode_output:-1) else goto L158
L158:
    r210 = CPy_YieldFromErrorHandle(r209, r208)
    dec_ref r209
    if is_error(r210) goto L229 (error at decode_output:245) else goto L159
L159:
    if r210 goto L162 else goto L160 :: bool
L160:
    r202 = r5
    r211 = __mypyc_self__.__mypyc_temp__37
    if is_error(r211) goto L230 (error at decode_output:-1) else goto L161
L161:
    CPy_RestoreExcInfo(r211)
    dec_ref r211
    goto L151
L162:
    r199 = r5
    r212 = __mypyc_self__.__mypyc_temp__37
    if is_error(r212) goto L231 (error at decode_output:-1) else goto L163
L163:
    CPy_RestoreExcInfo(r212)
    dec_ref r212
    goto L172
L164:
    r213 = __mypyc_self__.__mypyc_temp__37
    if is_error(r213) goto L180 (error at decode_output:-1) else goto L165
L165:
    CPy_RestoreExcInfo(r213)
    dec_ref r213
    r214 = CPy_KeepPropagating()
    if not r214 goto L180 else goto L166 :: bool
L166:
    unreachable
L167:
    r215 = __mypyc_self__.__mypyc_temp__36
    if is_error(r215) goto L232 (error at decode_output:-1) else goto L168
L168:
    r216 = CPyIter_Send(r215, arg)
    dec_ref r215
    dec_ref arg
    if is_error(r216) goto L170 else goto L169
L169:
    r202 = r216
    goto L151
L170:
    r217 = CPy_FetchStopIterationValue()
    if is_error(r217) goto L180 (error at decode_output:245) else goto L171
L171:
    r199 = r217
L172:
    r218 = __mypyc_self__.__mypyc_temp__35
    if is_error(r218) goto L226 (error at decode_output:-1) else goto L173
L173:
    CPy_RestoreExcInfo(r218)
    dec_ref r218
    __mypyc_self__.__mypyc_next_label__ = -1
L174:
    if is_error(stop_iter_ptr) goto L175 else goto L177
L175:
    CPyGen_SetStopIterationValue(r199)
    dec_ref r199
    if not 0 goto L188 else goto L176 :: bool
L176:
    unreachable
L177:
    set_mem stop_iter_ptr, r199 :: builtins.object*
    return 0
L178:
    CPy_Reraise()
    if not 0 goto L180 else goto L179 :: bool
L179:
    unreachable
L180:
    r220 = __mypyc_self__.__mypyc_temp__35
    if is_error(r220) goto L188 (error at decode_output:-1) else goto L181
L181:
    CPy_RestoreExcInfo(r220)
    dec_ref r220
    r221 = CPy_KeepPropagating()
    if not r221 goto L188 else goto L182 :: bool
L182:
    unreachable
L183:
    r222 = r6 == 0
    if r222 goto L233 else goto L184 :: bool
L184:
    r223 = r6 == 1
    if r223 goto L234 else goto L235 :: bool
L185:
    r224 = r6 == 2
    if r224 goto L152 else goto L236 :: bool
L186:
    r225 = raise StopIteration
    if not r225 goto L188 (error at decode_output:216) else goto L187 :: bool
L187:
    unreachable
L188:
    r226 = <error> :: object
    return r226
L189:
    dec_ref r11
    goto L188
L190:
    dec_ref r12
    goto L188
L191:
    dec_ref r26
    goto L102
L192:
    dec_ref r33
    goto L57
L193:
    dec_ref r33
    dec_ref r34
    goto L25
L194:
    dec_ref r33
    dec_ref r34
    goto L57
L195:
    dec_ref r45
    goto L57
L196:
    xdec_ref r1
    goto L39
L197:
    xdec_ref r1
    goto L38
L198:
    xdec_ref r1
    goto L48
L199:
    dec_ref r48
    goto L48
L200:
    dec_ref r45
    goto L48
L201:
    dec_ref arg
    goto L57
L202:
    dec_ref r78
    goto L86
L203:
    dec_ref r78
    dec_ref r79
    goto L86
L204:
    dec_ref r78
    dec_ref r79
    dec_ref r82
    goto L86
L205:
    dec_ref r86
    goto L69
L206:
    dec_ref r93
    goto L86
L207:
    dec_ref r99
    goto L86
L208:
    dec_ref r106
    goto L86
L209:
    dec_ref r116
    goto L102
L210:
    dec_ref r136
    goto L180
L211:
    dec_ref r136
    dec_ref r137
    goto L180
L212:
    dec_ref r136
    dec_ref r137
    dec_ref r140
    goto L180
L213:
    dec_ref r136
    dec_ref r137
    dec_ref r140
    dec_ref r141
    goto L180
L214:
    dec_ref r137
    dec_ref r140
    dec_ref r141
    dec_ref r142
    goto L180
L215:
    dec_ref r143
    goto L114
L216:
    dec_ref r140
    dec_ref r141
    dec_ref r142
    goto L180
L217:
    dec_ref r141
    dec_ref r142
    goto L180
L218:
    dec_ref r142
    goto L180
L219:
    dec_ref r150
    goto L180
L220:
    dec_ref r169
    goto L180
L221:
    dec_ref r173
    goto L135
L222:
    dec_ref r176
    goto L180
L223:
    dec_ref r189
    goto L180
L224:
    xdec_ref r3
    goto L150
L225:
    xdec_ref r3
    goto L180
L226:
    dec_ref r199
    goto L180
L227:
    xdec_ref r5
    goto L155
L228:
    xdec_ref r5
    goto L154
L229:
    xdec_ref r5
    goto L164
L230:
    dec_ref r202
    goto L164
L231:
    dec_ref r199
    goto L164
L232:
    dec_ref arg
    goto L180
L233:
    xdec_ref r1
    xdec_ref r5
    goto L1
L234:
    xdec_ref r5
    goto L36
L235:
    xdec_ref r1
    goto L185
L236:
    xdec_ref r5
    goto L186

def decode_output_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def decode_output_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def decode_output_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def decode_output_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def decode_output_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def decode_output_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def decode_output(call, data):
    call :: object
    data :: bytes
    r0 :: dank_mids.brownie_patch.call.decode_output_gen
    r1, r2, r3 :: bool
    r4 :: dank_mids.brownie_patch.call.decode_output_gen
L0:
    r0 = decode_output_gen()
    if is_error(r0) goto L4 (error at decode_output:216) else goto L1
L1:
    r0.__mypyc_next_label__ = 0
    inc_ref call
    r0.call = call; r2 = is_error
    if not r2 goto L5 (error at decode_output:216) else goto L2 :: bool
L2:
    inc_ref data
    r0.data = data; r3 = is_error
    if not r3 goto L5 (error at decode_output:216) else goto L3 :: bool
L3:
    return r0
L4:
    r4 = <error> :: dank_mids.brownie_patch.call.decode_output_gen
    return r4
L5:
    dec_ref r0
    goto L4

def _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0 :: i32
    r1 :: object
    r2 :: bit
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: bool
    r7 :: bit
    r8 :: bool
    r9 :: object
L0:
    r0 = __mypyc_self__.__mypyc_next_label__
    goto L11
L1:
    r1 = load_address _Py_NoneStruct
    r2 = type != r1
    if r2 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L14 (error at _request_data_no_args:248) else goto L3 :: bool
L3:
    unreachable
L4:
    r3 = __mypyc_self__.call
    if is_error(r3) goto L14 (error at _request_data_no_args:249) else goto L5
L5:
    r4 = 'signature'
    r5 = CPyObject_GetAttr(r3, r4)
    dec_ref r3
    if is_error(r5) goto L14 (error at _request_data_no_args:249) else goto L6
L6:
    __mypyc_self__.__mypyc_next_label__ = -1
L7:
    if is_error(stop_iter_ptr) goto L8 else goto L10
L8:
    CPyGen_SetStopIterationValue(r5)
    dec_ref r5
    if not 0 goto L14 else goto L9 :: bool
L9:
    unreachable
L10:
    set_mem stop_iter_ptr, r5 :: builtins.object*
    return 0
L11:
    r7 = r0 == 0
    if r7 goto L1 else goto L12 :: bool
L12:
    r8 = raise StopIteration
    if not r8 goto L14 (error at _request_data_no_args:248) else goto L13 :: bool
L13:
    unreachable
L14:
    r9 = <error> :: object
    return r9

def _request_data_no_args_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _request_data_no_args_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _request_data_no_args_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _request_data_no_args_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def _request_data_no_args_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def _request_data_no_args_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _request_data_no_args(call):
    call :: object
    r0 :: dank_mids.brownie_patch.call._request_data_no_args_gen
    r1, r2 :: bool
    r3 :: dank_mids.brownie_patch.call._request_data_no_args_gen
L0:
    r0 = _request_data_no_args_gen()
    if is_error(r0) goto L3 (error at _request_data_no_args:248) else goto L1
L1:
    r0.__mypyc_next_label__ = 0
    inc_ref call
    r0.call = call; r2 = is_error
    if not r2 goto L4 (error at _request_data_no_args:248) else goto L2 :: bool
L2:
    return r0
L3:
    r3 = <error> :: dank_mids.brownie_patch.call._request_data_no_args_gen
    return r3
L4:
    dec_ref r0
    goto L3

def __encode_input(abi, signature, args):
    abi :: dict
    signature :: str
    args :: tuple
    r0 :: list
    r1 :: str
    r2 :: object
    r3 :: dict
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8, r9 :: object
    r10 :: bool
    r11 :: object[2]
    r12 :: object_ptr
    r13 :: object
    r14 :: bytes
    r15 :: str
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19, r20 :: str
    r21 :: tuple[object, object, object]
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: bit
    r26 :: object
    r27 :: bit
    r28 :: object
L0:
L1:
    r0 = format_input_but_cache_checksums(abi, args)
    if is_error(r0) goto L14 (error at __encode_input:260) else goto L2
L2:
    r1 = 'inputs'
    r2 = CPyDict_GetItem(abi, r1)
    if is_error(r2) goto L22 (error at __encode_input:261) else goto L3
L3:
    r3 = dank_mids.brownie_patch.call.globals :: static
    r4 = 'get_type_strings'
    r5 = CPyDict_GetItem(r3, r4)
    if is_error(r5) goto L23 (error at __encode_input:261) else goto L4
L4:
    r6 = [r2]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r5, r7, 1, 0)
    dec_ref r5
    if is_error(r8) goto L23 (error at __encode_input:261) else goto L5
L5:
    dec_ref r2
    r9 = dank_mids.brownie_patch.call.__eth_abi_encode :: static
    if is_error(r9) goto L24 else goto L8
L6:
    r10 = raise NameError('value for final name "__eth_abi_encode" was not set')
    if not r10 goto L14 (error at __encode_input:262) else goto L7 :: bool
L7:
    unreachable
L8:
    r11 = [r8, r0]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r9, r12, 2, 0)
    if is_error(r13) goto L25 (error at __encode_input:262) else goto L9
L9:
    dec_ref r8
    dec_ref r0
    r14 = cast(bytes, r13)
    if is_error(r14) goto L14 (error at __encode_input:262) else goto L10
L10:
    r15 = 'hex'
    r16 = [r14]
    r17 = load_address r16
    r18 = PyObject_VectorcallMethod(r15, r17, 9223372036854775809, 0)
    if is_error(r18) goto L26 (error at __encode_input:262) else goto L11
L11:
    dec_ref r14
    r19 = cast(str, r18)
    if is_error(r19) goto L14 (error at __encode_input:262) else goto L12
L12:
    r20 = PyUnicode_Concat(signature, r19)
    dec_ref r19
    if is_error(r20) goto L14 (error at __encode_input:262) else goto L13
L13:
    return r20
L14:
    r21 = CPy_CatchError()
    r22 = builtins :: module
    r23 = 'Exception'
    r24 = CPyObject_GetAttr(r22, r23)
    if is_error(r24) goto L19 (error at __encode_input:263) else goto L15
L15:
    r25 = CPy_ExceptionMatches(r24)
    dec_ref r24
    if r25 goto L16 else goto L17 :: bool
L16:
    r26 = CPy_GetExcValue()
    CPy_RestoreExcInfo(r21)
    dec_ref r21
    return r26
L17:
    CPy_Reraise()
    if not 0 goto L19 else goto L27 :: bool
L18:
    unreachable
L19:
    CPy_RestoreExcInfo(r21)
    dec_ref r21
    r27 = CPy_KeepPropagating()
    if not r27 goto L21 else goto L20 :: bool
L20:
    unreachable
L21:
    r28 = <error> :: object
    return r28
L22:
    dec_ref r0
    goto L14
L23:
    dec_ref r0
    dec_ref r2
    goto L14
L24:
    dec_ref r0
    dec_ref r8
    goto L6
L25:
    dec_ref r0
    dec_ref r8
    goto L14
L26:
    dec_ref r14
    goto L14
L27:
    dec_ref r21
    goto L18

def __decode_output(hexstr, abi):
    hexstr :: object
    abi :: dict
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
    r9 :: bool
    r10 :: object[1]
    r11 :: object_ptr
    r12, r13 :: object
    r14 :: bool
    r15 :: object[2]
    r16 :: object_ptr
    r17 :: object
    r18, result :: tuple
    r19 :: object
    r20 :: tuple
    r21 :: ptr
    r22 :: native_int
    r23 :: short_int
    r24 :: bit
    r25, r26 :: object
    r27 :: tuple[object, object, object]
    r28 :: dict
    r29 :: str
    r30 :: object
    r31 :: bit
    r32, e :: object
    r33 :: str
    r34 :: object
    r35, r36 :: str
    r37 :: dict
    r38 :: list
    r39 :: object
    r40 :: i32
    r41 :: bit
    r42 :: tuple
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: object
    r47 :: str
    r48 :: object
    r49 :: bit
    r50 :: object
    r51 :: bit
    r52 :: object
L0:
L1:
    r0 = 'outputs'
    r1 = CPyDict_GetItem(abi, r0)
    if is_error(r1) goto L20 (error at __decode_output:282) else goto L2
L2:
    r2 = dank_mids.brownie_patch.call.globals :: static
    r3 = 'get_type_strings'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L38 (error at __decode_output:282) else goto L3
L3:
    r5 = [r1]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r4, r6, 1, 0)
    dec_ref r4
    if is_error(r7) goto L38 (error at __decode_output:282) else goto L4
L4:
    dec_ref r1
    r8 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r8) goto L39 else goto L7
L5:
    r9 = raise NameError('value for final name "HexBytes" was not set')
    if not r9 goto L20 (error at __decode_output:283) else goto L6 :: bool
L6:
    unreachable
L7:
    r10 = [hexstr]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r8, r11, 1, 0)
    if is_error(r12) goto L40 (error at __decode_output:283) else goto L8
L8:
    r13 = dank_mids.brownie_patch.call.__eth_abi_decode :: static
    if is_error(r13) goto L41 else goto L11
L9:
    r14 = raise NameError('value for final name "__eth_abi_decode" was not set')
    if not r14 goto L20 (error at __decode_output:283) else goto L10 :: bool
L10:
    unreachable
L11:
    r15 = [r7, r12]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r13, r16, 2, 0)
    if is_error(r17) goto L42 (error at __decode_output:283) else goto L12
L12:
    dec_ref r7
    dec_ref r12
    r18 = cast(tuple, r17)
    if is_error(r18) goto L20 (error at __decode_output:283) else goto L13
L13:
    result = r18
    r19 = format_output_but_cache_checksums(abi, result)
    dec_ref result
    if is_error(r19) goto L20 (error at __decode_output:284) else goto L14
L14:
    r20 = cast(tuple, r19)
    if is_error(r20) goto L20 (error at __decode_output:284) else goto L15
L15:
    result = r20
    r21 = get_element_ptr result ob_size :: PyVarObject
    r22 = load_mem r21 :: native_int*
    r23 = r22 << 1
    r24 = r23 == 2
    if r24 goto L16 else goto L18 :: bool
L16:
    r25 = CPySequenceTuple_GetItem(result, 0)
    dec_ref result
    if is_error(r25) goto L20 (error at __decode_output:285) else goto L17
L17:
    r26 = r25
    goto L19
L18:
    r26 = result
L19:
    return r26
L20:
    r27 = CPy_CatchError()
    r28 = dank_mids.brownie_patch.call.globals :: static
    r29 = 'DecodingError'
    r30 = CPyDict_GetItem(r28, r29)
    if is_error(r30) goto L35 (error at __decode_output:286) else goto L21
L21:
    r31 = CPy_ExceptionMatches(r30)
    dec_ref r30
    if r31 goto L22 else goto L30 :: bool
L22:
    r32 = CPy_GetExcValue()
    e = r32
    r33 = 'args'
    r34 = CPyObject_GetAttr(e, r33)
    if is_error(r34) goto L43 (error at __decode_output:287) else goto L23
L23:
    r35 = 'hexstr'
    r36 = 'abi'
    r37 = CPyDict_Build(2, r35, hexstr, r36, abi)
    if is_error(r37) goto L44 (error at __decode_output:287) else goto L24
L24:
    r38 = PyList_New(0)
    if is_error(r38) goto L45 (error at __decode_output:287) else goto L25
L25:
    r39 = CPyList_Extend(r38, r34)
    dec_ref r34
    if is_error(r39) goto L46 (error at __decode_output:287) else goto L47
L26:
    r40 = PyList_Append(r38, r37)
    dec_ref r37
    r41 = r40 >= 0 :: signed
    if not r41 goto L48 (error at __decode_output:287) else goto L27 :: bool
L27:
    r42 = PyList_AsTuple(r38)
    dec_ref r38
    if is_error(r42) goto L43 (error at __decode_output:287) else goto L28
L28:
    r43 = 'args'
    r44 = PyObject_SetAttr(e, r43, r42)
    dec_ref r42
    r45 = r44 >= 0 :: signed
    if not r45 goto L43 (error at __decode_output:287) else goto L29 :: bool
L29:
    CPy_RestoreExcInfo(r27)
    dec_ref r27
    return e
L30:
    r46 = builtins :: module
    r47 = 'Exception'
    r48 = CPyObject_GetAttr(r46, r47)
    if is_error(r48) goto L35 (error at __decode_output:289) else goto L31
L31:
    r49 = CPy_ExceptionMatches(r48)
    dec_ref r48
    if r49 goto L32 else goto L33 :: bool
L32:
    r50 = CPy_GetExcValue()
    e = r50
    CPy_RestoreExcInfo(r27)
    dec_ref r27
    return e
L33:
    CPy_Reraise()
    if not 0 goto L35 else goto L49 :: bool
L34:
    unreachable
L35:
    CPy_RestoreExcInfo(r27)
    dec_ref r27
    r51 = CPy_KeepPropagating()
    if not r51 goto L37 else goto L36 :: bool
L36:
    unreachable
L37:
    r52 = <error> :: object
    return r52
L38:
    dec_ref r1
    goto L20
L39:
    dec_ref r7
    goto L5
L40:
    dec_ref r7
    goto L20
L41:
    dec_ref r7
    dec_ref r12
    goto L9
L42:
    dec_ref r7
    dec_ref r12
    goto L20
L43:
    dec_ref e
    goto L35
L44:
    dec_ref e
    dec_ref r34
    goto L35
L45:
    dec_ref e
    dec_ref r34
    dec_ref r37
    goto L35
L46:
    dec_ref e
    dec_ref r37
    dec_ref r38
    goto L35
L47:
    dec_ref r39
    goto L26
L48:
    dec_ref e
    dec_ref r38
    goto L35
L49:
    dec_ref r27
    goto L34

def __validate_output(abi, hexstr):
    abi :: dict
    hexstr, r0 :: object
    r1 :: bool
    r2 :: object[1]
    r3 :: object_ptr
    r4, r5, r6, r7, r8, r9 :: object
    r10 :: str
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: i32
    r17 :: bit
    r18 :: bool
    r19 :: str
    r20 :: list
    r21, r22 :: ptr
    r23 :: object
    r24 :: bool
    r25 :: object[1]
    r26 :: object_ptr
    r27, r28, r29, r30, r31, r32, r33 :: object
    r34 :: bool
    r35 :: object[2]
    r36 :: object_ptr
    r37 :: object
    r38 :: tuple
    r39, revert_str :: object
    r40, r41, r42 :: str
    r43 :: object
    r44 :: bool
    r45 :: object[1]
    r46 :: object_ptr
    r47 :: object
    r48 :: str
    r49 :: object
    r50 :: i32
    r51 :: bit
    r52 :: bool
    r53 :: object
    r54 :: bool
    r55 :: object[1]
    r56 :: object_ptr
    r57, r58, r59, r60, r61, r62 :: object
    r63 :: str
    r64 :: object[1]
    r65 :: object_ptr
    r66, r67, r68 :: object
    r69 :: object[2]
    r70 :: object_ptr
    r71 :: object
    r72 :: int
    r73 :: dict
    r74 :: str
    r75, r76 :: object
    r77 :: i32
    r78 :: bit
    r79 :: bool
    r80 :: dict
    r81 :: str
    r82, r83, r84 :: object
    r85, r86, r87, r88, r89, r90, r91 :: str
    r92 :: object
    r93 :: bool
    r94 :: object[1]
    r95 :: object_ptr
    r96 :: object
    r97 :: str
    r98 :: object
    r99 :: i32
    r100 :: bit
    r101 :: bool
    r102 :: str
    r103 :: object
    r104 :: bool
    r105 :: object[1]
    r106 :: object_ptr
    r107 :: object
    r108 :: str
    r109 :: object
    r110 :: i32
    r111 :: bit
    r112 :: bool
    r113 :: i32
    r114 :: bit
    r115 :: bool
    r116 :: str
    r117 :: object
    r118 :: bool
    r119 :: object[1]
    r120 :: object_ptr
    r121 :: object
    r122 :: tuple[object, object, object]
    r123 :: object
    r124 :: str
    r125 :: object
    r126 :: bit
    r127 :: object
    r128 :: dict
    r129 :: str
    r130 :: object
    r131 :: object[1]
    r132 :: object_ptr
    r133 :: object
    r134 :: tuple[object, object, object]
    r135, r136 :: bit
    r137 :: None
L0:
L1:
    r0 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r0) goto L2 else goto L4
L2:
    r1 = raise NameError('value for final name "HexBytes" was not set')
    if not r1 goto L81 (error at __validate_output:295) else goto L3 :: bool
L3:
    unreachable
L4:
    r2 = [hexstr]
    r3 = load_address r2
    r4 = PyObject_Vectorcall(r0, r3, 1, 0)
    if is_error(r4) goto L81 (error at __validate_output:295) else goto L5
L5:
    r5 = load_address _Py_NoneStruct
    r6 = load_address _Py_NoneStruct
    r7 = object 4
    r8 = PySlice_New(r5, r7, r6)
    if is_error(r8) goto L98 (error at __validate_output:295) else goto L6
L6:
    r9 = PyObject_GetItem(r4, r8)
    dec_ref r4
    dec_ref r8
    if is_error(r9) goto L81 (error at __validate_output:295) else goto L7
L7:
    r10 = 'hex'
    r11 = [r9]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775809, 0)
    if is_error(r13) goto L99 (error at __validate_output:295) else goto L8
L8:
    dec_ref r9
    r14 = '0x08c379a0'
    r15 = PyObject_RichCompare(r13, r14, 2)
    if is_error(r15) goto L100 (error at __validate_output:296) else goto L9
L9:
    r16 = PyObject_IsTrue(r15)
    dec_ref r15
    r17 = r16 >= 0 :: signed
    if not r17 goto L100 (error at __validate_output:296) else goto L10 :: bool
L10:
    r18 = truncate r16: i32 to builtins.bool
    if r18 goto L101 else goto L32 :: bool
L11:
    r19 = 'string'
    r20 = PyList_New(1)
    if is_error(r20) goto L81 (error at __validate_output:297) else goto L12
L12:
    r21 = get_element_ptr r20 ob_item :: PyListObject
    r22 = load_mem r21 :: ptr*
    inc_ref r19
    set_mem r22, r19 :: builtins.object*
    r23 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r23) goto L102 else goto L15
L13:
    r24 = raise NameError('value for final name "HexBytes" was not set')
    if not r24 goto L81 (error at __validate_output:297) else goto L14 :: bool
L14:
    unreachable
L15:
    r25 = [hexstr]
    r26 = load_address r25
    r27 = PyObject_Vectorcall(r23, r26, 1, 0)
    if is_error(r27) goto L103 (error at __validate_output:297) else goto L16
L16:
    r28 = load_address _Py_NoneStruct
    r29 = load_address _Py_NoneStruct
    r30 = object 4
    r31 = PySlice_New(r30, r28, r29)
    if is_error(r31) goto L104 (error at __validate_output:297) else goto L17
L17:
    r32 = PyObject_GetItem(r27, r31)
    dec_ref r27
    dec_ref r31
    if is_error(r32) goto L103 (error at __validate_output:297) else goto L18
L18:
    r33 = dank_mids.brownie_patch.call.__eth_abi_decode :: static
    if is_error(r33) goto L105 else goto L21
L19:
    r34 = raise NameError('value for final name "__eth_abi_decode" was not set')
    if not r34 goto L81 (error at __validate_output:297) else goto L20 :: bool
L20:
    unreachable
L21:
    r35 = [r20, r32]
    r36 = load_address r35
    r37 = PyObject_Vectorcall(r33, r36, 2, 0)
    if is_error(r37) goto L106 (error at __validate_output:297) else goto L22
L22:
    dec_ref r20
    dec_ref r32
    r38 = cast(tuple, r37)
    if is_error(r38) goto L81 (error at __validate_output:297) else goto L23
L23:
    r39 = CPySequenceTuple_GetItem(r38, 0)
    dec_ref r38
    if is_error(r39) goto L81 (error at __validate_output:297) else goto L24
L24:
    revert_str = r39
    r40 = 'Call reverted: '
    r41 = PyObject_Str(revert_str)
    dec_ref revert_str
    if is_error(r41) goto L81 (error at __validate_output:298) else goto L25
L25:
    r42 = CPyStr_Build(2, r40, r41)
    dec_ref r41
    if is_error(r42) goto L81 (error at __validate_output:298) else goto L26
L26:
    r43 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r43) goto L107 else goto L29
L27:
    r44 = raise NameError('value for final name "Revert" was not set')
    if not r44 goto L81 (error at __validate_output:298) else goto L28 :: bool
L28:
    unreachable
L29:
    r45 = [r42]
    r46 = load_address r45
    r47 = PyObject_Vectorcall(r43, r46, 1, 0)
    if is_error(r47) goto L108 (error at __validate_output:298) else goto L30
L30:
    dec_ref r42
    CPy_Raise(r47)
    dec_ref r47
    if not 0 goto L81 (error at __validate_output:298) else goto L31 :: bool
L31:
    unreachable
L32:
    r48 = '0x4e487b71'
    r49 = PyObject_RichCompare(r13, r48, 2)
    if is_error(r49) goto L100 (error at __validate_output:299) else goto L33
L33:
    r50 = PyObject_IsTrue(r49)
    dec_ref r49
    r51 = r50 >= 0 :: signed
    if not r51 goto L100 (error at __validate_output:299) else goto L34 :: bool
L34:
    r52 = truncate r50: i32 to builtins.bool
    if r52 goto L109 else goto L61 :: bool
L35:
    r53 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r53) goto L36 else goto L38
L36:
    r54 = raise NameError('value for final name "HexBytes" was not set')
    if not r54 goto L81 (error at __validate_output:300) else goto L37 :: bool
L37:
    unreachable
L38:
    r55 = [hexstr]
    r56 = load_address r55
    r57 = PyObject_Vectorcall(r53, r56, 1, 0)
    if is_error(r57) goto L81 (error at __validate_output:300) else goto L39
L39:
    r58 = load_address _Py_NoneStruct
    r59 = load_address _Py_NoneStruct
    r60 = object 4
    r61 = PySlice_New(r60, r58, r59)
    if is_error(r61) goto L110 (error at __validate_output:300) else goto L40
L40:
    r62 = PyObject_GetItem(r57, r61)
    dec_ref r57
    dec_ref r61
    if is_error(r62) goto L81 (error at __validate_output:300) else goto L41
L41:
    r63 = 'hex'
    r64 = [r62]
    r65 = load_address r64
    r66 = PyObject_VectorcallMethod(r63, r65, 9223372036854775809, 0)
    if is_error(r66) goto L111 (error at __validate_output:300) else goto L42
L42:
    dec_ref r62
    r67 = load_address PyLong_Type
    r68 = object 16
    r69 = [r66, r68]
    r70 = load_address r69
    r71 = PyObject_Vectorcall(r67, r70, 2, 0)
    if is_error(r71) goto L112 (error at __validate_output:300) else goto L43
L43:
    dec_ref r66
    r72 = unbox(int, r71)
    dec_ref r71
    if is_error(r72) goto L81 (error at __validate_output:300) else goto L44
L44:
    r73 = dank_mids.brownie_patch.call.globals :: static
    r74 = 'SOLIDITY_ERROR_CODES'
    r75 = CPyDict_GetItem(r73, r74)
    if is_error(r75) goto L113 (error at __validate_output:301) else goto L45
L45:
    inc_ref r72 :: int
    r76 = box(int, r72)
    r77 = PySequence_Contains(r75, r76)
    dec_ref r75
    dec_ref r76
    r78 = r77 >= 0 :: signed
    if not r78 goto L113 (error at __validate_output:301) else goto L46 :: bool
L46:
    r79 = truncate r77: i32 to builtins.bool
    if r79 goto L47 else goto L50 :: bool
L47:
    r80 = dank_mids.brownie_patch.call.globals :: static
    r81 = 'SOLIDITY_ERROR_CODES'
    r82 = CPyDict_GetItem(r80, r81)
    if is_error(r82) goto L113 (error at __validate_output:302) else goto L48
L48:
    r83 = box(int, r72)
    r84 = PyObject_GetItem(r82, r83)
    dec_ref r82
    dec_ref r83
    if is_error(r84) goto L81 (error at __validate_output:302) else goto L49
L49:
    revert_str = r84
    goto L53
L50:
    r85 = 'Panic (error code: '
    r86 = CPyTagged_Str(r72)
    dec_ref r72 :: int
    if is_error(r86) goto L81 (error at __validate_output:304) else goto L51
L51:
    r87 = ')'
    r88 = CPyStr_Build(3, r85, r86, r87)
    dec_ref r86
    if is_error(r88) goto L81 (error at __validate_output:304) else goto L52
L52:
    revert_str = r88
L53:
    r89 = 'Call reverted: '
    r90 = PyObject_Str(revert_str)
    dec_ref revert_str
    if is_error(r90) goto L81 (error at __validate_output:305) else goto L54
L54:
    r91 = CPyStr_Build(2, r89, r90)
    dec_ref r90
    if is_error(r91) goto L81 (error at __validate_output:305) else goto L55
L55:
    r92 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r92) goto L114 else goto L58
L56:
    r93 = raise NameError('value for final name "Revert" was not set')
    if not r93 goto L81 (error at __validate_output:305) else goto L57 :: bool
L57:
    unreachable
L58:
    r94 = [r91]
    r95 = load_address r94
    r96 = PyObject_Vectorcall(r92, r95, 1, 0)
    if is_error(r96) goto L115 (error at __validate_output:305) else goto L59
L59:
    dec_ref r91
    CPy_Raise(r96)
    dec_ref r96
    if not 0 goto L81 (error at __validate_output:305) else goto L60 :: bool
L60:
    unreachable
L61:
    r97 = '0xc1b84b2f'
    r98 = PyObject_RichCompare(r13, r97, 2)
    dec_ref r13
    if is_error(r98) goto L81 (error at __validate_output:306) else goto L62
L62:
    r99 = PyObject_IsTrue(r98)
    dec_ref r98
    r100 = r99 >= 0 :: signed
    if not r100 goto L81 (error at __validate_output:306) else goto L63 :: bool
L63:
    r101 = truncate r99: i32 to builtins.bool
    if r101 goto L64 else goto L70 :: bool
L64:
    r102 = 'Call reverted: execution reverted'
    r103 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r103) goto L65 else goto L67
L65:
    r104 = raise NameError('value for final name "Revert" was not set')
    if not r104 goto L81 (error at __validate_output:307) else goto L66 :: bool
L66:
    unreachable
L67:
    r105 = [r102]
    r106 = load_address r105
    r107 = PyObject_Vectorcall(r103, r106, 1, 0)
    if is_error(r107) goto L81 (error at __validate_output:307) else goto L68
L68:
    CPy_Raise(r107)
    dec_ref r107
    if not 0 goto L81 (error at __validate_output:307) else goto L69 :: bool
L69:
    unreachable
L70:
    r108 = 'outputs'
    r109 = CPyDict_GetItem(abi, r108)
    if is_error(r109) goto L81 (error at __validate_output:308) else goto L71
L71:
    r110 = PyObject_IsTrue(r109)
    dec_ref r109
    r111 = r110 >= 0 :: signed
    if not r111 goto L81 (error at __validate_output:308) else goto L72 :: bool
L72:
    r112 = truncate r110: i32 to builtins.bool
    if r112 goto L73 else goto L96 :: bool
L73:
    r113 = PyObject_IsTrue(hexstr)
    r114 = r113 >= 0 :: signed
    if not r114 goto L81 (error at __validate_output:293) else goto L74 :: bool
L74:
    r115 = truncate r113: i32 to builtins.bool
    if r115 goto L96 else goto L75 :: bool
L75:
    r116 = 'No data was returned - the call likely reverted'
    r117 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r117) goto L76 else goto L78
L76:
    r118 = raise NameError('value for final name "Revert" was not set')
    if not r118 goto L81 (error at __validate_output:309) else goto L77 :: bool
L77:
    unreachable
L78:
    r119 = [r116]
    r120 = load_address r119
    r121 = PyObject_Vectorcall(r117, r120, 1, 0)
    if is_error(r121) goto L81 (error at __validate_output:309) else goto L79
L79:
    CPy_Raise(r121)
    dec_ref r121
    if not 0 goto L81 (error at __validate_output:309) else goto L80 :: bool
L80:
    unreachable
L81:
    r122 = CPy_CatchError()
    r123 = builtins :: module
    r124 = 'ValueError'
    r125 = CPyObject_GetAttr(r123, r124)
    if is_error(r125) goto L94 (error at __validate_output:310) else goto L82
L82:
    r126 = CPy_ExceptionMatches(r125)
    dec_ref r125
    if r126 goto L83 else goto L92 :: bool
L83:
    r127 = CPy_GetExcValue()
L84:
    r128 = dank_mids.brownie_patch.call.globals :: static
    r129 = 'VirtualMachineError'
    r130 = CPyDict_GetItem(r128, r129)
    if is_error(r130) goto L88 (error at __validate_output:312) else goto L85
L85:
    r131 = [r127]
    r132 = load_address r131
    r133 = PyObject_Vectorcall(r130, r132, 1, 0)
    dec_ref r130
    if is_error(r133) goto L88 (error at __validate_output:312) else goto L86
L86:
    CPy_Raise(r133)
    dec_ref r133
    if not 0 goto L88 (error at __validate_output:312) else goto L116 :: bool
L87:
    unreachable
L88:
    r134 = CPy_CatchError()
    CPy_Raise(r127)
    dec_ref r127
    if not 0 goto L90 (error at __validate_output:314) else goto L117 :: bool
L89:
    unreachable
L90:
    CPy_RestoreExcInfo(r134)
    dec_ref r134
    r135 = CPy_KeepPropagating()
    if not r135 goto L94 else goto L118 :: bool
L91:
    unreachable
L92:
    CPy_Reraise()
    if not 0 goto L94 else goto L119 :: bool
L93:
    unreachable
L94:
    CPy_RestoreExcInfo(r122)
    dec_ref r122
    r136 = CPy_KeepPropagating()
    if not r136 goto L97 else goto L95 :: bool
L95:
    unreachable
L96:
    return 1
L97:
    r137 = <error> :: None
    return r137
L98:
    dec_ref r4
    goto L81
L99:
    dec_ref r9
    goto L81
L100:
    dec_ref r13
    goto L81
L101:
    dec_ref r13
    goto L11
L102:
    dec_ref r20
    goto L13
L103:
    dec_ref r20
    goto L81
L104:
    dec_ref r20
    dec_ref r27
    goto L81
L105:
    dec_ref r20
    dec_ref r32
    goto L19
L106:
    dec_ref r20
    dec_ref r32
    goto L81
L107:
    dec_ref r42
    goto L27
L108:
    dec_ref r42
    goto L81
L109:
    dec_ref r13
    goto L35
L110:
    dec_ref r57
    goto L81
L111:
    dec_ref r62
    goto L81
L112:
    dec_ref r66
    goto L81
L113:
    dec_ref r72 :: int
    goto L81
L114:
    dec_ref r91
    goto L56
L115:
    dec_ref r91
    goto L81
L116:
    dec_ref r122
    dec_ref r127
    goto L87
L117:
    dec_ref r122
    dec_ref r134
    goto L89
L118:
    dec_ref r122
    goto L91
L119:
    dec_ref r122
    goto L93

def format_input_but_cache_checksums(abi, inputs):
    abi :: dict
    inputs :: union[list, tuple]
    r0 :: int
    r1 :: bit
    r2 :: str
    r3 :: object
    r4 :: int
    r5 :: bit
    r6 :: str
    r7 :: object
    r8, r9, r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: str
    r18, r19 :: object
    r20 :: bool
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: list
    r25 :: tuple[object, object, object]
    r26 :: object
    r27 :: str
    r28 :: object
    r29 :: bit
    r30, r31 :: object
    r32 :: str
    r33 :: object
    r34, r35, r36, r37 :: str
    r38 :: object[1]
    r39 :: object_ptr
    r40 :: object
    r41 :: bit
    r42 :: list
L0:
    r0 = CPyObject_Size(inputs)
    if is_error(r0) goto L33 (error at format_input_but_cache_checksums:322) else goto L1
L1:
    r1 = r0 != 0
    dec_ref r0 :: int
    if r1 goto L2 else goto L12 :: bool
L2:
    r2 = 'inputs'
    r3 = CPyDict_GetItem(abi, r2)
    if is_error(r3) goto L33 (error at format_input_but_cache_checksums:322) else goto L3
L3:
    r4 = CPyObject_Size(r3)
    dec_ref r3
    if is_error(r4) goto L33 (error at format_input_but_cache_checksums:322) else goto L4
L4:
    r5 = r4 != 0
    dec_ref r4 :: int
    if r5 goto L12 else goto L5 :: bool
L5:
    r6 = 'name'
    r7 = CPyDict_GetItem(abi, r6)
    if is_error(r7) goto L33 (error at format_input_but_cache_checksums:323) else goto L6
L6:
    r8 = PyObject_Str(r7)
    dec_ref r7
    if is_error(r8) goto L33 (error at format_input_but_cache_checksums:323) else goto L7
L7:
    r9 = ' requires no arguments'
    r10 = CPyStr_Build(2, r8, r9)
    dec_ref r8
    if is_error(r10) goto L33 (error at format_input_but_cache_checksums:323) else goto L8
L8:
    r11 = builtins :: module
    r12 = 'TypeError'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L34 (error at format_input_but_cache_checksums:323) else goto L9
L9:
    r14 = [r10]
    r15 = load_address r14
    r16 = PyObject_Vectorcall(r13, r15, 1, 0)
    dec_ref r13
    if is_error(r16) goto L34 (error at format_input_but_cache_checksums:323) else goto L10
L10:
    dec_ref r10
    CPy_Raise(r16)
    dec_ref r16
    if not 0 goto L33 (error at format_input_but_cache_checksums:323) else goto L11 :: bool
L11:
    unreachable
L12:
    r17 = 'inputs'
    r18 = CPyDict_GetItem(abi, r17)
    if is_error(r18) goto L33 (error at format_input_but_cache_checksums:324) else goto L13
L13:
    r19 = dank_mids.brownie_patch.call._get_abi_types :: static
    if is_error(r19) goto L35 else goto L16
L14:
    r20 = raise NameError('value for final name "_get_abi_types" was not set')
    if not r20 goto L33 (error at format_input_but_cache_checksums:324) else goto L15 :: bool
L15:
    unreachable
L16:
    r21 = [r18]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(r19, r22, 1, 0)
    if is_error(r23) goto L36 (error at format_input_but_cache_checksums:324) else goto L17
L17:
    dec_ref r18
L18:
    r24 = _format_tuple_but_cache_checksums(r23, inputs)
    dec_ref r23
    if is_error(r24) goto L20 (error at format_input_but_cache_checksums:326) else goto L19
L19:
    return r24
L20:
    r25 = CPy_CatchError()
    r26 = builtins :: module
    r27 = 'Exception'
    r28 = CPyObject_GetAttr(r26, r27)
    if is_error(r28) goto L31 (error at format_input_but_cache_checksums:327) else goto L21
L21:
    r29 = CPy_ExceptionMatches(r28)
    dec_ref r28
    if r29 goto L22 else goto L29 :: bool
L22:
    r30 = CPy_GetExcValue()
    r31 = PyObject_Type(r30)
    r32 = 'name'
    r33 = CPyDict_GetItem(abi, r32)
    if is_error(r33) goto L37 (error at format_input_but_cache_checksums:328) else goto L23
L23:
    r34 = PyObject_Str(r33)
    dec_ref r33
    if is_error(r34) goto L37 (error at format_input_but_cache_checksums:328) else goto L24
L24:
    r35 = ' '
    r36 = PyObject_Str(r30)
    dec_ref r30
    if is_error(r36) goto L38 (error at format_input_but_cache_checksums:328) else goto L25
L25:
    r37 = CPyStr_Build(3, r34, r35, r36)
    dec_ref r34
    dec_ref r36
    if is_error(r37) goto L39 (error at format_input_but_cache_checksums:328) else goto L26
L26:
    r38 = [r37]
    r39 = load_address r38
    r40 = PyObject_Vectorcall(r31, r39, 1, 0)
    dec_ref r31
    if is_error(r40) goto L40 (error at format_input_but_cache_checksums:328) else goto L27
L27:
    dec_ref r37
    CPy_Raise(r40)
    dec_ref r40
    if not 0 goto L31 (error at format_input_but_cache_checksums:328) else goto L41 :: bool
L28:
    unreachable
L29:
    CPy_Reraise()
    if not 0 goto L31 else goto L42 :: bool
L30:
    unreachable
L31:
    CPy_RestoreExcInfo(r25)
    dec_ref r25
    r41 = CPy_KeepPropagating()
    if not r41 goto L33 else goto L32 :: bool
L32:
    unreachable
L33:
    r42 = <error> :: list
    return r42
L34:
    dec_ref r10
    goto L33
L35:
    dec_ref r18
    goto L14
L36:
    dec_ref r18
    goto L33
L37:
    dec_ref r30
    dec_ref r31
    goto L31
L38:
    dec_ref r31
    dec_ref r34
    goto L31
L39:
    dec_ref r31
    goto L31
L40:
    dec_ref r37
    goto L31
L41:
    dec_ref r25
    goto L28
L42:
    dec_ref r25
    goto L30

def format_output_but_cache_checksums(abi, outputs):
    abi :: dict
    outputs :: union[list, tuple]
    r0 :: str
    r1, r2 :: object
    r3 :: bool
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: list
    r8 :: str
    r9, r10 :: object
    r11 :: bool
    r12 :: object[2]
    r13 :: object_ptr
    r14, r15 :: object
L0:
    r0 = 'outputs'
    r1 = CPyDict_GetItem(abi, r0)
    if is_error(r1) goto L12 (error at format_output_but_cache_checksums:335) else goto L1
L1:
    r2 = dank_mids.brownie_patch.call._get_abi_types :: static
    if is_error(r2) goto L13 else goto L4
L2:
    r3 = raise NameError('value for final name "_get_abi_types" was not set')
    if not r3 goto L12 (error at format_output_but_cache_checksums:335) else goto L3 :: bool
L3:
    unreachable
L4:
    r4 = [r1]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r2, r5, 1, 0)
    if is_error(r6) goto L14 (error at format_output_but_cache_checksums:335) else goto L5
L5:
    dec_ref r1
    r7 = _format_tuple_but_cache_checksums(r6, outputs)
    dec_ref r6
    if is_error(r7) goto L12 (error at format_output_but_cache_checksums:336) else goto L6
L6:
    r8 = 'outputs'
    r9 = CPyDict_GetItem(abi, r8)
    if is_error(r9) goto L15 (error at format_output_but_cache_checksums:337) else goto L7
L7:
    r10 = dank_mids.brownie_patch.call.ReturnValue :: static
    if is_error(r10) goto L16 else goto L10
L8:
    r11 = raise NameError('value for final name "ReturnValue" was not set')
    if not r11 goto L12 (error at format_output_but_cache_checksums:337) else goto L9 :: bool
L9:
    unreachable
L10:
    r12 = [r7, r9]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r10, r13, 2, 0)
    if is_error(r14) goto L17 (error at format_output_but_cache_checksums:337) else goto L11
L11:
    dec_ref r7
    dec_ref r9
    return r14
L12:
    r15 = <error> :: object
    return r15
L13:
    dec_ref r1
    goto L2
L14:
    dec_ref r1
    goto L12
L15:
    dec_ref r7
    goto L12
L16:
    dec_ref r7
    dec_ref r9
    goto L8
L17:
    dec_ref r7
    dec_ref r9
    goto L12

def _format_tuple_but_cache_checksums(abi_types, values):
    abi_types :: object
    values :: union[list, tuple]
    r0 :: list
    r1 :: int
    r2 :: object
    r3 :: bool
    r4 :: object
    r5 :: object[2]
    r6 :: object_ptr
    r7, r8, r9, r10, r11 :: object
    r12 :: str
    r13 :: object
    r14 :: i32
    r15 :: bit
    r16 :: bool
    r17 :: union[list, tuple]
    r18 :: list
    r19 :: i32
    r20 :: bit
    r21 :: object
    r22 :: bool
    r23 :: i32
    r24 :: bit
    r25 :: bool
    r26 :: str
    r27 :: object
    r28 :: union[list, tuple]
    r29 :: list
    r30 :: i32
    r31 :: bit
    r32 :: str
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: i32
    r39 :: bit
    r40 :: tuple[object, object, object]
    r41 :: object
    r42 :: str
    r43 :: object
    r44 :: bit
    r45, r46 :: object
    r47, r48, r49, r50, r51 :: str
    r52 :: object[1]
    r53 :: object_ptr
    r54 :: object
    r55, r56, r57 :: bit
    r58 :: list
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L45 (error at _format_tuple_but_cache_checksums:347) else goto L1
L1:
    r1 = CPyObject_Size(abi_types)
    if is_error(r1) goto L46 (error at _format_tuple_but_cache_checksums:348) else goto L2
L2:
    r2 = dank_mids.brownie_patch.call._check_array :: static
    if is_error(r2) goto L47 else goto L5
L3:
    r3 = raise NameError('value for final name "_check_array" was not set')
    if not r3 goto L45 (error at _format_tuple_but_cache_checksums:348) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = box(int, r1)
    r5 = [values, r4]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r2, r6, 2, 0)
    if is_error(r7) goto L48 (error at _format_tuple_but_cache_checksums:348) else goto L49
L6:
    dec_ref r4
    r8 = PyObject_GetIter(abi_types)
    if is_error(r8) goto L46 (error at _format_tuple_but_cache_checksums:349) else goto L7
L7:
    r9 = PyObject_GetIter(values)
    if is_error(r9) goto L50 (error at _format_tuple_but_cache_checksums:349) else goto L8
L8:
    r10 = PyIter_Next(r8)
    if is_error(r10) goto L51 else goto L9
L9:
    r11 = PyIter_Next(r9)
    if is_error(r11) goto L52 else goto L10
L10:
L11:
    r12 = 'is_array'
    r13 = CPyObject_GetAttr(r10, r12)
    if is_error(r13) goto L53 (error at _format_tuple_but_cache_checksums:351) else goto L12
L12:
    r14 = PyObject_IsTrue(r13)
    dec_ref r13
    r15 = r14 >= 0 :: signed
    if not r15 goto L53 (error at _format_tuple_but_cache_checksums:351) else goto L13 :: bool
L13:
    r16 = truncate r14: i32 to builtins.bool
    if r16 goto L14 else goto L17 :: bool
L14:
    inc_ref r11
    r17 = cast(union[list, tuple], r11)
    if is_error(r17) goto L53 (error at _format_tuple_but_cache_checksums:352) else goto L15
L15:
    r18 = _format_array_but_cache_checksums(r10, r17)
    dec_ref r10
    dec_ref r17
    if is_error(r18) goto L54 (error at _format_tuple_but_cache_checksums:352) else goto L16
L16:
    r19 = PyList_Append(r0, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L54 (error at _format_tuple_but_cache_checksums:352) else goto L55 :: bool
L17:
    r21 = dank_mids.brownie_patch.call.TupleType :: static
    if is_error(r21) goto L56 else goto L20
L18:
    r22 = raise NameError('value for final name "TupleType" was not set')
    if not r22 goto L30 (error at _format_tuple_but_cache_checksums:353) else goto L57 :: bool
L19:
    unreachable
L20:
    r23 = PyObject_IsInstance(r10, r21)
    r24 = r23 >= 0 :: signed
    if not r24 goto L53 (error at _format_tuple_but_cache_checksums:353) else goto L21 :: bool
L21:
    r25 = truncate r23: i32 to builtins.bool
    if r25 goto L22 else goto L26 :: bool
L22:
    r26 = 'components'
    r27 = CPyObject_GetAttr(r10, r26)
    dec_ref r10
    if is_error(r27) goto L54 (error at _format_tuple_but_cache_checksums:354) else goto L23
L23:
    inc_ref r11
    r28 = cast(union[list, tuple], r11)
    if is_error(r28) goto L58 (error at _format_tuple_but_cache_checksums:354) else goto L24
L24:
    r29 = _format_tuple_but_cache_checksums(r27, r28)
    dec_ref r27
    dec_ref r28
    if is_error(r29) goto L54 (error at _format_tuple_but_cache_checksums:354) else goto L25
L25:
    r30 = PyList_Append(r0, r29)
    dec_ref r29
    r31 = r30 >= 0 :: signed
    if not r31 goto L54 (error at _format_tuple_but_cache_checksums:354) else goto L59 :: bool
L26:
    r32 = 'to_type_str'
    r33 = [r10]
    r34 = load_address r33
    r35 = PyObject_VectorcallMethod(r32, r34, 9223372036854775809, 0)
    if is_error(r35) goto L53 (error at _format_tuple_but_cache_checksums:356) else goto L27
L27:
    dec_ref r10
    r36 = cast(str, r35)
    if is_error(r36) goto L54 (error at _format_tuple_but_cache_checksums:356) else goto L28
L28:
    r37 = _format_single_but_cache_checksums(r36, r11)
    dec_ref r36
    if is_error(r37) goto L54 (error at _format_tuple_but_cache_checksums:356) else goto L29
L29:
    r38 = PyList_Append(r0, r37)
    dec_ref r37
    r39 = r38 >= 0 :: signed
    if not r39 goto L54 (error at _format_tuple_but_cache_checksums:356) else goto L60 :: bool
L30:
    r40 = CPy_CatchError()
    r41 = builtins :: module
    r42 = 'Exception'
    r43 = CPyObject_GetAttr(r41, r42)
    if is_error(r43) goto L61 (error at _format_tuple_but_cache_checksums:357) else goto L31
L31:
    r44 = CPy_ExceptionMatches(r43)
    dec_ref r43
    if r44 goto L32 else goto L62 :: bool
L32:
    r45 = CPy_GetExcValue()
    r46 = PyObject_Type(r45)
    r47 = "'"
    r48 = PyObject_Str(r11)
    dec_ref r11
    if is_error(r48) goto L63 (error at _format_tuple_but_cache_checksums:358) else goto L33
L33:
    r49 = "' - "
    r50 = PyObject_Str(r45)
    dec_ref r45
    if is_error(r50) goto L64 (error at _format_tuple_but_cache_checksums:358) else goto L34
L34:
    r51 = CPyStr_Build(4, r47, r48, r49, r50)
    dec_ref r48
    dec_ref r50
    if is_error(r51) goto L65 (error at _format_tuple_but_cache_checksums:358) else goto L35
L35:
    r52 = [r51]
    r53 = load_address r52
    r54 = PyObject_Vectorcall(r46, r53, 1, 0)
    dec_ref r46
    if is_error(r54) goto L66 (error at _format_tuple_but_cache_checksums:358) else goto L36
L36:
    dec_ref r51
    CPy_Raise(r54)
    dec_ref r54
    if not 0 goto L40 (error at _format_tuple_but_cache_checksums:358) else goto L67 :: bool
L37:
    unreachable
L38:
    CPy_Reraise()
    if not 0 goto L40 else goto L68 :: bool
L39:
    unreachable
L40:
    CPy_RestoreExcInfo(r40)
    dec_ref r40
    r55 = CPy_KeepPropagating()
    if not r55 goto L45 else goto L41 :: bool
L41:
    unreachable
L42:
    r56 = CPy_NoErrOccurred()
    if not r56 goto L46 (error at _format_tuple_but_cache_checksums:349) else goto L43 :: bool
L43:
    r57 = CPy_NoErrOccurred()
    if not r57 goto L46 (error at _format_tuple_but_cache_checksums:349) else goto L44 :: bool
L44:
    return r0
L45:
    r58 = <error> :: list
    return r58
L46:
    dec_ref r0
    goto L45
L47:
    dec_ref r0
    dec_ref r1 :: int
    goto L3
L48:
    dec_ref r0
    dec_ref r4
    goto L45
L49:
    dec_ref r7
    goto L6
L50:
    dec_ref r0
    dec_ref r8
    goto L45
L51:
    dec_ref r8
    dec_ref r9
    goto L42
L52:
    dec_ref r8
    dec_ref r9
    dec_ref r10
    goto L42
L53:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    dec_ref r10
    goto L30
L54:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    goto L30
L55:
    dec_ref r11
    goto L8
L56:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    dec_ref r10
    goto L18
L57:
    dec_ref r11
    goto L19
L58:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    dec_ref r27
    goto L30
L59:
    dec_ref r11
    goto L8
L60:
    dec_ref r11
    goto L8
L61:
    dec_ref r11
    goto L40
L62:
    dec_ref r11
    goto L38
L63:
    dec_ref r45
    dec_ref r46
    goto L40
L64:
    dec_ref r46
    dec_ref r48
    goto L40
L65:
    dec_ref r46
    goto L40
L66:
    dec_ref r51
    goto L40
L67:
    dec_ref r40
    goto L37
L68:
    dec_ref r40
    goto L39

def _format_array_but_cache_checksums(abi_type, values):
    abi_type :: object
    values :: union[list, tuple]
    r0 :: str
    r1, r2, r3 :: object
    r4 :: int
    r5 :: bit
    r6 :: str
    r7, r8, r9, r10, r11 :: object
    r12 :: union[object, None]
    r13, r14 :: object
    r15 :: bool
    r16 :: object[2]
    r17 :: object_ptr
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: i32
    r24 :: bit
    r25 :: bool
    r26 :: list
    r27, r28 :: object
    r29 :: union[list, tuple]
    r30 :: list
    r31 :: i32
    r32, r33 :: bit
    r34 :: object
    r35 :: bool
    r36 :: i32
    r37 :: bit
    r38 :: bool
    r39 :: str
    r40 :: object
    r41 :: list
    r42, r43 :: object
    r44 :: union[list, tuple]
    r45 :: list
    r46 :: i32
    r47, r48 :: bit
    r49 :: str
    r50 :: object[1]
    r51 :: object_ptr
    r52 :: object
    r53 :: str
    r54 :: list
    r55, r56, r57 :: object
    r58 :: i32
    r59, r60 :: bit
    r61 :: list
L0:
    r0 = 'arrlist'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L48 (error at _format_array_but_cache_checksums:363) else goto L1
L1:
    r2 = object -1
    r3 = PyObject_GetItem(r1, r2)
    dec_ref r1
    if is_error(r3) goto L48 (error at _format_array_but_cache_checksums:363) else goto L2
L2:
    r4 = CPyObject_Size(r3)
    dec_ref r3
    if is_error(r4) goto L48 (error at _format_array_but_cache_checksums:363) else goto L3
L3:
    r5 = r4 != 0
    dec_ref r4 :: int
    if r5 goto L4 else goto L8 :: bool
L4:
    r6 = 'arrlist'
    r7 = CPyObject_GetAttr(abi_type, r6)
    if is_error(r7) goto L48 (error at _format_array_but_cache_checksums:363) else goto L5
L5:
    r8 = object -1
    r9 = PyObject_GetItem(r7, r8)
    dec_ref r7
    if is_error(r9) goto L48 (error at _format_array_but_cache_checksums:363) else goto L6
L6:
    r10 = object 0
    r11 = PyObject_GetItem(r9, r10)
    dec_ref r9
    if is_error(r11) goto L48 (error at _format_array_but_cache_checksums:363) else goto L7
L7:
    r12 = r11
    goto L9
L8:
    r13 = box(None, 1)
    inc_ref r13
    r12 = r13
L9:
    r14 = dank_mids.brownie_patch.call._check_array :: static
    if is_error(r14) goto L49 else goto L12
L10:
    r15 = raise NameError('value for final name "_check_array" was not set')
    if not r15 goto L48 (error at _format_array_but_cache_checksums:363) else goto L11 :: bool
L11:
    unreachable
L12:
    r16 = [values, r12]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r14, r17, 2, 0)
    if is_error(r18) goto L50 (error at _format_array_but_cache_checksums:363) else goto L51
L13:
    dec_ref r12
    r19 = 'item_type'
    r20 = CPyObject_GetAttr(abi_type, r19)
    if is_error(r20) goto L48 (error at _format_array_but_cache_checksums:364) else goto L14
L14:
    r21 = 'is_array'
    r22 = CPyObject_GetAttr(r20, r21)
    if is_error(r22) goto L52 (error at _format_array_but_cache_checksums:365) else goto L15
L15:
    r23 = PyObject_IsTrue(r22)
    dec_ref r22
    r24 = r23 >= 0 :: signed
    if not r24 goto L52 (error at _format_array_but_cache_checksums:365) else goto L16 :: bool
L16:
    r25 = truncate r23: i32 to builtins.bool
    if r25 goto L17 else goto L25 :: bool
L17:
    r26 = PyList_New(0)
    if is_error(r26) goto L52 (error at _format_array_but_cache_checksums:366) else goto L18
L18:
    r27 = PyObject_GetIter(values)
    if is_error(r27) goto L53 (error at _format_array_but_cache_checksums:366) else goto L19
L19:
    r28 = PyIter_Next(r27)
    if is_error(r28) goto L54 else goto L20
L20:
    r29 = cast(union[list, tuple], r28)
    if is_error(r29) goto L55 (error at _format_array_but_cache_checksums:366) else goto L21
L21:
    r30 = _format_array_but_cache_checksums(r20, r29)
    dec_ref r29
    if is_error(r30) goto L55 (error at _format_array_but_cache_checksums:366) else goto L22
L22:
    r31 = PyList_Append(r26, r30)
    dec_ref r30
    r32 = r31 >= 0 :: signed
    if not r32 goto L55 (error at _format_array_but_cache_checksums:366) else goto L19 :: bool
L23:
    r33 = CPy_NoErrOccurred()
    if not r33 goto L56 (error at _format_array_but_cache_checksums:366) else goto L24 :: bool
L24:
    return r26
L25:
    r34 = dank_mids.brownie_patch.call.TupleType :: static
    if is_error(r34) goto L57 else goto L28
L26:
    r35 = raise NameError('value for final name "TupleType" was not set')
    if not r35 goto L48 (error at _format_array_but_cache_checksums:367) else goto L27 :: bool
L27:
    unreachable
L28:
    r36 = PyObject_IsInstance(r20, r34)
    r37 = r36 >= 0 :: signed
    if not r37 goto L52 (error at _format_array_but_cache_checksums:367) else goto L29 :: bool
L29:
    r38 = truncate r36: i32 to builtins.bool
    if r38 goto L30 else goto L39 :: bool
L30:
    r39 = 'components'
    r40 = CPyObject_GetAttr(r20, r39)
    dec_ref r20
    if is_error(r40) goto L48 (error at _format_array_but_cache_checksums:368) else goto L31
L31:
    r41 = PyList_New(0)
    if is_error(r41) goto L58 (error at _format_array_but_cache_checksums:369) else goto L32
L32:
    r42 = PyObject_GetIter(values)
    if is_error(r42) goto L59 (error at _format_array_but_cache_checksums:369) else goto L33
L33:
    r43 = PyIter_Next(r42)
    if is_error(r43) goto L60 else goto L34
L34:
    r44 = cast(union[list, tuple], r43)
    if is_error(r44) goto L61 (error at _format_array_but_cache_checksums:369) else goto L35
L35:
    r45 = _format_tuple_but_cache_checksums(r40, r44)
    dec_ref r44
    if is_error(r45) goto L61 (error at _format_array_but_cache_checksums:369) else goto L36
L36:
    r46 = PyList_Append(r41, r45)
    dec_ref r45
    r47 = r46 >= 0 :: signed
    if not r47 goto L61 (error at _format_array_but_cache_checksums:369) else goto L33 :: bool
L37:
    r48 = CPy_NoErrOccurred()
    if not r48 goto L62 (error at _format_array_but_cache_checksums:369) else goto L38 :: bool
L38:
    return r41
L39:
    r49 = 'to_type_str'
    r50 = [r20]
    r51 = load_address r50
    r52 = PyObject_VectorcallMethod(r49, r51, 9223372036854775809, 0)
    if is_error(r52) goto L52 (error at _format_array_but_cache_checksums:371) else goto L40
L40:
    dec_ref r20
    r53 = cast(str, r52)
    if is_error(r53) goto L48 (error at _format_array_but_cache_checksums:371) else goto L41
L41:
    r54 = PyList_New(0)
    if is_error(r54) goto L63 (error at _format_array_but_cache_checksums:372) else goto L42
L42:
    r55 = PyObject_GetIter(values)
    if is_error(r55) goto L64 (error at _format_array_but_cache_checksums:372) else goto L43
L43:
    r56 = PyIter_Next(r55)
    if is_error(r56) goto L65 else goto L44
L44:
    r57 = _format_single_but_cache_checksums(r53, r56)
    dec_ref r56
    if is_error(r57) goto L66 (error at _format_array_but_cache_checksums:372) else goto L45
L45:
    r58 = PyList_Append(r54, r57)
    dec_ref r57
    r59 = r58 >= 0 :: signed
    if not r59 goto L66 (error at _format_array_but_cache_checksums:372) else goto L43 :: bool
L46:
    r60 = CPy_NoErrOccurred()
    if not r60 goto L67 (error at _format_array_but_cache_checksums:372) else goto L47 :: bool
L47:
    return r54
L48:
    r61 = <error> :: list
    return r61
L49:
    dec_ref r12
    goto L10
L50:
    dec_ref r12
    goto L48
L51:
    dec_ref r18
    goto L13
L52:
    dec_ref r20
    goto L48
L53:
    dec_ref r20
    dec_ref r26
    goto L48
L54:
    dec_ref r20
    dec_ref r27
    goto L23
L55:
    dec_ref r20
    dec_ref r26
    dec_ref r27
    goto L48
L56:
    dec_ref r26
    goto L48
L57:
    dec_ref r20
    goto L26
L58:
    dec_ref r40
    goto L48
L59:
    dec_ref r40
    dec_ref r41
    goto L48
L60:
    dec_ref r40
    dec_ref r42
    goto L37
L61:
    dec_ref r40
    dec_ref r41
    dec_ref r42
    goto L48
L62:
    dec_ref r41
    goto L48
L63:
    dec_ref r53
    goto L48
L64:
    dec_ref r53
    dec_ref r54
    goto L48
L65:
    dec_ref r53
    dec_ref r55
    goto L46
L66:
    dec_ref r53
    dec_ref r54
    dec_ref r55
    goto L48
L67:
    dec_ref r54
    goto L48

def _format_single_but_cache_checksums(type_str, value):
    type_str :: str
    value :: object
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4 :: object
    r5 :: bool
    r6 :: object[2]
    r7 :: object_ptr
    r8 :: object
    r9 :: str
    r10 :: i32
    r11 :: bit
    r12 :: bool
    r13 :: object
    r14 :: bool
    r15 :: object[2]
    r16 :: object_ptr
    r17 :: object
    r18 :: str
    r19 :: bool
    r20 :: object
    r21 :: bool
    r22 :: object[1]
    r23 :: object_ptr
    r24 :: object
    r25 :: str
    r26 :: bool
    r27 :: object
    r28 :: bool
    r29 :: object[1]
    r30 :: object_ptr
    r31 :: object
    r32 :: str
    r33 :: bool
    r34, r35, r36 :: object
    r37 :: str
    r38, r39, r40 :: object
    r41 :: tuple[object, object, object, object, object]
    r42 :: object
    r43 :: i32
    r44 :: bit
    r45 :: bool
    r46 :: union[str, bytes, object, int]
    r47 :: str
    r48 :: object
    r49 :: bool
    r50 :: object[1]
    r51 :: object_ptr
    r52 :: object
    r53 :: str
    r54 :: i32
    r55 :: bit
    r56 :: bool
    r57 :: object
    r58 :: bool
    r59 :: object[2]
    r60 :: object_ptr
    r61 :: object
    r62 :: str
    r63 :: i32
    r64 :: bit
    r65 :: bool
    r66 :: object
    r67 :: bool
    r68 :: object[1]
    r69 :: object_ptr
    r70 :: object
    r71, r72 :: str
    r73 :: object
    r74 :: str
    r75 :: object
    r76 :: object[1]
    r77 :: object_ptr
    r78, r79 :: object
L0:
    r0 = 'uint'
    r1 = PyUnicode_Contains(type_str, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L57 (error at _format_single_but_cache_checksums:377) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L2 else goto L7 :: bool
L2:
    r4 = dank_mids.brownie_patch.call.to_uint :: static
    if is_error(r4) goto L3 else goto L5
L3:
    r5 = raise NameError('value for final name "to_uint" was not set')
    if not r5 goto L57 (error at _format_single_but_cache_checksums:378) else goto L4 :: bool
L4:
    unreachable
L5:
    r6 = [value, type_str]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r4, r7, 2, 0)
    if is_error(r8) goto L57 (error at _format_single_but_cache_checksums:378) else goto L6
L6:
    return r8
L7:
    r9 = 'int'
    r10 = PyUnicode_Contains(type_str, r9)
    r11 = r10 >= 0 :: signed
    if not r11 goto L57 (error at _format_single_but_cache_checksums:379) else goto L8 :: bool
L8:
    r12 = truncate r10: i32 to builtins.bool
    if r12 goto L9 else goto L14 :: bool
L9:
    r13 = dank_mids.brownie_patch.call.to_int :: static
    if is_error(r13) goto L10 else goto L12
L10:
    r14 = raise NameError('value for final name "to_int" was not set')
    if not r14 goto L57 (error at _format_single_but_cache_checksums:380) else goto L11 :: bool
L11:
    unreachable
L12:
    r15 = [value, type_str]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r13, r16, 2, 0)
    if is_error(r17) goto L57 (error at _format_single_but_cache_checksums:380) else goto L13
L13:
    return r17
L14:
    r18 = 'fixed168x10'
    r19 = CPyStr_Equal(type_str, r18)
    if r19 goto L15 else goto L20 :: bool
L15:
    r20 = dank_mids.brownie_patch.call.to_decimal :: static
    if is_error(r20) goto L16 else goto L18
L16:
    r21 = raise NameError('value for final name "to_decimal" was not set')
    if not r21 goto L57 (error at _format_single_but_cache_checksums:382) else goto L17 :: bool
L17:
    unreachable
L18:
    r22 = [value]
    r23 = load_address r22
    r24 = PyObject_Vectorcall(r20, r23, 1, 0)
    if is_error(r24) goto L57 (error at _format_single_but_cache_checksums:382) else goto L19
L19:
    return r24
L20:
    r25 = 'bool'
    r26 = CPyStr_Equal(type_str, r25)
    if r26 goto L21 else goto L26 :: bool
L21:
    r27 = dank_mids.brownie_patch.call.to_bool :: static
    if is_error(r27) goto L22 else goto L24
L22:
    r28 = raise NameError('value for final name "to_bool" was not set')
    if not r28 goto L57 (error at _format_single_but_cache_checksums:384) else goto L23 :: bool
L23:
    unreachable
L24:
    r29 = [value]
    r30 = load_address r29
    r31 = PyObject_Vectorcall(r27, r30, 1, 0)
    if is_error(r31) goto L57 (error at _format_single_but_cache_checksums:384) else goto L25
L25:
    return r31
L26:
    r32 = 'address'
    r33 = CPyStr_Equal(type_str, r32)
    if r33 goto L27 else goto L38 :: bool
L27:
    r34 = load_address PyUnicode_Type
    r35 = load_address PyBytes_Type
    r36 = builtins :: module
    r37 = 'bytearray'
    r38 = CPyObject_GetAttr(r36, r37)
    if is_error(r38) goto L57 (error at _format_single_but_cache_checksums:388) else goto L28
L28:
    r39 = load_address PyLong_Type
    r40 = load_address PyBool_Type
    inc_ref r34
    inc_ref r35
    inc_ref r39
    inc_ref r40
    r41 = (r34, r35, r38, r39, r40)
    r42 = box(tuple[object, object, object, object, object], r41)
    r43 = PyObject_IsInstance(value, r42)
    dec_ref r42
    r44 = r43 >= 0 :: signed
    if not r44 goto L57 (error at _format_single_but_cache_checksums:388) else goto L29 :: bool
L29:
    r45 = truncate r43: i32 to builtins.bool
    if r45 goto L30 else goto L31 :: bool
L30:
    inc_ref value
    r46 = value
    goto L33
L31:
    r47 = PyObject_Str(value)
    if is_error(r47) goto L57 (error at _format_single_but_cache_checksums:388) else goto L32
L32:
    r46 = r47
L33:
    r48 = dank_mids.brownie_patch.call.to_checksum_address :: static
    if is_error(r48) goto L58 else goto L36
L34:
    r49 = raise NameError('value for final name "to_checksum_address" was not set')
    if not r49 goto L57 (error at _format_single_but_cache_checksums:387) else goto L35 :: bool
L35:
    unreachable
L36:
    r50 = [r46]
    r51 = load_address r50
    r52 = PyObject_Vectorcall(r48, r51, 1, 0)
    if is_error(r52) goto L59 (error at _format_single_but_cache_checksums:387) else goto L37
L37:
    dec_ref r46
    return r52
L38:
    r53 = 'byte'
    r54 = PyUnicode_Contains(type_str, r53)
    r55 = r54 >= 0 :: signed
    if not r55 goto L57 (error at _format_single_but_cache_checksums:390) else goto L39 :: bool
L39:
    r56 = truncate r54: i32 to builtins.bool
    if r56 goto L40 else goto L45 :: bool
L40:
    r57 = dank_mids.brownie_patch.call.HexString :: static
    if is_error(r57) goto L41 else goto L43
L41:
    r58 = raise NameError('value for final name "HexString" was not set')
    if not r58 goto L57 (error at _format_single_but_cache_checksums:391) else goto L42 :: bool
L42:
    unreachable
L43:
    r59 = [value, type_str]
    r60 = load_address r59
    r61 = PyObject_Vectorcall(r57, r60, 2, 0)
    if is_error(r61) goto L57 (error at _format_single_but_cache_checksums:391) else goto L44
L44:
    return r61
L45:
    r62 = 'string'
    r63 = PyUnicode_Contains(type_str, r62)
    r64 = r63 >= 0 :: signed
    if not r64 goto L57 (error at _format_single_but_cache_checksums:392) else goto L46 :: bool
L46:
    r65 = truncate r63: i32 to builtins.bool
    if r65 goto L47 else goto L52 :: bool
L47:
    r66 = dank_mids.brownie_patch.call.to_string :: static
    if is_error(r66) goto L48 else goto L50
L48:
    r67 = raise NameError('value for final name "to_string" was not set')
    if not r67 goto L57 (error at _format_single_but_cache_checksums:393) else goto L49 :: bool
L49:
    unreachable
L50:
    r68 = [value]
    r69 = load_address r68
    r70 = PyObject_Vectorcall(r66, r69, 1, 0)
    if is_error(r70) goto L57 (error at _format_single_but_cache_checksums:393) else goto L51
L51:
    return r70
L52:
    r71 = 'Unknown type: '
    r72 = CPyStr_Build(2, r71, type_str)
    if is_error(r72) goto L57 (error at _format_single_but_cache_checksums:394) else goto L53
L53:
    r73 = builtins :: module
    r74 = 'TypeError'
    r75 = CPyObject_GetAttr(r73, r74)
    if is_error(r75) goto L60 (error at _format_single_but_cache_checksums:394) else goto L54
L54:
    r76 = [r72]
    r77 = load_address r76
    r78 = PyObject_Vectorcall(r75, r77, 1, 0)
    dec_ref r75
    if is_error(r78) goto L60 (error at _format_single_but_cache_checksums:394) else goto L55
L55:
    dec_ref r72
    CPy_Raise(r78)
    dec_ref r78
    if not 0 goto L57 (error at _format_single_but_cache_checksums:394) else goto L56 :: bool
L56:
    unreachable
L57:
    r79 = <error> :: object
    return r79
L58:
    dec_ref r46
    goto L34
L59:
    dec_ref r46
    goto L57
L60:
    dec_ref r72
    goto L57

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: dict
    r30, r31 :: object
    r32 :: str
    r33 :: dict
    r34 :: object
    r35, r36, r37, r38, r39 :: object_ptr
    r40 :: object_ptr[5]
    r41 :: c_ptr
    r42 :: native_int[5]
    r43 :: c_ptr
    r44 :: object
    r45 :: dict
    r46, r47 :: str
    r48 :: bit
    r49 :: object
    r50 :: str
    r51 :: dict
    r52, r53 :: object
    r54 :: str
    r55 :: dict
    r56, r57 :: object
    r58 :: str
    r59 :: dict
    r60, r61 :: object
    r62 :: str
    r63 :: dict
    r64, r65 :: object
    r66 :: str
    r67 :: dict
    r68, r69 :: object
    r70 :: str
    r71 :: dict
    r72, r73 :: object
    r74 :: str
    r75 :: dict
    r76, r77 :: object
    r78 :: str
    r79 :: dict
    r80, r81 :: object
    r82 :: str
    r83 :: dict
    r84, r85 :: object
    r86 :: str
    r87 :: dict
    r88, r89 :: object
    r90 :: str
    r91 :: dict
    r92, r93 :: object
    r94 :: str
    r95 :: dict
    r96, r97 :: object
    r98 :: str
    r99 :: dict
    r100, r101, r102 :: object
    r103 :: str
    r104 :: dict
    r105, r106 :: object
    r107 :: str
    r108 :: dict
    r109, r110 :: object
    r111 :: str
    r112 :: dict
    r113, r114 :: object
    r115 :: str
    r116 :: dict
    r117, r118 :: object
    r119 :: str
    r120 :: dict
    r121, r122 :: object
    r123 :: bool
    r124 :: str
    r125 :: object
    r126 :: bool
    r127 :: dict
    r128 :: str
    r129 :: i32
    r130 :: bit
    r131 :: str
    r132 :: dict
    r133 :: str
    r134 :: object
    r135 :: object[1]
    r136 :: object_ptr
    r137 :: object
    r138 :: dict
    r139 :: str
    r140 :: i32
    r141 :: bit
    r142 :: str
    r143 :: object
    r144 :: dict
    r145 :: str
    r146 :: object
    r147 :: object[2]
    r148 :: object_ptr
    r149 :: object
    r150 :: dict
    r151 :: str
    r152 :: i32
    r153 :: bit
    r154 :: dict
    r155 :: str
    r156 :: object
    r157 :: dict
    r158 :: str
    r159, r160 :: object
    r161 :: dict
    r162 :: str
    r163 :: i32
    r164 :: bit
    r165 :: dict
    r166 :: str
    r167 :: object
    r168 :: dict
    r169 :: str
    r170 :: object
    r171 :: dict
    r172 :: str
    r173, r174 :: object
    r175 :: dict
    r176 :: str
    r177 :: object
    r178 :: dict
    r179 :: str
    r180, r181 :: object
    r182 :: tuple[object, object]
    r183, r184 :: object
    r185 :: tuple[object, object]
    r186, r187 :: object
    r188 :: dict
    r189 :: str
    r190 :: i32
    r191 :: bit
    r192 :: str
    r193 :: dict
    r194 :: str
    r195, r196 :: object
    r197 :: dict
    r198 :: str
    r199 :: object
    r200 :: tuple[object, object]
    r201, r202 :: object
    r203 :: dict
    r204 :: str
    r205 :: object
    r206 :: object[2]
    r207 :: object_ptr
    r208 :: object
    r209 :: dict
    r210 :: str
    r211 :: i32
    r212 :: bit
    r213 :: object
    r214 :: str
    r215 :: object
    r216 :: dict
    r217 :: str
    r218 :: i32
    r219 :: bit
    r220 :: dict
    r221 :: str
    r222 :: object
    r223 :: str
    r224 :: object
    r225 :: dict
    r226 :: str
    r227 :: i32
    r228 :: bit
    r229 :: dict
    r230 :: str
    r231 :: object
    r232 :: str
    r233 :: object
    r234 :: str
    r235 :: object
    r236 :: str
    r237 :: object
    r238 :: dict
    r239 :: str
    r240 :: i32
    r241 :: bit
    r242 :: dict
    r243 :: str
    r244 :: object
    r245 :: str
    r246 :: object
    r247 :: str
    r248 :: object
    r249 :: str
    r250 :: object
    r251 :: dict
    r252 :: str
    r253 :: i32
    r254 :: bit
    r255 :: dict
    r256 :: str
    r257 :: object
    r258 :: str
    r259 :: object
    r260 :: str
    r261 :: object
    r262 :: str
    r263 :: object
    r264 :: dict
    r265 :: str
    r266 :: i32
    r267 :: bit
    r268 :: dict
    r269 :: str
    r270 :: object
    r271 :: str
    r272 :: object
    r273 :: str
    r274 :: object
    r275 :: str
    r276 :: object
    r277 :: dict
    r278 :: str
    r279 :: i32
    r280 :: bit
    r281 :: dict
    r282 :: str
    r283 :: object
    r284 :: str
    r285 :: object
    r286 :: dict
    r287 :: str
    r288 :: i32
    r289 :: bit
    r290 :: dict
    r291 :: str
    r292 :: object
    r293 :: str
    r294 :: object
    r295 :: str
    r296 :: object
    r297 :: str
    r298 :: object
    r299 :: dict
    r300 :: str
    r301 :: i32
    r302 :: bit
    r303 :: dict
    r304 :: str
    r305 :: object
    r306 :: str
    r307 :: object
    r308 :: str
    r309 :: object
    r310 :: str
    r311 :: object
    r312 :: dict
    r313 :: str
    r314 :: i32
    r315 :: bit
    r316 :: dict
    r317 :: str
    r318 :: object
    r319 :: str
    r320 :: object
    r321 :: str
    r322 :: object
    r323 :: str
    r324 :: object
    r325 :: dict
    r326 :: str
    r327 :: i32
    r328 :: bit
    r329 :: dict
    r330 :: str
    r331 :: object
    r332 :: str
    r333 :: object
    r334 :: str
    r335 :: object
    r336 :: str
    r337 :: object
    r338 :: dict
    r339 :: str
    r340 :: i32
    r341 :: bit
    r342 :: dict
    r343 :: str
    r344 :: object
    r345 :: str
    r346 :: object
    r347 :: str
    r348 :: object
    r349 :: str
    r350 :: object
    r351 :: dict
    r352 :: str
    r353 :: i32
    r354 :: bit
    r355 :: dict
    r356 :: str
    r357 :: object
    r358 :: str
    r359 :: object
    r360 :: str
    r361 :: object
    r362 :: str
    r363 :: object
    r364 :: dict
    r365 :: str
    r366 :: i32
    r367 :: bit
    r368 :: dict
    r369 :: str
    r370 :: object
    r371 :: str
    r372 :: object
    r373 :: str
    r374 :: object
    r375 :: str
    r376 :: object
    r377 :: dict
    r378 :: str
    r379 :: i32
    r380 :: bit
    r381 :: dict
    r382 :: str
    r383 :: object
    r384 :: str
    r385 :: object
    r386 :: bool
    r387 :: object[1]
    r388 :: object_ptr
    r389 :: object
    r390 :: dict
    r391 :: str
    r392 :: i32
    r393 :: bit
    r394 :: dank_mids.brownie_patch.call.__mypyc_lambda__0_obj
    r395 :: dict
    r396 :: str
    r397 :: i32
    r398 :: bit
    r399 :: dank_mids.brownie_patch.call.__mypyc_lambda__1_obj
    r400 :: dict
    r401 :: str
    r402 :: i32
    r403 :: bit
    r404 :: dict
    r405 :: str
    r406 :: object
    r407 :: str
    r408 :: object
    r409 :: dict
    r410 :: str
    r411 :: i32
    r412 :: bit
    r413 :: dict
    r414 :: str
    r415 :: object
    r416 :: dict
    r417 :: str
    r418 :: object
    r419 :: object[1]
    r420 :: object_ptr
    r421 :: object
    r422 :: dict
    r423 :: str
    r424 :: i32
    r425 :: bit
    r426 :: dict
    r427 :: str
    r428 :: object
    r429 :: str
    r430 :: object
    r431 :: dict
    r432 :: str
    r433 :: i32
    r434 :: bit
    r435 :: dict
    r436 :: str
    r437 :: object
    r438 :: str
    r439 :: object
    r440 :: dict
    r441 :: str
    r442 :: i32
    r443 :: bit
    r444 :: str
    r445 :: set
    r446 :: i32
    r447 :: bit
    r448 :: dict
    r449 :: str
    r450 :: i32
    r451 :: bit
    r452 :: dict
    r453 :: str
    r454 :: object
    r455 :: str
    r456 :: object
    r457 :: dict
    r458 :: str
    r459 :: i32
    r460 :: bit
    r461 :: tuple[object, object, object]
    r462 :: object
    r463 :: str
    r464 :: object
    r465 :: bit
    r466 :: dict
    r467 :: str
    r468 :: object
    r469 :: i32
    r470 :: bit
    r471 :: str
    r472 :: dict
    r473 :: str
    r474 :: object
    r475 :: str
    r476 :: i32
    r477 :: bit
    r478, r479 :: bool
    r480 :: bit
    r481 :: dict
    r482 :: str
    r483 :: object
    r484 :: dict
    r485 :: str
    r486 :: object
    r487 :: str
    r488 :: object
    r489 :: object[3]
    r490 :: object_ptr
    r491 :: object
    r492 :: dict
    r493 :: str
    r494 :: i32
    r495 :: bit
    r496 :: i32
    r497 :: bit
    r498 :: bool
    r499 :: dict
    r500 :: str
    r501 :: object
    r502 :: set
    r503 :: dict
    r504 :: str
    r505, r506 :: object
    r507 :: bool
    r508 :: object[1]
    r509 :: object_ptr
    r510 :: object
    r511 :: i32
    r512 :: bit
    r513 :: dict
    r514 :: str
    r515 :: object
    r516 :: dict
    r517 :: str
    r518 :: object
    r519 :: str
    r520 :: object
    r521 :: str
    r522 :: object
    r523 :: str
    r524 :: i32
    r525 :: bit
    r526 :: dict
    r527 :: str
    r528 :: object
    r529 :: dict
    r530 :: str
    r531 :: object
    r532 :: str
    r533 :: object
    r534 :: str
    r535 :: object
    r536 :: str
    r537 :: i32
    r538 :: bit
    r539 :: dict
    r540 :: str
    r541 :: object
    r542 :: dict
    r543 :: str
    r544 :: object
    r545 :: str
    r546 :: object
    r547 :: str
    r548 :: object
    r549 :: str
    r550 :: i32
    r551 :: bit
    r552 :: dict
    r553 :: str
    r554 :: object
    r555 :: dict
    r556 :: str
    r557 :: object
    r558 :: str
    r559 :: object
    r560 :: str
    r561 :: object
    r562 :: str
    r563 :: i32
    r564 :: bit
    r565 :: dict
    r566 :: str
    r567 :: object
    r568 :: dict
    r569 :: str
    r570 :: object
    r571 :: str
    r572 :: object
    r573 :: str
    r574 :: object
    r575 :: str
    r576 :: i32
    r577 :: bit
    r578 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L208 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address decimal :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('decimal', 'decimal', 'decimal'),)
    r11 = dank_mids.brownie_patch.call.globals :: static
    r12 = 'dank_mids/brownie_patch/call.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L208 else goto L4 :: bool
L4:
    r15 = ('BrokenProcessPool',)
    r16 = 'concurrent.futures.process'
    r17 = dank_mids.brownie_patch.call.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L208 (error at <module>:2) else goto L5
L5:
    concurrent.futures.process = r18 :: module
    dec_ref r18
    r19 = ('Logger',)
    r20 = 'logging'
    r21 = dank_mids.brownie_patch.call.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L208 (error at <module>:3) else goto L6
L6:
    logging = r22 :: module
    dec_ref r22
    r23 = ('PicklingError',)
    r24 = 'pickle'
    r25 = dank_mids.brownie_patch.call.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L208 (error at <module>:4) else goto L7
L7:
    pickle = r26 :: module
    dec_ref r26
    r27 = ('MethodType',)
    r28 = 'types'
    r29 = dank_mids.brownie_patch.call.globals :: static
    r30 = CPyImport_ImportFromMany(r28, r27, r27, r29)
    if is_error(r30) goto L208 (error at <module>:5) else goto L8
L8:
    types = r30 :: module
    dec_ref r30
    r31 = ('TYPE_CHECKING', 'Any', 'Callable', 'Dict', 'Final', 'List', 'NewType', 'Optional', 'Sequence', 'Tuple', 'TypeVar', 'Union')
    r32 = 'typing'
    r33 = dank_mids.brownie_patch.call.globals :: static
    r34 = CPyImport_ImportFromMany(r32, r31, r31, r33)
    if is_error(r34) goto L208 (error at <module>:6) else goto L9
L9:
    typing = r34 :: module
    dec_ref r34
    r35 = load_address brownie.convert.datatypes :: module
    r36 = load_address brownie.convert.normalize :: module
    r37 = load_address brownie.network.contract :: module
    r38 = load_address faster_eth_abi :: module
    r39 = load_address hexbytes :: module
    r40 = [r35, r36, r37, r38, r39]
    r41 = load_address r40
    r42 = [21, 22, 23, 24, 25]
    r43 = load_address r42
    r44 = (('brownie.convert.datatypes', 'brownie', 'brownie'), ('brownie.convert.normalize', 'brownie', 'brownie'), ('brownie.network.contract', 'brownie', 'brownie'), ('faster_eth_abi', 'faster_eth_abi', 'faster_eth_abi'), ('hexbytes', 'hexbytes', 'hexbytes'))
    r45 = dank_mids.brownie_patch.call.globals :: static
    r46 = 'dank_mids/brownie_patch/call.py'
    r47 = '<module>'
    r48 = CPyImport_ImportMany(r44, r41, r45, r46, r47, r43)
    if not r48 goto L208 else goto L10 :: bool
L10:
    r49 = ('AsyncProcessPoolExecutor',)
    r50 = 'a_sync'
    r51 = dank_mids.brownie_patch.call.globals :: static
    r52 = CPyImport_ImportFromMany(r50, r49, r49, r51)
    if is_error(r52) goto L208 (error at <module>:26) else goto L11
L11:
    a_sync = r52 :: module
    dec_ref r52
    r53 = ('chain',)
    r54 = 'brownie'
    r55 = dank_mids.brownie_patch.call.globals :: static
    r56 = CPyImport_ImportFromMany(r54, r53, r53, r55)
    if is_error(r56) goto L208 (error at <module>:27) else goto L12
L12:
    brownie = r56 :: module
    dec_ref r56
    r57 = ('ABIType',)
    r58 = 'brownie.convert.normalize'
    r59 = dank_mids.brownie_patch.call.globals :: static
    r60 = CPyImport_ImportFromMany(r58, r57, r57, r59)
    if is_error(r60) goto L208 (error at <module>:28) else goto L13
L13:
    brownie.convert.normalize = r60 :: module
    dec_ref r60
    r61 = ('get_type_strings',)
    r62 = 'brownie.convert.utils'
    r63 = dank_mids.brownie_patch.call.globals :: static
    r64 = CPyImport_ImportFromMany(r62, r61, r61, r63)
    if is_error(r64) goto L208 (error at <module>:29) else goto L14
L14:
    brownie.convert.utils = r64 :: module
    dec_ref r64
    r65 = ('VirtualMachineError',)
    r66 = 'brownie.exceptions'
    r67 = dank_mids.brownie_patch.call.globals :: static
    r68 = CPyImport_ImportFromMany(r66, r65, r65, r67)
    if is_error(r68) goto L208 (error at <module>:30) else goto L15
L15:
    brownie.exceptions = r68 :: module
    dec_ref r68
    r69 = ('ContractCall',)
    r70 = 'brownie.network.contract'
    r71 = dank_mids.brownie_patch.call.globals :: static
    r72 = CPyImport_ImportFromMany(r70, r69, r69, r71)
    if is_error(r72) goto L208 (error at <module>:31) else goto L16
L16:
    brownie.network.contract = r72 :: module
    dec_ref r72
    r73 = ('SOLIDITY_ERROR_CODES',)
    r74 = 'brownie.project.compiler.solidity'
    r75 = dank_mids.brownie_patch.call.globals :: static
    r76 = CPyImport_ImportFromMany(r74, r73, r73, r75)
    if is_error(r76) goto L208 (error at <module>:32) else goto L17
L17:
    brownie.project.compiler.solidity = r76 :: module
    dec_ref r76
    r77 = ('DecodingError', 'InsufficientDataBytes')
    r78 = 'faster_eth_abi.exceptions'
    r79 = dank_mids.brownie_patch.call.globals :: static
    r80 = CPyImport_ImportFromMany(r78, r77, r77, r79)
    if is_error(r80) goto L208 (error at <module>:33) else goto L18
L18:
    faster_eth_abi.exceptions = r80 :: module
    dec_ref r80
    r81 = ('HexStr',)
    r82 = 'eth_typing'
    r83 = dank_mids.brownie_patch.call.globals :: static
    r84 = CPyImport_ImportFromMany(r82, r81, r81, r83)
    if is_error(r84) goto L208 (error at <module>:34) else goto L19
L19:
    eth_typing = r84 :: module
    dec_ref r84
    r85 = ('Address',)
    r86 = 'evmspec.data'
    r87 = dank_mids.brownie_patch.call.globals :: static
    r88 = CPyImport_ImportFromMany(r86, r85, r85, r87)
    if is_error(r88) goto L208 (error at <module>:35) else goto L20
L20:
    evmspec.data = r88 :: module
    dec_ref r88
    r89 = ('BytesLike',)
    r90 = 'hexbytes.main'
    r91 = dank_mids.brownie_patch.call.globals :: static
    r92 = CPyImport_ImportFromMany(r90, r89, r89, r91)
    if is_error(r92) goto L208 (error at <module>:36) else goto L21
L21:
    hexbytes.main = r92 :: module
    dec_ref r92
    r93 = ('MULTICALL2_ADDRESSES',)
    r94 = 'multicall.constants'
    r95 = dank_mids.brownie_patch.call.globals :: static
    r96 = CPyImport_ImportFromMany(r94, r93, r93, r95)
    if is_error(r96) goto L208 (error at <module>:37) else goto L22
L22:
    multicall.constants = r96 :: module
    dec_ref r96
    r97 = ('BlockIdentifier',)
    r98 = 'web3.types'
    r99 = dank_mids.brownie_patch.call.globals :: static
    r100 = CPyImport_ImportFromMany(r98, r97, r97, r99)
    if is_error(r100) goto L208 (error at <module>:38) else goto L23
L23:
    web3.types = r100 :: module
    dec_ref r100
    r101 = ('ENVIRONMENT_VARIABLES',)
    r102 = ('ENVS',)
    r103 = 'dank_mids'
    r104 = dank_mids.brownie_patch.call.globals :: static
    r105 = CPyImport_ImportFromMany(r103, r101, r102, r104)
    if is_error(r105) goto L208 (error at <module>:40) else goto L24
L24:
    dank_mids = r105 :: module
    dec_ref r105
    r106 = ('exceptions',)
    r107 = 'dank_mids'
    r108 = dank_mids.brownie_patch.call.globals :: static
    r109 = CPyImport_ImportFromMany(r107, r106, r106, r108)
    if is_error(r109) goto L208 (error at <module>:41) else goto L25
L25:
    dank_mids = r109 :: module
    dec_ref r109
    r110 = ('getLogger',)
    r111 = 'dank_mids._logging'
    r112 = dank_mids.brownie_patch.call.globals :: static
    r113 = CPyImport_ImportFromMany(r111, r110, r110, r112)
    if is_error(r113) goto L208 (error at <module>:42) else goto L26
L26:
    dank_mids._logging = r113 :: module
    dec_ref r113
    r114 = ('lru_cache_lite_nonull',)
    r115 = 'dank_mids.helpers.lru_cache'
    r116 = dank_mids.brownie_patch.call.globals :: static
    r117 = CPyImport_ImportFromMany(r115, r114, r114, r116)
    if is_error(r117) goto L208 (error at <module>:43) else goto L27
L27:
    dank_mids.helpers.lru_cache = r117 :: module
    dec_ref r117
    r118 = ('DankWeb3',)
    r119 = 'dank_mids.helpers._helpers'
    r120 = dank_mids.brownie_patch.call.globals :: static
    r121 = CPyImport_ImportFromMany(r119, r118, r118, r120)
    if is_error(r121) goto L208 (error at <module>:44) else goto L28
L28:
    dank_mids.helpers._helpers = r121 :: module
    dec_ref r121
    if 0 goto L29 else goto L29 :: bool
L29:
    r122 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r122) goto L30 else goto L32
L30:
    r123 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r123 goto L208 (error at <module>:50) else goto L31 :: bool
L31:
    unreachable
L32:
    r124 = 'application'
    r125 = CPyObject_GetAttr(r122, r124)
    if is_error(r125) goto L208 (error at <module>:50) else goto L33
L33:
    r126 = unbox(bool, r125)
    if is_error(r126) goto L209 (error at <module>:50) else goto L34
L34:
    dank_mids.brownie_patch.call.APPLICATION_MODE = r126 :: static
    r127 = dank_mids.brownie_patch.call.globals :: static
    r128 = 'APPLICATION_MODE'
    r129 = CPyDict_SetItem(r127, r128, r125)
    dec_ref r125
    r130 = r129 >= 0 :: signed
    if not r130 goto L208 (error at <module>:50) else goto L35 :: bool
L35:
    r131 = '_T'
    r132 = dank_mids.brownie_patch.call.globals :: static
    r133 = 'TypeVar'
    r134 = CPyDict_GetItem(r132, r133)
    if is_error(r134) goto L208 (error at <module>:53) else goto L36
L36:
    r135 = [r131]
    r136 = load_address r135
    r137 = PyObject_Vectorcall(r134, r136, 1, 0)
    dec_ref r134
    if is_error(r137) goto L208 (error at <module>:53) else goto L37
L37:
    r138 = dank_mids.brownie_patch.call.globals :: static
    r139 = '_T'
    r140 = CPyDict_SetItem(r138, r139, r137)
    dec_ref r137
    r141 = r140 >= 0 :: signed
    if not r141 goto L208 (error at <module>:53) else goto L38 :: bool
L38:
    r142 = 'TypeStr'
    r143 = load_address PyUnicode_Type
    r144 = dank_mids.brownie_patch.call.globals :: static
    r145 = 'NewType'
    r146 = CPyDict_GetItem(r144, r145)
    if is_error(r146) goto L208 (error at <module>:54) else goto L39
L39:
    r147 = [r142, r143]
    r148 = load_address r147
    r149 = PyObject_Vectorcall(r146, r148, 2, 0)
    dec_ref r146
    if is_error(r149) goto L208 (error at <module>:54) else goto L40
L40:
    r150 = dank_mids.brownie_patch.call.globals :: static
    r151 = 'TypeStr'
    r152 = CPyDict_SetItem(r150, r151, r149)
    dec_ref r149
    r153 = r152 >= 0 :: signed
    if not r153 goto L208 (error at <module>:54) else goto L41 :: bool
L41:
    r154 = dank_mids.brownie_patch.call.globals :: static
    r155 = 'List'
    r156 = CPyDict_GetItem(r154, r155)
    if is_error(r156) goto L208 (error at <module>:55) else goto L42
L42:
    r157 = dank_mids.brownie_patch.call.globals :: static
    r158 = 'TypeStr'
    r159 = CPyDict_GetItem(r157, r158)
    if is_error(r159) goto L210 (error at <module>:55) else goto L43
L43:
    r160 = PyObject_GetItem(r156, r159)
    dec_ref r156
    dec_ref r159
    if is_error(r160) goto L208 (error at <module>:55) else goto L44
L44:
    r161 = dank_mids.brownie_patch.call.globals :: static
    r162 = 'TypeStrs'
    r163 = CPyDict_SetItem(r161, r162, r160)
    dec_ref r160
    r164 = r163 >= 0 :: signed
    if not r164 goto L208 (error at <module>:55) else goto L45 :: bool
L45:
    r165 = dank_mids.brownie_patch.call.globals :: static
    r166 = 'Union'
    r167 = CPyDict_GetItem(r165, r166)
    if is_error(r167) goto L208 (error at <module>:56) else goto L46
L46:
    r168 = dank_mids.brownie_patch.call.globals :: static
    r169 = 'List'
    r170 = CPyDict_GetItem(r168, r169)
    if is_error(r170) goto L211 (error at <module>:56) else goto L47
L47:
    r171 = dank_mids.brownie_patch.call.globals :: static
    r172 = '_T'
    r173 = CPyDict_GetItem(r171, r172)
    if is_error(r173) goto L212 (error at <module>:56) else goto L48
L48:
    r174 = PyObject_GetItem(r170, r173)
    dec_ref r170
    dec_ref r173
    if is_error(r174) goto L211 (error at <module>:56) else goto L49
L49:
    r175 = dank_mids.brownie_patch.call.globals :: static
    r176 = 'Tuple'
    r177 = CPyDict_GetItem(r175, r176)
    if is_error(r177) goto L213 (error at <module>:56) else goto L50
L50:
    r178 = dank_mids.brownie_patch.call.globals :: static
    r179 = '_T'
    r180 = CPyDict_GetItem(r178, r179)
    if is_error(r180) goto L214 (error at <module>:56) else goto L51
L51:
    r181 = load_address _Py_EllipsisObject
    inc_ref r181
    r182 = (r180, r181)
    r183 = box(tuple[object, object], r182)
    r184 = PyObject_GetItem(r177, r183)
    dec_ref r177
    dec_ref r183
    if is_error(r184) goto L213 (error at <module>:56) else goto L52
L52:
    r185 = (r174, r184)
    r186 = box(tuple[object, object], r185)
    r187 = PyObject_GetItem(r167, r186)
    dec_ref r167
    dec_ref r186
    if is_error(r187) goto L208 (error at <module>:56) else goto L53
L53:
    r188 = dank_mids.brownie_patch.call.globals :: static
    r189 = 'ListOrTuple'
    r190 = CPyDict_SetItem(r188, r189, r187)
    dec_ref r187
    r191 = r190 >= 0 :: signed
    if not r191 goto L208 (error at <module>:56) else goto L54 :: bool
L54:
    r192 = 'AbiDict'
    r193 = dank_mids.brownie_patch.call.globals :: static
    r194 = 'Dict'
    r195 = CPyDict_GetItem(r193, r194)
    if is_error(r195) goto L208 (error at <module>:57) else goto L55
L55:
    r196 = load_address PyUnicode_Type
    r197 = dank_mids.brownie_patch.call.globals :: static
    r198 = 'Any'
    r199 = CPyDict_GetItem(r197, r198)
    if is_error(r199) goto L215 (error at <module>:57) else goto L56
L56:
    inc_ref r196
    r200 = (r196, r199)
    r201 = box(tuple[object, object], r200)
    r202 = PyObject_GetItem(r195, r201)
    dec_ref r195
    dec_ref r201
    if is_error(r202) goto L208 (error at <module>:57) else goto L57
L57:
    r203 = dank_mids.brownie_patch.call.globals :: static
    r204 = 'NewType'
    r205 = CPyDict_GetItem(r203, r204)
    if is_error(r205) goto L216 (error at <module>:57) else goto L58
L58:
    r206 = [r192, r202]
    r207 = load_address r206
    r208 = PyObject_Vectorcall(r205, r207, 2, 0)
    dec_ref r205
    if is_error(r208) goto L216 (error at <module>:57) else goto L59
L59:
    dec_ref r202
    r209 = dank_mids.brownie_patch.call.globals :: static
    r210 = 'AbiDict'
    r211 = CPyDict_SetItem(r209, r210, r208)
    dec_ref r208
    r212 = r211 >= 0 :: signed
    if not r212 goto L208 (error at <module>:57) else goto L60 :: bool
L60:
    r213 = decimal :: module
    r214 = 'Decimal'
    r215 = CPyObject_GetAttr(r213, r214)
    if is_error(r215) goto L208 (error at <module>:61) else goto L61
L61:
    dank_mids.brownie_patch.call.Decimal = r215 :: static
    r216 = dank_mids.brownie_patch.call.globals :: static
    r217 = 'Decimal'
    r218 = CPyDict_SetItem(r216, r217, r215)
    dec_ref r215
    r219 = r218 >= 0 :: signed
    if not r219 goto L208 (error at <module>:61) else goto L62 :: bool
L62:
    r220 = dank_mids.brownie_patch.call.globals :: static
    r221 = 'hexbytes'
    r222 = CPyDict_GetItem(r220, r221)
    if is_error(r222) goto L208 (error at <module>:62) else goto L63
L63:
    r223 = 'HexBytes'
    r224 = CPyObject_GetAttr(r222, r223)
    dec_ref r222
    if is_error(r224) goto L208 (error at <module>:62) else goto L64
L64:
    dank_mids.brownie_patch.call.HexBytes = r224 :: static
    r225 = dank_mids.brownie_patch.call.globals :: static
    r226 = 'HexBytes'
    r227 = CPyDict_SetItem(r225, r226, r224)
    dec_ref r224
    r228 = r227 >= 0 :: signed
    if not r228 goto L208 (error at <module>:62) else goto L65 :: bool
L65:
    r229 = dank_mids.brownie_patch.call.globals :: static
    r230 = 'brownie'
    r231 = CPyDict_GetItem(r229, r230)
    if is_error(r231) goto L208 (error at <module>:63) else goto L66
L66:
    r232 = 'network'
    r233 = CPyObject_GetAttr(r231, r232)
    dec_ref r231
    if is_error(r233) goto L208 (error at <module>:63) else goto L67
L67:
    r234 = 'contract'
    r235 = CPyObject_GetAttr(r233, r234)
    dec_ref r233
    if is_error(r235) goto L208 (error at <module>:63) else goto L68
L68:
    r236 = 'Contract'
    r237 = CPyObject_GetAttr(r235, r236)
    dec_ref r235
    if is_error(r237) goto L208 (error at <module>:63) else goto L69
L69:
    dank_mids.brownie_patch.call.Contract = r237 :: static
    r238 = dank_mids.brownie_patch.call.globals :: static
    r239 = 'Contract'
    r240 = CPyDict_SetItem(r238, r239, r237)
    dec_ref r237
    r241 = r240 >= 0 :: signed
    if not r241 goto L208 (error at <module>:63) else goto L70 :: bool
L70:
    r242 = dank_mids.brownie_patch.call.globals :: static
    r243 = 'brownie'
    r244 = CPyDict_GetItem(r242, r243)
    if is_error(r244) goto L208 (error at <module>:64) else goto L71
L71:
    r245 = 'convert'
    r246 = CPyObject_GetAttr(r244, r245)
    dec_ref r244
    if is_error(r246) goto L208 (error at <module>:64) else goto L72
L72:
    r247 = 'datatypes'
    r248 = CPyObject_GetAttr(r246, r247)
    dec_ref r246
    if is_error(r248) goto L208 (error at <module>:64) else goto L73
L73:
    r249 = 'ReturnValue'
    r250 = CPyObject_GetAttr(r248, r249)
    dec_ref r248
    if is_error(r250) goto L208 (error at <module>:64) else goto L74
L74:
    dank_mids.brownie_patch.call.ReturnValue = r250 :: static
    r251 = dank_mids.brownie_patch.call.globals :: static
    r252 = 'ReturnValue'
    r253 = CPyDict_SetItem(r251, r252, r250)
    dec_ref r250
    r254 = r253 >= 0 :: signed
    if not r254 goto L208 (error at <module>:64) else goto L75 :: bool
L75:
    r255 = dank_mids.brownie_patch.call.globals :: static
    r256 = 'brownie'
    r257 = CPyDict_GetItem(r255, r256)
    if is_error(r257) goto L208 (error at <module>:65) else goto L76
L76:
    r258 = 'convert'
    r259 = CPyObject_GetAttr(r257, r258)
    dec_ref r257
    if is_error(r259) goto L208 (error at <module>:65) else goto L77
L77:
    r260 = 'normalize'
    r261 = CPyObject_GetAttr(r259, r260)
    dec_ref r259
    if is_error(r261) goto L208 (error at <module>:65) else goto L78
L78:
    r262 = 'HexString'
    r263 = CPyObject_GetAttr(r261, r262)
    dec_ref r261
    if is_error(r263) goto L208 (error at <module>:65) else goto L79
L79:
    dank_mids.brownie_patch.call.HexString = r263 :: static
    r264 = dank_mids.brownie_patch.call.globals :: static
    r265 = 'HexString'
    r266 = CPyDict_SetItem(r264, r265, r263)
    dec_ref r263
    r267 = r266 >= 0 :: signed
    if not r267 goto L208 (error at <module>:65) else goto L80 :: bool
L80:
    r268 = dank_mids.brownie_patch.call.globals :: static
    r269 = 'brownie'
    r270 = CPyDict_GetItem(r268, r269)
    if is_error(r270) goto L208 (error at <module>:66) else goto L81
L81:
    r271 = 'convert'
    r272 = CPyObject_GetAttr(r270, r271)
    dec_ref r270
    if is_error(r272) goto L208 (error at <module>:66) else goto L82
L82:
    r273 = 'normalize'
    r274 = CPyObject_GetAttr(r272, r273)
    dec_ref r272
    if is_error(r274) goto L208 (error at <module>:66) else goto L83
L83:
    r275 = 'TupleType'
    r276 = CPyObject_GetAttr(r274, r275)
    dec_ref r274
    if is_error(r276) goto L208 (error at <module>:66) else goto L84
L84:
    dank_mids.brownie_patch.call.TupleType = r276 :: static
    r277 = dank_mids.brownie_patch.call.globals :: static
    r278 = 'TupleType'
    r279 = CPyDict_SetItem(r277, r278, r276)
    dec_ref r276
    r280 = r279 >= 0 :: signed
    if not r280 goto L208 (error at <module>:66) else goto L85 :: bool
L85:
    r281 = dank_mids.brownie_patch.call.globals :: static
    r282 = 'exceptions'
    r283 = CPyDict_GetItem(r281, r282)
    if is_error(r283) goto L208 (error at <module>:68) else goto L86
L86:
    r284 = 'Revert'
    r285 = CPyObject_GetAttr(r283, r284)
    dec_ref r283
    if is_error(r285) goto L208 (error at <module>:68) else goto L87
L87:
    dank_mids.brownie_patch.call.Revert = r285 :: static
    r286 = dank_mids.brownie_patch.call.globals :: static
    r287 = 'Revert'
    r288 = CPyDict_SetItem(r286, r287, r285)
    dec_ref r285
    r289 = r288 >= 0 :: signed
    if not r289 goto L208 (error at <module>:68) else goto L88 :: bool
L88:
    r290 = dank_mids.brownie_patch.call.globals :: static
    r291 = 'brownie'
    r292 = CPyDict_GetItem(r290, r291)
    if is_error(r292) goto L208 (error at <module>:70) else goto L89
L89:
    r293 = 'convert'
    r294 = CPyObject_GetAttr(r292, r293)
    dec_ref r292
    if is_error(r294) goto L208 (error at <module>:70) else goto L90
L90:
    r295 = 'normalize'
    r296 = CPyObject_GetAttr(r294, r295)
    dec_ref r294
    if is_error(r296) goto L208 (error at <module>:70) else goto L91
L91:
    r297 = 'to_bool'
    r298 = CPyObject_GetAttr(r296, r297)
    dec_ref r296
    if is_error(r298) goto L208 (error at <module>:70) else goto L92
L92:
    dank_mids.brownie_patch.call.to_bool = r298 :: static
    r299 = dank_mids.brownie_patch.call.globals :: static
    r300 = 'to_bool'
    r301 = CPyDict_SetItem(r299, r300, r298)
    dec_ref r298
    r302 = r301 >= 0 :: signed
    if not r302 goto L208 (error at <module>:70) else goto L93 :: bool
L93:
    r303 = dank_mids.brownie_patch.call.globals :: static
    r304 = 'brownie'
    r305 = CPyDict_GetItem(r303, r304)
    if is_error(r305) goto L208 (error at <module>:71) else goto L94
L94:
    r306 = 'convert'
    r307 = CPyObject_GetAttr(r305, r306)
    dec_ref r305
    if is_error(r307) goto L208 (error at <module>:71) else goto L95
L95:
    r308 = 'normalize'
    r309 = CPyObject_GetAttr(r307, r308)
    dec_ref r307
    if is_error(r309) goto L208 (error at <module>:71) else goto L96
L96:
    r310 = 'to_decimal'
    r311 = CPyObject_GetAttr(r309, r310)
    dec_ref r309
    if is_error(r311) goto L208 (error at <module>:71) else goto L97
L97:
    dank_mids.brownie_patch.call.to_decimal = r311 :: static
    r312 = dank_mids.brownie_patch.call.globals :: static
    r313 = 'to_decimal'
    r314 = CPyDict_SetItem(r312, r313, r311)
    dec_ref r311
    r315 = r314 >= 0 :: signed
    if not r315 goto L208 (error at <module>:71) else goto L98 :: bool
L98:
    r316 = dank_mids.brownie_patch.call.globals :: static
    r317 = 'brownie'
    r318 = CPyDict_GetItem(r316, r317)
    if is_error(r318) goto L208 (error at <module>:72) else goto L99
L99:
    r319 = 'convert'
    r320 = CPyObject_GetAttr(r318, r319)
    dec_ref r318
    if is_error(r320) goto L208 (error at <module>:72) else goto L100
L100:
    r321 = 'normalize'
    r322 = CPyObject_GetAttr(r320, r321)
    dec_ref r320
    if is_error(r322) goto L208 (error at <module>:72) else goto L101
L101:
    r323 = 'to_int'
    r324 = CPyObject_GetAttr(r322, r323)
    dec_ref r322
    if is_error(r324) goto L208 (error at <module>:72) else goto L102
L102:
    dank_mids.brownie_patch.call.to_int = r324 :: static
    r325 = dank_mids.brownie_patch.call.globals :: static
    r326 = 'to_int'
    r327 = CPyDict_SetItem(r325, r326, r324)
    dec_ref r324
    r328 = r327 >= 0 :: signed
    if not r328 goto L208 (error at <module>:72) else goto L103 :: bool
L103:
    r329 = dank_mids.brownie_patch.call.globals :: static
    r330 = 'brownie'
    r331 = CPyDict_GetItem(r329, r330)
    if is_error(r331) goto L208 (error at <module>:73) else goto L104
L104:
    r332 = 'convert'
    r333 = CPyObject_GetAttr(r331, r332)
    dec_ref r331
    if is_error(r333) goto L208 (error at <module>:73) else goto L105
L105:
    r334 = 'normalize'
    r335 = CPyObject_GetAttr(r333, r334)
    dec_ref r333
    if is_error(r335) goto L208 (error at <module>:73) else goto L106
L106:
    r336 = 'to_string'
    r337 = CPyObject_GetAttr(r335, r336)
    dec_ref r335
    if is_error(r337) goto L208 (error at <module>:73) else goto L107
L107:
    dank_mids.brownie_patch.call.to_string = r337 :: static
    r338 = dank_mids.brownie_patch.call.globals :: static
    r339 = 'to_string'
    r340 = CPyDict_SetItem(r338, r339, r337)
    dec_ref r337
    r341 = r340 >= 0 :: signed
    if not r341 goto L208 (error at <module>:73) else goto L108 :: bool
L108:
    r342 = dank_mids.brownie_patch.call.globals :: static
    r343 = 'brownie'
    r344 = CPyDict_GetItem(r342, r343)
    if is_error(r344) goto L208 (error at <module>:74) else goto L109
L109:
    r345 = 'convert'
    r346 = CPyObject_GetAttr(r344, r345)
    dec_ref r344
    if is_error(r346) goto L208 (error at <module>:74) else goto L110
L110:
    r347 = 'normalize'
    r348 = CPyObject_GetAttr(r346, r347)
    dec_ref r346
    if is_error(r348) goto L208 (error at <module>:74) else goto L111
L111:
    r349 = 'to_uint'
    r350 = CPyObject_GetAttr(r348, r349)
    dec_ref r348
    if is_error(r350) goto L208 (error at <module>:74) else goto L112
L112:
    dank_mids.brownie_patch.call.to_uint = r350 :: static
    r351 = dank_mids.brownie_patch.call.globals :: static
    r352 = 'to_uint'
    r353 = CPyDict_SetItem(r351, r352, r350)
    dec_ref r350
    r354 = r353 >= 0 :: signed
    if not r354 goto L208 (error at <module>:74) else goto L113 :: bool
L113:
    r355 = dank_mids.brownie_patch.call.globals :: static
    r356 = 'brownie'
    r357 = CPyDict_GetItem(r355, r356)
    if is_error(r357) goto L208 (error at <module>:75) else goto L114
L114:
    r358 = 'convert'
    r359 = CPyObject_GetAttr(r357, r358)
    dec_ref r357
    if is_error(r359) goto L208 (error at <module>:75) else goto L115
L115:
    r360 = 'normalize'
    r361 = CPyObject_GetAttr(r359, r360)
    dec_ref r359
    if is_error(r361) goto L208 (error at <module>:75) else goto L116
L116:
    r362 = '_check_array'
    r363 = CPyObject_GetAttr(r361, r362)
    dec_ref r361
    if is_error(r363) goto L208 (error at <module>:75) else goto L117
L117:
    dank_mids.brownie_patch.call._check_array = r363 :: static
    r364 = dank_mids.brownie_patch.call.globals :: static
    r365 = '_check_array'
    r366 = CPyDict_SetItem(r364, r365, r363)
    dec_ref r363
    r367 = r366 >= 0 :: signed
    if not r367 goto L208 (error at <module>:75) else goto L118 :: bool
L118:
    r368 = dank_mids.brownie_patch.call.globals :: static
    r369 = 'brownie'
    r370 = CPyDict_GetItem(r368, r369)
    if is_error(r370) goto L208 (error at <module>:76) else goto L119
L119:
    r371 = 'convert'
    r372 = CPyObject_GetAttr(r370, r371)
    dec_ref r370
    if is_error(r372) goto L208 (error at <module>:76) else goto L120
L120:
    r373 = 'normalize'
    r374 = CPyObject_GetAttr(r372, r373)
    dec_ref r372
    if is_error(r374) goto L208 (error at <module>:76) else goto L121
L121:
    r375 = '_get_abi_types'
    r376 = CPyObject_GetAttr(r374, r375)
    dec_ref r374
    if is_error(r376) goto L208 (error at <module>:76) else goto L122
L122:
    dank_mids.brownie_patch.call._get_abi_types = r376 :: static
    r377 = dank_mids.brownie_patch.call.globals :: static
    r378 = '_get_abi_types'
    r379 = CPyDict_SetItem(r377, r378, r376)
    dec_ref r376
    r380 = r379 >= 0 :: signed
    if not r380 goto L208 (error at <module>:76) else goto L123 :: bool
L123:
    r381 = dank_mids.brownie_patch.call.globals :: static
    r382 = '__name__'
    r383 = CPyDict_GetItem(r381, r382)
    if is_error(r383) goto L208 (error at <module>:79) else goto L124
L124:
    r384 = cast(str, r383)
    if is_error(r384) goto L208 (error at <module>:79) else goto L125
L125:
    r385 = dank_mids._logging.getLogger :: static
    if is_error(r385) goto L217 else goto L128
L126:
    r386 = raise NameError('value for final name "getLogger" was not set')
    if not r386 goto L208 (error at <module>:79) else goto L127 :: bool
L127:
    unreachable
L128:
    r387 = [r384]
    r388 = load_address r387
    r389 = PyObject_Vectorcall(r385, r388, 1, 0)
    if is_error(r389) goto L218 (error at <module>:79) else goto L129
L129:
    dec_ref r384
    dank_mids.brownie_patch.call.logger = r389 :: static
    r390 = dank_mids.brownie_patch.call.globals :: static
    r391 = 'logger'
    r392 = CPyDict_SetItem(r390, r391, r389)
    dec_ref r389
    r393 = r392 >= 0 :: signed
    if not r393 goto L208 (error at <module>:79) else goto L130 :: bool
L130:
    r394 = __mypyc_lambda__0_obj()
    if is_error(r394) goto L208 (error at <module>:82) else goto L131
L131:
    dank_mids.brownie_patch.call.encode = r394 :: static
    r395 = dank_mids.brownie_patch.call.globals :: static
    r396 = 'encode'
    r397 = CPyDict_SetItem(r395, r396, r394)
    dec_ref r394
    r398 = r397 >= 0 :: signed
    if not r398 goto L208 (error at <module>:82) else goto L132 :: bool
L132:
    r399 = __mypyc_lambda__1_obj()
    if is_error(r399) goto L208 (error at <module>:101) else goto L133
L133:
    dank_mids.brownie_patch.call.decode = r399 :: static
    r400 = dank_mids.brownie_patch.call.globals :: static
    r401 = 'decode'
    r402 = CPyDict_SetItem(r400, r401, r399)
    dec_ref r399
    r403 = r402 >= 0 :: signed
    if not r403 goto L208 (error at <module>:101) else goto L134 :: bool
L134:
    r404 = dank_mids.brownie_patch.call.globals :: static
    r405 = 'Address'
    r406 = CPyDict_GetItem(r404, r405)
    if is_error(r406) goto L208 (error at <module>:122) else goto L135
L135:
    r407 = 'checksum'
    r408 = CPyObject_GetAttr(r406, r407)
    dec_ref r406
    if is_error(r408) goto L208 (error at <module>:122) else goto L136
L136:
    dank_mids.brownie_patch.call.to_checksum_address = r408 :: static
    r409 = dank_mids.brownie_patch.call.globals :: static
    r410 = 'to_checksum_address'
    r411 = CPyDict_SetItem(r409, r410, r408)
    dec_ref r408
    r412 = r411 >= 0 :: signed
    if not r412 goto L208 (error at <module>:122) else goto L137 :: bool
L137:
    r413 = dank_mids.brownie_patch.call.globals :: static
    r414 = '_get_coroutine_fn'
    r415 = CPyDict_GetItem(r413, r414)
    if is_error(r415) goto L208 (error at <module>:140) else goto L138
L138:
    r416 = dank_mids.brownie_patch.call.globals :: static
    r417 = 'lru_cache_lite_nonull'
    r418 = CPyDict_GetItem(r416, r417)
    if is_error(r418) goto L219 (error at <module>:140) else goto L139
L139:
    r419 = [r415]
    r420 = load_address r419
    r421 = PyObject_Vectorcall(r418, r420, 1, 0)
    dec_ref r418
    if is_error(r421) goto L219 (error at <module>:140) else goto L140
L140:
    dec_ref r415
    r422 = dank_mids.brownie_patch.call.globals :: static
    r423 = '_get_coroutine_fn'
    r424 = CPyDict_SetItem(r422, r423, r421)
    dec_ref r421
    r425 = r424 >= 0 :: signed
    if not r425 goto L208 (error at <module>:140) else goto L141 :: bool
L141:
    r426 = dank_mids.brownie_patch.call.globals :: static
    r427 = 'faster_eth_abi'
    r428 = CPyDict_GetItem(r426, r427)
    if is_error(r428) goto L208 (error at <module>:252) else goto L142
L142:
    r429 = 'encode'
    r430 = CPyObject_GetAttr(r428, r429)
    dec_ref r428
    if is_error(r430) goto L208 (error at <module>:252) else goto L143
L143:
    dank_mids.brownie_patch.call.__eth_abi_encode = r430 :: static
    r431 = dank_mids.brownie_patch.call.globals :: static
    r432 = '__eth_abi_encode'
    r433 = CPyDict_SetItem(r431, r432, r430)
    dec_ref r430
    r434 = r433 >= 0 :: signed
    if not r434 goto L208 (error at <module>:252) else goto L144 :: bool
L144:
    r435 = dank_mids.brownie_patch.call.globals :: static
    r436 = 'faster_eth_abi'
    r437 = CPyDict_GetItem(r435, r436)
    if is_error(r437) goto L208 (error at <module>:254) else goto L145
L145:
    r438 = 'decode'
    r439 = CPyObject_GetAttr(r437, r438)
    dec_ref r437
    if is_error(r439) goto L208 (error at <module>:254) else goto L146
L146:
    dank_mids.brownie_patch.call.__eth_abi_decode = r439 :: static
    r440 = dank_mids.brownie_patch.call.globals :: static
    r441 = '__eth_abi_decode'
    r442 = CPyDict_SetItem(r440, r441, r439)
    dec_ref r439
    r443 = r442 >= 0 :: signed
    if not r443 goto L208 (error at <module>:254) else goto L147 :: bool
L147:
    r444 = '0xcA11bde05977b3631167028862bE2a173976CA11'
    r445 = PySet_New(0)
    if is_error(r445) goto L208 (error at <module>:267) else goto L148
L148:
    r446 = PySet_Add(r445, r444)
    r447 = r446 >= 0 :: signed
    if not r447 goto L220 (error at <module>:267) else goto L149 :: bool
L149:
    r448 = dank_mids.brownie_patch.call.globals :: static
    r449 = '_skip_proc_pool'
    r450 = CPyDict_SetItem(r448, r449, r445)
    dec_ref r445
    r451 = r450 >= 0 :: signed
    if not r451 goto L208 (error at <module>:267) else goto L150 :: bool
L150:
    if 1 goto L151 else goto L168 :: bool
L151:
    r452 = dank_mids.brownie_patch.call.globals :: static
    r453 = 'chain'
    r454 = CPyDict_GetItem(r452, r453)
    if is_error(r454) goto L154 (error at <module>:271) else goto L152
L152:
    r455 = 'id'
    r456 = CPyObject_GetAttr(r454, r455)
    dec_ref r454
    if is_error(r456) goto L154 (error at <module>:271) else goto L153
L153:
    r457 = dank_mids.brownie_patch.call.globals :: static
    r458 = 'chainid'
    r459 = CPyDict_SetItem(r457, r458, r456)
    dec_ref r456
    r460 = r459 >= 0 :: signed
    if not r460 goto L154 (error at <module>:271) else goto L168 :: bool
L154:
    r461 = CPy_CatchError()
    r462 = builtins :: module
    r463 = 'Exception'
    r464 = CPyObject_GetAttr(r462, r463)
    if is_error(r464) goto L166 (error at <module>:273) else goto L155
L155:
    r465 = CPy_ExceptionMatches(r464)
    dec_ref r464
    if r465 goto L156 else goto L163 :: bool
L156:
    r466 = dank_mids.brownie_patch.call.globals :: static
    r467 = 'e'
    r468 = CPy_GetExcValue()
    r469 = CPyDict_SetItem(r466, r467, r468)
    dec_ref r468
    r470 = r469 >= 0 :: signed
    if not r470 goto L166 (error at <module>:273) else goto L157 :: bool
L157:
    r471 = '429'
    r472 = dank_mids.brownie_patch.call.globals :: static
    r473 = 'e'
    r474 = CPyDict_GetItem(r472, r473)
    if is_error(r474) goto L166 (error at <module>:274) else goto L158
L158:
    r475 = PyObject_Str(r474)
    dec_ref r474
    if is_error(r475) goto L166 (error at <module>:274) else goto L159
L159:
    r476 = PyUnicode_Contains(r475, r471)
    dec_ref r475
    r477 = r476 >= 0 :: signed
    if not r477 goto L166 (error at <module>:274) else goto L160 :: bool
L160:
    r478 = truncate r476: i32 to builtins.bool
    r479 = r478 ^ 1
    if r479 goto L161 else goto L165 :: bool
L161:
    CPy_Reraise()
    if not 0 goto L166 else goto L221 :: bool
L162:
    unreachable
L163:
    CPy_Reraise()
    if not 0 goto L166 else goto L222 :: bool
L164:
    unreachable
L165:
    CPy_RestoreExcInfo(r461)
    dec_ref r461
    goto L150
L166:
    CPy_RestoreExcInfo(r461)
    dec_ref r461
    r480 = CPy_KeepPropagating()
    if not r480 goto L208 else goto L167 :: bool
L167:
    unreachable
L168:
    r481 = dank_mids.brownie_patch.call.globals :: static
    r482 = 'MULTICALL2_ADDRESSES'
    r483 = CPyDict_GetItem(r481, r482)
    if is_error(r483) goto L208 (error at <module>:276) else goto L169
L169:
    r484 = dank_mids.brownie_patch.call.globals :: static
    r485 = 'chainid'
    r486 = CPyDict_GetItem(r484, r485)
    if is_error(r486) goto L223 (error at <module>:276) else goto L170
L170:
    r487 = 'get'
    r488 = box(None, 1)
    r489 = [r483, r486, r488]
    r490 = load_address r489
    r491 = PyObject_VectorcallMethod(r487, r490, 9223372036854775811, 0)
    if is_error(r491) goto L224 (error at <module>:276) else goto L171
L171:
    dec_ref r483
    dec_ref r486
    r492 = dank_mids.brownie_patch.call.globals :: static
    r493 = 'multicall2'
    r494 = CPyDict_SetItem(r492, r493, r491)
    r495 = r494 >= 0 :: signed
    if not r495 goto L225 (error at <module>:276) else goto L172 :: bool
L172:
    r496 = PyObject_IsTrue(r491)
    dec_ref r491
    r497 = r496 >= 0 :: signed
    if not r497 goto L208 (error at <module>:276) else goto L173 :: bool
L173:
    r498 = truncate r496: i32 to builtins.bool
    if r498 goto L174 else goto L182 :: bool
L174:
    r499 = dank_mids.brownie_patch.call.globals :: static
    r500 = '_skip_proc_pool'
    r501 = CPyDict_GetItem(r499, r500)
    if is_error(r501) goto L208 (error at <module>:277) else goto L175
L175:
    r502 = cast(set, r501)
    if is_error(r502) goto L208 (error at <module>:277) else goto L176
L176:
    r503 = dank_mids.brownie_patch.call.globals :: static
    r504 = 'multicall2'
    r505 = CPyDict_GetItem(r503, r504)
    if is_error(r505) goto L226 (error at <module>:277) else goto L177
L177:
    r506 = dank_mids.brownie_patch.call.to_checksum_address :: static
    if is_error(r506) goto L227 else goto L180
L178:
    r507 = raise NameError('value for final name "to_checksum_address" was not set')
    if not r507 goto L208 (error at <module>:277) else goto L179 :: bool
L179:
    unreachable
L180:
    r508 = [r505]
    r509 = load_address r508
    r510 = PyObject_Vectorcall(r506, r509, 1, 0)
    if is_error(r510) goto L228 (error at <module>:277) else goto L181
L181:
    dec_ref r505
    r511 = PySet_Add(r502, r510)
    dec_ref r502
    dec_ref r510
    r512 = r511 >= 0 :: signed
    if not r512 goto L208 (error at <module>:277) else goto L182 :: bool
L182:
    r513 = dank_mids.brownie_patch.call.globals :: static
    r514 = 'format_input_but_cache_checksums'
    r515 = CPyDict_GetItem(r513, r514)
    if is_error(r515) goto L208 (error at <module>:340) else goto L183
L183:
    r516 = dank_mids.brownie_patch.call.globals :: static
    r517 = 'brownie'
    r518 = CPyDict_GetItem(r516, r517)
    if is_error(r518) goto L229 (error at <module>:340) else goto L184
L184:
    r519 = 'network'
    r520 = CPyObject_GetAttr(r518, r519)
    dec_ref r518
    if is_error(r520) goto L229 (error at <module>:340) else goto L185
L185:
    r521 = 'contract'
    r522 = CPyObject_GetAttr(r520, r521)
    dec_ref r520
    if is_error(r522) goto L229 (error at <module>:340) else goto L186
L186:
    r523 = 'format_input'
    r524 = PyObject_SetAttr(r522, r523, r515)
    dec_ref r522
    dec_ref r515
    r525 = r524 >= 0 :: signed
    if not r525 goto L208 (error at <module>:340) else goto L187 :: bool
L187:
    r526 = dank_mids.brownie_patch.call.globals :: static
    r527 = 'format_output_but_cache_checksums'
    r528 = CPyDict_GetItem(r526, r527)
    if is_error(r528) goto L208 (error at <module>:341) else goto L188
L188:
    r529 = dank_mids.brownie_patch.call.globals :: static
    r530 = 'brownie'
    r531 = CPyDict_GetItem(r529, r530)
    if is_error(r531) goto L230 (error at <module>:341) else goto L189
L189:
    r532 = 'network'
    r533 = CPyObject_GetAttr(r531, r532)
    dec_ref r531
    if is_error(r533) goto L230 (error at <module>:341) else goto L190
L190:
    r534 = 'contract'
    r535 = CPyObject_GetAttr(r533, r534)
    dec_ref r533
    if is_error(r535) goto L230 (error at <module>:341) else goto L191
L191:
    r536 = 'format_output'
    r537 = PyObject_SetAttr(r535, r536, r528)
    dec_ref r535
    dec_ref r528
    r538 = r537 >= 0 :: signed
    if not r538 goto L208 (error at <module>:341) else goto L192 :: bool
L192:
    r539 = dank_mids.brownie_patch.call.globals :: static
    r540 = '_format_array_but_cache_checksums'
    r541 = CPyDict_GetItem(r539, r540)
    if is_error(r541) goto L208 (error at <module>:398) else goto L193
L193:
    r542 = dank_mids.brownie_patch.call.globals :: static
    r543 = 'brownie'
    r544 = CPyDict_GetItem(r542, r543)
    if is_error(r544) goto L231 (error at <module>:398) else goto L194
L194:
    r545 = 'convert'
    r546 = CPyObject_GetAttr(r544, r545)
    dec_ref r544
    if is_error(r546) goto L231 (error at <module>:398) else goto L195
L195:
    r547 = 'normalize'
    r548 = CPyObject_GetAttr(r546, r547)
    dec_ref r546
    if is_error(r548) goto L231 (error at <module>:398) else goto L196
L196:
    r549 = '_format_array'
    r550 = PyObject_SetAttr(r548, r549, r541)
    dec_ref r548
    dec_ref r541
    r551 = r550 >= 0 :: signed
    if not r551 goto L208 (error at <module>:398) else goto L197 :: bool
L197:
    r552 = dank_mids.brownie_patch.call.globals :: static
    r553 = '_format_single_but_cache_checksums'
    r554 = CPyDict_GetItem(r552, r553)
    if is_error(r554) goto L208 (error at <module>:399) else goto L198
L198:
    r555 = dank_mids.brownie_patch.call.globals :: static
    r556 = 'brownie'
    r557 = CPyDict_GetItem(r555, r556)
    if is_error(r557) goto L232 (error at <module>:399) else goto L199
L199:
    r558 = 'convert'
    r559 = CPyObject_GetAttr(r557, r558)
    dec_ref r557
    if is_error(r559) goto L232 (error at <module>:399) else goto L200
L200:
    r560 = 'normalize'
    r561 = CPyObject_GetAttr(r559, r560)
    dec_ref r559
    if is_error(r561) goto L232 (error at <module>:399) else goto L201
L201:
    r562 = '_format_single'
    r563 = PyObject_SetAttr(r561, r562, r554)
    dec_ref r561
    dec_ref r554
    r564 = r563 >= 0 :: signed
    if not r564 goto L208 (error at <module>:399) else goto L202 :: bool
L202:
    r565 = dank_mids.brownie_patch.call.globals :: static
    r566 = '_format_tuple_but_cache_checksums'
    r567 = CPyDict_GetItem(r565, r566)
    if is_error(r567) goto L208 (error at <module>:400) else goto L203
L203:
    r568 = dank_mids.brownie_patch.call.globals :: static
    r569 = 'brownie'
    r570 = CPyDict_GetItem(r568, r569)
    if is_error(r570) goto L233 (error at <module>:400) else goto L204
L204:
    r571 = 'convert'
    r572 = CPyObject_GetAttr(r570, r571)
    dec_ref r570
    if is_error(r572) goto L233 (error at <module>:400) else goto L205
L205:
    r573 = 'normalize'
    r574 = CPyObject_GetAttr(r572, r573)
    dec_ref r572
    if is_error(r574) goto L233 (error at <module>:400) else goto L206
L206:
    r575 = '_format_tuple'
    r576 = PyObject_SetAttr(r574, r575, r567)
    dec_ref r574
    dec_ref r567
    r577 = r576 >= 0 :: signed
    if not r577 goto L208 (error at <module>:400) else goto L207 :: bool
L207:
    return 1
L208:
    r578 = <error> :: None
    return r578
L209:
    dec_ref r125
    goto L208
L210:
    dec_ref r156
    goto L208
L211:
    dec_ref r167
    goto L208
L212:
    dec_ref r167
    dec_ref r170
    goto L208
L213:
    dec_ref r167
    dec_ref r174
    goto L208
L214:
    dec_ref r167
    dec_ref r174
    dec_ref r177
    goto L208
L215:
    dec_ref r195
    goto L208
L216:
    dec_ref r202
    goto L208
L217:
    dec_ref r384
    goto L126
L218:
    dec_ref r384
    goto L208
L219:
    dec_ref r415
    goto L208
L220:
    dec_ref r445
    goto L208
L221:
    dec_ref r461
    goto L162
L222:
    dec_ref r461
    goto L164
L223:
    dec_ref r483
    goto L208
L224:
    dec_ref r483
    dec_ref r486
    goto L208
L225:
    dec_ref r491
    goto L208
L226:
    dec_ref r502
    goto L208
L227:
    dec_ref r502
    dec_ref r505
    goto L178
L228:
    dec_ref r502
    dec_ref r505
    goto L208
L229:
    dec_ref r515
    goto L208
L230:
    dec_ref r528
    goto L208
L231:
    dec_ref r541
    goto L208
L232:
    dec_ref r554
    goto L208
L233:
    dec_ref r567
    goto L208

def log_check(batch_type, member_type, num_calls):
    batch_type, member_type :: str
    num_calls :: int
    r0 :: str
    r1 :: object
    r2 :: bool
    r3 :: object
    r4 :: object[4]
    r5 :: object_ptr
    r6 :: object
    r7 :: None
L0:
    r0 = 'checking if we should reduce %s batch size... (%s %s)'
    r1 = dank_mids.helpers.batch_size._log_info :: static
    if is_error(r1) goto L1 else goto L3
L1:
    r2 = raise NameError('value for final name "_log_info" was not set')
    if not r2 goto L5 (error at log_check:14) else goto L2 :: bool
L2:
    unreachable
L3:
    inc_ref num_calls :: int
    r3 = box(int, num_calls)
    r4 = [r0, batch_type, r3, member_type]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r1, r5, 4, 0)
    if is_error(r6) goto L6 (error at log_check:14) else goto L7
L4:
    dec_ref r3
    return 1
L5:
    r7 = <error> :: None
    return r7
L6:
    dec_ref r3
    goto L5
L7:
    dec_ref r6
    goto L4

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13 :: str
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20 :: dict
    r21 :: str
    r22 :: i32
    r23 :: bit
    r24 :: object
    r25 :: bool
    r26 :: str
    r27 :: object
    r28 :: dict
    r29 :: str
    r30 :: i32
    r31 :: bit
    r32 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L14 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('getLogger',)
    r6 = 'logging'
    r7 = dank_mids.helpers.batch_size.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L14 (error at <module>:1) else goto L4
L4:
    logging = r8 :: module
    dec_ref r8
    r9 = ('Final', 'Literal')
    r10 = 'typing'
    r11 = dank_mids.helpers.batch_size.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L14 (error at <module>:2) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = 'dank_mids.batch_size'
    r14 = dank_mids.helpers.batch_size.globals :: static
    r15 = 'getLogger'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L14 (error at <module>:5) else goto L6
L6:
    r17 = [r13]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r16, r18, 1, 0)
    dec_ref r16
    if is_error(r19) goto L14 (error at <module>:5) else goto L7
L7:
    dank_mids.helpers.batch_size.batch_size_logger = r19 :: static
    r20 = dank_mids.helpers.batch_size.globals :: static
    r21 = 'batch_size_logger'
    r22 = CPyDict_SetItem(r20, r21, r19)
    dec_ref r19
    r23 = r22 >= 0 :: signed
    if not r23 goto L14 (error at <module>:5) else goto L8 :: bool
L8:
    r24 = dank_mids.helpers.batch_size.batch_size_logger :: static
    if is_error(r24) goto L9 else goto L11
L9:
    r25 = raise NameError('value for final name "batch_size_logger" was not set')
    if not r25 goto L14 (error at <module>:6) else goto L10 :: bool
L10:
    unreachable
L11:
    r26 = 'info'
    r27 = CPyObject_GetAttr(r24, r26)
    if is_error(r27) goto L14 (error at <module>:6) else goto L12
L12:
    dank_mids.helpers.batch_size._log_info = r27 :: static
    r28 = dank_mids.helpers.batch_size.globals :: static
    r29 = '_log_info'
    r30 = CPyDict_SetItem(r28, r29, r27)
    dec_ref r27
    r31 = r30 >= 0 :: signed
    if not r31 goto L14 (error at <module>:6) else goto L13 :: bool
L13:
    return 1
L14:
    r32 = <error> :: None
    return r32

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: object_ptr
    r10 :: object_ptr[1]
    r11 :: c_ptr
    r12 :: native_int[1]
    r13 :: c_ptr
    r14 :: object
    r15 :: dict
    r16, r17 :: str
    r18 :: bit
    r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26 :: object
    r27 :: str
    r28 :: dict
    r29 :: str
    r30 :: object
    r31 :: object[1]
    r32 :: object_ptr
    r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: i32
    r37 :: bit
    r38 :: object
    r39 :: bool
    r40 :: dict
    r41 :: str
    r42 :: object
    r43 :: str
    r44, r45 :: object
    r46 :: str
    r47 :: object[3]
    r48 :: object_ptr
    r49, r50 :: object
    r51 :: bool
    r52 :: dict
    r53 :: str
    r54 :: object
    r55 :: str
    r56, r57 :: object
    r58 :: str
    r59 :: object[3]
    r60 :: object_ptr
    r61, r62 :: object
    r63 :: bool
    r64 :: dict
    r65 :: str
    r66, r67 :: object
    r68 :: str
    r69 :: object[3]
    r70 :: object_ptr
    r71, r72 :: object
    r73 :: bool
    r74 :: str
    r75 :: object
    r76 :: dict
    r77 :: str
    r78 :: i32
    r79 :: bit
    r80 :: str
    r81 :: dict
    r82 :: str
    r83 :: object
    r84 :: object[1]
    r85 :: object_ptr
    r86 :: object
    r87 :: dict
    r88 :: str
    r89 :: i32
    r90 :: bit
    r91 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L36 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = dank_mids._envs.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L36 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address a_sync :: module
    r10 = [r9]
    r11 = load_address r10
    r12 = [3]
    r13 = load_address r12
    r14 = (('a_sync', 'a_sync', 'a_sync'),)
    r15 = dank_mids._envs.globals :: static
    r16 = 'dank_mids/_envs.py'
    r17 = '<module>'
    r18 = CPyImport_ImportMany(r14, r11, r15, r16, r17, r13)
    if not r18 goto L36 else goto L5 :: bool
L5:
    r19 = ('EnvVarFactory',)
    r20 = 'typed_envs'
    r21 = dank_mids._envs.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L36 (error at <module>:4) else goto L6
L6:
    typed_envs = r22 :: module
    dec_ref r22
    r23 = ('BlockSemaphore',)
    r24 = 'dank_mids.semaphores'
    r25 = dank_mids._envs.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L36 (error at <module>:6) else goto L7
L7:
    dank_mids.semaphores = r26 :: module
    dec_ref r26
    r27 = 'DANKMIDS'
    r28 = dank_mids._envs.globals :: static
    r29 = 'EnvVarFactory'
    r30 = CPyDict_GetItem(r28, r29)
    if is_error(r30) goto L36 (error at <module>:9) else goto L8
L8:
    r31 = [r27]
    r32 = load_address r31
    r33 = PyObject_Vectorcall(r30, r32, 1, 0)
    dec_ref r30
    if is_error(r33) goto L36 (error at <module>:9) else goto L9
L9:
    dank_mids._envs._factory = r33 :: static
    r34 = dank_mids._envs.globals :: static
    r35 = '_factory'
    r36 = CPyDict_SetItem(r34, r35, r33)
    dec_ref r33
    r37 = r36 >= 0 :: signed
    if not r37 goto L36 (error at <module>:9) else goto L10 :: bool
L10:
    r38 = dank_mids._envs._factory :: static
    if is_error(r38) goto L11 else goto L13
L11:
    r39 = raise NameError('value for final name "_factory" was not set')
    if not r39 goto L36 (error at <module>:13) else goto L12 :: bool
L12:
    unreachable
L13:
    r40 = dank_mids._envs.globals :: static
    r41 = 'a_sync'
    r42 = CPyDict_GetItem(r40, r41)
    if is_error(r42) goto L36 (error at <module>:13) else goto L14
L14:
    r43 = 'Semaphore'
    r44 = CPyObject_GetAttr(r42, r43)
    dec_ref r42
    if is_error(r44) goto L36 (error at <module>:13) else goto L15
L15:
    r45 = load_address PyLong_Type
    r46 = 'register_string_converter'
    r47 = [r38, r44, r45]
    r48 = load_address r47
    r49 = PyObject_VectorcallMethod(r46, r48, 9223372036854775811, 0)
    if is_error(r49) goto L37 (error at <module>:13) else goto L38
L16:
    dec_ref r44
    r50 = dank_mids._envs._factory :: static
    if is_error(r50) goto L17 else goto L19
L17:
    r51 = raise NameError('value for final name "_factory" was not set')
    if not r51 goto L36 (error at <module>:14) else goto L18 :: bool
L18:
    unreachable
L19:
    r52 = dank_mids._envs.globals :: static
    r53 = 'a_sync'
    r54 = CPyDict_GetItem(r52, r53)
    if is_error(r54) goto L36 (error at <module>:14) else goto L20
L20:
    r55 = 'ProcessPoolExecutor'
    r56 = CPyObject_GetAttr(r54, r55)
    dec_ref r54
    if is_error(r56) goto L36 (error at <module>:14) else goto L21
L21:
    r57 = load_address PyLong_Type
    r58 = 'register_string_converter'
    r59 = [r50, r56, r57]
    r60 = load_address r59
    r61 = PyObject_VectorcallMethod(r58, r60, 9223372036854775811, 0)
    if is_error(r61) goto L39 (error at <module>:14) else goto L40
L22:
    dec_ref r56
    r62 = dank_mids._envs._factory :: static
    if is_error(r62) goto L23 else goto L25
L23:
    r63 = raise NameError('value for final name "_factory" was not set')
    if not r63 goto L36 (error at <module>:15) else goto L24 :: bool
L24:
    unreachable
L25:
    r64 = dank_mids._envs.globals :: static
    r65 = 'BlockSemaphore'
    r66 = CPyDict_GetItem(r64, r65)
    if is_error(r66) goto L36 (error at <module>:15) else goto L26
L26:
    r67 = load_address PyLong_Type
    r68 = 'register_string_converter'
    r69 = [r62, r66, r67]
    r70 = load_address r69
    r71 = PyObject_VectorcallMethod(r68, r70, 9223372036854775811, 0)
    if is_error(r71) goto L41 (error at <module>:15) else goto L42
L27:
    dec_ref r66
    r72 = dank_mids._envs._factory :: static
    if is_error(r72) goto L28 else goto L30
L28:
    r73 = raise NameError('value for final name "_factory" was not set')
    if not r73 goto L36 (error at <module>:17) else goto L29 :: bool
L29:
    unreachable
L30:
    r74 = 'create_env'
    r75 = CPyObject_GetAttr(r72, r74)
    if is_error(r75) goto L36 (error at <module>:17) else goto L31
L31:
    dank_mids._envs.create_env = r75 :: static
    r76 = dank_mids._envs.globals :: static
    r77 = 'create_env'
    r78 = CPyDict_SetItem(r76, r77, r75)
    dec_ref r75
    r79 = r78 >= 0 :: signed
    if not r79 goto L36 (error at <module>:17) else goto L32 :: bool
L32:
    r80 = 'DANK_MIDS'
    r81 = dank_mids._envs.globals :: static
    r82 = 'EnvVarFactory'
    r83 = CPyDict_GetItem(r81, r82)
    if is_error(r83) goto L36 (error at <module>:20) else goto L33
L33:
    r84 = [r80]
    r85 = load_address r84
    r86 = PyObject_Vectorcall(r83, r85, 1, 0)
    dec_ref r83
    if is_error(r86) goto L36 (error at <module>:20) else goto L34
L34:
    dank_mids._envs._deprecated_format = r86 :: static
    r87 = dank_mids._envs.globals :: static
    r88 = '_deprecated_format'
    r89 = CPyDict_SetItem(r87, r88, r86)
    dec_ref r86
    r90 = r89 >= 0 :: signed
    if not r90 goto L36 (error at <module>:20) else goto L35 :: bool
L35:
    return 1
L36:
    r91 = <error> :: None
    return r91
L37:
    dec_ref r44
    goto L36
L38:
    dec_ref r49
    goto L16
L39:
    dec_ref r56
    goto L36
L40:
    dec_ref r61
    goto L22
L41:
    dec_ref r66
    goto L36
L42:
    dec_ref r71
    goto L27

def coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1 :: object
    r2 :: i32
    r3 :: object
    r4 :: bit
    r5 :: dank_mids.brownie_patch.types.DankOverloadedMethod
    r6 :: tuple
    r7 :: str
    r8 :: object[2]
    r9 :: object_ptr
    r10 :: object
    r11 :: union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx]
    r12 :: bool
    r13 :: union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx]
    r14 :: tuple
    r15, r16 :: union[int, None]
    r17 :: union[dict, None]
    r18 :: str
    r19 :: object
    r20 :: list
    r21 :: object
    r22, r23, r24 :: str
    r25 :: tuple
    r26 :: dict
    r27, r28 :: object
    r29 :: bool
    r30, r31, r32, r33, r34 :: object
    r35 :: bool
    r36 :: object
    r37 :: bool
    r38 :: object
    r39 :: bit
    r40 :: tuple[object, object, object]
    r41 :: bool
    r42 :: object_ptr
    r43 :: object
    r44 :: bool
    r45, r46, r47 :: tuple[object, object, object]
    r48 :: bit
    r49, r50, r51 :: object
    r52 :: bool
    r53, r54 :: bit
    r55 :: bool
    r56 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_next_label__
    goto L53
L1:
    r3 = load_address _Py_NoneStruct
    r4 = type != r3
    if r4 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L57 (error at coroutine:57) else goto L3 :: bool
L3:
    unreachable
L4:
    r5 = __mypyc_self__.self
    if is_error(r5) goto L57 (error at coroutine:75) else goto L5
L5:
    r6 = __mypyc_self__.args
    if is_error(r6) goto L58 (error at coroutine:75) else goto L6
L6:
    r7 = '_get_fn_from_args'
    r8 = [r5, r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775810, 0)
    if is_error(r10) goto L59 (error at coroutine:75) else goto L7
L7:
    dec_ref r5
    dec_ref r6
    r11 = cast(union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx], r10)
    if is_error(r11) goto L57 (error at coroutine:75) else goto L8
L8:
    __mypyc_self__.call = r11; r12 = is_error
    if not r12 goto L57 (error at coroutine:75) else goto L9 :: bool
L9:
    r13 = __mypyc_self__.call
    if is_error(r13) goto L57 (error at coroutine:76) else goto L10
L10:
    r14 = __mypyc_self__.args
    if is_error(r14) goto L60 (error at coroutine:77) else goto L11
L11:
    r15 = __mypyc_self__.block_identifier
    if is_error(r15) goto L61 (error at coroutine:77) else goto L12
L12:
    r16 = __mypyc_self__.decimals
    if is_error(r16) goto L62 (error at coroutine:77) else goto L13
L13:
    r17 = __mypyc_self__.override
    if is_error(r17) goto L63 (error at coroutine:77) else goto L14
L14:
    r18 = 'coroutine'
    r19 = CPyObject_GetAttr(r13, r18)
    dec_ref r13
    if is_error(r19) goto L64 (error at coroutine:76) else goto L15
L15:
    r20 = PyList_New(0)
    if is_error(r20) goto L65 (error at coroutine:76) else goto L16
L16:
    r21 = CPyList_Extend(r20, r14)
    dec_ref r14
    if is_error(r21) goto L66 (error at coroutine:76) else goto L67
L17:
    r22 = 'block_identifier'
    r23 = 'decimals'
    r24 = 'override'
    r25 = PyList_AsTuple(r20)
    dec_ref r20
    if is_error(r25) goto L68 (error at coroutine:76) else goto L18
L18:
    r26 = CPyDict_Build(3, r22, r15, r23, r16, r24, r17)
    dec_ref r15
    dec_ref r16
    dec_ref r17
    if is_error(r26) goto L69 (error at coroutine:76) else goto L19
L19:
    r27 = PyObject_Call(r19, r25, r26)
    dec_ref r19
    dec_ref r25
    dec_ref r26
    if is_error(r27) goto L57 (error at coroutine:76) else goto L20
L20:
    r28 = CPy_GetCoro(r27)
    dec_ref r27
    if is_error(r28) goto L57 (error at coroutine:76) else goto L21
L21:
    __mypyc_self__.__mypyc_temp__0 = r28; r29 = is_error
    if not r29 goto L57 (error at coroutine:-1) else goto L22 :: bool
L22:
    r30 = __mypyc_self__.__mypyc_temp__0
    if is_error(r30) goto L57 (error at coroutine:-1) else goto L23
L23:
    r31 = CPyIter_Next(r30)
    dec_ref r30
    if is_error(r31) goto L24 else goto L26
L24:
    r32 = CPy_FetchStopIterationValue()
    if is_error(r32) goto L57 (error at coroutine:76) else goto L25
L25:
    r33 = r32
    r34 = <error> :: object
    __mypyc_self__.__mypyc_temp__0 = r34; r35 = is_error
    if not r35 goto L70 (error at coroutine:76) else goto L48 :: bool
L26:
    r36 = r31
L27:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r36
L28:
    r38 = load_address _Py_NoneStruct
    r39 = type != r38
    if r39 goto L29 else goto L71 :: bool
L29:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L32 (error at coroutine:76) else goto L72 :: bool
L30:
    unreachable
L31:
    inc_ref arg
    goto L43
L32:
    r40 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__1 = r40; r41 = is_error
    if not r41 goto L73 (error at coroutine:-1) else goto L33 :: bool
L33:
    r42 = load_address r1
    r43 = __mypyc_self__.__mypyc_temp__0
    if is_error(r43) goto L73 (error at coroutine:-1) else goto L34
L34:
    r44 = CPy_YieldFromErrorHandle(r43, r42)
    dec_ref r43
    if is_error(r44) goto L73 (error at coroutine:76) else goto L35
L35:
    if r44 goto L38 else goto L36 :: bool
L36:
    r36 = r1
    r45 = __mypyc_self__.__mypyc_temp__1
    if is_error(r45) goto L74 (error at coroutine:-1) else goto L37
L37:
    CPy_RestoreExcInfo(r45)
    dec_ref r45
    goto L27
L38:
    r33 = r1
    r46 = __mypyc_self__.__mypyc_temp__1
    if is_error(r46) goto L75 (error at coroutine:-1) else goto L39
L39:
    CPy_RestoreExcInfo(r46)
    dec_ref r46
    goto L48
L40:
    r47 = __mypyc_self__.__mypyc_temp__1
    if is_error(r47) goto L57 (error at coroutine:-1) else goto L41
L41:
    CPy_RestoreExcInfo(r47)
    dec_ref r47
    r48 = CPy_KeepPropagating()
    if not r48 goto L57 else goto L42 :: bool
L42:
    unreachable
L43:
    r49 = __mypyc_self__.__mypyc_temp__0
    if is_error(r49) goto L76 (error at coroutine:-1) else goto L44
L44:
    r50 = CPyIter_Send(r49, arg)
    dec_ref r49
    dec_ref arg
    if is_error(r50) goto L46 else goto L45
L45:
    r36 = r50
    goto L27
L46:
    r51 = CPy_FetchStopIterationValue()
    if is_error(r51) goto L57 (error at coroutine:76) else goto L47
L47:
    r33 = r51
L48:
    __mypyc_self__.__mypyc_next_label__ = -1
L49:
    if is_error(stop_iter_ptr) goto L50 else goto L52
L50:
    CPyGen_SetStopIterationValue(r33)
    dec_ref r33
    if not 0 goto L57 else goto L51 :: bool
L51:
    unreachable
L52:
    set_mem stop_iter_ptr, r33 :: builtins.object*
    return 0
L53:
    r53 = r2 == 0
    if r53 goto L77 else goto L54 :: bool
L54:
    r54 = r2 == 1
    if r54 goto L28 else goto L78 :: bool
L55:
    r55 = raise StopIteration
    if not r55 goto L57 (error at coroutine:57) else goto L56 :: bool
L56:
    unreachable
L57:
    r56 = <error> :: object
    return r56
L58:
    dec_ref r5
    goto L57
L59:
    dec_ref r5
    dec_ref r6
    goto L57
L60:
    dec_ref r13
    goto L57
L61:
    dec_ref r13
    dec_ref r14
    goto L57
L62:
    dec_ref r13
    dec_ref r14
    dec_ref r15
    goto L57
L63:
    dec_ref r13
    dec_ref r14
    dec_ref r15
    dec_ref r16
    goto L57
L64:
    dec_ref r14
    dec_ref r15
    dec_ref r16
    dec_ref r17
    goto L57
L65:
    dec_ref r14
    dec_ref r15
    dec_ref r16
    dec_ref r17
    dec_ref r19
    goto L57
L66:
    dec_ref r15
    dec_ref r16
    dec_ref r17
    dec_ref r19
    dec_ref r20
    goto L57
L67:
    dec_ref r21
    goto L17
L68:
    dec_ref r15
    dec_ref r16
    dec_ref r17
    dec_ref r19
    goto L57
L69:
    dec_ref r19
    dec_ref r25
    goto L57
L70:
    dec_ref r33
    goto L57
L71:
    xdec_ref r1
    goto L31
L72:
    xdec_ref r1
    goto L30
L73:
    xdec_ref r1
    goto L40
L74:
    dec_ref r36
    goto L40
L75:
    dec_ref r33
    goto L40
L76:
    dec_ref arg
    goto L57
L77:
    xdec_ref r1
    goto L1
L78:
    xdec_ref r1
    goto L55

def coroutine_DankOverloadedMethod_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine_DankOverloadedMethod_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine_DankOverloadedMethod_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine_DankOverloadedMethod_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutine_DankOverloadedMethod_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def coroutine_DankOverloadedMethod_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def DankOverloadedMethod.coroutine(self, args, block_identifier, decimals, override):
    self :: dank_mids.brownie_patch.types.DankOverloadedMethod
    args :: tuple
    block_identifier, decimals :: union[int, None]
    override :: union[dict, None]
    r0, r1, r2 :: object
    r3 :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    r4, r5, r6, r7, r8, r9 :: bool
    r10 :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
L0:
    if is_error(block_identifier) goto L1 else goto L14
L1:
    r0 = box(None, 1)
    inc_ref r0
    block_identifier = r0
L2:
    if is_error(decimals) goto L3 else goto L15
L3:
    r1 = box(None, 1)
    inc_ref r1
    decimals = r1
L4:
    if is_error(override) goto L5 else goto L16
L5:
    r2 = box(None, 1)
    inc_ref r2
    override = r2
L6:
    r3 = coroutine_DankOverloadedMethod_gen()
    if is_error(r3) goto L17 (error at coroutine:57) else goto L7
L7:
    r3.__mypyc_next_label__ = 0
    inc_ref self
    r3.self = self; r5 = is_error
    if not r5 goto L18 (error at coroutine:57) else goto L8 :: bool
L8:
    inc_ref args
    r3.args = args; r6 = is_error
    if not r6 goto L18 (error at coroutine:57) else goto L9 :: bool
L9:
    r3.block_identifier = block_identifier; r7 = is_error
    if not r7 goto L19 (error at coroutine:57) else goto L10 :: bool
L10:
    r3.decimals = decimals; r8 = is_error
    if not r8 goto L20 (error at coroutine:57) else goto L11 :: bool
L11:
    r3.override = override; r9 = is_error
    if not r9 goto L21 (error at coroutine:57) else goto L12 :: bool
L12:
    return r3
L13:
    r10 = <error> :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    return r10
L14:
    inc_ref block_identifier
    goto L2
L15:
    inc_ref decimals
    goto L4
L16:
    inc_ref override
    goto L6
L17:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    goto L13
L18:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r3
    goto L13
L19:
    dec_ref decimals
    dec_ref override
    dec_ref r3
    goto L13
L20:
    dec_ref override
    dec_ref r3
    goto L13
L21:
    dec_ref r3
    goto L13

def DankOverloadedMethod._add_fn(self, abi, natspec):
    self :: dank_mids.brownie_patch.types.DankOverloadedMethod
    abi, natspec :: dict
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx]
    r8 :: list
    r9 :: str
    r10, r11, r12 :: object
    r13 :: str
    r14 :: object
    r15, r16, r17 :: str
    r18 :: object[3]
    r19 :: object_ptr
    r20 :: object
    r21 :: i32
    r22, r23 :: bit
    r24 :: tuple
    r25 :: dict
    r26 :: i32
    r27 :: bit
    r28 :: str
    r29 :: object
    r30 :: str
    r31 :: object[2]
    r32 :: object_ptr
    r33 :: object
    r34 :: None
L0:
    r0 = '_address'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L19 (error at _add_fn:91) else goto L1
L1:
    r2 = '_name'
    r3 = CPyObject_GetAttr(self, r2)
    if is_error(r3) goto L20 (error at _add_fn:91) else goto L2
L2:
    r4 = '_owner'
    r5 = CPyObject_GetAttr(self, r4)
    if is_error(r5) goto L21 (error at _add_fn:91) else goto L3
L3:
    r6 = cast(str, r3)
    if is_error(r6) goto L22 (error at _add_fn:91) else goto L4
L4:
    r7 = _get_method_object(r1, abi, r6, r5, natspec)
    dec_ref r1
    dec_ref r6
    dec_ref r5
    if is_error(r7) goto L19 (error at _add_fn:91) else goto L5
L5:
    r8 = PyList_New(0)
    if is_error(r8) goto L23 (error at _add_fn:92) else goto L6
L6:
    r9 = 'inputs'
    r10 = CPyDict_GetItem(abi, r9)
    if is_error(r10) goto L24 (error at _add_fn:92) else goto L7
L7:
    r11 = PyObject_GetIter(r10)
    dec_ref r10
    if is_error(r11) goto L24 (error at _add_fn:92) else goto L8
L8:
    r12 = PyIter_Next(r11)
    if is_error(r12) goto L25 else goto L9
L9:
    r13 = 'type'
    r14 = PyObject_GetItem(r12, r13)
    dec_ref r12
    if is_error(r14) goto L26 (error at _add_fn:92) else goto L10
L10:
    r15 = '256'
    r16 = ''
    r17 = 'replace'
    r18 = [r14, r15, r16]
    r19 = load_address r18
    r20 = PyObject_VectorcallMethod(r17, r19, 9223372036854775811, 0)
    if is_error(r20) goto L27 (error at _add_fn:92) else goto L11
L11:
    dec_ref r14
    r21 = PyList_Append(r8, r20)
    dec_ref r20
    r22 = r21 >= 0 :: signed
    if not r22 goto L26 (error at _add_fn:92) else goto L8 :: bool
L12:
    r23 = CPy_NoErrOccurred()
    if not r23 goto L24 (error at _add_fn:92) else goto L13 :: bool
L13:
    r24 = PyList_AsTuple(r8)
    dec_ref r8
    if is_error(r24) goto L23 (error at _add_fn:92) else goto L14
L14:
    r25 = self.methods
    if is_error(r25) goto L28 (error at _add_fn:93) else goto L15
L15:
    r26 = CPyDict_SetItem(r25, r24, r7)
    dec_ref r25
    dec_ref r24
    dec_ref r7
    r27 = r26 >= 0 :: signed
    if not r27 goto L19 (error at _add_fn:93) else goto L16 :: bool
L16:
    r28 = 'natspec'
    r29 = CPyObject_GetAttr(self, r28)
    if is_error(r29) goto L19 (error at _add_fn:94) else goto L17
L17:
    r30 = 'update'
    r31 = [r29, natspec]
    r32 = load_address r31
    r33 = PyObject_VectorcallMethod(r30, r32, 9223372036854775810, 0)
    if is_error(r33) goto L29 (error at _add_fn:94) else goto L30
L18:
    dec_ref r29
    return 1
L19:
    r34 = <error> :: None
    return r34
L20:
    dec_ref r1
    goto L19
L21:
    dec_ref r1
    dec_ref r3
    goto L19
L22:
    dec_ref r1
    dec_ref r5
    goto L19
L23:
    dec_ref r7
    goto L19
L24:
    dec_ref r7
    dec_ref r8
    goto L19
L25:
    dec_ref r11
    goto L12
L26:
    dec_ref r7
    dec_ref r8
    dec_ref r11
    goto L19
L27:
    dec_ref r7
    dec_ref r8
    dec_ref r11
    dec_ref r14
    goto L19
L28:
    dec_ref r7
    dec_ref r24
    goto L19
L29:
    dec_ref r29
    goto L19
L30:
    dec_ref r33
    goto L18

def _get_method_object(address, abi, name, owner, natspec):
    address :: object
    abi :: dict
    name :: str
    owner :: union[object, None]
    natspec :: dict
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4 :: str
    r5, constant :: object
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10, r11 :: bool
    r12 :: str
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: bool
    r17 :: object
    r18 :: i32
    r19 :: bit
    r20 :: bool
    r21 :: tuple
    r22 :: dict
    r23 :: dank_mids.brownie_patch.types.DankContractCall
    r24 :: tuple
    r25 :: dict
    r26 :: dank_mids.brownie_patch.types.DankContractTx
    r27 :: union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx]
L0:
    r0 = 'constant'
    r1 = PyDict_Contains(abi, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L24 (error at _get_method_object:131) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L2 else goto L4 :: bool
L2:
    r4 = 'constant'
    r5 = CPyDict_GetItem(abi, r4)
    if is_error(r5) goto L24 (error at _get_method_object:132) else goto L3
L3:
    constant = r5
    goto L14
L4:
    r6 = 'stateMutability'
    r7 = CPyDict_GetItem(abi, r6)
    if is_error(r7) goto L24 (error at _get_method_object:134) else goto L5
L5:
    r8 = 'view'
    r9 = PyObject_RichCompare(r7, r8, 2)
    dec_ref r7
    if is_error(r9) goto L24 (error at _get_method_object:-1) else goto L6
L6:
    r10 = unbox(bool, r9)
    dec_ref r9
    if is_error(r10) goto L24 (error at _get_method_object:-1) else goto L7
L7:
    if r10 goto L8 else goto L9 :: bool
L8:
    r11 = r10
    goto L13
L9:
    r12 = 'stateMutability'
    r13 = CPyDict_GetItem(abi, r12)
    if is_error(r13) goto L24 (error at _get_method_object:134) else goto L10
L10:
    r14 = 'pure'
    r15 = PyObject_RichCompare(r13, r14, 2)
    dec_ref r13
    if is_error(r15) goto L24 (error at _get_method_object:-1) else goto L11
L11:
    r16 = unbox(bool, r15)
    dec_ref r15
    if is_error(r16) goto L24 (error at _get_method_object:-1) else goto L12
L12:
    r11 = r16
L13:
    r17 = box(bool, r11)
    inc_ref r17
    constant = r17
L14:
    r18 = PyObject_IsTrue(constant)
    dec_ref constant
    r19 = r18 >= 0 :: signed
    if not r19 goto L24 (error at _get_method_object:132) else goto L15 :: bool
L15:
    r20 = truncate r18: i32 to builtins.bool
    if r20 goto L16 else goto L20 :: bool
L16:
    r21 = PyTuple_Pack(5, address, abi, name, owner, natspec)
    if is_error(r21) goto L24 (error at _get_method_object:137) else goto L17
L17:
    r22 = PyDict_New()
    if is_error(r22) goto L25 (error at _get_method_object:137) else goto L18
L18:
    r23 = DankContractCall(r21, r22)
    dec_ref r21
    dec_ref r22
    if is_error(r23) goto L24 (error at _get_method_object:137) else goto L19
L19:
    return r23
L20:
    r24 = PyTuple_Pack(5, address, abi, name, owner, natspec)
    if is_error(r24) goto L24 (error at _get_method_object:138) else goto L21
L21:
    r25 = PyDict_New()
    if is_error(r25) goto L26 (error at _get_method_object:138) else goto L22
L22:
    r26 = DankContractTx(r24, r25)
    dec_ref r24
    dec_ref r25
    if is_error(r26) goto L24 (error at _get_method_object:138) else goto L23
L23:
    return r26
L24:
    r27 = <error> :: union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx]
    return r27
L25:
    dec_ref r21
    goto L24
L26:
    dec_ref r24
    goto L24

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24 :: object
    r25 :: str
    r26 :: dict
    r27 :: str
    r28 :: object
    r29 :: object[1]
    r30 :: object_ptr
    r31 :: object
    r32 :: dict
    r33 :: str
    r34 :: i32
    r35 :: bit
    r36 :: dict
    r37 :: str
    r38 :: object
    r39 :: dict
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: object
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: tuple[object, object, object]
    r49, r50 :: object
    r51 :: dict
    r52 :: str
    r53 :: i32
    r54 :: bit
    r55 :: dict
    r56 :: str
    r57 :: object
    r58 :: dict
    r59 :: str
    r60 :: object
    r61 :: tuple
    r62 :: str
    r63, r64 :: object
    r65 :: bool
    r66, r67 :: str
    r68 :: tuple
    r69 :: i32
    r70 :: bit
    r71 :: dict
    r72 :: str
    r73 :: i32
    r74 :: bit
    r75 :: dict
    r76 :: str
    r77 :: object
    r78 :: dict
    r79 :: str
    r80 :: object
    r81 :: tuple
    r82 :: str
    r83, r84 :: object
    r85 :: bool
    r86, r87 :: str
    r88 :: tuple
    r89 :: i32
    r90 :: bit
    r91 :: dict
    r92 :: str
    r93 :: i32
    r94 :: bit
    r95 :: dict
    r96 :: str
    r97, r98, r99 :: object
    r100 :: tuple[object, object]
    r101, r102 :: object
    r103 :: dict
    r104 :: str
    r105 :: i32
    r106 :: bit
    r107 :: dict
    r108 :: str
    r109 :: object
    r110 :: dict
    r111 :: str
    r112 :: object
    r113 :: dict
    r114 :: str
    r115, r116 :: object
    r117 :: tuple
    r118 :: str
    r119, r120 :: object
    r121 :: bool
    r122, r123, r124 :: str
    r125 :: tuple
    r126 :: i32
    r127 :: bit
    r128 :: dict
    r129 :: str
    r130 :: i32
    r131 :: bit
    r132 :: dict
    r133 :: str
    r134, r135, r136, r137 :: object
    r138 :: tuple[object, object, object]
    r139, r140 :: object
    r141 :: dict
    r142 :: str
    r143 :: i32
    r144 :: bit
    r145 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L50 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Dict', 'Optional', 'Tuple', 'TypeVar', 'Union', 'final')
    r6 = 'typing'
    r7 = dank_mids.brownie_patch.types.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L50 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ContractCall', 'ContractTx', 'OverloadedMethod')
    r10 = 'brownie.network.contract'
    r11 = dank_mids.brownie_patch.types.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L50 (error at <module>:3) else goto L5
L5:
    brownie.network.contract = r12 :: module
    dec_ref r12
    r13 = ('AccountsType',)
    r14 = 'brownie.typing'
    r15 = dank_mids.brownie_patch.types.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L50 (error at <module>:4) else goto L6
L6:
    brownie.typing = r16 :: module
    dec_ref r16
    r17 = ('ChecksumAddress',)
    r18 = 'eth_typing'
    r19 = dank_mids.brownie_patch.types.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L50 (error at <module>:5) else goto L7
L7:
    eth_typing = r20 :: module
    dec_ref r20
    r21 = ('_DankMethod', '_DankMethodMixin', '_EVMType')
    r22 = 'dank_mids.brownie_patch._method'
    r23 = dank_mids.brownie_patch.types.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L50 (error at <module>:7) else goto L8
L8:
    dank_mids.brownie_patch._method = r24 :: module
    dec_ref r24
    r25 = '_T'
    r26 = dank_mids.brownie_patch.types.globals :: static
    r27 = 'TypeVar'
    r28 = CPyDict_GetItem(r26, r27)
    if is_error(r28) goto L50 (error at <module>:10) else goto L9
L9:
    r29 = [r25]
    r30 = load_address r29
    r31 = PyObject_Vectorcall(r28, r30, 1, 0)
    dec_ref r28
    if is_error(r31) goto L50 (error at <module>:10) else goto L10
L10:
    r32 = dank_mids.brownie_patch.types.globals :: static
    r33 = '_T'
    r34 = CPyDict_SetItem(r32, r33, r31)
    dec_ref r31
    r35 = r34 >= 0 :: signed
    if not r35 goto L50 (error at <module>:10) else goto L11 :: bool
L11:
    r36 = dank_mids.brownie_patch.types.globals :: static
    r37 = 'Union'
    r38 = CPyDict_GetItem(r36, r37)
    if is_error(r38) goto L50 (error at <module>:12) else goto L12
L12:
    r39 = dank_mids.brownie_patch.types.globals :: static
    r40 = 'ContractCall'
    r41 = CPyDict_GetItem(r39, r40)
    if is_error(r41) goto L51 (error at <module>:12) else goto L13
L13:
    r42 = dank_mids.brownie_patch.types.globals :: static
    r43 = 'ContractTx'
    r44 = CPyDict_GetItem(r42, r43)
    if is_error(r44) goto L52 (error at <module>:12) else goto L14
L14:
    r45 = dank_mids.brownie_patch.types.globals :: static
    r46 = 'OverloadedMethod'
    r47 = CPyDict_GetItem(r45, r46)
    if is_error(r47) goto L53 (error at <module>:12) else goto L15
L15:
    r48 = (r41, r44, r47)
    r49 = box(tuple[object, object, object], r48)
    r50 = PyObject_GetItem(r38, r49)
    dec_ref r38
    dec_ref r49
    if is_error(r50) goto L50 (error at <module>:12) else goto L16
L16:
    r51 = dank_mids.brownie_patch.types.globals :: static
    r52 = 'ContractMethod'
    r53 = CPyDict_SetItem(r51, r52, r50)
    dec_ref r50
    r54 = r53 >= 0 :: signed
    if not r54 goto L50 (error at <module>:12) else goto L17 :: bool
L17:
    r55 = dank_mids.brownie_patch.types.globals :: static
    r56 = '_DankMethod'
    r57 = CPyDict_GetItem(r55, r56)
    if is_error(r57) goto L50 (error at <module>:17) else goto L18
L18:
    r58 = dank_mids.brownie_patch.types.globals :: static
    r59 = 'ContractCall'
    r60 = CPyDict_GetItem(r58, r59)
    if is_error(r60) goto L54 (error at <module>:17) else goto L19
L19:
    r61 = PyTuple_Pack(2, r57, r60)
    dec_ref r57
    dec_ref r60
    if is_error(r61) goto L50 (error at <module>:17) else goto L20
L20:
    r62 = 'dank_mids.brownie_patch.types'
    r63 = dank_mids.brownie_patch.types.DankContractCall_template :: type
    r64 = CPyType_FromTemplate(r63, r61, r62)
    dec_ref r61
    if is_error(r64) goto L50 (error at <module>:17) else goto L21
L21:
    r65 = DankContractCall_trait_vtable_setup()
    if is_error(r65) goto L55 (error at <module>:-1) else goto L22
L22:
    r66 = '__mypyc_attrs__'
    r67 = '__dict__'
    r68 = PyTuple_Pack(1, r67)
    if is_error(r68) goto L55 (error at <module>:17) else goto L23
L23:
    r69 = PyObject_SetAttr(r64, r66, r68)
    dec_ref r68
    r70 = r69 >= 0 :: signed
    if not r70 goto L55 (error at <module>:17) else goto L24 :: bool
L24:
    dank_mids.brownie_patch.types.DankContractCall = r64 :: type
    r71 = dank_mids.brownie_patch.types.globals :: static
    r72 = 'DankContractCall'
    r73 = CPyDict_SetItem(r71, r72, r64)
    dec_ref r64
    r74 = r73 >= 0 :: signed
    if not r74 goto L50 (error at <module>:17) else goto L25 :: bool
L25:
    r75 = dank_mids.brownie_patch.types.globals :: static
    r76 = '_DankMethod'
    r77 = CPyDict_GetItem(r75, r76)
    if is_error(r77) goto L50 (error at <module>:29) else goto L26
L26:
    r78 = dank_mids.brownie_patch.types.globals :: static
    r79 = 'ContractTx'
    r80 = CPyDict_GetItem(r78, r79)
    if is_error(r80) goto L56 (error at <module>:29) else goto L27
L27:
    r81 = PyTuple_Pack(2, r77, r80)
    dec_ref r77
    dec_ref r80
    if is_error(r81) goto L50 (error at <module>:29) else goto L28
L28:
    r82 = 'dank_mids.brownie_patch.types'
    r83 = dank_mids.brownie_patch.types.DankContractTx_template :: type
    r84 = CPyType_FromTemplate(r83, r81, r82)
    dec_ref r81
    if is_error(r84) goto L50 (error at <module>:29) else goto L29
L29:
    r85 = DankContractTx_trait_vtable_setup()
    if is_error(r85) goto L57 (error at <module>:-1) else goto L30
L30:
    r86 = '__mypyc_attrs__'
    r87 = '__dict__'
    r88 = PyTuple_Pack(1, r87)
    if is_error(r88) goto L57 (error at <module>:29) else goto L31
L31:
    r89 = PyObject_SetAttr(r84, r86, r88)
    dec_ref r88
    r90 = r89 >= 0 :: signed
    if not r90 goto L57 (error at <module>:29) else goto L32 :: bool
L32:
    dank_mids.brownie_patch.types.DankContractTx = r84 :: type
    r91 = dank_mids.brownie_patch.types.globals :: static
    r92 = 'DankContractTx'
    r93 = CPyDict_SetItem(r91, r92, r84)
    dec_ref r84
    r94 = r93 >= 0 :: signed
    if not r94 goto L50 (error at <module>:29) else goto L33 :: bool
L33:
    r95 = dank_mids.brownie_patch.types.globals :: static
    r96 = 'Union'
    r97 = CPyDict_GetItem(r95, r96)
    if is_error(r97) goto L50 (error at <module>:40) else goto L34
L34:
    r98 = dank_mids.brownie_patch.types.DankContractCall :: type
    r99 = dank_mids.brownie_patch.types.DankContractTx :: type
    inc_ref r98
    inc_ref r99
    r100 = (r98, r99)
    r101 = box(tuple[object, object], r100)
    r102 = PyObject_GetItem(r97, r101)
    dec_ref r97
    dec_ref r101
    if is_error(r102) goto L50 (error at <module>:40) else goto L35
L35:
    r103 = dank_mids.brownie_patch.types.globals :: static
    r104 = '_NonOverloaded'
    r105 = CPyDict_SetItem(r103, r104, r102)
    dec_ref r102
    r106 = r105 >= 0 :: signed
    if not r106 goto L50 (error at <module>:40) else goto L36 :: bool
L36:
    r107 = dank_mids.brownie_patch.types.globals :: static
    r108 = 'OverloadedMethod'
    r109 = CPyDict_GetItem(r107, r108)
    if is_error(r109) goto L50 (error at <module>:45) else goto L37
L37:
    r110 = dank_mids.brownie_patch.types.globals :: static
    r111 = '_DankMethodMixin'
    r112 = CPyDict_GetItem(r110, r111)
    if is_error(r112) goto L58 (error at <module>:45) else goto L38
L38:
    r113 = dank_mids.brownie_patch.types.globals :: static
    r114 = '_T'
    r115 = CPyDict_GetItem(r113, r114)
    if is_error(r115) goto L59 (error at <module>:45) else goto L39
L39:
    r116 = PyObject_GetItem(r112, r115)
    dec_ref r112
    dec_ref r115
    if is_error(r116) goto L58 (error at <module>:45) else goto L40
L40:
    r117 = PyTuple_Pack(2, r109, r116)
    dec_ref r109
    dec_ref r116
    if is_error(r117) goto L50 (error at <module>:45) else goto L41
L41:
    r118 = 'dank_mids.brownie_patch.types'
    r119 = dank_mids.brownie_patch.types.DankOverloadedMethod_template :: type
    r120 = CPyType_FromTemplate(r119, r117, r118)
    dec_ref r117
    if is_error(r120) goto L50 (error at <module>:45) else goto L42
L42:
    r121 = DankOverloadedMethod_trait_vtable_setup()
    if is_error(r121) goto L60 (error at <module>:-1) else goto L43
L43:
    r122 = '__mypyc_attrs__'
    r123 = 'methods'
    r124 = '__dict__'
    r125 = PyTuple_Pack(2, r123, r124)
    if is_error(r125) goto L60 (error at <module>:45) else goto L44
L44:
    r126 = PyObject_SetAttr(r120, r122, r125)
    dec_ref r125
    r127 = r126 >= 0 :: signed
    if not r127 goto L60 (error at <module>:45) else goto L45 :: bool
L45:
    dank_mids.brownie_patch.types.DankOverloadedMethod = r120 :: type
    r128 = dank_mids.brownie_patch.types.globals :: static
    r129 = 'DankOverloadedMethod'
    r130 = CPyDict_SetItem(r128, r129, r120)
    dec_ref r120
    r131 = r130 >= 0 :: signed
    if not r131 goto L50 (error at <module>:45) else goto L46 :: bool
L46:
    r132 = dank_mids.brownie_patch.types.globals :: static
    r133 = 'Union'
    r134 = CPyDict_GetItem(r132, r133)
    if is_error(r134) goto L50 (error at <module>:97) else goto L47
L47:
    r135 = dank_mids.brownie_patch.types.DankContractCall :: type
    r136 = dank_mids.brownie_patch.types.DankContractTx :: type
    r137 = dank_mids.brownie_patch.types.DankOverloadedMethod :: type
    inc_ref r135
    inc_ref r136
    inc_ref r137
    r138 = (r135, r136, r137)
    r139 = box(tuple[object, object, object], r138)
    r140 = PyObject_GetItem(r134, r139)
    dec_ref r134
    dec_ref r139
    if is_error(r140) goto L50 (error at <module>:97) else goto L48
L48:
    r141 = dank_mids.brownie_patch.types.globals :: static
    r142 = 'DankContractMethod'
    r143 = CPyDict_SetItem(r141, r142, r140)
    dec_ref r140
    r144 = r143 >= 0 :: signed
    if not r144 goto L50 (error at <module>:97) else goto L49 :: bool
L49:
    return 1
L50:
    r145 = <error> :: None
    return r145
L51:
    dec_ref r38
    goto L50
L52:
    dec_ref r38
    dec_ref r41
    goto L50
L53:
    dec_ref r38
    dec_ref r41
    dec_ref r44
    goto L50
L54:
    dec_ref r57
    goto L50
L55:
    dec_ref r64
    goto L50
L56:
    dec_ref r77
    goto L50
L57:
    dec_ref r84
    goto L50
L58:
    dec_ref r109
    goto L50
L59:
    dec_ref r109
    dec_ref r112
    goto L50
L60:
    dec_ref r120
    goto L50

def RawResponse.__init__(self, raw):
    self :: dank_mids.helpers._codec.RawResponse
    raw :: object
L0:
    inc_ref raw
    self._raw = raw
    return 1

def RawResponse.decode(self, partial):
    self :: dank_mids.helpers._codec.RawResponse
    partial :: bool
    r0 :: dict
    r1 :: str
    r2, r3 :: object
    r4 :: bit
    r5 :: None
    r6 :: object
    r7 :: dict
    r8 :: str
    r9 :: object
    r10 :: union[object, None]
    r11 :: dict
    r12 :: str
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: object[2]
    r18 :: object_ptr
    r19, r20, r21 :: object
L0:
    if is_error(partial) goto L1 else goto L2
L1:
    partial = 0
L2:
    r0 = dank_mids.helpers._codec.globals :: static
    r1 = 'better_decode'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L13 (error at decode:96) else goto L3
L3:
    r3 = load_address _Py_NoneStruct
    r4 = r2 == r3
    dec_ref r2
    if r4 goto L4 else goto L5 :: bool
L4:
    r5 = __import_from_types()
    if is_error(r5) goto L13 (error at decode:97) else goto L5
L5:
    r6 = self._raw
    if partial goto L6 else goto L8 :: bool
L6:
    r7 = dank_mids.helpers._codec.globals :: static
    r8 = 'PartialResponse'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L14 (error at decode:98) else goto L7
L7:
    r10 = r9
    goto L10
L8:
    r11 = dank_mids.helpers._codec.globals :: static
    r12 = 'Response'
    r13 = CPyDict_GetItem(r11, r12)
    if is_error(r13) goto L14 (error at decode:98) else goto L9
L9:
    r10 = r13
L10:
    r14 = dank_mids.helpers._codec.globals :: static
    r15 = 'better_decode'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L15 (error at decode:98) else goto L11
L11:
    r17 = [r6, r10]
    r18 = load_address r17
    r19 = ('type',)
    r20 = PyObject_Vectorcall(r16, r18, 1, r19)
    dec_ref r16
    if is_error(r20) goto L15 (error at decode:98) else goto L12
L12:
    dec_ref r6
    dec_ref r10
    return r20
L13:
    r21 = <error> :: object
    return r21
L14:
    dec_ref r6
    goto L13
L15:
    dec_ref r6
    dec_ref r10
    goto L13

def decode_raw(data):
    data, r0 :: object
    r1 :: bool
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5 :: dank_mids.helpers._codec.RawResponse
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: bool
    r9 :: bit
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: list
    r14 :: object
    r15 :: i32
    r16 :: bit
    r17 :: tuple
    r18 :: str
    r19 :: i32
    r20, r21 :: bit
    r22 :: dank_mids.helpers._codec.RawResponse
L0:
L1:
    r0 = dank_mids.helpers._codec._decode_raw :: static
    if is_error(r0) goto L2 else goto L4
L2:
    r1 = raise NameError('value for final name "_decode_raw" was not set')
    if not r1 goto L7 (error at decode_raw:114) else goto L3 :: bool
L3:
    unreachable
L4:
    r2 = [data]
    r3 = load_address r2
    r4 = PyObject_Vectorcall(r0, r3, 1, 0)
    if is_error(r4) goto L7 (error at decode_raw:114) else goto L5
L5:
    r5 = RawResponse(r4)
    dec_ref r4
    if is_error(r5) goto L7 (error at decode_raw:114) else goto L6
L6:
    return r5
L7:
    r6 = CPy_CatchError()
    r7 = dank_mids.helpers._codec.DecodeError :: static
    if is_error(r7) goto L8 else goto L10
L8:
    r8 = raise NameError('value for final name "DecodeError" was not set')
    if not r8 goto L21 (error at decode_raw:115) else goto L24 :: bool
L9:
    unreachable
L10:
    r9 = CPy_ExceptionMatches(r7)
    if r9 goto L11 else goto L19 :: bool
L11:
    r10 = CPy_GetExcValue()
    r11 = 'args'
    r12 = CPyObject_GetAttr(r10, r11)
    if is_error(r12) goto L25 (error at decode_raw:116) else goto L12
L12:
    r13 = PyList_New(0)
    if is_error(r13) goto L26 (error at decode_raw:116) else goto L13
L13:
    r14 = CPyList_Extend(r13, r12)
    dec_ref r12
    if is_error(r14) goto L27 (error at decode_raw:116) else goto L28
L14:
    r15 = PyList_Append(r13, data)
    r16 = r15 >= 0 :: signed
    if not r16 goto L27 (error at decode_raw:116) else goto L15 :: bool
L15:
    r17 = PyList_AsTuple(r13)
    dec_ref r13
    if is_error(r17) goto L25 (error at decode_raw:116) else goto L16
L16:
    r18 = 'args'
    r19 = PyObject_SetAttr(r10, r18, r17)
    dec_ref r10
    dec_ref r17
    r20 = r19 >= 0 :: signed
    if not r20 goto L21 (error at decode_raw:116) else goto L17 :: bool
L17:
    CPy_Reraise()
    if not 0 goto L21 else goto L29 :: bool
L18:
    unreachable
L19:
    CPy_Reraise()
    if not 0 goto L21 else goto L30 :: bool
L20:
    unreachable
L21:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r21 = CPy_KeepPropagating()
    if not r21 goto L23 else goto L22 :: bool
L22:
    unreachable
L23:
    r22 = <error> :: dank_mids.helpers._codec.RawResponse
    return r22
L24:
    dec_ref r6
    goto L9
L25:
    dec_ref r10
    goto L21
L26:
    dec_ref r10
    dec_ref r12
    goto L21
L27:
    dec_ref r10
    dec_ref r13
    goto L21
L28:
    dec_ref r14
    goto L14
L29:
    dec_ref r6
    goto L18
L30:
    dec_ref r6
    goto L20

def decode_jsonrpc_batch(data):
    data :: object
    r0 :: dict
    r1 :: str
    r2, r3 :: object
    r4 :: bit
    r5 :: None
    r6 :: dict
    r7 :: str
    r8 :: object
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    decoded :: union[list, object]
    r12 :: bit
    r13 :: list
    r14, r15 :: object
    r16 :: dank_mids.helpers._codec.RawResponse
    r17 :: i32
    r18, r19 :: bit
    r20, r21 :: union[list, object]
L0:
    r0 = dank_mids.helpers._codec.globals :: static
    r1 = '_decode_batch'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L15 (error at decode_jsonrpc_batch:130) else goto L1
L1:
    r3 = load_address _Py_NoneStruct
    r4 = r2 == r3
    dec_ref r2
    if r4 goto L2 else goto L3 :: bool
L2:
    r5 = __make_decode_batch()
    if is_error(r5) goto L15 (error at decode_jsonrpc_batch:131) else goto L3
L3:
    r6 = dank_mids.helpers._codec.globals :: static
    r7 = '_decode_batch'
    r8 = CPyDict_GetItem(r6, r7)
    if is_error(r8) goto L15 (error at decode_jsonrpc_batch:133) else goto L4
L4:
    r9 = [data]
    r10 = load_address r9
    r11 = PyObject_Vectorcall(r8, r10, 1, 0)
    dec_ref r8
    if is_error(r11) goto L15 (error at decode_jsonrpc_batch:133) else goto L5
L5:
    decoded = r11
    r12 = PyList_Check(decoded)
    if r12 goto L6 else goto L13 :: bool
L6:
    r13 = PyList_New(0)
    if is_error(r13) goto L16 (error at decode_jsonrpc_batch:134) else goto L7
L7:
    r14 = PyObject_GetIter(decoded)
    dec_ref decoded
    if is_error(r14) goto L17 (error at decode_jsonrpc_batch:134) else goto L8
L8:
    r15 = PyIter_Next(r14)
    if is_error(r15) goto L18 else goto L9
L9:
    r16 = RawResponse(r15)
    dec_ref r15
    if is_error(r16) goto L19 (error at decode_jsonrpc_batch:134) else goto L10
L10:
    r17 = PyList_Append(r13, r16)
    dec_ref r16
    r18 = r17 >= 0 :: signed
    if not r18 goto L19 (error at decode_jsonrpc_batch:134) else goto L8 :: bool
L11:
    r19 = CPy_NoErrOccurred()
    if not r19 goto L17 (error at decode_jsonrpc_batch:134) else goto L12 :: bool
L12:
    r20 = r13
    goto L14
L13:
    r20 = decoded
L14:
    return r20
L15:
    r21 = <error> :: union[object, list]
    return r21
L16:
    dec_ref decoded
    goto L15
L17:
    dec_ref r13
    goto L15
L18:
    dec_ref r14
    goto L11
L19:
    dec_ref r13
    dec_ref r14
    goto L15

def _encode_hook(obj):
    obj :: union[int, object, bytes]
    r0 :: object
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4 :: int
    r5 :: object
    r6 :: str
    r7, r8 :: object
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    r12 :: str
    r13 :: tuple[object, object, object]
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: bit
    r18, e :: object
    r19 :: dict
    r20 :: str
    r21 :: object
    r22 :: i32
    r23 :: bit
    r24 :: bool
    r25 :: dict
    r26 :: object
    r27 :: str
    r28 :: object[1]
    r29 :: object_ptr
    r30, r31, r32 :: object
    r33 :: tuple[object, object]
    r34, r35, r36 :: object
    r37 :: i32
    r38, r39 :: bit
    r40 :: str
    r41 :: object
    r42 :: tuple
    r43, r44 :: object
    r45 :: str
    r46 :: object
    r47 :: list
    r48 :: object
    r49 :: i32
    r50 :: bit
    r51 :: i32
    r52 :: bit
    r53 :: tuple
    r54 :: dict
    r55, r56 :: object
    r57 :: str
    r58 :: object
    r59 :: bit
    r60, r61 :: object
    r62 :: bool
    r63 :: i32
    r64 :: bit
    r65 :: bool
    r66 :: object
    r67 :: str
    r68 :: object[1]
    r69 :: object_ptr
    r70 :: object
    r71 :: dict
    r72 :: str
    r73 :: object
    r74 :: i32
    r75 :: bit
    r76 :: bool
    r77, r78 :: str
    r79 :: object
    r80 :: tuple
    r81, r82 :: object
    r83 :: str
    r84 :: object
    r85 :: list
    r86 :: object
    r87 :: i32
    r88 :: bit
    r89 :: i32
    r90 :: bit
    r91 :: tuple
    r92 :: dict
    r93 :: object
    r94 :: bit
    r95 :: union[object, list, dict]
L0:
L1:
    r0 = load_address PyLong_Type
    r1 = [obj]
    r2 = load_address r1
    r3 = PyObject_Vectorcall(r0, r2, 1, 0)
    if is_error(r3) goto L7 (error at _encode_hook:152) else goto L2
L2:
    r4 = unbox(int, r3)
    dec_ref r3
    if is_error(r4) goto L7 (error at _encode_hook:152) else goto L3
L3:
    r5 = builtins :: module
    r6 = 'hex'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L66 (error at _encode_hook:152) else goto L4
L4:
    r8 = box(int, r4)
    r9 = [r8]
    r10 = load_address r9
    r11 = PyObject_Vectorcall(r7, r10, 1, 0)
    dec_ref r7
    if is_error(r11) goto L67 (error at _encode_hook:152) else goto L5
L5:
    dec_ref r8
    r12 = cast(str, r11)
    if is_error(r12) goto L7 (error at _encode_hook:152) else goto L6
L6:
    return r12
L7:
    r13 = CPy_CatchError()
    r14 = builtins :: module
    r15 = 'TypeError'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L63 (error at _encode_hook:153) else goto L8
L8:
    r17 = CPy_ExceptionMatches(r16)
    dec_ref r16
    if r17 goto L9 else goto L34 :: bool
L9:
    r18 = CPy_GetExcValue()
    e = r18
    r19 = dank_mids.helpers._codec.globals :: static
    r20 = 'Mapping'
    r21 = CPyDict_GetItem(r19, r20)
    if is_error(r21) goto L68 (error at _encode_hook:156) else goto L10
L10:
    r22 = PyObject_IsInstance(obj, r21)
    dec_ref r21
    r23 = r22 >= 0 :: signed
    if not r23 goto L68 (error at _encode_hook:156) else goto L11 :: bool
L11:
    r24 = truncate r22: i32 to builtins.bool
    if r24 goto L69 else goto L22 :: bool
L12:
    r25 = PyDict_New()
    if is_error(r25) goto L63 (error at _encode_hook:157) else goto L13
L13:
    inc_ref obj
    r26 = obj
    r27 = 'items'
    r28 = [r26]
    r29 = load_address r28
    r30 = PyObject_VectorcallMethod(r27, r29, 9223372036854775809, 0)
    if is_error(r30) goto L70 (error at _encode_hook:157) else goto L14
L14:
    dec_ref r26
L15:
    r31 = PyObject_GetIter(r30)
    dec_ref r30
    if is_error(r31) goto L71 (error at _encode_hook:157) else goto L16
L16:
    r32 = PyIter_Next(r31)
    if is_error(r32) goto L72 else goto L17
L17:
    r33 = unbox(tuple[object, object], r32)
    dec_ref r32
    if is_error(r33) goto L73 (error at _encode_hook:157) else goto L18
L18:
    r34 = r33[0]
    r35 = r33[1]
    dec_ref r33
    r36 = _rudimentary_encode_dict_value(r35)
    dec_ref r35
    if is_error(r36) goto L74 (error at _encode_hook:157) else goto L19
L19:
    r37 = CPyDict_SetItem(r25, r34, r36)
    dec_ref r34
    dec_ref r36
    r38 = r37 >= 0 :: signed
    if not r38 goto L73 (error at _encode_hook:157) else goto L16 :: bool
L20:
    r39 = CPy_NoErrOccurred()
    if not r39 goto L71 (error at _encode_hook:157) else goto L21 :: bool
L21:
    CPy_RestoreExcInfo(r13)
    dec_ref r13
    return r25
L22:
    r40 = 'args'
    r41 = CPyObject_GetAttr(e, r40)
    dec_ref e
    if is_error(r41) goto L63 (error at _encode_hook:159) else goto L23
L23:
    r42 = cast(tuple, r41)
    if is_error(r42) goto L63 (error at _encode_hook:159) else goto L24
L24:
    r43 = PyObject_Type(obj)
    r44 = builtins :: module
    r45 = 'TypeError'
    r46 = CPyObject_GetAttr(r44, r45)
    if is_error(r46) goto L75 (error at _encode_hook:159) else goto L25
L25:
    r47 = PyList_New(0)
    if is_error(r47) goto L76 (error at _encode_hook:159) else goto L26
L26:
    r48 = CPyList_Extend(r47, r42)
    dec_ref r42
    if is_error(r48) goto L77 (error at _encode_hook:159) else goto L78
L27:
    r49 = PyList_Append(r47, obj)
    r50 = r49 >= 0 :: signed
    if not r50 goto L77 (error at _encode_hook:159) else goto L28 :: bool
L28:
    r51 = PyList_Append(r47, r43)
    dec_ref r43
    r52 = r51 >= 0 :: signed
    if not r52 goto L79 (error at _encode_hook:159) else goto L29 :: bool
L29:
    r53 = PyList_AsTuple(r47)
    dec_ref r47
    if is_error(r53) goto L80 (error at _encode_hook:159) else goto L30
L30:
    r54 = PyDict_New()
    if is_error(r54) goto L81 (error at _encode_hook:159) else goto L31
L31:
    r55 = PyObject_Call(r46, r53, r54)
    dec_ref r46
    dec_ref r53
    dec_ref r54
    if is_error(r55) goto L63 (error at _encode_hook:159) else goto L32
L32:
    CPy_Raise(r55)
    dec_ref r55
    if not 0 goto L63 (error at _encode_hook:159) else goto L82 :: bool
L33:
    unreachable
L34:
    r56 = builtins :: module
    r57 = 'ValueError'
    r58 = CPyObject_GetAttr(r56, r57)
    if is_error(r58) goto L63 (error at _encode_hook:160) else goto L35
L35:
    r59 = CPy_ExceptionMatches(r58)
    dec_ref r58
    if r59 goto L36 else goto L61 :: bool
L36:
    r60 = CPy_GetExcValue()
    e = r60
    r61 = dank_mids.helpers._codec.HexBytes :: static
    if is_error(r61) goto L83 else goto L39
L37:
    r62 = raise NameError('value for final name "HexBytes" was not set')
    if not r62 goto L63 (error at _encode_hook:163) else goto L84 :: bool
L38:
    unreachable
L39:
    r63 = PyObject_IsInstance(obj, r61)
    r64 = r63 >= 0 :: signed
    if not r64 goto L68 (error at _encode_hook:163) else goto L40 :: bool
L40:
    r65 = truncate r63: i32 to builtins.bool
    if r65 goto L85 else goto L44 :: bool
L41:
    inc_ref obj
    r66 = obj
    r67 = 'hex'
    r68 = [r66]
    r69 = load_address r68
    r70 = PyObject_VectorcallMethod(r67, r69, 9223372036854775809, 0)
    if is_error(r70) goto L86 (error at _encode_hook:164) else goto L42
L42:
    dec_ref r66
L43:
    CPy_RestoreExcInfo(r13)
    dec_ref r13
    return r70
L44:
    r71 = dank_mids.helpers._codec.globals :: static
    r72 = 'Address'
    r73 = CPyDict_GetItem(r71, r72)
    if is_error(r73) goto L68 (error at _encode_hook:165) else goto L45
L45:
    r74 = PyObject_IsInstance(obj, r73)
    dec_ref r73
    r75 = r74 >= 0 :: signed
    if not r75 goto L68 (error at _encode_hook:165) else goto L46 :: bool
L46:
    r76 = truncate r74: i32 to builtins.bool
    if r76 goto L87 else goto L49 :: bool
L47:
    r77 = PyObject_Str(obj)
    if is_error(r77) goto L63 (error at _encode_hook:166) else goto L48
L48:
    CPy_RestoreExcInfo(r13)
    dec_ref r13
    return r77
L49:
    r78 = 'args'
    r79 = CPyObject_GetAttr(e, r78)
    dec_ref e
    if is_error(r79) goto L63 (error at _encode_hook:168) else goto L50
L50:
    r80 = cast(tuple, r79)
    if is_error(r80) goto L63 (error at _encode_hook:168) else goto L51
L51:
    r81 = PyObject_Type(obj)
    r82 = builtins :: module
    r83 = 'ValueError'
    r84 = CPyObject_GetAttr(r82, r83)
    if is_error(r84) goto L88 (error at _encode_hook:168) else goto L52
L52:
    r85 = PyList_New(0)
    if is_error(r85) goto L89 (error at _encode_hook:168) else goto L53
L53:
    r86 = CPyList_Extend(r85, r80)
    dec_ref r80
    if is_error(r86) goto L90 (error at _encode_hook:168) else goto L91
L54:
    r87 = PyList_Append(r85, obj)
    r88 = r87 >= 0 :: signed
    if not r88 goto L90 (error at _encode_hook:168) else goto L55 :: bool
L55:
    r89 = PyList_Append(r85, r81)
    dec_ref r81
    r90 = r89 >= 0 :: signed
    if not r90 goto L92 (error at _encode_hook:168) else goto L56 :: bool
L56:
    r91 = PyList_AsTuple(r85)
    dec_ref r85
    if is_error(r91) goto L93 (error at _encode_hook:168) else goto L57
L57:
    r92 = PyDict_New()
    if is_error(r92) goto L94 (error at _encode_hook:168) else goto L58
L58:
    r93 = PyObject_Call(r84, r91, r92)
    dec_ref r84
    dec_ref r91
    dec_ref r92
    if is_error(r93) goto L63 (error at _encode_hook:168) else goto L59
L59:
    CPy_Raise(r93)
    dec_ref r93
    if not 0 goto L63 (error at _encode_hook:168) else goto L95 :: bool
L60:
    unreachable
L61:
    CPy_Reraise()
    if not 0 goto L63 else goto L96 :: bool
L62:
    unreachable
L63:
    CPy_RestoreExcInfo(r13)
    dec_ref r13
    r94 = CPy_KeepPropagating()
    if not r94 goto L65 else goto L64 :: bool
L64:
    unreachable
L65:
    r95 = <error> :: union[object, list, dict]
    return r95
L66:
    dec_ref r4 :: int
    goto L7
L67:
    dec_ref r8
    goto L7
L68:
    dec_ref e
    goto L63
L69:
    dec_ref e
    goto L12
L70:
    dec_ref r25
    dec_ref r26
    goto L63
L71:
    dec_ref r25
    goto L63
L72:
    dec_ref r31
    goto L20
L73:
    dec_ref r25
    dec_ref r31
    goto L63
L74:
    dec_ref r25
    dec_ref r31
    dec_ref r34
    goto L63
L75:
    dec_ref r42
    dec_ref r43
    goto L63
L76:
    dec_ref r42
    dec_ref r43
    dec_ref r46
    goto L63
L77:
    dec_ref r43
    dec_ref r46
    dec_ref r47
    goto L63
L78:
    dec_ref r48
    goto L27
L79:
    dec_ref r46
    dec_ref r47
    goto L63
L80:
    dec_ref r46
    goto L63
L81:
    dec_ref r46
    dec_ref r53
    goto L63
L82:
    dec_ref r13
    goto L33
L83:
    dec_ref e
    goto L37
L84:
    dec_ref r13
    goto L38
L85:
    dec_ref e
    goto L41
L86:
    dec_ref r66
    goto L63
L87:
    dec_ref e
    goto L47
L88:
    dec_ref r80
    dec_ref r81
    goto L63
L89:
    dec_ref r80
    dec_ref r81
    dec_ref r84
    goto L63
L90:
    dec_ref r81
    dec_ref r84
    dec_ref r85
    goto L63
L91:
    dec_ref r86
    goto L54
L92:
    dec_ref r84
    dec_ref r85
    goto L63
L93:
    dec_ref r84
    goto L63
L94:
    dec_ref r84
    dec_ref r91
    goto L63
L95:
    dec_ref r13
    goto L60
L96:
    dec_ref r13
    goto L62

def _rudimentary_encode_dict_value(value):
    value :: union[int, object]
    r0 :: bit
    r1 :: int
    r2 :: object
    r3 :: str
    r4, r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8 :: object
    r9 :: str
    r10 :: union[str, object]
    r11 :: object
L0:
    r0 = PyLong_Check(value)
    if r0 goto L1 else goto L6 :: bool
L1:
    r1 = unbox(int, value)
    if is_error(r1) goto L8 (error at _rudimentary_encode_dict_value:177) else goto L2
L2:
    r2 = builtins :: module
    r3 = 'hex'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L9 (error at _rudimentary_encode_dict_value:177) else goto L3
L3:
    r5 = box(int, r1)
    r6 = [r5]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r4, r7, 1, 0)
    dec_ref r4
    if is_error(r8) goto L10 (error at _rudimentary_encode_dict_value:177) else goto L4
L4:
    dec_ref r5
    r9 = cast(str, r8)
    if is_error(r9) goto L8 (error at _rudimentary_encode_dict_value:177) else goto L5
L5:
    r10 = r9
    goto L7
L6:
    inc_ref value
    r10 = value
L7:
    return r10
L8:
    r11 = <error> :: object
    return r11
L9:
    dec_ref r1 :: int
    goto L8
L10:
    dec_ref r5
    goto L8

def __mypyc_lambda__0_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__0_obj.__call__(__mypyc_self__, _):
    __mypyc_self__ :: dank_mids.helpers._codec.__mypyc_lambda__0_obj
    _, r0 :: object
L0:
    r0 = load_address _Py_EllipsisObject
    inc_ref r0
    return r0

def _int_to_big_endian(value):
    value :: int
    r0 :: str
    r1 :: object
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5, r6, r7 :: int
    r8 :: bit
    r9 :: int
    r10, r11 :: str
    r12, r13 :: object
    r14 :: object[3]
    r15 :: object_ptr
    r16 :: object
    r17, r18 :: bytes
L0:
    r0 = 'bit_length'
    inc_ref value :: int
    r1 = box(int, value)
    r2 = [r1]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r0, r3, 9223372036854775809, 0)
    if is_error(r4) goto L10 (error at _int_to_big_endian:210) else goto L1
L1:
    dec_ref r1
    r5 = unbox(int, r4)
    dec_ref r4
    if is_error(r5) goto L9 (error at _int_to_big_endian:210) else goto L2
L2:
    r6 = CPyTagged_Add(r5, 14)
    dec_ref r5 :: int
    r7 = CPyTagged_Rshift(r6, 6)
    dec_ref r6 :: int
    if is_error(r7) goto L9 (error at _int_to_big_endian:-1) else goto L3
L3:
    r8 = r7 != 0
    if r8 goto L4 else goto L11 :: bool
L4:
    r9 = r7
    goto L6
L5:
    r9 = 2
L6:
    r10 = 'big'
    r11 = 'to_bytes'
    inc_ref value :: int
    r12 = box(int, value)
    r13 = box(int, r9)
    r14 = [r12, r13, r10]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r11, r15, 9223372036854775811, 0)
    if is_error(r16) goto L12 (error at _int_to_big_endian:210) else goto L7
L7:
    dec_ref r12
    dec_ref r13
    r17 = cast(bytes, r16)
    if is_error(r17) goto L9 (error at _int_to_big_endian:210) else goto L8
L8:
    return r17
L9:
    r18 = <error> :: bytes
    return r18
L10:
    dec_ref r1
    goto L9
L11:
    dec_ref r7 :: int
    goto L5
L12:
    dec_ref r12
    dec_ref r13
    goto L9

def _encode_uint_256(i):
    i :: int
    r0, r1 :: bytes
    r2 :: str
    r3 :: object
    r4 :: object[3]
    r5 :: object_ptr
    r6 :: object
    r7, r8 :: bytes
L0:
    r0 = _int_to_big_endian(i)
    if is_error(r0) goto L4 (error at _encode_uint_256:214) else goto L1
L1:
    r1 = b'\x00'
    r2 = 'rjust'
    r3 = object 32
    r4 = [r0, r3, r1]
    r5 = load_address r4
    r6 = PyObject_VectorcallMethod(r2, r5, 9223372036854775811, 0)
    if is_error(r6) goto L5 (error at _encode_uint_256:215) else goto L2
L2:
    dec_ref r0
    r7 = cast(bytes, r6)
    if is_error(r7) goto L4 (error at _encode_uint_256:215) else goto L3
L3:
    return r7
L4:
    r8 = <error> :: bytes
    return r8
L5:
    dec_ref r0
    goto L4

def __encode_new(values):
    values :: object
    r0 :: tuple[bytes, int]
    r1 :: bytes
    r2 :: int
    r3 :: bytes
    r4 :: int
    r5, r6, r7 :: bytes
L0:
    r0 = __encode_elements_new(values)
    if is_error(r0) goto L4 (error at __encode_new:219) else goto L1
L1:
    r1 = borrow r0[0]
    r2 = borrow r0[1]
    r3 = unborrow r1
    r4 = unborrow r2
    r5 = _encode_uint_256(r4)
    dec_ref r4 :: int
    if is_error(r5) goto L5 (error at __encode_new:220) else goto L2
L2:
    r6 = CPyBytes_Concat(r5, r3)
    dec_ref r3
    if is_error(r6) goto L4 (error at __encode_new:220) else goto L3
L3:
    return r6
L4:
    r7 = <error> :: bytes
    return r7
L5:
    dec_ref r3
    goto L4

def __encode_elements_new(values):
    values :: object
    r0 :: list
    r1, r2 :: object
    r3 :: union[tuple[object, object], list]
    r4 :: object
    r5 :: bool
    r6 :: object[1]
    r7 :: object_ptr
    r8 :: object
    r9 :: i32
    r10, r11 :: bit
    r12 :: ptr
    r13 :: native_int
    r14 :: short_int
    count, r15 :: int
    r16 :: list
    r17 :: object
    r18, r19 :: ptr
    offset :: int
    r20 :: object
    r21 :: list
    r22 :: native_int
    r23 :: ptr
    r24 :: native_int
    r25 :: bit
    r26, r27 :: ptr
    r28 :: native_int
    r29 :: ptr
    r30 :: object
    r31, r32 :: int
    r33 :: object
    r34 :: i32
    r35 :: bit
    r36 :: native_int
    r37 :: ptr
    r38 :: native_int
    r39 :: list
    r40 :: native_int
    r41 :: ptr
    r42 :: native_int
    r43 :: bit
    r44, r45 :: ptr
    r46 :: native_int
    r47 :: ptr
    r48 :: object
    r49, r50 :: int
    r51 :: bytes
    r52 :: native_int
    r53 :: object
    r54 :: bytes
    r55 :: list
    r56, r57 :: object
    r58 :: tuple
    r59 :: bytes
    r60, r61 :: tuple[bytes, int]
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L32 (error at __encode_elements_new:224) else goto L1
L1:
    r1 = PyObject_GetIter(values)
    if is_error(r1) goto L33 (error at __encode_elements_new:224) else goto L2
L2:
    r2 = PyIter_Next(r1)
    if is_error(r2) goto L34 else goto L3
L3:
    r3 = cast(union[tuple[object, object], list], r2)
    if is_error(r3) goto L35 (error at __encode_elements_new:224) else goto L4
L4:
    r4 = dank_mids.helpers._codec._item_encoder :: static
    if is_error(r4) goto L36 else goto L7
L5:
    r5 = raise NameError('value for final name "_item_encoder" was not set')
    if not r5 goto L32 (error at __encode_elements_new:224) else goto L6 :: bool
L6:
    unreachable
L7:
    r6 = [r3]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r4, r7, 1, 0)
    if is_error(r8) goto L37 (error at __encode_elements_new:224) else goto L8
L8:
    dec_ref r3
    r9 = PyList_Append(r0, r8)
    dec_ref r8
    r10 = r9 >= 0 :: signed
    if not r10 goto L35 (error at __encode_elements_new:224) else goto L2 :: bool
L9:
    r11 = CPy_NoErrOccurred()
    if not r11 goto L33 (error at __encode_elements_new:224) else goto L10 :: bool
L10:
    r12 = get_element_ptr r0 ob_size :: PyVarObject
    r13 = load_mem r12 :: native_int*
    r14 = r13 << 1
    count = r14
    r15 = CPyTagged_Multiply(64, count)
    r16 = PyList_New(1)
    if is_error(r16) goto L38 (error at __encode_elements_new:227) else goto L11
L11:
    r17 = object 0
    r18 = get_element_ptr r16 ob_item :: PyListObject
    r19 = load_mem r18 :: ptr*
    inc_ref r17
    set_mem r19, r17 :: builtins.object*
    offset = 0
    r20 = CPyList_GetSlice(r0, 0, -2)
    if is_error(r20) goto L39 (error at __encode_elements_new:229) else goto L12
L12:
    r21 = cast(list, r20)
    if is_error(r21) goto L39 (error at __encode_elements_new:229) else goto L13
L13:
    r22 = 0
L14:
    r23 = get_element_ptr r21 ob_size :: PyVarObject
    r24 = load_mem r23 :: native_int*
    r25 = r22 < r24 :: signed
    if r25 goto L15 else goto L40 :: bool
L15:
    r26 = get_element_ptr r21 ob_item :: PyListObject
    r27 = load_mem r26 :: ptr*
    r28 = r22 * 8
    r29 = r27 + r28
    r30 = load_mem r29 :: builtins.object*
    r31 = CPyObject_Size(r30)
    dec_ref r30
    if is_error(r31) goto L41 (error at __encode_elements_new:230) else goto L16
L16:
    r32 = CPyTagged_Add(offset, r31)
    dec_ref offset :: int
    dec_ref r31 :: int
    offset = r32
    inc_ref offset :: int
    r33 = box(int, offset)
    r34 = PyList_Append(r16, r33)
    dec_ref r33
    r35 = r34 >= 0 :: signed
    if not r35 goto L41 (error at __encode_elements_new:231) else goto L17 :: bool
L17:
    r36 = r22 + 1
    r22 = r36
    goto L14
L18:
    r37 = get_element_ptr r16 ob_size :: PyVarObject
    r38 = load_mem r37 :: native_int*
    r39 = PyList_New(r38)
    if is_error(r39) goto L42 (error at __encode_elements_new:232) else goto L19
L19:
    r40 = 0
L20:
    r41 = get_element_ptr r16 ob_size :: PyVarObject
    r42 = load_mem r41 :: native_int*
    r43 = r40 < r42 :: signed
    if r43 goto L21 else goto L43 :: bool
L21:
    r44 = get_element_ptr r16 ob_item :: PyListObject
    r45 = load_mem r44 :: ptr*
    r46 = r40 * 8
    r47 = r45 + r46
    r48 = load_mem r47 :: builtins.object*
    r49 = unbox(int, r48)
    dec_ref r48
    if is_error(r49) goto L44 (error at __encode_elements_new:232) else goto L22
L22:
    r50 = CPyTagged_Add(r15, r49)
    dec_ref r49 :: int
    r51 = _encode_uint_256(r50)
    dec_ref r50 :: int
    if is_error(r51) goto L44 (error at __encode_elements_new:232) else goto L23
L23:
    CPyList_SetItemUnsafe(r39, r40, r51)
L24:
    r52 = r40 + 1
    r40 = r52
    goto L20
L25:
    r53 = PyObject_GetIter(r39)
    dec_ref r39
    if is_error(r53) goto L45 (error at __encode_elements_new:232) else goto L26
L26:
    r54 = b''
    r55 = PyList_New(0)
    if is_error(r55) goto L46 (error at __encode_elements_new:233) else goto L27
L27:
    r56 = CPyList_Extend(r55, r53)
    dec_ref r53
    if is_error(r56) goto L47 (error at __encode_elements_new:233) else goto L48
L28:
    r57 = CPyList_Extend(r55, r0)
    dec_ref r0
    if is_error(r57) goto L49 (error at __encode_elements_new:233) else goto L50
L29:
    r58 = PyList_AsTuple(r55)
    dec_ref r55
    if is_error(r58) goto L51 (error at __encode_elements_new:233) else goto L30
L30:
    r59 = CPyBytes_Join(r54, r58)
    dec_ref r58
    if is_error(r59) goto L51 (error at __encode_elements_new:233) else goto L31
L31:
    r60 = (r59, count)
    return r60
L32:
    r61 = <error> :: tuple[bytes, int]
    return r61
L33:
    dec_ref r0
    goto L32
L34:
    dec_ref r1
    goto L9
L35:
    dec_ref r0
    dec_ref r1
    goto L32
L36:
    dec_ref r0
    dec_ref r1
    dec_ref r3
    goto L5
L37:
    dec_ref r0
    dec_ref r1
    dec_ref r3
    goto L32
L38:
    dec_ref r0
    dec_ref count :: int
    dec_ref r15 :: int
    goto L32
L39:
    dec_ref r0
    dec_ref count :: int
    dec_ref r15 :: int
    dec_ref r16
    dec_ref offset :: int
    goto L32
L40:
    dec_ref offset :: int
    dec_ref r21
    goto L18
L41:
    dec_ref r0
    dec_ref count :: int
    dec_ref r15 :: int
    dec_ref r16
    dec_ref offset :: int
    dec_ref r21
    goto L32
L42:
    dec_ref r0
    dec_ref count :: int
    dec_ref r15 :: int
    dec_ref r16
    goto L32
L43:
    dec_ref r15 :: int
    dec_ref r16
    goto L25
L44:
    dec_ref r0
    dec_ref count :: int
    dec_ref r15 :: int
    dec_ref r16
    dec_ref r39
    goto L32
L45:
    dec_ref r0
    dec_ref count :: int
    goto L32
L46:
    dec_ref r0
    dec_ref count :: int
    dec_ref r53
    goto L32
L47:
    dec_ref r0
    dec_ref count :: int
    dec_ref r55
    goto L32
L48:
    dec_ref r56
    goto L28
L49:
    dec_ref count :: int
    dec_ref r55
    goto L32
L50:
    dec_ref r57
    goto L29
L51:
    dec_ref count :: int
    goto L32

def mcall_encode(data):
    data :: object
    r0 :: tuple[bool, object]
    r1 :: object
    r2 :: bool
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7, r8 :: bytes
L0:
    inc_ref data
    r0 = (0, data)
    r1 = dank_mids.helpers._codec._mcall_encoder :: static
    if is_error(r1) goto L7 else goto L3
L1:
    r2 = raise NameError('value for final name "_mcall_encoder" was not set')
    if not r2 goto L6 (error at mcall_encode:246) else goto L2 :: bool
L2:
    unreachable
L3:
    r3 = box(tuple[bool, object], r0)
    r4 = [r3]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r1, r5, 1, 0)
    if is_error(r6) goto L8 (error at mcall_encode:246) else goto L4
L4:
    dec_ref r3
    r7 = cast(bytes, r6)
    if is_error(r7) goto L6 (error at mcall_encode:246) else goto L5
L5:
    return r7
L6:
    r8 = <error> :: bytes
    return r8
L7:
    dec_ref r0
    goto L1
L8:
    dec_ref r3
    goto L6

def mcall_decode(data):
    data :: object
    r0, r1 :: str
    r2 :: object[2]
    r3 :: object_ptr
    r4, r5 :: object
    r6 :: bool
    r7 :: object[1]
    r8 :: object_ptr
    r9, r10 :: object
    r11 :: bool
    r12 :: object[1]
    r13 :: object_ptr
    r14 :: object
    r15 :: tuple[int, int, tuple]
    r16 :: tuple
    r17 :: tuple[object, object, object]
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: bit
    r22 :: object
    r23 :: dict
    r24 :: str
    r25, r26 :: object
    r27 :: bit
    r28 :: None
    r29 :: str
    r30 :: object
    r31 :: tuple
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: i32
    r36 :: bit
    r37 :: bool
    r38 :: str
    r39 :: object[1]
    r40 :: object_ptr
    r41 :: object
    r42 :: union[object, str]
    r43 :: list
    r44 :: object
    r45 :: i32
    r46 :: bit
    r47 :: tuple
    r48 :: str
    r49 :: i32
    r50, r51 :: bit
    r52 :: ptr
    r53 :: native_int
    r54 :: list
    r55 :: native_int
    r56 :: ptr
    r57 :: native_int
    r58 :: bit
    r59 :: object
    r60 :: tuple[bool, bytes]
    r61 :: bytes
    r62 :: native_int
    r63 :: union[list, object]
L0:
L1:
    r0 = 'eth_call'
    r1 = 'decode_result'
    r2 = [data, r0]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775810, 0)
    if is_error(r4) goto L12 (error at mcall_decode:255) else goto L2
L2:
    r5 = dank_mids.helpers._codec.ContextFramesBytesIO :: static
    if is_error(r5) goto L43 else goto L5
L3:
    r6 = raise NameError('value for final name "ContextFramesBytesIO" was not set')
    if not r6 goto L12 (error at mcall_decode:255) else goto L4 :: bool
L4:
    unreachable
L5:
    r7 = [r4]
    r8 = load_address r7
    r9 = PyObject_Vectorcall(r5, r8, 1, 0)
    if is_error(r9) goto L44 (error at mcall_decode:255) else goto L6
L6:
    dec_ref r4
    r10 = dank_mids.helpers._codec._mcall_decoder :: static
    if is_error(r10) goto L45 else goto L9
L7:
    r11 = raise NameError('value for final name "_mcall_decoder" was not set')
    if not r11 goto L12 (error at mcall_decode:255) else goto L8 :: bool
L8:
    unreachable
L9:
    r12 = [r9]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r10, r13, 1, 0)
    if is_error(r14) goto L46 (error at mcall_decode:255) else goto L10
L10:
    dec_ref r9
    r15 = unbox(tuple[int, int, tuple], r14)
    dec_ref r14
    if is_error(r15) goto L12 (error at mcall_decode:255) else goto L11
L11:
    r16 = r15[2]
    dec_ref r15
    goto L35
L12:
    r17 = CPy_CatchError()
    r18 = builtins :: module
    r19 = 'Exception'
    r20 = CPyObject_GetAttr(r18, r19)
    if is_error(r20) goto L33 (error at mcall_decode:256) else goto L13
L13:
    r21 = CPy_ExceptionMatches(r20)
    dec_ref r20
    if r21 goto L14 else goto L31 :: bool
L14:
    r22 = CPy_GetExcValue()
    r23 = dank_mids.helpers._codec.globals :: static
    r24 = 'PartialResponse'
    r25 = CPyDict_GetItem(r23, r24)
    if is_error(r25) goto L47 (error at mcall_decode:257) else goto L15
L15:
    r26 = load_address _Py_NoneStruct
    r27 = r25 == r26
    dec_ref r25
    if r27 goto L16 else goto L17 :: bool
L16:
    r28 = __import_from_types()
    if is_error(r28) goto L47 (error at mcall_decode:258) else goto L17
L17:
    r29 = 'args'
    r30 = CPyObject_GetAttr(r22, r29)
    if is_error(r30) goto L47 (error at mcall_decode:260) else goto L18
L18:
    r31 = cast(tuple, r30)
    if is_error(r31) goto L47 (error at mcall_decode:260) else goto L19
L19:
    r32 = dank_mids.helpers._codec.globals :: static
    r33 = 'PartialResponse'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L48 (error at mcall_decode:260) else goto L20
L20:
    r35 = PyObject_IsInstance(data, r34)
    dec_ref r34
    r36 = r35 >= 0 :: signed
    if not r36 goto L48 (error at mcall_decode:260) else goto L21 :: bool
L21:
    r37 = truncate r35: i32 to builtins.bool
    if r37 goto L22 else goto L24 :: bool
L22:
    r38 = 'decode_result'
    r39 = [data]
    r40 = load_address r39
    r41 = PyObject_VectorcallMethod(r38, r40, 9223372036854775809, 0)
    if is_error(r41) goto L48 (error at mcall_decode:260) else goto L23
L23:
    r42 = r41
    goto L25
L24:
    inc_ref data
    r42 = data
L25:
    r43 = PyList_New(0)
    if is_error(r43) goto L49 (error at mcall_decode:260) else goto L26
L26:
    r44 = CPyList_Extend(r43, r31)
    dec_ref r31
    if is_error(r44) goto L50 (error at mcall_decode:260) else goto L51
L27:
    r45 = PyList_Append(r43, r42)
    dec_ref r42
    r46 = r45 >= 0 :: signed
    if not r46 goto L52 (error at mcall_decode:260) else goto L28 :: bool
L28:
    r47 = PyList_AsTuple(r43)
    dec_ref r43
    if is_error(r47) goto L47 (error at mcall_decode:260) else goto L29
L29:
    r48 = 'args'
    r49 = PyObject_SetAttr(r22, r48, r47)
    dec_ref r47
    r50 = r49 >= 0 :: signed
    if not r50 goto L47 (error at mcall_decode:260) else goto L30 :: bool
L30:
    CPy_RestoreExcInfo(r17)
    dec_ref r17
    return r22
L31:
    CPy_Reraise()
    if not 0 goto L33 else goto L53 :: bool
L32:
    unreachable
L33:
    CPy_RestoreExcInfo(r17)
    dec_ref r17
    r51 = CPy_KeepPropagating()
    if not r51 goto L42 else goto L34 :: bool
L34:
    unreachable
L35:
    r52 = get_element_ptr r16 ob_size :: PyVarObject
    r53 = load_mem r52 :: native_int*
    r54 = PyList_New(r53)
    if is_error(r54) goto L54 (error at mcall_decode:263) else goto L36
L36:
    r55 = 0
L37:
    r56 = get_element_ptr r16 ob_size :: PyVarObject
    r57 = load_mem r56 :: native_int*
    r58 = r55 < r57 :: signed
    if r58 goto L38 else goto L55 :: bool
L38:
    r59 = CPySequenceTuple_GetItemUnsafe(r16, r55)
    r60 = unbox(tuple[bool, bytes], r59)
    dec_ref r59
    if is_error(r60) goto L56 (error at mcall_decode:263) else goto L39
L39:
    r61 = r60[1]
    dec_ref r60
    CPyList_SetItemUnsafe(r54, r55, r61)
L40:
    r62 = r55 + 1
    r55 = r62
    goto L37
L41:
    return r54
L42:
    r63 = <error> :: union[list, object]
    return r63
L43:
    dec_ref r4
    goto L3
L44:
    dec_ref r4
    goto L12
L45:
    dec_ref r9
    goto L7
L46:
    dec_ref r9
    goto L12
L47:
    dec_ref r22
    goto L33
L48:
    dec_ref r22
    dec_ref r31
    goto L33
L49:
    dec_ref r22
    dec_ref r31
    dec_ref r42
    goto L33
L50:
    dec_ref r22
    dec_ref r42
    dec_ref r43
    goto L33
L51:
    dec_ref r44
    goto L27
L52:
    dec_ref r22
    dec_ref r43
    goto L33
L53:
    dec_ref r17
    goto L32
L54:
    dec_ref r16
    goto L42
L55:
    dec_ref r16
    goto L41
L56:
    dec_ref r16
    dec_ref r54
    goto L42

def __import_from_types():
    r0 :: object
    r1 :: str
    r2 :: dict
    r3 :: object
    r4 :: None
L0:
    r0 = ('PartialResponse', 'Request', 'Response', 'better_decode')
    r1 = 'dank_mids.types'
    r2 = dank_mids.helpers._codec.globals :: static
    r3 = CPyImport_ImportFromMany(r1, r0, r0, r2)
    if is_error(r3) goto L2 (error at __import_from_types:269) else goto L1
L1:
    dank_mids.types = r3 :: module
    dec_ref r3
    return 1
L2:
    r4 = <error> :: None
    return r4

def __make_decode_batch():
    r0 :: object
    r1 :: str
    r2 :: dict
    r3 :: object
    r4 :: dict
    r5 :: str
    r6 :: object
    r7 :: dict
    r8 :: str
    r9 :: object
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: str
    r14, r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: object
    r19 :: tuple[object, object]
    r20, r21 :: object
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: object[1]
    r26 :: object_ptr
    r27, r28 :: object
    r29 :: str
    r30 :: object
    r31 :: dict
    r32 :: str
    r33 :: i32
    r34 :: bit
    r35 :: None
L0:
    r0 = ('PartialResponse',)
    r1 = 'dank_mids.types'
    r2 = dank_mids.helpers._codec.globals :: static
    r3 = CPyImport_ImportFromMany(r1, r0, r0, r2)
    if is_error(r3) goto L13 (error at __make_decode_batch:273) else goto L1
L1:
    dank_mids.types = r3 :: module
    dec_ref r3
    r4 = dank_mids.helpers._codec.globals :: static
    r5 = 'Union'
    r6 = CPyDict_GetItem(r4, r5)
    if is_error(r6) goto L13 (error at __make_decode_batch:276) else goto L2
L2:
    r7 = dank_mids.helpers._codec.globals :: static
    r8 = 'List'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L14 (error at __make_decode_batch:276) else goto L3
L3:
    r10 = dank_mids.helpers._codec.globals :: static
    r11 = 'msgspec'
    r12 = CPyDict_GetItem(r10, r11)
    if is_error(r12) goto L15 (error at __make_decode_batch:276) else goto L4
L4:
    r13 = 'Raw'
    r14 = CPyObject_GetAttr(r12, r13)
    dec_ref r12
    if is_error(r14) goto L15 (error at __make_decode_batch:276) else goto L5
L5:
    r15 = PyObject_GetItem(r9, r14)
    dec_ref r9
    dec_ref r14
    if is_error(r15) goto L14 (error at __make_decode_batch:276) else goto L6
L6:
    r16 = dank_mids.helpers._codec.globals :: static
    r17 = 'PartialResponse'
    r18 = CPyDict_GetItem(r16, r17)
    if is_error(r18) goto L16 (error at __make_decode_batch:276) else goto L7
L7:
    r19 = (r15, r18)
    r20 = box(tuple[object, object], r19)
    r21 = PyObject_GetItem(r6, r20)
    dec_ref r6
    dec_ref r20
    if is_error(r21) goto L13 (error at __make_decode_batch:276) else goto L8
L8:
    r22 = dank_mids.helpers._codec.globals :: static
    r23 = 'Decoder'
    r24 = CPyDict_GetItem(r22, r23)
    if is_error(r24) goto L17 (error at __make_decode_batch:276) else goto L9
L9:
    r25 = [r21]
    r26 = load_address r25
    r27 = ('type',)
    r28 = PyObject_Vectorcall(r24, r26, 0, r27)
    dec_ref r24
    if is_error(r28) goto L17 (error at __make_decode_batch:276) else goto L10
L10:
    dec_ref r21
    r29 = 'decode'
    r30 = CPyObject_GetAttr(r28, r29)
    dec_ref r28
    if is_error(r30) goto L13 (error at __make_decode_batch:276) else goto L11
L11:
    r31 = dank_mids.helpers._codec.globals :: static
    r32 = '_decode_batch'
    r33 = CPyDict_SetItem(r31, r32, r30)
    dec_ref r30
    r34 = r33 >= 0 :: signed
    if not r34 goto L13 (error at __make_decode_batch:276) else goto L12 :: bool
L12:
    return 1
L13:
    r35 = <error> :: None
    return r35
L14:
    dec_ref r6
    goto L13
L15:
    dec_ref r6
    dec_ref r9
    goto L13
L16:
    dec_ref r6
    dec_ref r15
    goto L13
L17:
    dec_ref r21
    goto L13

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9, r10 :: object_ptr
    r11 :: object_ptr[2]
    r12 :: c_ptr
    r13 :: native_int[2]
    r14 :: c_ptr
    r15 :: object
    r16 :: dict
    r17, r18 :: str
    r19 :: bit
    r20 :: object
    r21 :: str
    r22 :: dict
    r23, r24 :: object
    r25 :: str
    r26 :: dict
    r27, r28 :: object
    r29 :: str
    r30 :: dict
    r31, r32 :: object
    r33 :: str
    r34 :: dict
    r35, r36 :: object
    r37 :: str
    r38 :: dict
    r39, r40 :: object
    r41 :: str
    r42 :: dict
    r43 :: object
    r44 :: dict
    r45 :: str
    r46 :: object
    r47 :: i32
    r48 :: bit
    r49 :: dict
    r50 :: str
    r51 :: object
    r52 :: i32
    r53 :: bit
    r54 :: dict
    r55 :: str
    r56 :: object
    r57 :: i32
    r58 :: bit
    r59 :: dict
    r60 :: str
    r61 :: object
    r62 :: i32
    r63 :: bit
    r64 :: str
    r65 :: dict
    r66 :: str
    r67 :: object
    r68 :: object[1]
    r69 :: object_ptr
    r70 :: object
    r71 :: dict
    r72 :: str
    r73 :: i32
    r74 :: bit
    r75 :: dict
    r76 :: str
    r77 :: object
    r78 :: dict
    r79 :: str
    r80 :: object
    r81 :: dict
    r82 :: str
    r83 :: object
    r84 :: dict
    r85 :: str
    r86 :: object
    r87 :: tuple[object, object, object]
    r88, r89 :: object
    r90 :: dict
    r91 :: str
    r92 :: i32
    r93 :: bit
    r94 :: dict
    r95 :: str
    r96, r97 :: object
    r98 :: dict
    r99 :: str
    r100 :: object
    r101 :: dict
    r102 :: str
    r103 :: object
    r104 :: str
    r105, r106 :: object
    r107 :: tuple[object, object, object, object]
    r108, r109 :: object
    r110 :: dict
    r111 :: str
    r112 :: i32
    r113 :: bit
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: dict
    r118 :: str
    r119 :: object
    r120 :: dict
    r121 :: str
    r122 :: object
    r123 :: dict
    r124 :: str
    r125, r126 :: object
    r127 :: dict
    r128 :: str
    r129, r130 :: object
    r131 :: dict
    r132 :: str
    r133 :: object
    r134 :: tuple[object, object]
    r135, r136 :: object
    r137 :: tuple[object, object, object]
    r138, r139 :: object
    r140 :: dict
    r141 :: str
    r142 :: i32
    r143 :: bit
    r144 :: dict
    r145 :: str
    r146 :: object
    r147 :: dict
    r148 :: str
    r149 :: object
    r150 :: dict
    r151 :: str
    r152 :: object
    r153 :: dict
    r154 :: str
    r155 :: object
    r156 :: str
    r157 :: object
    r158 :: tuple[object, object]
    r159, r160 :: object
    r161 :: dict
    r162 :: str
    r163 :: object
    r164 :: dict
    r165 :: str
    r166 :: object
    r167 :: dict
    r168 :: str
    r169 :: object
    r170 :: dict
    r171 :: str
    r172 :: object
    r173 :: str
    r174 :: object
    r175 :: tuple[object, object]
    r176, r177, r178 :: object
    r179 :: tuple[object, object]
    r180, r181 :: object
    r182 :: dict
    r183 :: str
    r184 :: i32
    r185 :: bit
    r186 :: dict
    r187 :: str
    r188 :: object
    r189 :: dict
    r190 :: str
    r191, r192 :: object
    r193 :: dict
    r194 :: str
    r195 :: object
    r196 :: dict
    r197 :: str
    r198, r199 :: object
    r200 :: tuple[object, object]
    r201, r202 :: object
    r203 :: list
    r204, r205 :: ptr
    r206 :: object
    r207 :: tuple[list, object]
    r208, r209 :: object
    r210 :: dict
    r211 :: str
    r212 :: i32
    r213 :: bit
    r214 :: dict
    r215 :: str
    r216, r217, r218 :: object
    r219 :: dict
    r220 :: str
    r221 :: object
    r222 :: dict
    r223 :: str
    r224 :: object
    r225 :: str
    r226 :: object
    r227 :: tuple[str, object]
    r228, r229, r230 :: object
    r231 :: tuple[object, object]
    r232, r233 :: object
    r234 :: tuple[object, object, object]
    r235, r236 :: object
    r237 :: dict
    r238 :: str
    r239 :: i32
    r240 :: bit
    r241 :: dict
    r242 :: str
    r243, r244 :: object
    r245 :: dict
    r246 :: str
    r247 :: object
    r248 :: tuple[object, object]
    r249, r250 :: object
    r251 :: dict
    r252 :: str
    r253 :: i32
    r254 :: bit
    r255 :: dict
    r256 :: str
    r257 :: object
    r258 :: str
    r259 :: object
    r260 :: dict
    r261 :: str
    r262 :: i32
    r263 :: bit
    r264 :: dict
    r265 :: str
    r266 :: object
    r267 :: dict
    r268 :: str
    r269 :: object
    r270 :: str
    r271 :: object
    r272 :: str
    r273 :: tuple[object, str]
    r274, r275 :: object
    r276 :: dict
    r277 :: str
    r278 :: i32
    r279 :: bit
    r280 :: dict
    r281 :: str
    r282 :: object
    r283 :: dict
    r284 :: str
    r285, r286, r287 :: object
    r288 :: tuple[object, object]
    r289, r290 :: object
    r291 :: list
    r292, r293 :: ptr
    r294 :: dict
    r295 :: str
    r296 :: object
    r297 :: dict
    r298 :: str
    r299 :: object
    r300 :: dict
    r301 :: str
    r302 :: object
    r303 :: str
    r304, r305 :: object
    r306 :: str
    r307 :: tuple[object, str]
    r308, r309 :: object
    r310 :: tuple[list, object]
    r311, r312 :: object
    r313 :: dict
    r314 :: str
    r315 :: i32
    r316 :: bit
    r317 :: dict
    r318 :: str
    r319 :: object
    r320 :: str
    r321 :: object
    r322 :: dict
    r323 :: str
    r324 :: i32
    r325 :: bit
    r326 :: dict
    r327 :: str
    r328 :: object
    r329 :: str
    r330 :: object
    r331 :: dict
    r332 :: str
    r333 :: i32
    r334 :: bit
    r335 :: dict
    r336 :: str
    r337 :: object
    r338 :: str
    r339 :: object
    r340 :: dict
    r341 :: str
    r342 :: i32
    r343 :: bit
    r344 :: dict
    r345 :: str
    r346 :: object
    r347 :: str
    r348 :: object
    r349 :: dict
    r350 :: str
    r351 :: i32
    r352 :: bit
    r353 :: object
    r354 :: dict
    r355 :: str
    r356 :: object
    r357 :: object[1]
    r358 :: object_ptr
    r359, r360 :: object
    r361 :: str
    r362 :: object
    r363 :: dict
    r364 :: str
    r365 :: i32
    r366 :: bit
    r367 :: object
    r368 :: bool
    r369 :: dict
    r370 :: str
    r371 :: object
    r372 :: object[1]
    r373 :: object_ptr
    r374, r375 :: object
    r376 :: str
    r377 :: object
    r378 :: dict
    r379 :: str
    r380 :: i32
    r381 :: bit
    r382 :: dict
    r383 :: str
    r384 :: object
    r385 :: i32
    r386 :: bit
    r387 :: object
    r388 :: str
    r389, r390 :: object
    r391 :: bool
    r392, r393 :: str
    r394 :: tuple
    r395 :: i32
    r396 :: bit
    r397 :: dict
    r398 :: str
    r399 :: i32
    r400 :: bit
    r401 :: dict
    r402 :: str
    r403 :: object
    r404 :: dict
    r405 :: str
    r406 :: object
    r407 :: object[1]
    r408 :: object_ptr
    r409, r410 :: object
    r411 :: str
    r412 :: object
    r413 :: dict
    r414 :: str
    r415 :: i32
    r416 :: bit
    r417 :: dict
    r418 :: str
    r419 :: object
    r420 :: str
    r421 :: object
    r422, r423 :: str
    r424 :: object[2]
    r425 :: object_ptr
    r426 :: object
    r427 :: dict
    r428 :: str
    r429 :: i32
    r430 :: bit
    r431 :: object
    r432 :: bool
    r433 :: str
    r434, r435, r436 :: object
    r437 :: dict
    r438 :: str
    r439 :: i32
    r440 :: bit
    r441 :: object
    r442 :: bool
    r443 :: str
    r444 :: object
    r445 :: dict
    r446 :: str
    r447 :: i32
    r448 :: bit
    r449 :: dank_mids.helpers._codec.__mypyc_lambda__0_obj
    r450 :: object
    r451 :: bool
    r452 :: str
    r453 :: i32
    r454 :: bit
    r455 :: object
    r456 :: bool
    r457 :: str
    r458 :: i32
    r459 :: bit
    r460 :: object
    r461 :: bool
    r462 :: str
    r463 :: i32
    r464 :: bit
    r465 :: dict
    r466 :: str
    r467, r468 :: object
    r469 :: bool
    r470 :: str
    r471 :: i32
    r472 :: bit
    r473 :: dict
    r474 :: str
    r475, r476 :: object
    r477 :: bool
    r478 :: str
    r479 :: i32
    r480 :: bit
    r481 :: dict
    r482 :: str
    r483 :: object
    r484 :: str
    r485 :: object
    r486, r487 :: str
    r488 :: object[2]
    r489 :: object_ptr
    r490 :: object
    r491 :: str
    r492 :: object
    r493 :: dict
    r494 :: str
    r495 :: i32
    r496 :: bit
    r497 :: object
    r498 :: dict
    r499 :: str
    r500 :: i32
    r501 :: bit
    r502 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L175 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Any', 'AnyStr', 'Callable', 'Dict', 'Final', 'Iterable', 'List', 'Literal', 'Mapping', 'Optional', 'Union', 'Tuple', 'Type', 'TypeVar', 'Union', 'final', 'overload')
    r6 = 'typing'
    r7 = dank_mids.helpers._codec.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L175 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address hexbytes :: module
    r10 = load_address msgspec :: module
    r11 = [r9, r10]
    r12 = load_address r11
    r13 = [22, 23]
    r14 = load_address r13
    r15 = (('hexbytes', 'hexbytes', 'hexbytes'), ('msgspec', 'msgspec', 'msgspec'))
    r16 = dank_mids.helpers._codec.globals :: static
    r17 = 'dank_mids/helpers/_codec.py'
    r18 = '<module>'
    r19 = CPyImport_ImportMany(r15, r12, r16, r17, r18, r14)
    if not r19 goto L175 else goto L5 :: bool
L5:
    r20 = ('ChecksumAddress', 'HexStr')
    r21 = 'eth_typing'
    r22 = dank_mids.helpers._codec.globals :: static
    r23 = CPyImport_ImportFromMany(r21, r20, r20, r22)
    if is_error(r23) goto L175 (error at <module>:24) else goto L6
L6:
    eth_typing = r23 :: module
    dec_ref r23
    r24 = ('decoding',)
    r25 = 'faster_eth_abi'
    r26 = dank_mids.helpers._codec.globals :: static
    r27 = CPyImport_ImportFromMany(r25, r24, r24, r26)
    if is_error(r27) goto L175 (error at <module>:25) else goto L7
L7:
    faster_eth_abi = r27 :: module
    dec_ref r27
    r28 = ('default_codec',)
    r29 = 'faster_eth_abi.abi'
    r30 = dank_mids.helpers._codec.globals :: static
    r31 = CPyImport_ImportFromMany(r29, r28, r28, r30)
    if is_error(r31) goto L175 (error at <module>:26) else goto L8
L8:
    faster_eth_abi.abi = r31 :: module
    dec_ref r31
    r32 = ('DynamicArrayEncoder', 'TupleEncoder')
    r33 = 'faster_eth_abi.encoding'
    r34 = dank_mids.helpers._codec.globals :: static
    r35 = CPyImport_ImportFromMany(r33, r32, r32, r34)
    if is_error(r35) goto L175 (error at <module>:27) else goto L9
L9:
    faster_eth_abi.encoding = r35 :: module
    dec_ref r35
    r36 = ('Address',)
    r37 = 'evmspec.data'
    r38 = dank_mids.helpers._codec.globals :: static
    r39 = CPyImport_ImportFromMany(r37, r36, r36, r38)
    if is_error(r39) goto L175 (error at <module>:28) else goto L10
L10:
    evmspec.data = r39 :: module
    dec_ref r39
    r40 = ('Decoder', 'Encoder')
    r41 = 'msgspec.json'
    r42 = dank_mids.helpers._codec.globals :: static
    r43 = CPyImport_ImportFromMany(r41, r40, r40, r42)
    if is_error(r43) goto L175 (error at <module>:29) else goto L11
L11:
    msgspec.json = r43 :: module
    dec_ref r43
    if 0 goto L12 else goto L12 :: bool
L12:
    r44 = dank_mids.helpers._codec.globals :: static
    r45 = 'PartialResponse'
    r46 = box(None, 1)
    r47 = CPyDict_SetItem(r44, r45, r46)
    r48 = r47 >= 0 :: signed
    if not r48 goto L175 (error at <module>:36) else goto L13 :: bool
L13:
    r49 = dank_mids.helpers._codec.globals :: static
    r50 = 'Request'
    r51 = box(None, 1)
    r52 = CPyDict_SetItem(r49, r50, r51)
    r53 = r52 >= 0 :: signed
    if not r53 goto L175 (error at <module>:37) else goto L14 :: bool
L14:
    r54 = dank_mids.helpers._codec.globals :: static
    r55 = 'Response'
    r56 = box(None, 1)
    r57 = CPyDict_SetItem(r54, r55, r56)
    r58 = r57 >= 0 :: signed
    if not r58 goto L175 (error at <module>:38) else goto L15 :: bool
L15:
    r59 = dank_mids.helpers._codec.globals :: static
    r60 = 'better_decode'
    r61 = box(None, 1)
    r62 = CPyDict_SetItem(r59, r60, r61)
    r63 = r62 >= 0 :: signed
    if not r63 goto L175 (error at <module>:39) else goto L16 :: bool
L16:
    r64 = '__T'
    r65 = dank_mids.helpers._codec.globals :: static
    r66 = 'TypeVar'
    r67 = CPyDict_GetItem(r65, r66)
    if is_error(r67) goto L175 (error at <module>:42) else goto L17
L17:
    r68 = [r64]
    r69 = load_address r68
    r70 = PyObject_Vectorcall(r67, r69, 1, 0)
    dec_ref r67
    if is_error(r70) goto L175 (error at <module>:42) else goto L18
L18:
    r71 = dank_mids.helpers._codec.globals :: static
    r72 = '__T'
    r73 = CPyDict_SetItem(r71, r72, r70)
    dec_ref r70
    r74 = r73 >= 0 :: signed
    if not r74 goto L175 (error at <module>:42) else goto L19 :: bool
L19:
    r75 = dank_mids.helpers._codec.globals :: static
    r76 = 'Union'
    r77 = CPyDict_GetItem(r75, r76)
    if is_error(r77) goto L175 (error at <module>:45) else goto L20
L20:
    r78 = dank_mids.helpers._codec.globals :: static
    r79 = 'ChecksumAddress'
    r80 = CPyDict_GetItem(r78, r79)
    if is_error(r80) goto L176 (error at <module>:45) else goto L21
L21:
    r81 = dank_mids.helpers._codec.globals :: static
    r82 = 'HexStr'
    r83 = CPyDict_GetItem(r81, r82)
    if is_error(r83) goto L177 (error at <module>:45) else goto L22
L22:
    r84 = dank_mids.helpers._codec.globals :: static
    r85 = 'Address'
    r86 = CPyDict_GetItem(r84, r85)
    if is_error(r86) goto L178 (error at <module>:45) else goto L23
L23:
    r87 = (r80, r83, r86)
    r88 = box(tuple[object, object, object], r87)
    r89 = PyObject_GetItem(r77, r88)
    dec_ref r77
    dec_ref r88
    if is_error(r89) goto L175 (error at <module>:45) else goto L24
L24:
    r90 = dank_mids.helpers._codec.globals :: static
    r91 = 'StrEncodable'
    r92 = CPyDict_SetItem(r90, r91, r89)
    dec_ref r89
    r93 = r92 >= 0 :: signed
    if not r93 goto L175 (error at <module>:45) else goto L25 :: bool
L25:
    r94 = dank_mids.helpers._codec.globals :: static
    r95 = 'Union'
    r96 = CPyDict_GetItem(r94, r95)
    if is_error(r96) goto L175 (error at <module>:46) else goto L26
L26:
    r97 = load_address PyLong_Type
    r98 = dank_mids.helpers._codec.globals :: static
    r99 = 'StrEncodable'
    r100 = CPyDict_GetItem(r98, r99)
    if is_error(r100) goto L179 (error at <module>:46) else goto L27
L27:
    r101 = dank_mids.helpers._codec.globals :: static
    r102 = 'hexbytes'
    r103 = CPyDict_GetItem(r101, r102)
    if is_error(r103) goto L180 (error at <module>:46) else goto L28
L28:
    r104 = 'HexBytes'
    r105 = CPyObject_GetAttr(r103, r104)
    dec_ref r103
    if is_error(r105) goto L180 (error at <module>:46) else goto L29
L29:
    r106 = load_address PyBytes_Type
    inc_ref r97
    inc_ref r106
    r107 = (r97, r100, r105, r106)
    r108 = box(tuple[object, object, object, object], r107)
    r109 = PyObject_GetItem(r96, r108)
    dec_ref r96
    dec_ref r108
    if is_error(r109) goto L175 (error at <module>:46) else goto L30
L30:
    r110 = dank_mids.helpers._codec.globals :: static
    r111 = 'Encodable'
    r112 = CPyDict_SetItem(r110, r111, r109)
    dec_ref r109
    r113 = r112 >= 0 :: signed
    if not r113 goto L175 (error at <module>:46) else goto L31 :: bool
L31:
    r114 = dank_mids.helpers._codec.globals :: static
    r115 = 'Union'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L175 (error at <module>:48) else goto L32
L32:
    r117 = dank_mids.helpers._codec.globals :: static
    r118 = 'HexStr'
    r119 = CPyDict_GetItem(r117, r118)
    if is_error(r119) goto L181 (error at <module>:48) else goto L33
L33:
    r120 = dank_mids.helpers._codec.globals :: static
    r121 = 'List'
    r122 = CPyDict_GetItem(r120, r121)
    if is_error(r122) goto L182 (error at <module>:48) else goto L34
L34:
    r123 = dank_mids.helpers._codec.globals :: static
    r124 = 'HexStr'
    r125 = CPyDict_GetItem(r123, r124)
    if is_error(r125) goto L183 (error at <module>:48) else goto L35
L35:
    r126 = PyObject_GetItem(r122, r125)
    dec_ref r122
    dec_ref r125
    if is_error(r126) goto L182 (error at <module>:48) else goto L36
L36:
    r127 = dank_mids.helpers._codec.globals :: static
    r128 = 'Dict'
    r129 = CPyDict_GetItem(r127, r128)
    if is_error(r129) goto L184 (error at <module>:48) else goto L37
L37:
    r130 = load_address PyUnicode_Type
    r131 = dank_mids.helpers._codec.globals :: static
    r132 = 'HexStr'
    r133 = CPyDict_GetItem(r131, r132)
    if is_error(r133) goto L185 (error at <module>:48) else goto L38
L38:
    inc_ref r130
    r134 = (r130, r133)
    r135 = box(tuple[object, object], r134)
    r136 = PyObject_GetItem(r129, r135)
    dec_ref r129
    dec_ref r135
    if is_error(r136) goto L184 (error at <module>:48) else goto L39
L39:
    r137 = (r119, r126, r136)
    r138 = box(tuple[object, object, object], r137)
    r139 = PyObject_GetItem(r116, r138)
    dec_ref r116
    dec_ref r138
    if is_error(r139) goto L175 (error at <module>:48) else goto L40
L40:
    r140 = dank_mids.helpers._codec.globals :: static
    r141 = 'RpcThing'
    r142 = CPyDict_SetItem(r140, r141, r139)
    dec_ref r139
    r143 = r142 >= 0 :: signed
    if not r143 goto L175 (error at <module>:48) else goto L41 :: bool
L41:
    r144 = dank_mids.helpers._codec.globals :: static
    r145 = 'Union'
    r146 = CPyDict_GetItem(r144, r145)
    if is_error(r146) goto L175 (error at <module>:51) else goto L42
L42:
    r147 = dank_mids.helpers._codec.globals :: static
    r148 = 'Tuple'
    r149 = CPyDict_GetItem(r147, r148)
    if is_error(r149) goto L186 (error at <module>:52) else goto L43
L43:
    r150 = dank_mids.helpers._codec.globals :: static
    r151 = 'ChecksumAddress'
    r152 = CPyDict_GetItem(r150, r151)
    if is_error(r152) goto L187 (error at <module>:52) else goto L44
L44:
    r153 = dank_mids.helpers._codec.globals :: static
    r154 = 'hexbytes'
    r155 = CPyDict_GetItem(r153, r154)
    if is_error(r155) goto L188 (error at <module>:52) else goto L45
L45:
    r156 = 'HexBytes'
    r157 = CPyObject_GetAttr(r155, r156)
    dec_ref r155
    if is_error(r157) goto L188 (error at <module>:52) else goto L46
L46:
    r158 = (r152, r157)
    r159 = box(tuple[object, object], r158)
    r160 = PyObject_GetItem(r149, r159)
    dec_ref r149
    dec_ref r159
    if is_error(r160) goto L186 (error at <module>:52) else goto L47
L47:
    r161 = dank_mids.helpers._codec.globals :: static
    r162 = 'List'
    r163 = CPyDict_GetItem(r161, r162)
    if is_error(r163) goto L189 (error at <module>:53) else goto L48
L48:
    r164 = dank_mids.helpers._codec.globals :: static
    r165 = 'Union'
    r166 = CPyDict_GetItem(r164, r165)
    if is_error(r166) goto L190 (error at <module>:53) else goto L49
L49:
    r167 = dank_mids.helpers._codec.globals :: static
    r168 = 'ChecksumAddress'
    r169 = CPyDict_GetItem(r167, r168)
    if is_error(r169) goto L191 (error at <module>:53) else goto L50
L50:
    r170 = dank_mids.helpers._codec.globals :: static
    r171 = 'hexbytes'
    r172 = CPyDict_GetItem(r170, r171)
    if is_error(r172) goto L192 (error at <module>:53) else goto L51
L51:
    r173 = 'HexBytes'
    r174 = CPyObject_GetAttr(r172, r173)
    dec_ref r172
    if is_error(r174) goto L192 (error at <module>:53) else goto L52
L52:
    r175 = (r169, r174)
    r176 = box(tuple[object, object], r175)
    r177 = PyObject_GetItem(r166, r176)
    dec_ref r166
    dec_ref r176
    if is_error(r177) goto L190 (error at <module>:53) else goto L53
L53:
    r178 = PyObject_GetItem(r163, r177)
    dec_ref r163
    dec_ref r177
    if is_error(r178) goto L189 (error at <module>:53) else goto L54
L54:
    r179 = (r160, r178)
    r180 = box(tuple[object, object], r179)
    r181 = PyObject_GetItem(r146, r180)
    dec_ref r146
    dec_ref r180
    if is_error(r181) goto L175 (error at <module>:51) else goto L55
L55:
    r182 = dank_mids.helpers._codec.globals :: static
    r183 = 'MulticallChunk'
    r184 = CPyDict_SetItem(r182, r183, r181)
    dec_ref r181
    r185 = r184 >= 0 :: signed
    if not r185 goto L175 (error at <module>:51) else goto L56 :: bool
L56:
    r186 = dank_mids.helpers._codec.globals :: static
    r187 = 'Callable'
    r188 = CPyDict_GetItem(r186, r187)
    if is_error(r188) goto L175 (error at <module>:55) else goto L57
L57:
    r189 = dank_mids.helpers._codec.globals :: static
    r190 = 'Tuple'
    r191 = CPyDict_GetItem(r189, r190)
    if is_error(r191) goto L193 (error at <module>:55) else goto L58
L58:
    r192 = load_address PyBool_Type
    r193 = dank_mids.helpers._codec.globals :: static
    r194 = 'Iterable'
    r195 = CPyDict_GetItem(r193, r194)
    if is_error(r195) goto L194 (error at <module>:55) else goto L59
L59:
    r196 = dank_mids.helpers._codec.globals :: static
    r197 = 'MulticallChunk'
    r198 = CPyDict_GetItem(r196, r197)
    if is_error(r198) goto L195 (error at <module>:55) else goto L60
L60:
    r199 = PyObject_GetItem(r195, r198)
    dec_ref r195
    dec_ref r198
    if is_error(r199) goto L194 (error at <module>:55) else goto L61
L61:
    inc_ref r192
    r200 = (r192, r199)
    r201 = box(tuple[object, object], r200)
    r202 = PyObject_GetItem(r191, r201)
    dec_ref r191
    dec_ref r201
    if is_error(r202) goto L193 (error at <module>:55) else goto L62
L62:
    r203 = PyList_New(1)
    if is_error(r203) goto L196 (error at <module>:55) else goto L63
L63:
    r204 = get_element_ptr r203 ob_item :: PyListObject
    r205 = load_mem r204 :: ptr*
    set_mem r205, r202 :: builtins.object*
    r206 = load_address PyBytes_Type
    inc_ref r206
    r207 = (r203, r206)
    r208 = box(tuple[list, object], r207)
    r209 = PyObject_GetItem(r188, r208)
    dec_ref r188
    dec_ref r208
    if is_error(r209) goto L175 (error at <module>:55) else goto L64
L64:
    r210 = dank_mids.helpers._codec.globals :: static
    r211 = 'MulticallEncoder'
    r212 = CPyDict_SetItem(r210, r211, r209)
    dec_ref r209
    r213 = r212 >= 0 :: signed
    if not r213 goto L175 (error at <module>:55) else goto L65 :: bool
L65:
    r214 = dank_mids.helpers._codec.globals :: static
    r215 = 'Tuple'
    r216 = CPyDict_GetItem(r214, r215)
    if is_error(r216) goto L175 (error at <module>:57) else goto L66
L66:
    r217 = load_address PyLong_Type
    r218 = load_address PyLong_Type
    r219 = dank_mids.helpers._codec.globals :: static
    r220 = 'Tuple'
    r221 = CPyDict_GetItem(r219, r220)
    if is_error(r221) goto L197 (error at <module>:57) else goto L67
L67:
    r222 = dank_mids.helpers._codec.globals :: static
    r223 = 'Tuple'
    r224 = CPyDict_GetItem(r222, r223)
    if is_error(r224) goto L198 (error at <module>:57) else goto L68
L68:
    r225 = 'Success'
    r226 = load_address PyBytes_Type
    inc_ref r225
    inc_ref r226
    r227 = (r225, r226)
    r228 = box(tuple[str, object], r227)
    r229 = PyObject_GetItem(r224, r228)
    dec_ref r224
    dec_ref r228
    if is_error(r229) goto L198 (error at <module>:57) else goto L69
L69:
    r230 = load_address _Py_EllipsisObject
    inc_ref r230
    r231 = (r229, r230)
    r232 = box(tuple[object, object], r231)
    r233 = PyObject_GetItem(r221, r232)
    dec_ref r221
    dec_ref r232
    if is_error(r233) goto L197 (error at <module>:57) else goto L70
L70:
    inc_ref r217
    inc_ref r218
    r234 = (r217, r218, r233)
    r235 = box(tuple[object, object, object], r234)
    r236 = PyObject_GetItem(r216, r235)
    dec_ref r216
    dec_ref r235
    if is_error(r236) goto L175 (error at <module>:57) else goto L71
L71:
    r237 = dank_mids.helpers._codec.globals :: static
    r238 = 'DecodedMulticall'
    r239 = CPyDict_SetItem(r237, r238, r236)
    dec_ref r236
    r240 = r239 >= 0 :: signed
    if not r240 goto L175 (error at <module>:57) else goto L72 :: bool
L72:
    r241 = dank_mids.helpers._codec.globals :: static
    r242 = 'Callable'
    r243 = CPyDict_GetItem(r241, r242)
    if is_error(r243) goto L175 (error at <module>:58) else goto L73
L73:
    r244 = load_address _Py_EllipsisObject
    r245 = dank_mids.helpers._codec.globals :: static
    r246 = 'DecodedMulticall'
    r247 = CPyDict_GetItem(r245, r246)
    if is_error(r247) goto L199 (error at <module>:58) else goto L74
L74:
    inc_ref r244
    r248 = (r244, r247)
    r249 = box(tuple[object, object], r248)
    r250 = PyObject_GetItem(r243, r249)
    dec_ref r243
    dec_ref r249
    if is_error(r250) goto L175 (error at <module>:58) else goto L75
L75:
    r251 = dank_mids.helpers._codec.globals :: static
    r252 = 'MulticallDecoder'
    r253 = CPyDict_SetItem(r251, r252, r250)
    dec_ref r250
    r254 = r253 >= 0 :: signed
    if not r254 goto L175 (error at <module>:58) else goto L76 :: bool
L76:
    r255 = dank_mids.helpers._codec.globals :: static
    r256 = 'List'
    r257 = CPyDict_GetItem(r255, r256)
    if is_error(r257) goto L175 (error at <module>:61) else goto L77
L77:
    r258 = 'types.Request'
    r259 = PyObject_GetItem(r257, r258)
    dec_ref r257
    if is_error(r259) goto L175 (error at <module>:61) else goto L78
L78:
    r260 = dank_mids.helpers._codec.globals :: static
    r261 = 'JSONRPCBatchRequest'
    r262 = CPyDict_SetItem(r260, r261, r259)
    dec_ref r259
    r263 = r262 >= 0 :: signed
    if not r263 goto L175 (error at <module>:61) else goto L79 :: bool
L79:
    r264 = dank_mids.helpers._codec.globals :: static
    r265 = 'Union'
    r266 = CPyDict_GetItem(r264, r265)
    if is_error(r266) goto L175 (error at <module>:63) else goto L80
L80:
    r267 = dank_mids.helpers._codec.globals :: static
    r268 = 'List'
    r269 = CPyDict_GetItem(r267, r268)
    if is_error(r269) goto L200 (error at <module>:63) else goto L81
L81:
    r270 = 'RawResponse'
    r271 = PyObject_GetItem(r269, r270)
    dec_ref r269
    if is_error(r271) goto L200 (error at <module>:63) else goto L82
L82:
    r272 = 'types.PartialResponse'
    inc_ref r272
    r273 = (r271, r272)
    r274 = box(tuple[object, str], r273)
    r275 = PyObject_GetItem(r266, r274)
    dec_ref r266
    dec_ref r274
    if is_error(r275) goto L175 (error at <module>:63) else goto L83
L83:
    r276 = dank_mids.helpers._codec.globals :: static
    r277 = 'JSONRPCBatchResponse'
    r278 = CPyDict_SetItem(r276, r277, r275)
    dec_ref r275
    r279 = r278 >= 0 :: signed
    if not r279 goto L175 (error at <module>:63) else goto L84 :: bool
L84:
    r280 = dank_mids.helpers._codec.globals :: static
    r281 = 'Callable'
    r282 = CPyDict_GetItem(r280, r281)
    if is_error(r282) goto L175 (error at <module>:64) else goto L85
L85:
    r283 = dank_mids.helpers._codec.globals :: static
    r284 = 'Union'
    r285 = CPyDict_GetItem(r283, r284)
    if is_error(r285) goto L201 (error at <module>:64) else goto L86
L86:
    r286 = load_address PyUnicode_Type
    r287 = load_address PyBytes_Type
    inc_ref r286
    inc_ref r287
    r288 = (r286, r287)
    r289 = box(tuple[object, object], r288)
    r290 = PyObject_GetItem(r285, r289)
    dec_ref r285
    dec_ref r289
    if is_error(r290) goto L201 (error at <module>:64) else goto L87
L87:
    r291 = PyList_New(1)
    if is_error(r291) goto L202 (error at <module>:64) else goto L88
L88:
    r292 = get_element_ptr r291 ob_item :: PyListObject
    r293 = load_mem r292 :: ptr*
    set_mem r293, r290 :: builtins.object*
    r294 = dank_mids.helpers._codec.globals :: static
    r295 = 'Union'
    r296 = CPyDict_GetItem(r294, r295)
    if is_error(r296) goto L203 (error at <module>:64) else goto L89
L89:
    r297 = dank_mids.helpers._codec.globals :: static
    r298 = 'List'
    r299 = CPyDict_GetItem(r297, r298)
    if is_error(r299) goto L204 (error at <module>:64) else goto L90
L90:
    r300 = dank_mids.helpers._codec.globals :: static
    r301 = 'msgspec'
    r302 = CPyDict_GetItem(r300, r301)
    if is_error(r302) goto L205 (error at <module>:64) else goto L91
L91:
    r303 = 'Raw'
    r304 = CPyObject_GetAttr(r302, r303)
    dec_ref r302
    if is_error(r304) goto L205 (error at <module>:64) else goto L92
L92:
    r305 = PyObject_GetItem(r299, r304)
    dec_ref r299
    dec_ref r304
    if is_error(r305) goto L204 (error at <module>:64) else goto L93
L93:
    r306 = 'types.PartialResponse'
    inc_ref r306
    r307 = (r305, r306)
    r308 = box(tuple[object, str], r307)
    r309 = PyObject_GetItem(r296, r308)
    dec_ref r296
    dec_ref r308
    if is_error(r309) goto L203 (error at <module>:64) else goto L94
L94:
    r310 = (r291, r309)
    r311 = box(tuple[list, object], r310)
    r312 = PyObject_GetItem(r282, r311)
    dec_ref r282
    dec_ref r311
    if is_error(r312) goto L175 (error at <module>:64) else goto L95
L95:
    r313 = dank_mids.helpers._codec.globals :: static
    r314 = 'BatchDecoder'
    r315 = CPyDict_SetItem(r313, r314, r312)
    dec_ref r312
    r316 = r315 >= 0 :: signed
    if not r316 goto L175 (error at <module>:64) else goto L96 :: bool
L96:
    r317 = dank_mids.helpers._codec.globals :: static
    r318 = 'hexbytes'
    r319 = CPyDict_GetItem(r317, r318)
    if is_error(r319) goto L175 (error at <module>:67) else goto L97
L97:
    r320 = 'HexBytes'
    r321 = CPyObject_GetAttr(r319, r320)
    dec_ref r319
    if is_error(r321) goto L175 (error at <module>:67) else goto L98
L98:
    dank_mids.helpers._codec.HexBytes = r321 :: static
    r322 = dank_mids.helpers._codec.globals :: static
    r323 = 'HexBytes'
    r324 = CPyDict_SetItem(r322, r323, r321)
    dec_ref r321
    r325 = r324 >= 0 :: signed
    if not r325 goto L175 (error at <module>:67) else goto L99 :: bool
L99:
    r326 = dank_mids.helpers._codec.globals :: static
    r327 = 'msgspec'
    r328 = CPyDict_GetItem(r326, r327)
    if is_error(r328) goto L175 (error at <module>:68) else goto L100
L100:
    r329 = 'Raw'
    r330 = CPyObject_GetAttr(r328, r329)
    dec_ref r328
    if is_error(r330) goto L175 (error at <module>:68) else goto L101
L101:
    dank_mids.helpers._codec.Raw = r330 :: static
    r331 = dank_mids.helpers._codec.globals :: static
    r332 = 'Raw'
    r333 = CPyDict_SetItem(r331, r332, r330)
    dec_ref r330
    r334 = r333 >= 0 :: signed
    if not r334 goto L175 (error at <module>:68) else goto L102 :: bool
L102:
    r335 = dank_mids.helpers._codec.globals :: static
    r336 = 'decoding'
    r337 = CPyDict_GetItem(r335, r336)
    if is_error(r337) goto L175 (error at <module>:69) else goto L103
L103:
    r338 = 'ContextFramesBytesIO'
    r339 = CPyObject_GetAttr(r337, r338)
    dec_ref r337
    if is_error(r339) goto L175 (error at <module>:69) else goto L104
L104:
    dank_mids.helpers._codec.ContextFramesBytesIO = r339 :: static
    r340 = dank_mids.helpers._codec.globals :: static
    r341 = 'ContextFramesBytesIO'
    r342 = CPyDict_SetItem(r340, r341, r339)
    dec_ref r339
    r343 = r342 >= 0 :: signed
    if not r343 goto L175 (error at <module>:69) else goto L105 :: bool
L105:
    r344 = dank_mids.helpers._codec.globals :: static
    r345 = 'msgspec'
    r346 = CPyDict_GetItem(r344, r345)
    if is_error(r346) goto L175 (error at <module>:70) else goto L106
L106:
    r347 = 'DecodeError'
    r348 = CPyObject_GetAttr(r346, r347)
    dec_ref r346
    if is_error(r348) goto L175 (error at <module>:70) else goto L107
L107:
    dank_mids.helpers._codec.DecodeError = r348 :: static
    r349 = dank_mids.helpers._codec.globals :: static
    r350 = 'DecodeError'
    r351 = CPyDict_SetItem(r349, r350, r348)
    dec_ref r348
    r352 = r351 >= 0 :: signed
    if not r352 goto L175 (error at <module>:70) else goto L108 :: bool
L108:
    r353 = load_address PyUnicode_Type
    r354 = dank_mids.helpers._codec.globals :: static
    r355 = 'Decoder'
    r356 = CPyDict_GetItem(r354, r355)
    if is_error(r356) goto L175 (error at <module>:72) else goto L109
L109:
    r357 = [r353]
    r358 = load_address r357
    r359 = ('type',)
    r360 = PyObject_Vectorcall(r356, r358, 0, r359)
    dec_ref r356
    if is_error(r360) goto L175 (error at <module>:72) else goto L110
L110:
    r361 = 'decode'
    r362 = CPyObject_GetAttr(r360, r361)
    dec_ref r360
    if is_error(r362) goto L175 (error at <module>:72) else goto L111
L111:
    dank_mids.helpers._codec.decode_string = r362 :: static
    r363 = dank_mids.helpers._codec.globals :: static
    r364 = 'decode_string'
    r365 = CPyDict_SetItem(r363, r364, r362)
    dec_ref r362
    r366 = r365 >= 0 :: signed
    if not r366 goto L175 (error at <module>:72) else goto L112 :: bool
L112:
    r367 = dank_mids.helpers._codec.Raw :: static
    if is_error(r367) goto L113 else goto L115
L113:
    r368 = raise NameError('value for final name "Raw" was not set')
    if not r368 goto L175 (error at <module>:73) else goto L114 :: bool
L114:
    unreachable
L115:
    r369 = dank_mids.helpers._codec.globals :: static
    r370 = 'Decoder'
    r371 = CPyDict_GetItem(r369, r370)
    if is_error(r371) goto L175 (error at <module>:73) else goto L116
L116:
    r372 = [r367]
    r373 = load_address r372
    r374 = ('type',)
    r375 = PyObject_Vectorcall(r371, r373, 0, r374)
    dec_ref r371
    if is_error(r375) goto L175 (error at <module>:73) else goto L117
L117:
    r376 = 'decode'
    r377 = CPyObject_GetAttr(r375, r376)
    dec_ref r375
    if is_error(r377) goto L175 (error at <module>:73) else goto L118
L118:
    dank_mids.helpers._codec._decode_raw = r377 :: static
    r378 = dank_mids.helpers._codec.globals :: static
    r379 = '_decode_raw'
    r380 = CPyDict_SetItem(r378, r379, r377)
    dec_ref r377
    r381 = r380 >= 0 :: signed
    if not r381 goto L175 (error at <module>:73) else goto L119 :: bool
L119:
    r382 = dank_mids.helpers._codec.globals :: static
    r383 = '_decode_batch'
    r384 = box(None, 1)
    r385 = CPyDict_SetItem(r382, r383, r384)
    r386 = r385 >= 0 :: signed
    if not r386 goto L175 (error at <module>:75) else goto L120 :: bool
L120:
    r387 = <error> :: object
    r388 = 'dank_mids.helpers._codec'
    r389 = dank_mids.helpers._codec.RawResponse_template :: type
    r390 = CPyType_FromTemplate(r389, r387, r388)
    if is_error(r390) goto L175 (error at <module>:79) else goto L121
L121:
    r391 = RawResponse_trait_vtable_setup()
    if is_error(r391) goto L206 (error at <module>:-1) else goto L122
L122:
    r392 = '__mypyc_attrs__'
    r393 = '_raw'
    r394 = PyTuple_Pack(1, r393)
    if is_error(r394) goto L206 (error at <module>:79) else goto L123
L123:
    r395 = PyObject_SetAttr(r390, r392, r394)
    dec_ref r394
    r396 = r395 >= 0 :: signed
    if not r396 goto L206 (error at <module>:79) else goto L124 :: bool
L124:
    dank_mids.helpers._codec.RawResponse = r390 :: type
    r397 = dank_mids.helpers._codec.globals :: static
    r398 = 'RawResponse'
    r399 = CPyDict_SetItem(r397, r398, r390)
    dec_ref r390
    r400 = r399 >= 0 :: signed
    if not r400 goto L175 (error at <module>:79) else goto L125 :: bool
L125:
    r401 = dank_mids.helpers._codec.globals :: static
    r402 = '_encode_hook'
    r403 = CPyDict_GetItem(r401, r402)
    if is_error(r403) goto L175 (error at <module>:180) else goto L126
L126:
    r404 = dank_mids.helpers._codec.globals :: static
    r405 = 'Encoder'
    r406 = CPyDict_GetItem(r404, r405)
    if is_error(r406) goto L207 (error at <module>:180) else goto L127
L127:
    r407 = [r403]
    r408 = load_address r407
    r409 = ('enc_hook',)
    r410 = PyObject_Vectorcall(r406, r408, 0, r409)
    dec_ref r406
    if is_error(r410) goto L207 (error at <module>:180) else goto L128
L128:
    dec_ref r403
    r411 = 'encode'
    r412 = CPyObject_GetAttr(r410, r411)
    dec_ref r410
    if is_error(r412) goto L175 (error at <module>:180) else goto L129
L129:
    dank_mids.helpers._codec.encode = r412 :: static
    r413 = dank_mids.helpers._codec.globals :: static
    r414 = 'encode'
    r415 = CPyDict_SetItem(r413, r414, r412)
    dec_ref r412
    r416 = r415 >= 0 :: signed
    if not r416 goto L175 (error at <module>:180) else goto L130 :: bool
L130:
    r417 = dank_mids.helpers._codec.globals :: static
    r418 = 'default_codec'
    r419 = CPyDict_GetItem(r417, r418)
    if is_error(r419) goto L175 (error at <module>:199) else goto L131
L131:
    r420 = '_registry'
    r421 = CPyObject_GetAttr(r419, r420)
    dec_ref r419
    if is_error(r421) goto L175 (error at <module>:199) else goto L132
L132:
    r422 = '(bool,(address,bytes)[])'
    r423 = 'get_encoder'
    r424 = [r421, r422]
    r425 = load_address r424
    r426 = PyObject_VectorcallMethod(r423, r425, 9223372036854775810, 0)
    if is_error(r426) goto L208 (error at <module>:199) else goto L133
L133:
    dec_ref r421
    dank_mids.helpers._codec._mcall_encoder = r426 :: static
    r427 = dank_mids.helpers._codec.globals :: static
    r428 = '_mcall_encoder'
    r429 = CPyDict_SetItem(r427, r428, r426)
    dec_ref r426
    r430 = r429 >= 0 :: signed
    if not r430 goto L175 (error at <module>:199) else goto L134 :: bool
L134:
    r431 = dank_mids.helpers._codec._mcall_encoder :: static
    if is_error(r431) goto L135 else goto L137
L135:
    r432 = raise NameError('value for final name "_mcall_encoder" was not set')
    if not r432 goto L175 (error at <module>:202) else goto L136 :: bool
L136:
    unreachable
L137:
    r433 = 'encoders'
    r434 = CPyObject_GetAttr(r431, r433)
    if is_error(r434) goto L175 (error at <module>:202) else goto L138
L138:
    r435 = object -1
    r436 = PyObject_GetItem(r434, r435)
    dec_ref r434
    if is_error(r436) goto L175 (error at <module>:202) else goto L139
L139:
    dank_mids.helpers._codec._array_encoder = r436 :: static
    r437 = dank_mids.helpers._codec.globals :: static
    r438 = '_array_encoder'
    r439 = CPyDict_SetItem(r437, r438, r436)
    dec_ref r436
    r440 = r439 >= 0 :: signed
    if not r440 goto L175 (error at <module>:202) else goto L140 :: bool
L140:
    r441 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r441) goto L141 else goto L143
L141:
    r442 = raise NameError('value for final name "_array_encoder" was not set')
    if not r442 goto L175 (error at <module>:203) else goto L142 :: bool
L142:
    unreachable
L143:
    r443 = 'item_encoder'
    r444 = CPyObject_GetAttr(r441, r443)
    if is_error(r444) goto L175 (error at <module>:203) else goto L144
L144:
    dank_mids.helpers._codec._item_encoder = r444 :: static
    r445 = dank_mids.helpers._codec.globals :: static
    r446 = '_item_encoder'
    r447 = CPyDict_SetItem(r445, r446, r444)
    dec_ref r444
    r448 = r447 >= 0 :: signed
    if not r448 goto L175 (error at <module>:203) else goto L145 :: bool
L145:
    r449 = __mypyc_lambda__0_obj()
    if is_error(r449) goto L175 (error at <module>:206) else goto L146
L146:
    r450 = dank_mids.helpers._codec._mcall_encoder :: static
    if is_error(r450) goto L209 else goto L149
L147:
    r451 = raise NameError('value for final name "_mcall_encoder" was not set')
    if not r451 goto L175 (error at <module>:206) else goto L148 :: bool
L148:
    unreachable
L149:
    r452 = 'validate_value'
    r453 = PyObject_SetAttr(r450, r452, r449)
    r454 = r453 >= 0 :: signed
    if not r454 goto L210 (error at <module>:206) else goto L150 :: bool
L150:
    r455 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r455) goto L211 else goto L153
L151:
    r456 = raise NameError('value for final name "_array_encoder" was not set')
    if not r456 goto L175 (error at <module>:206) else goto L152 :: bool
L152:
    unreachable
L153:
    r457 = 'validate_value'
    r458 = PyObject_SetAttr(r455, r457, r449)
    r459 = r458 >= 0 :: signed
    if not r459 goto L210 (error at <module>:206) else goto L154 :: bool
L154:
    r460 = dank_mids.helpers._codec._item_encoder :: static
    if is_error(r460) goto L212 else goto L157
L155:
    r461 = raise NameError('value for final name "_item_encoder" was not set')
    if not r461 goto L175 (error at <module>:206) else goto L156 :: bool
L156:
    unreachable
L157:
    r462 = 'validate_value'
    r463 = PyObject_SetAttr(r460, r462, r449)
    dec_ref r449
    r464 = r463 >= 0 :: signed
    if not r464 goto L175 (error at <module>:206) else goto L158 :: bool
L158:
    r465 = dank_mids.helpers._codec.globals :: static
    r466 = '__encode_new'
    r467 = CPyDict_GetItem(r465, r466)
    if is_error(r467) goto L175 (error at <module>:236) else goto L159
L159:
    r468 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r468) goto L213 else goto L162
L160:
    r469 = raise NameError('value for final name "_array_encoder" was not set')
    if not r469 goto L175 (error at <module>:236) else goto L161 :: bool
L161:
    unreachable
L162:
    r470 = 'encode'
    r471 = PyObject_SetAttr(r468, r470, r467)
    dec_ref r467
    r472 = r471 >= 0 :: signed
    if not r472 goto L175 (error at <module>:236) else goto L163 :: bool
L163:
    r473 = dank_mids.helpers._codec.globals :: static
    r474 = '__encode_elements_new'
    r475 = CPyDict_GetItem(r473, r474)
    if is_error(r475) goto L175 (error at <module>:237) else goto L164
L164:
    r476 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r476) goto L214 else goto L167
L165:
    r477 = raise NameError('value for final name "_array_encoder" was not set')
    if not r477 goto L175 (error at <module>:237) else goto L166 :: bool
L166:
    unreachable
L167:
    r478 = 'encode_elements'
    r479 = PyObject_SetAttr(r476, r478, r475)
    dec_ref r475
    r480 = r479 >= 0 :: signed
    if not r480 goto L175 (error at <module>:237) else goto L168 :: bool
L168:
    r481 = dank_mids.helpers._codec.globals :: static
    r482 = 'default_codec'
    r483 = CPyDict_GetItem(r481, r482)
    if is_error(r483) goto L175 (error at <module>:240) else goto L169
L169:
    r484 = '_registry'
    r485 = CPyObject_GetAttr(r483, r484)
    dec_ref r483
    if is_error(r485) goto L175 (error at <module>:240) else goto L170
L170:
    r486 = '(uint256,uint256,(bool,bytes)[])'
    r487 = 'get_decoder'
    r488 = [r485, r486]
    r489 = load_address r488
    r490 = PyObject_VectorcallMethod(r487, r489, 9223372036854775810, 0)
    if is_error(r490) goto L215 (error at <module>:240) else goto L171
L171:
    dec_ref r485
    r491 = 'decode'
    r492 = CPyObject_GetAttr(r490, r491)
    dec_ref r490
    if is_error(r492) goto L175 (error at <module>:240) else goto L172
L172:
    dank_mids.helpers._codec._mcall_decoder = r492 :: static
    r493 = dank_mids.helpers._codec.globals :: static
    r494 = '_mcall_decoder'
    r495 = CPyDict_SetItem(r493, r494, r492)
    dec_ref r492
    r496 = r495 >= 0 :: signed
    if not r496 goto L175 (error at <module>:240) else goto L173 :: bool
L173:
    r497 = load_address PyBool_Type
    r498 = dank_mids.helpers._codec.globals :: static
    r499 = 'Success'
    r500 = CPyDict_SetItem(r498, r499, r497)
    r501 = r500 >= 0 :: signed
    if not r501 goto L175 (error at <module>:250) else goto L174 :: bool
L174:
    return 1
L175:
    r502 = <error> :: None
    return r502
L176:
    dec_ref r77
    goto L175
L177:
    dec_ref r77
    dec_ref r80
    goto L175
L178:
    dec_ref r77
    dec_ref r80
    dec_ref r83
    goto L175
L179:
    dec_ref r96
    goto L175
L180:
    dec_ref r96
    dec_ref r100
    goto L175
L181:
    dec_ref r116
    goto L175
L182:
    dec_ref r116
    dec_ref r119
    goto L175
L183:
    dec_ref r116
    dec_ref r119
    dec_ref r122
    goto L175
L184:
    dec_ref r116
    dec_ref r119
    dec_ref r126
    goto L175
L185:
    dec_ref r116
    dec_ref r119
    dec_ref r126
    dec_ref r129
    goto L175
L186:
    dec_ref r146
    goto L175
L187:
    dec_ref r146
    dec_ref r149
    goto L175
L188:
    dec_ref r146
    dec_ref r149
    dec_ref r152
    goto L175
L189:
    dec_ref r146
    dec_ref r160
    goto L175
L190:
    dec_ref r146
    dec_ref r160
    dec_ref r163
    goto L175
L191:
    dec_ref r146
    dec_ref r160
    dec_ref r163
    dec_ref r166
    goto L175
L192:
    dec_ref r146
    dec_ref r160
    dec_ref r163
    dec_ref r166
    dec_ref r169
    goto L175
L193:
    dec_ref r188
    goto L175
L194:
    dec_ref r188
    dec_ref r191
    goto L175
L195:
    dec_ref r188
    dec_ref r191
    dec_ref r195
    goto L175
L196:
    dec_ref r188
    dec_ref r202
    goto L175
L197:
    dec_ref r216
    goto L175
L198:
    dec_ref r216
    dec_ref r221
    goto L175
L199:
    dec_ref r243
    goto L175
L200:
    dec_ref r266
    goto L175
L201:
    dec_ref r282
    goto L175
L202:
    dec_ref r282
    dec_ref r290
    goto L175
L203:
    dec_ref r282
    dec_ref r291
    goto L175
L204:
    dec_ref r282
    dec_ref r291
    dec_ref r296
    goto L175
L205:
    dec_ref r282
    dec_ref r291
    dec_ref r296
    dec_ref r299
    goto L175
L206:
    dec_ref r390
    goto L175
L207:
    dec_ref r403
    goto L175
L208:
    dec_ref r421
    goto L175
L209:
    dec_ref r449
    goto L147
L210:
    dec_ref r449
    goto L175
L211:
    dec_ref r449
    goto L151
L212:
    dec_ref r449
    goto L155
L213:
    dec_ref r467
    goto L160
L214:
    dec_ref r475
    goto L165
L215:
    dec_ref r485
    goto L175

def DummyLogger.info(args, kwargs):
    args :: tuple
    kwargs :: dict
L0:
    return 1

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19, r20 :: object
    r21 :: bool
    r22 :: str
    r23 :: tuple
    r24 :: i32
    r25 :: bit
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: bool
    r32 :: i32
    r33 :: bit
    r34 :: bool
    r35 :: str
    r36 :: object
    r37 :: bool
    r38 :: object[1]
    r39 :: object_ptr
    r40 :: object
    r41 :: dict
    r42 :: str
    r43 :: i32
    r44 :: bit
    r45 :: dank_mids._demo_mode.DummyLogger
    r46 :: dict
    r47 :: str
    r48 :: i32
    r49 :: bit
    r50 :: dict
    r51 :: str
    r52 :: object
    r53 :: dict
    r54 :: str
    r55 :: i32
    r56 :: bit
    r57 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L26 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Final', 'final')
    r6 = 'typing'
    r7 = dank_mids._demo_mode.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L26 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ENVIRONMENT_VARIABLES',)
    r10 = 'dank_mids'
    r11 = dank_mids._demo_mode.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L26 (error at <module>:3) else goto L5
L5:
    dank_mids = r12 :: module
    dec_ref r12
    r13 = ('getLogger',)
    r14 = 'dank_mids._logging'
    r15 = dank_mids._demo_mode.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L26 (error at <module>:4) else goto L6
L6:
    dank_mids._logging = r16 :: module
    dec_ref r16
    r17 = <error> :: object
    r18 = 'dank_mids._demo_mode'
    r19 = dank_mids._demo_mode.DummyLogger_template :: type
    r20 = CPyType_FromTemplate(r19, r17, r18)
    if is_error(r20) goto L26 (error at <module>:8) else goto L7
L7:
    r21 = DummyLogger_trait_vtable_setup()
    if is_error(r21) goto L27 (error at <module>:-1) else goto L8
L8:
    r22 = '__mypyc_attrs__'
    r23 = PyTuple_Pack(0)
    if is_error(r23) goto L27 (error at <module>:8) else goto L9
L9:
    r24 = PyObject_SetAttr(r20, r22, r23)
    dec_ref r23
    r25 = r24 >= 0 :: signed
    if not r25 goto L27 (error at <module>:8) else goto L10 :: bool
L10:
    dank_mids._demo_mode.DummyLogger = r20 :: type
    r26 = dank_mids._demo_mode.globals :: static
    r27 = 'DummyLogger'
    r28 = CPyDict_SetItem(r26, r27, r20)
    dec_ref r20
    r29 = r28 >= 0 :: signed
    if not r29 goto L26 (error at <module>:8) else goto L11 :: bool
L11:
    r30 = dank_mids.ENVIRONMENT_VARIABLES.DEMO_MODE :: static
    if is_error(r30) goto L12 else goto L14
L12:
    r31 = raise NameError('value for final name "DEMO_MODE" was not set')
    if not r31 goto L26 (error at <module>:30) else goto L13 :: bool
L13:
    unreachable
L14:
    r32 = PyObject_IsTrue(r30)
    r33 = r32 >= 0 :: signed
    if not r33 goto L26 (error at <module>:30) else goto L15 :: bool
L15:
    r34 = truncate r32: i32 to builtins.bool
    if r34 goto L16 else goto L21 :: bool
L16:
    r35 = 'dank_mids.demo'
    r36 = dank_mids._logging.getLogger :: static
    if is_error(r36) goto L17 else goto L19
L17:
    r37 = raise NameError('value for final name "getLogger" was not set')
    if not r37 goto L26 (error at <module>:31) else goto L18 :: bool
L18:
    unreachable
L19:
    r38 = [r35]
    r39 = load_address r38
    r40 = PyObject_Vectorcall(r36, r39, 1, 0)
    if is_error(r40) goto L26 (error at <module>:31) else goto L20
L20:
    r41 = dank_mids._demo_mode.globals :: static
    r42 = '_logger'
    r43 = CPyDict_SetItem(r41, r42, r40)
    dec_ref r40
    r44 = r43 >= 0 :: signed
    if not r44 goto L26 (error at <module>:31) else goto L23 :: bool
L21:
    r45 = DummyLogger()
    if is_error(r45) goto L26 (error at <module>:33) else goto L22
L22:
    r46 = dank_mids._demo_mode.globals :: static
    r47 = '_logger'
    r48 = CPyDict_SetItem(r46, r47, r45)
    dec_ref r45
    r49 = r48 >= 0 :: signed
    if not r49 goto L26 (error at <module>:33) else goto L23 :: bool
L23:
    r50 = dank_mids._demo_mode.globals :: static
    r51 = '_logger'
    r52 = CPyDict_GetItem(r50, r51)
    if is_error(r52) goto L26 (error at <module>:35) else goto L24
L24:
    dank_mids._demo_mode.demo_logger = r52 :: static
    r53 = dank_mids._demo_mode.globals :: static
    r54 = 'demo_logger'
    r55 = CPyDict_SetItem(r53, r54, r52)
    dec_ref r52
    r56 = r55 >= 0 :: signed
    if not r56 goto L26 (error at <module>:35) else goto L25 :: bool
L25:
    return 1
L26:
    r57 = <error> :: None
    return r57
L27:
    dec_ref r20
    goto L26

def _create_named_task(awaitable):
    awaitable, r0 :: object
    r1 :: str
    r2 :: object
    r3, r4, r5 :: str
    r6 :: object
    r7 :: bool
    r8 :: object[2]
    r9 :: object_ptr
    r10, r11, r12 :: object
L0:
    r0 = PyObject_Type(awaitable)
    r1 = '__name__'
    r2 = CPyObject_GetAttr(r0, r1)
    dec_ref r0
    if is_error(r2) goto L8 (error at _create_named_task:35) else goto L1
L1:
    r3 = cast(str, r2)
    if is_error(r3) goto L8 (error at _create_named_task:35) else goto L2
L2:
    r4 = ' via DankBatch'
    r5 = CPyStr_Build(2, r3, r4)
    dec_ref r3
    if is_error(r5) goto L8 (error at _create_named_task:35) else goto L3
L3:
    r6 = dank_mids._batch.create_task :: static
    if is_error(r6) goto L9 else goto L6
L4:
    r7 = raise NameError('value for final name "create_task" was not set')
    if not r7 goto L8 (error at _create_named_task:35) else goto L5 :: bool
L5:
    unreachable
L6:
    r8 = [awaitable, r5]
    r9 = load_address r8
    r10 = ('name',)
    r11 = PyObject_Vectorcall(r6, r9, 1, r10)
    if is_error(r11) goto L10 (error at _create_named_task:35) else goto L7
L7:
    dec_ref r5
    return r11
L8:
    r12 = <error> :: object
    return r12
L9:
    dec_ref r5
    goto L4
L10:
    dec_ref r5
    goto L8

def DankBatch.__init__(self, controller, multicalls, rpc_calls):
    self :: dank_mids._batch.DankBatch
    controller :: object
    multicalls :: dict
    rpc_calls :: object
    r0 :: str
    r1 :: object
    r2 :: str
    r3, r4, r5 :: object
    r6 :: i32
    r7 :: bit
    r8 :: bool
    r9, r10 :: object
    r11 :: None
L0:
    inc_ref controller
    self.controller = controller
    inc_ref multicalls
    self.multicalls = multicalls
    inc_ref rpc_calls
    self.rpc_calls = rpc_calls
    self._awaited = 0
    r0 = 'batcher'
    r1 = CPyObject_GetAttr(controller, r0)
    if is_error(r1) goto L8 (error at __init__:74) else goto L1
L1:
    r2 = 'step'
    r3 = CPyObject_GetAttr(r1, r2)
    dec_ref r1
    if is_error(r3) goto L8 (error at __init__:74) else goto L2
L2:
    r4 = object 0
    r5 = PyObject_RichCompare(r3, r4, 0)
    if is_error(r5) goto L9 (error at __init__:74) else goto L3
L3:
    r6 = PyObject_IsTrue(r5)
    dec_ref r5
    r7 = r6 >= 0 :: signed
    if not r7 goto L9 (error at __init__:74) else goto L4 :: bool
L4:
    r8 = truncate r6: i32 to builtins.bool
    if r8 goto L5 else goto L10 :: bool
L5:
    r9 = r3
    goto L7
L6:
    r10 = object 0
    inc_ref r10
    r9 = r10
L7:
    self._check_len = r9
    return 1
L8:
    r11 = <error> :: None
    return r11
L9:
    dec_ref r3
    goto L8
L10:
    dec_ref r3
    goto L6

def DankBatch.__repr__(self):
    self :: dank_mids._batch.DankBatch
    r0 :: str
    r1 :: int
    r2 :: object
    r3 :: str
    r4, r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8 :: object
    r9, r10, r11, r12 :: str
L0:
    r0 = '<dank_mids.DankBatch object at '
    r1 = CPyTagged_Id(self)
    r2 = builtins :: module
    r3 = 'hex'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L6 (error at __repr__:77) else goto L1
L1:
    r5 = box(int, r1)
    r6 = [r5]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r4, r7, 1, 0)
    dec_ref r4
    if is_error(r8) goto L7 (error at __repr__:77) else goto L2
L2:
    dec_ref r5
    r9 = cast(str, r8)
    if is_error(r9) goto L5 (error at __repr__:77) else goto L3
L3:
    r10 = '>'
    r11 = CPyStr_Build(3, r0, r9, r10)
    dec_ref r9
    if is_error(r11) goto L5 (error at __repr__:77) else goto L4
L4:
    return r11
L5:
    r12 = <error> :: str
    return r12
L6:
    dec_ref r1 :: int
    goto L5
L7:
    dec_ref r5
    goto L5

def DankBatch.__await__(self):
    self :: dank_mids._batch.DankBatch
    r0 :: bool
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8 :: bool
    r9 :: dict
    r10 :: short_int
    r11 :: native_int
    r12 :: object
    r13 :: tuple[bool, short_int, object]
    r14 :: short_int
    r15 :: bool
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: object[3]
    r20 :: object_ptr
    r21, r22 :: object
    r23, r24 :: bit
    r25, r26, r27 :: object
    r28 :: str
    r29 :: i32
    r30, r31 :: bit
    r32 :: dank_mids._batch._await_DankBatch_gen
    r33 :: str
    r34 :: object[1]
    r35 :: object_ptr
    r36, r37 :: object
L0:
    r0 = self._awaited
    if r0 goto L1 else goto L5 :: bool
L1:
    r1 = 'The batch has already been awaited'
    r2 = builtins :: module
    r3 = 'RuntimeError'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L18 (error at __await__:94) else goto L2
L2:
    r5 = [r1]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r4, r6, 1, 0)
    dec_ref r4
    if is_error(r7) goto L18 (error at __await__:94) else goto L3
L3:
    CPy_Raise(r7)
    dec_ref r7
    if not 0 goto L18 (error at __await__:94) else goto L4 :: bool
L4:
    unreachable
L5:
    self._awaited = 1
    r9 = self.multicalls
    r10 = 0
    r11 = PyDict_Size(r9)
    r12 = CPyDict_GetValuesIter(r9)
    if is_error(r12) goto L19 (error at __await__:96) else goto L6
L6:
    r13 = CPyDict_NextValue(r12, r10)
    r14 = r13[1]
    r10 = r14
    r15 = r13[0]
    if r15 goto L7 else goto L20 :: bool
L7:
    r16 = r13[2]
    dec_ref r13
    r17 = 'start'
    r18 = box(bool, 0)
    r19 = [r16, self, r18]
    r20 = load_address r19
    r21 = ('cleanup',)
    r22 = PyObject_VectorcallMethod(r17, r20, 9223372036854775810, r21)
    if is_error(r22) goto L21 (error at __await__:97) else goto L22
L8:
    dec_ref r16
L9:
    r23 = CPyDict_CheckSize(r9, r11)
    if not r23 goto L23 (error at __await__:96) else goto L6 :: bool
L10:
    r24 = CPy_NoErrOccurred()
    if not r24 goto L18 (error at __await__:96) else goto L11 :: bool
L11:
    r25 = self.rpc_calls
    r26 = PyObject_GetIter(r25)
    dec_ref r25
    if is_error(r26) goto L18 (error at __await__:98) else goto L12
L12:
    r27 = PyIter_Next(r26)
    if is_error(r27) goto L24 else goto L13
L13:
    r28 = '_batch'
    r29 = PyObject_SetAttr(r27, r28, self)
    dec_ref r27
    r30 = r29 >= 0 :: signed
    if not r30 goto L25 (error at __await__:99) else goto L12 :: bool
L14:
    r31 = CPy_NoErrOccurred()
    if not r31 goto L18 (error at __await__:98) else goto L15 :: bool
L15:
    r32 = self._await()
    if is_error(r32) goto L18 (error at __await__:100) else goto L16
L16:
    r33 = '__await__'
    r34 = [r32]
    r35 = load_address r34
    r36 = PyObject_VectorcallMethod(r33, r35, 9223372036854775809, 0)
    if is_error(r36) goto L26 (error at __await__:100) else goto L17
L17:
    dec_ref r32
    return r36
L18:
    r37 = <error> :: object
    return r37
L19:
    dec_ref r9
    goto L18
L20:
    dec_ref r9
    dec_ref r12
    dec_ref r13
    goto L10
L21:
    dec_ref r9
    dec_ref r12
    dec_ref r16
    goto L18
L22:
    dec_ref r22
    goto L8
L23:
    dec_ref r9
    dec_ref r12
    goto L18
L24:
    dec_ref r26
    goto L14
L25:
    dec_ref r26
    goto L18
L26:
    dec_ref r32
    goto L18

def _await_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1, r2, r3 :: object
    r4 :: i32
    r5 :: object
    r6 :: bit
    r7 :: dank_mids._batch.DankBatch
    r8 :: object
    r9 :: list
    r10 :: bool
    r11 :: object
    r12 :: bool
    r13 :: list
    r14, r15 :: bool
    r16 :: list
    r17 :: ptr
    r18 :: native_int
    r19 :: list
    r20, r21 :: bool
    r22 :: list
    r23 :: ptr
    r24, r25 :: native_int
    r26 :: bit
    r27 :: list
    r28 :: native_int
    r29, r30 :: ptr
    r31 :: native_int
    r32 :: ptr
    r33 :: object
    r34 :: bool
    r35 :: native_int
    r36, r37 :: object
    r38, r39 :: native_int
    r40, r41, r42 :: bool
    r43 :: list
    r44 :: ptr
    r45, r46 :: native_int
    r47 :: bit
    r48 :: list
    r49 :: ptr
    r50, r51 :: native_int
    r52 :: bit
    r53 :: list
    r54 :: native_int
    r55, r56 :: ptr
    r57 :: native_int
    r58 :: ptr
    r59 :: object
    r60 :: bool
    r61 :: list
    r62 :: native_int
    r63, r64 :: ptr
    r65 :: native_int
    r66 :: ptr
    r67 :: object
    r68 :: bool
    r69, r70 :: object
    r71 :: bool
    r72, r73, r74, r75, r76 :: object
    r77 :: bool
    r78 :: object
    r79 :: bool
    r80 :: object
    r81 :: bit
    r82 :: tuple[object, object, object]
    r83 :: bool
    r84 :: object_ptr
    r85 :: object
    r86 :: bool
    r87, r88, r89 :: tuple[object, object, object]
    r90 :: bit
    r91, r92, r93 :: object
    r94 :: tuple[object, object, object]
    r95 :: bool
    r96 :: object
    r97 :: str
    r98 :: object
    r99 :: bit
    r100 :: object
    r101 :: bool
    r102, r103 :: object
    r104 :: ptr
    r105 :: object
    r106 :: bit
    r107 :: object
    r108 :: bool
    r109, r110 :: object
    r111 :: None
    r112 :: object
    r113 :: bool
    r114, r115 :: tuple[object, object, object]
    r116 :: bit
    r117, r118 :: native_int
    r119 :: bool
    r120, r121 :: native_int
    r122 :: bool
    r123 :: union[object, None]
    r124 :: object
    r125 :: bit
    r126 :: union[object, None]
    r127 :: object
    r128 :: bool
    r129, r130, r131, r132, r133 :: object
    r134 :: bool
    r135 :: object
    r136 :: bool
    r137 :: object
    r138 :: bit
    r139 :: tuple[object, object, object]
    r140 :: bool
    r141 :: object_ptr
    r142 :: object
    r143 :: bool
    r144, r145, r146 :: tuple[object, object, object]
    r147 :: bit
    r148, r149, r150, r151 :: object
    r152 :: bool
    r153, r154, r155 :: bit
    r156 :: bool
    r157 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = __mypyc_self__.__mypyc_next_label__
    goto L132
L1:
    r5 = load_address _Py_NoneStruct
    r6 = type != r5
    if r6 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L137 (error at _await:102) else goto L3 :: bool
L3:
    unreachable
L4:
    r7 = __mypyc_self__.self
    if is_error(r7) goto L137 (error at _await:114) else goto L5
L5:
    r8 = r7.coroutines
    dec_ref r7
    if is_error(r8) goto L137 (error at _await:114) else goto L6
L6:
    r9 = PySequence_List(r8)
    dec_ref r8
    if is_error(r9) goto L137 (error at _await:114) else goto L7
L7:
    __mypyc_self__.batches = r9; r10 = is_error
    if not r10 goto L137 (error at _await:114) else goto L8 :: bool
L8:
    r11 = box(None, 1)
    inc_ref r11
    __mypyc_self__.last_failure = r11; r12 = is_error
    if not r12 goto L137 (error at _await:116) else goto L9 :: bool
L9:
    r13 = __mypyc_self__.batches
    if is_error(r13) goto L137 (error at _await:117) else goto L10
L10:
    __mypyc_self__.__mypyc_temp__0 = r13; r14 = is_error
    if not r14 goto L137 (error at _await:-1) else goto L11 :: bool
L11:
    __mypyc_self__.__mypyc_temp__1 = 0; r15 = is_error
    if not r15 goto L137 (error at _await:-1) else goto L12 :: bool
L12:
    r16 = __mypyc_self__.batches
    if is_error(r16) goto L137 (error at _await:117) else goto L13
L13:
    r17 = get_element_ptr r16 ob_size :: PyVarObject
    r18 = load_mem r17 :: native_int*
    r19 = PyList_New(r18)
    if is_error(r19) goto L138 (error at _await:117) else goto L14
L14:
    __mypyc_self__.__mypyc_temp__2 = r16; r20 = is_error
    if not r20 goto L139 (error at _await:-1) else goto L15 :: bool
L15:
    __mypyc_self__.__mypyc_temp__3 = 0; r21 = is_error
    if not r21 goto L139 (error at _await:-1) else goto L16 :: bool
L16:
    r22 = __mypyc_self__.__mypyc_temp__2
    if is_error(r22) goto L139 (error at _await:117) else goto L17
L17:
    r23 = get_element_ptr r22 ob_size :: PyVarObject
    r24 = load_mem r23 :: native_int*
    dec_ref r22
    r25 = __mypyc_self__.__mypyc_temp__3
    if is_error(r25) goto L139 (error at _await:117) else goto L18
L18:
    r26 = r25 < r24 :: signed
    if r26 goto L19 else goto L28 :: bool
L19:
    r27 = __mypyc_self__.__mypyc_temp__2
    if is_error(r27) goto L139 (error at _await:117) else goto L20
L20:
    r28 = __mypyc_self__.__mypyc_temp__3
    if is_error(r28) goto L140 (error at _await:117) else goto L21
L21:
    r29 = get_element_ptr r27 ob_item :: PyListObject
    r30 = load_mem r29 :: ptr*
    r31 = r28 * 8
    r32 = r30 + r31
    r33 = load_mem r32 :: builtins.object*
    dec_ref r27
    __mypyc_self__.coro = r33; r34 = is_error
    if not r34 goto L139 (error at _await:117) else goto L22 :: bool
L22:
    r35 = __mypyc_self__.__mypyc_temp__3
    if is_error(r35) goto L139 (error at _await:-1) else goto L23
L23:
    r36 = __mypyc_self__.coro
    if is_error(r36) goto L139 (error at _await:117) else goto L24
L24:
    r37 = _create_named_task(r36)
    dec_ref r36
    if is_error(r37) goto L139 (error at _await:117) else goto L25
L25:
    CPyList_SetItemUnsafe(r19, r35, r37)
L26:
    r38 = __mypyc_self__.__mypyc_temp__3
    if is_error(r38) goto L139 (error at _await:117) else goto L27
L27:
    r39 = r38 + 1
    __mypyc_self__.__mypyc_temp__3 = r39; r40 = is_error
    if not r40 goto L139 (error at _await:117) else goto L16 :: bool
L28:
    __mypyc_self__.__mypyc_temp__4 = r19; r41 = is_error
    if not r41 goto L137 (error at _await:-1) else goto L29 :: bool
L29:
    __mypyc_self__.__mypyc_temp__5 = 0; r42 = is_error
    if not r42 goto L137 (error at _await:-1) else goto L30 :: bool
L30:
    r43 = __mypyc_self__.__mypyc_temp__0
    if is_error(r43) goto L137 (error at _await:117) else goto L31
L31:
    r44 = get_element_ptr r43 ob_size :: PyVarObject
    r45 = load_mem r44 :: native_int*
    dec_ref r43
    r46 = __mypyc_self__.__mypyc_temp__1
    if is_error(r46) goto L137 (error at _await:117) else goto L32
L32:
    r47 = r46 < r45 :: signed
    if r47 goto L33 else goto L96 :: bool
L33:
    r48 = __mypyc_self__.__mypyc_temp__4
    if is_error(r48) goto L137 (error at _await:117) else goto L34
L34:
    r49 = get_element_ptr r48 ob_size :: PyVarObject
    r50 = load_mem r49 :: native_int*
    dec_ref r48
    r51 = __mypyc_self__.__mypyc_temp__5
    if is_error(r51) goto L137 (error at _await:117) else goto L35
L35:
    r52 = r51 < r50 :: signed
    if r52 goto L36 else goto L96 :: bool
L36:
    r53 = __mypyc_self__.__mypyc_temp__0
    if is_error(r53) goto L137 (error at _await:117) else goto L37
L37:
    r54 = __mypyc_self__.__mypyc_temp__1
    if is_error(r54) goto L141 (error at _await:117) else goto L38
L38:
    r55 = get_element_ptr r53 ob_item :: PyListObject
    r56 = load_mem r55 :: ptr*
    r57 = r54 * 8
    r58 = r56 + r57
    r59 = load_mem r58 :: builtins.object*
    dec_ref r53
    __mypyc_self__.batch = r59; r60 = is_error
    if not r60 goto L137 (error at _await:117) else goto L39 :: bool
L39:
    r61 = __mypyc_self__.__mypyc_temp__4
    if is_error(r61) goto L137 (error at _await:117) else goto L40
L40:
    r62 = __mypyc_self__.__mypyc_temp__5
    if is_error(r62) goto L142 (error at _await:117) else goto L41
L41:
    r63 = get_element_ptr r61 ob_item :: PyListObject
    r64 = load_mem r63 :: ptr*
    r65 = r62 * 8
    r66 = r64 + r65
    r67 = load_mem r66 :: builtins.object*
    dec_ref r61
    __mypyc_self__.task = r67; r68 = is_error
    if not r68 goto L137 (error at _await:117) else goto L42 :: bool
L42:
    r69 = __mypyc_self__.task
    if is_error(r69) goto L71 (error at _await:119) else goto L43
L43:
    r70 = CPy_GetCoro(r69)
    dec_ref r69
    if is_error(r70) goto L71 (error at _await:119) else goto L44
L44:
    __mypyc_self__.__mypyc_temp__6 = r70; r71 = is_error
    if not r71 goto L71 (error at _await:-1) else goto L45 :: bool
L45:
    r72 = __mypyc_self__.__mypyc_temp__6
    if is_error(r72) goto L71 (error at _await:-1) else goto L46
L46:
    r73 = CPyIter_Next(r72)
    dec_ref r72
    if is_error(r73) goto L47 else goto L49
L47:
    r74 = CPy_FetchStopIterationValue()
    if is_error(r74) goto L71 (error at _await:119) else goto L48
L48:
    r75 = r74
    dec_ref r75
    r76 = <error> :: object
    __mypyc_self__.__mypyc_temp__6 = r76; r77 = is_error
    if not r77 goto L71 (error at _await:119) else goto L92 :: bool
L49:
    r78 = r73
L50:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r78
L51:
    r80 = load_address _Py_NoneStruct
    r81 = type != r80
    if r81 goto L52 else goto L143 :: bool
L52:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L55 (error at _await:119) else goto L144 :: bool
L53:
    unreachable
L54:
    inc_ref arg
    goto L66
L55:
    r82 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__7 = r82; r83 = is_error
    if not r83 goto L145 (error at _await:-1) else goto L56 :: bool
L56:
    r84 = load_address r1
    r85 = __mypyc_self__.__mypyc_temp__6
    if is_error(r85) goto L145 (error at _await:-1) else goto L57
L57:
    r86 = CPy_YieldFromErrorHandle(r85, r84)
    dec_ref r85
    if is_error(r86) goto L145 (error at _await:119) else goto L58
L58:
    if r86 goto L61 else goto L59 :: bool
L59:
    r78 = r1
    r87 = __mypyc_self__.__mypyc_temp__7
    if is_error(r87) goto L146 (error at _await:-1) else goto L60
L60:
    CPy_RestoreExcInfo(r87)
    dec_ref r87
    goto L50
L61:
    r75 = r1
    dec_ref r75
    r88 = __mypyc_self__.__mypyc_temp__7
    if is_error(r88) goto L63 (error at _await:-1) else goto L62
L62:
    CPy_RestoreExcInfo(r88)
    dec_ref r88
    goto L92
L63:
    r89 = __mypyc_self__.__mypyc_temp__7
    if is_error(r89) goto L71 (error at _await:-1) else goto L64
L64:
    CPy_RestoreExcInfo(r89)
    dec_ref r89
    r90 = CPy_KeepPropagating()
    if not r90 goto L71 else goto L65 :: bool
L65:
    unreachable
L66:
    r91 = __mypyc_self__.__mypyc_temp__6
    if is_error(r91) goto L147 (error at _await:-1) else goto L67
L67:
    r92 = CPyIter_Send(r91, arg)
    dec_ref r91
    dec_ref arg
    if is_error(r92) goto L69 else goto L68
L68:
    r78 = r92
    goto L50
L69:
    r93 = CPy_FetchStopIterationValue()
    if is_error(r93) goto L71 (error at _await:119) else goto L70
L70:
    r75 = r93
    dec_ref r75
    goto L92
L71:
    r94 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__8 = r94; r95 = is_error
    if not r95 goto L89 (error at _await:-1) else goto L72 :: bool
L72:
    r96 = builtins :: module
    r97 = 'Exception'
    r98 = CPyObject_GetAttr(r96, r97)
    if is_error(r98) goto L89 (error at _await:120) else goto L73
L73:
    r99 = CPy_ExceptionMatches(r98)
    dec_ref r98
    if r99 goto L74 else goto L85 :: bool
L74:
    r100 = CPy_GetExcValue()
    __mypyc_self__.e = r100; r101 = is_error
    if not r101 goto L89 (error at _await:120) else goto L75 :: bool
L75:
    r102 = __mypyc_self__.e
    if is_error(r102) goto L89 (error at _await:122) else goto L76
L76:
    r103 = dank_mids._exceptions.DankMidsInternalError :: type
    r104 = get_element_ptr r102 ob_type :: PyObject
    r105 = borrow load_mem r104 :: builtins.object*
    dec_ref r102
    r106 = r105 == r103
    if r106 goto L83 else goto L77 :: bool
L77:
    r107 = dank_mids._batch.logger :: static
    if is_error(r107) goto L78 else goto L80
L78:
    r108 = raise NameError('value for final name "logger" was not set')
    if not r108 goto L89 (error at _await:123) else goto L79 :: bool
L79:
    unreachable
L80:
    r109 = __mypyc_self__.batch
    if is_error(r109) goto L89 (error at _await:123) else goto L81
L81:
    r110 = __mypyc_self__.e
    if is_error(r110) goto L148 (error at _await:123) else goto L82
L82:
    r111 = log_internal_error(r107, r109, r110)
    dec_ref r109
    dec_ref r110
    if is_error(r111) goto L89 (error at _await:123) else goto L83
L83:
    r112 = __mypyc_self__.task
    if is_error(r112) goto L89 (error at _await:124) else goto L84
L84:
    __mypyc_self__.last_failure = r112; r113 = is_error
    if not r113 goto L89 (error at _await:124) else goto L87 :: bool
L85:
    CPy_Reraise()
    if not 0 goto L89 else goto L86 :: bool
L86:
    unreachable
L87:
    r114 = __mypyc_self__.__mypyc_temp__8
    if is_error(r114) goto L137 (error at _await:-1) else goto L88
L88:
    CPy_RestoreExcInfo(r114)
    dec_ref r114
    goto L92
L89:
    r115 = __mypyc_self__.__mypyc_temp__8
    if is_error(r115) goto L137 (error at _await:-1) else goto L90
L90:
    CPy_RestoreExcInfo(r115)
    dec_ref r115
    r116 = CPy_KeepPropagating()
    if not r116 goto L137 else goto L91 :: bool
L91:
    unreachable
L92:
    r117 = __mypyc_self__.__mypyc_temp__1
    if is_error(r117) goto L137 (error at _await:117) else goto L93
L93:
    r118 = r117 + 1
    __mypyc_self__.__mypyc_temp__1 = r118; r119 = is_error
    if not r119 goto L137 (error at _await:117) else goto L94 :: bool
L94:
    r120 = __mypyc_self__.__mypyc_temp__5
    if is_error(r120) goto L137 (error at _await:117) else goto L95
L95:
    r121 = r120 + 1
    __mypyc_self__.__mypyc_temp__5 = r121; r122 = is_error
    if not r122 goto L137 (error at _await:117) else goto L30 :: bool
L96:
    r123 = __mypyc_self__.last_failure
    if is_error(r123) goto L137 (error at _await:126) else goto L97
L97:
    r124 = load_address _Py_NoneStruct
    r125 = r123 != r124
    dec_ref r123
    if r125 goto L98 else goto L127 :: bool
L98:
    r126 = __mypyc_self__.last_failure
    if is_error(r126) goto L137 (error at _await:128) else goto L99
L99:
    r127 = CPy_GetCoro(r126)
    dec_ref r126
    if is_error(r127) goto L137 (error at _await:128) else goto L100
L100:
    __mypyc_self__.__mypyc_temp__9 = r127; r128 = is_error
    if not r128 goto L137 (error at _await:-1) else goto L101 :: bool
L101:
    r129 = __mypyc_self__.__mypyc_temp__9
    if is_error(r129) goto L137 (error at _await:-1) else goto L102
L102:
    r130 = CPyIter_Next(r129)
    dec_ref r129
    if is_error(r130) goto L103 else goto L105
L103:
    r131 = CPy_FetchStopIterationValue()
    if is_error(r131) goto L137 (error at _await:128) else goto L104
L104:
    r132 = r131
    dec_ref r132
    r133 = <error> :: object
    __mypyc_self__.__mypyc_temp__9 = r133; r134 = is_error
    if not r134 goto L137 (error at _await:128) else goto L127 :: bool
L105:
    r135 = r130
L106:
    __mypyc_self__.__mypyc_next_label__ = 2
    return r135
L107:
    r137 = load_address _Py_NoneStruct
    r138 = type != r137
    if r138 goto L108 else goto L149 :: bool
L108:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L111 (error at _await:128) else goto L150 :: bool
L109:
    unreachable
L110:
    inc_ref arg
    goto L122
L111:
    r139 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__10 = r139; r140 = is_error
    if not r140 goto L151 (error at _await:-1) else goto L112 :: bool
L112:
    r141 = load_address r3
    r142 = __mypyc_self__.__mypyc_temp__9
    if is_error(r142) goto L151 (error at _await:-1) else goto L113
L113:
    r143 = CPy_YieldFromErrorHandle(r142, r141)
    dec_ref r142
    if is_error(r143) goto L151 (error at _await:128) else goto L114
L114:
    if r143 goto L117 else goto L115 :: bool
L115:
    r135 = r3
    r144 = __mypyc_self__.__mypyc_temp__10
    if is_error(r144) goto L152 (error at _await:-1) else goto L116
L116:
    CPy_RestoreExcInfo(r144)
    dec_ref r144
    goto L106
L117:
    r132 = r3
    dec_ref r132
    r145 = __mypyc_self__.__mypyc_temp__10
    if is_error(r145) goto L119 (error at _await:-1) else goto L118
L118:
    CPy_RestoreExcInfo(r145)
    dec_ref r145
    goto L127
L119:
    r146 = __mypyc_self__.__mypyc_temp__10
    if is_error(r146) goto L137 (error at _await:-1) else goto L120
L120:
    CPy_RestoreExcInfo(r146)
    dec_ref r146
    r147 = CPy_KeepPropagating()
    if not r147 goto L137 else goto L121 :: bool
L121:
    unreachable
L122:
    r148 = __mypyc_self__.__mypyc_temp__9
    if is_error(r148) goto L153 (error at _await:-1) else goto L123
L123:
    r149 = CPyIter_Send(r148, arg)
    dec_ref r148
    dec_ref arg
    if is_error(r149) goto L125 else goto L124
L124:
    r135 = r149
    goto L106
L125:
    r150 = CPy_FetchStopIterationValue()
    if is_error(r150) goto L137 (error at _await:128) else goto L126
L126:
    r132 = r150
    dec_ref r132
L127:
    r151 = box(None, 1)
    __mypyc_self__.__mypyc_next_label__ = -1
L128:
    if is_error(stop_iter_ptr) goto L129 else goto L131
L129:
    CPyGen_SetStopIterationValue(r151)
    if not 0 goto L137 else goto L130 :: bool
L130:
    unreachable
L131:
    inc_ref r151
    set_mem stop_iter_ptr, r151 :: builtins.object*
    return 0
L132:
    r153 = r4 == 0
    if r153 goto L154 else goto L133 :: bool
L133:
    r154 = r4 == 1
    if r154 goto L155 else goto L156 :: bool
L134:
    r155 = r4 == 2
    if r155 goto L107 else goto L157 :: bool
L135:
    r156 = raise StopIteration
    if not r156 goto L137 (error at _await:102) else goto L136 :: bool
L136:
    unreachable
L137:
    r157 = <error> :: object
    return r157
L138:
    dec_ref r16
    goto L137
L139:
    dec_ref r19
    goto L137
L140:
    dec_ref r19
    dec_ref r27
    goto L137
L141:
    dec_ref r53
    goto L137
L142:
    dec_ref r61
    goto L137
L143:
    xdec_ref r1
    goto L54
L144:
    xdec_ref r1
    goto L53
L145:
    xdec_ref r1
    goto L63
L146:
    dec_ref r78
    goto L63
L147:
    dec_ref arg
    goto L71
L148:
    dec_ref r109
    goto L89
L149:
    xdec_ref r3
    goto L110
L150:
    xdec_ref r3
    goto L109
L151:
    xdec_ref r3
    goto L119
L152:
    dec_ref r135
    goto L119
L153:
    dec_ref arg
    goto L137
L154:
    xdec_ref r1
    xdec_ref r3
    goto L1
L155:
    xdec_ref r3
    goto L51
L156:
    xdec_ref r1
    goto L134
L157:
    xdec_ref r3
    goto L135

def _await_DankBatch_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _await_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _await_DankBatch_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _await_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _await_DankBatch_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _await_DankBatch_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = _await_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def _await_DankBatch_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def _await_DankBatch_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def DankBatch._await(self):
    self :: dank_mids._batch.DankBatch
    r0 :: dank_mids._batch._await_DankBatch_gen
    r1, r2 :: bool
    r3 :: dank_mids._batch._await_DankBatch_gen
L0:
    r0 = _await_DankBatch_gen()
    if is_error(r0) goto L3 (error at _await:102) else goto L1
L1:
    r0.__mypyc_next_label__ = 0
    inc_ref self
    r0.self = self; r2 = is_error
    if not r2 goto L4 (error at _await:102) else goto L2 :: bool
L2:
    return r0
L3:
    r3 = <error> :: dank_mids._batch._await_DankBatch_gen
    return r3
L4:
    dec_ref r0
    goto L3

def coroutines_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0 :: i32
    r1 :: object
    r2 :: bit
    r3 :: dank_mids._batch.DankBatch
    r4 :: object
    r5 :: bool
    r6 :: object
    r7 :: str
    r8 :: object
    r9 :: bool
    r10 :: dank_mids._batch.DankBatch
    r11 :: object
    r12 :: bool
    r13 :: dank_mids._batch.DankBatch
    r14 :: dict
    r15, r16 :: bool
    r17 :: dict
    r18 :: native_int
    r19 :: bool
    r20 :: object
    r21 :: bool
    r22 :: object
    r23 :: short_int
    r24 :: tuple[bool, short_int, object]
    r25 :: short_int
    r26, r27 :: bool
    r28 :: object
    r29 :: bool
    r30 :: object
    r31 :: int
    r32, r33, r34 :: object
    r35 :: i32
    r36 :: bit
    r37 :: bool
    r38, r39, r40 :: object
    r41 :: object[2]
    r42 :: object_ptr
    r43, r44, r45, r46 :: object
    r47 :: str
    r48 :: object
    r49 :: object[3]
    r50 :: object_ptr
    r51, r52, r53 :: object
    r54 :: str
    r55 :: object
    r56 :: bool
    r57 :: object
    r58 :: bool
    r59 :: object
    r60 :: bit
    r61 :: dank_mids._batch.DankBatch
    r62 :: object
    r63 :: dict
    r64 :: str
    r65 :: object
    r66 :: object[1]
    r67 :: object_ptr
    r68 :: object
    r69 :: bool
    r70 :: object
    r71 :: str
    r72 :: object
    r73 :: bool
    r74 :: dict
    r75 :: native_int
    r76, r77 :: bit
    r78 :: object
    r79 :: i32
    r80 :: bit
    r81 :: bool
    r82 :: object
    r83 :: int
    r84 :: bit
    r85, r86, r87 :: object
    r88 :: str
    r89 :: object
    r90 :: object[1]
    r91 :: object_ptr
    r92 :: object
    r93 :: bool
    r94 :: object
    r95 :: str
    r96 :: object
    r97 :: str
    r98 :: object[1]
    r99 :: object_ptr
    r100, r101, r102 :: object
    r103 :: dict
    r104 :: str
    r105 :: object
    r106 :: bit
    r107, r108, r109 :: object
    r110 :: str
    r111 :: object[1]
    r112 :: object_ptr
    r113 :: object
    r114 :: bool
    r115 :: object
    r116 :: bit
    r117 :: object
    r118 :: bool
    r119 :: object
    r120 :: bit
    r121 :: object
    r122 :: bool
    r123, r124, r125, r126 :: bit
    r127 :: bool
    r128 :: object
L0:
    r0 = __mypyc_self__.__mypyc_next_label__
    goto L93
L1:
    r1 = load_address _Py_NoneStruct
    r2 = type != r1
    if r2 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L99 (error at coroutines:131) else goto L3 :: bool
L3:
    unreachable
L4:
    r3 = __mypyc_self__.self
    if is_error(r3) goto L99 (error at coroutines:145) else goto L5
L5:
    r4 = r3.rpc_calls
    dec_ref r3
    __mypyc_self__.working_batch = r4; r5 = is_error
    if not r5 goto L99 (error at coroutines:145) else goto L6 :: bool
L6:
    r6 = __mypyc_self__.working_batch
    if is_error(r6) goto L99 (error at coroutines:148) else goto L7
L7:
    r7 = 'append'
    r8 = CPyObject_GetAttr(r6, r7)
    dec_ref r6
    if is_error(r8) goto L99 (error at coroutines:148) else goto L8
L8:
    __mypyc_self__.batch_append = r8; r9 = is_error
    if not r9 goto L99 (error at coroutines:148) else goto L9 :: bool
L9:
    r10 = __mypyc_self__.self
    if is_error(r10) goto L99 (error at coroutines:151) else goto L10
L10:
    r11 = r10._check_len
    dec_ref r10
    __mypyc_self__.check_len = r11; r12 = is_error
    if not r12 goto L99 (error at coroutines:151) else goto L11 :: bool
L11:
    r13 = __mypyc_self__.self
    if is_error(r13) goto L99 (error at coroutines:152) else goto L12
L12:
    r14 = r13.multicalls
    dec_ref r13
    inc_ref r14
    __mypyc_self__.__mypyc_temp__11 = r14; r15 = is_error
    if not r15 goto L100 (error at coroutines:-1) else goto L13 :: bool
L13:
    __mypyc_self__.__mypyc_temp__12 = 0; r16 = is_error
    if not r16 goto L100 (error at coroutines:-1) else goto L14 :: bool
L14:
    r17 = __mypyc_self__.__mypyc_temp__11
    if is_error(r17) goto L100 (error at coroutines:152) else goto L15
L15:
    r18 = PyDict_Size(r17)
    dec_ref r17
    __mypyc_self__.__mypyc_temp__13 = r18; r19 = is_error
    if not r19 goto L100 (error at coroutines:-1) else goto L16 :: bool
L16:
    r20 = CPyDict_GetValuesIter(r14)
    dec_ref r14
    if is_error(r20) goto L99 (error at coroutines:152) else goto L17
L17:
    __mypyc_self__.__mypyc_temp__14 = r20; r21 = is_error
    if not r21 goto L99 (error at coroutines:-1) else goto L18 :: bool
L18:
    r22 = __mypyc_self__.__mypyc_temp__14
    if is_error(r22) goto L99 (error at coroutines:152) else goto L19
L19:
    r23 = __mypyc_self__.__mypyc_temp__12
    if is_error(r23) goto L101 (error at coroutines:152) else goto L20
L20:
    r24 = CPyDict_NextValue(r22, r23)
    dec_ref r22
    r25 = r24[1]
    __mypyc_self__.__mypyc_temp__12 = r25; r26 = is_error
    if not r26 goto L102 (error at coroutines:152) else goto L21 :: bool
L21:
    r27 = r24[0]
    if r27 goto L22 else goto L103 :: bool
L22:
    r28 = r24[2]
    dec_ref r24
    __mypyc_self__.mcall = r28; r29 = is_error
    if not r29 goto L99 (error at coroutines:152) else goto L23 :: bool
L23:
    r30 = __mypyc_self__.mcall
    if is_error(r30) goto L99 (error at coroutines:153) else goto L24
L24:
    r31 = CPyObject_Size(r30)
    dec_ref r30
    if is_error(r31) goto L99 (error at coroutines:153) else goto L25
L25:
    r32 = __mypyc_self__.check_len
    if is_error(r32) goto L104 (error at coroutines:153) else goto L26
L26:
    r33 = box(int, r31)
    r34 = PyObject_RichCompare(r33, r32, 5)
    dec_ref r33
    dec_ref r32
    if is_error(r34) goto L99 (error at coroutines:153) else goto L27
L27:
    r35 = PyObject_IsTrue(r34)
    dec_ref r34
    r36 = r35 >= 0 :: signed
    if not r36 goto L99 (error at coroutines:153) else goto L28 :: bool
L28:
    r37 = truncate r35: i32 to builtins.bool
    if r37 goto L29 else goto L33 :: bool
L29:
    r38 = __mypyc_self__.mcall
    if is_error(r38) goto L99 (error at coroutines:154) else goto L30
L30:
    r39 = __mypyc_self__.batch_append
    if is_error(r39) goto L105 (error at coroutines:154) else goto L31
L31:
    r40 = box(bool, 1)
    r41 = [r38, r40]
    r42 = load_address r41
    r43 = ('skip_check',)
    r44 = PyObject_Vectorcall(r39, r42, 1, r43)
    dec_ref r39
    if is_error(r44) goto L105 (error at coroutines:154) else goto L106
L32:
    dec_ref r38
    goto L37
L33:
    r45 = __mypyc_self__.working_batch
    if is_error(r45) goto L99 (error at coroutines:158) else goto L34
L34:
    r46 = __mypyc_self__.mcall
    if is_error(r46) goto L107 (error at coroutines:158) else goto L35
L35:
    r47 = 'extend'
    r48 = box(bool, 1)
    r49 = [r45, r46, r48]
    r50 = load_address r49
    r51 = ('skip_check',)
    r52 = PyObject_VectorcallMethod(r47, r50, 9223372036854775810, r51)
    if is_error(r52) goto L108 (error at coroutines:158) else goto L109
L36:
    dec_ref r45
    dec_ref r46
L37:
    r53 = __mypyc_self__.working_batch
    if is_error(r53) goto L99 (error at coroutines:159) else goto L38
L38:
    r54 = 'is_full'
    r55 = CPyObject_GetAttr(r53, r54)
    dec_ref r53
    if is_error(r55) goto L99 (error at coroutines:159) else goto L39
L39:
    r56 = unbox(bool, r55)
    dec_ref r55
    if is_error(r56) goto L99 (error at coroutines:159) else goto L40
L40:
    if r56 goto L41 else goto L53 :: bool
L41:
    r57 = __mypyc_self__.working_batch
    if is_error(r57) goto L99 (error at coroutines:160) else goto L42
L42:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r57
L43:
    r59 = load_address _Py_NoneStruct
    r60 = type != r59
    if r60 goto L44 else goto L46 :: bool
L44:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L99 (error at coroutines:160) else goto L45 :: bool
L45:
    unreachable
L46:
    r61 = __mypyc_self__.self
    if is_error(r61) goto L99 (error at coroutines:161) else goto L47
L47:
    r62 = r61.controller
    dec_ref r61
    r63 = dank_mids._batch.globals :: static
    r64 = 'JSONRPCBatch'
    r65 = CPyDict_GetItem(r63, r64)
    if is_error(r65) goto L110 (error at coroutines:161) else goto L48
L48:
    r66 = [r62]
    r67 = load_address r66
    r68 = PyObject_Vectorcall(r65, r67, 1, 0)
    dec_ref r65
    if is_error(r68) goto L110 (error at coroutines:161) else goto L49
L49:
    dec_ref r62
    __mypyc_self__.working_batch = r68; r69 = is_error
    if not r69 goto L99 (error at coroutines:161) else goto L50 :: bool
L50:
    r70 = __mypyc_self__.working_batch
    if is_error(r70) goto L99 (error at coroutines:162) else goto L51
L51:
    r71 = 'append'
    r72 = CPyObject_GetAttr(r70, r71)
    dec_ref r70
    if is_error(r72) goto L99 (error at coroutines:162) else goto L52
L52:
    __mypyc_self__.batch_append = r72; r73 = is_error
    if not r73 goto L99 (error at coroutines:162) else goto L53 :: bool
L53:
    r74 = __mypyc_self__.__mypyc_temp__11
    if is_error(r74) goto L99 (error at coroutines:152) else goto L54
L54:
    r75 = __mypyc_self__.__mypyc_temp__13
    if is_error(r75) goto L111 (error at coroutines:152) else goto L55
L55:
    r76 = CPyDict_CheckSize(r74, r75)
    dec_ref r74
    if not r76 goto L99 (error at coroutines:152) else goto L18 :: bool
L56:
    r77 = CPy_NoErrOccurred()
    if not r77 goto L99 (error at coroutines:152) else goto L57 :: bool
L57:
    r78 = __mypyc_self__.working_batch
    if is_error(r78) goto L99 (error at coroutines:164) else goto L58
L58:
    r79 = PyObject_IsTrue(r78)
    dec_ref r78
    r80 = r79 >= 0 :: signed
    if not r80 goto L99 (error at coroutines:164) else goto L59 :: bool
L59:
    r81 = truncate r79: i32 to builtins.bool
    if r81 goto L60 else goto L88 :: bool
L60:
    r82 = __mypyc_self__.working_batch
    if is_error(r82) goto L99 (error at coroutines:165) else goto L61
L61:
    r83 = CPyObject_Size(r82)
    dec_ref r82
    if is_error(r83) goto L99 (error at coroutines:165) else goto L62
L62:
    r84 = r83 == 2
    dec_ref r83 :: int
    if r84 goto L63 else goto L83 :: bool
L63:
    r85 = __mypyc_self__.working_batch
    if is_error(r85) goto L99 (error at coroutines:166) else goto L64
L64:
    r86 = PyObject_GetIter(r85)
    dec_ref r85
    if is_error(r86) goto L99 (error at coroutines:166) else goto L65
L65:
    r87 = builtins :: module
    r88 = 'next'
    r89 = CPyObject_GetAttr(r87, r88)
    if is_error(r89) goto L112 (error at coroutines:166) else goto L66
L66:
    r90 = [r86]
    r91 = load_address r90
    r92 = PyObject_Vectorcall(r89, r91, 1, 0)
    dec_ref r89
    if is_error(r92) goto L112 (error at coroutines:166) else goto L67
L67:
    dec_ref r86
    __mypyc_self__.call = r92; r93 = is_error
    if not r93 goto L99 (error at coroutines:166) else goto L68 :: bool
L68:
    r94 = __mypyc_self__.working_batch
    if is_error(r94) goto L99 (error at coroutines:168) else goto L69
L69:
    r95 = '_done'
    r96 = CPyObject_GetAttr(r94, r95)
    dec_ref r94
    if is_error(r96) goto L99 (error at coroutines:168) else goto L70
L70:
    r97 = 'set'
    r98 = [r96]
    r99 = load_address r98
    r100 = PyObject_VectorcallMethod(r97, r99, 9223372036854775809, 0)
    if is_error(r100) goto L113 (error at coroutines:168) else goto L114
L71:
    dec_ref r96
    r101 = __mypyc_self__.call
    if is_error(r101) goto L99 (error at coroutines:169) else goto L72
L72:
    r102 = PyObject_Type(r101)
    dec_ref r101
    r103 = dank_mids._batch.globals :: static
    r104 = 'Multicall'
    r105 = CPyDict_GetItem(r103, r104)
    if is_error(r105) goto L115 (error at coroutines:169) else goto L73
L73:
    r106 = r102 == r105
    dec_ref r102
    dec_ref r105
    if r106 goto L74 else goto L76 :: bool
L74:
    r107 = __mypyc_self__.call
    if is_error(r107) goto L99 (error at coroutines:169) else goto L75
L75:
    r108 = r107
    goto L79
L76:
    r109 = __mypyc_self__.call
    if is_error(r109) goto L99 (error at coroutines:169) else goto L77
L77:
    r110 = 'make_request'
    r111 = [r109]
    r112 = load_address r111
    r113 = PyObject_VectorcallMethod(r110, r112, 9223372036854775809, 0)
    if is_error(r113) goto L116 (error at coroutines:169) else goto L78
L78:
    dec_ref r109
    r108 = r113
L79:
    __mypyc_self__.__mypyc_next_label__ = 2
    return r108
L80:
    r115 = load_address _Py_NoneStruct
    r116 = type != r115
    if r116 goto L81 else goto L88 :: bool
L81:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L99 (error at coroutines:169) else goto L82 :: bool
L82:
    unreachable
L83:
    r117 = __mypyc_self__.working_batch
    if is_error(r117) goto L99 (error at coroutines:171) else goto L84
L84:
    __mypyc_self__.__mypyc_next_label__ = 3
    return r117
L85:
    r119 = load_address _Py_NoneStruct
    r120 = type != r119
    if r120 goto L86 else goto L88 :: bool
L86:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L99 (error at coroutines:171) else goto L87 :: bool
L87:
    unreachable
L88:
    r121 = box(None, 1)
    __mypyc_self__.__mypyc_next_label__ = -1
L89:
    if is_error(stop_iter_ptr) goto L90 else goto L92
L90:
    CPyGen_SetStopIterationValue(r121)
    if not 0 goto L99 else goto L91 :: bool
L91:
    unreachable
L92:
    inc_ref r121
    set_mem stop_iter_ptr, r121 :: builtins.object*
    return 0
L93:
    r123 = r0 == 0
    if r123 goto L1 else goto L94 :: bool
L94:
    r124 = r0 == 1
    if r124 goto L43 else goto L95 :: bool
L95:
    r125 = r0 == 2
    if r125 goto L80 else goto L96 :: bool
L96:
    r126 = r0 == 3
    if r126 goto L85 else goto L97 :: bool
L97:
    r127 = raise StopIteration
    if not r127 goto L99 (error at coroutines:131) else goto L98 :: bool
L98:
    unreachable
L99:
    r128 = <error> :: object
    return r128
L100:
    dec_ref r14
    goto L99
L101:
    dec_ref r22
    goto L99
L102:
    dec_ref r24
    goto L99
L103:
    dec_ref r24
    goto L56
L104:
    dec_ref r31 :: int
    goto L99
L105:
    dec_ref r38
    goto L99
L106:
    dec_ref r44
    goto L32
L107:
    dec_ref r45
    goto L99
L108:
    dec_ref r45
    dec_ref r46
    goto L99
L109:
    dec_ref r52
    goto L36
L110:
    dec_ref r62
    goto L99
L111:
    dec_ref r74
    goto L99
L112:
    dec_ref r86
    goto L99
L113:
    dec_ref r96
    goto L99
L114:
    dec_ref r100
    goto L71
L115:
    dec_ref r102
    goto L99
L116:
    dec_ref r109
    goto L99

def coroutines_DankBatch_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutines_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutines_DankBatch_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutines_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutines_DankBatch_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutines_DankBatch_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutines_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutines_DankBatch_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def DankBatch.coroutines(self):
    self :: dank_mids._batch.DankBatch
    r0 :: dank_mids._batch.coroutines_DankBatch_gen
    r1, r2 :: bool
    r3 :: object
L0:
    r0 = coroutines_DankBatch_gen()
    if is_error(r0) goto L3 (error at coroutines:131) else goto L1
L1:
    r0.__mypyc_next_label__ = 0
    inc_ref self
    r0.self = self; r2 = is_error
    if not r2 goto L4 (error at coroutines:131) else goto L2 :: bool
L2:
    return r0
L3:
    r3 = <error> :: object
    return r3
L4:
    dec_ref r0
    goto L3

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13 :: object_ptr
    r14 :: object_ptr[1]
    r15 :: c_ptr
    r16 :: native_int[1]
    r17 :: c_ptr
    r18 :: object
    r19 :: dict
    r20, r21 :: str
    r22 :: bit
    r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: dict
    r30, r31 :: object
    r32 :: str
    r33 :: dict
    r34, r35 :: object
    r36 :: str
    r37 :: dict
    r38, r39 :: object
    r40 :: str
    r41 :: dict
    r42, r43 :: object
    r44 :: str
    r45 :: dict
    r46 :: object
    r47 :: str
    r48 :: dict
    r49 :: str
    r50 :: object
    r51 :: object[1]
    r52 :: object_ptr
    r53 :: object
    r54 :: dict
    r55 :: str
    r56 :: i32
    r57 :: bit
    r58 :: dict
    r59 :: str
    r60 :: object
    r61 :: dict
    r62 :: str
    r63 :: object
    r64 :: dict
    r65 :: str
    r66 :: object
    r67 :: dict
    r68 :: str
    r69, r70, r71 :: object
    r72 :: tuple[object, object, object]
    r73, r74 :: object
    r75 :: dict
    r76 :: str
    r77 :: i32
    r78 :: bit
    r79 :: dict
    r80 :: str
    r81 :: object
    r82 :: i32
    r83 :: bit
    r84 :: dict
    r85 :: str
    r86 :: object
    r87 :: i32
    r88 :: bit
    r89 :: dict
    r90 :: str
    r91 :: object
    r92 :: str
    r93 :: object
    r94 :: bool
    r95 :: object[1]
    r96 :: object_ptr
    r97 :: object
    r98 :: dict
    r99 :: str
    r100 :: i32
    r101 :: bit
    r102 :: dict
    r103 :: str
    r104 :: object
    r105 :: str
    r106 :: object
    r107 :: dict
    r108 :: str
    r109 :: i32
    r110 :: bit
    r111 :: object
    r112 :: str
    r113, r114 :: object
    r115 :: bool
    r116, r117, r118, r119, r120, r121 :: str
    r122 :: tuple
    r123 :: i32
    r124 :: bit
    r125 :: dict
    r126 :: str
    r127 :: i32
    r128 :: bit
    r129 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L41 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Task',)
    r6 = 'asyncio'
    r7 = dank_mids._batch.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L41 (error at <module>:1) else goto L4
L4:
    asyncio = r8 :: module
    dec_ref r8
    r9 = ('TYPE_CHECKING', 'Any', 'Awaitable', 'Final', 'Generator', 'TypeVar', 'Union', 'final')
    r10 = 'typing'
    r11 = dank_mids._batch.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L41 (error at <module>:2) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = load_address a_sync :: module
    r14 = [r13]
    r15 = load_address r14
    r16 = [4]
    r17 = load_address r16
    r18 = (('a_sync', 'a_sync', 'a_sync'),)
    r19 = dank_mids._batch.globals :: static
    r20 = 'dank_mids/_batch.py'
    r21 = '<module>'
    r22 = CPyImport_ImportMany(r18, r15, r19, r20, r21, r17)
    if not r22 goto L41 else goto L6 :: bool
L6:
    r23 = ('DankMidsInternalError',)
    r24 = 'dank_mids._exceptions'
    r25 = dank_mids._batch.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L41 (error at <module>:6) else goto L7
L7:
    dank_mids._exceptions = r26 :: module
    dec_ref r26
    r27 = ('getLogger',)
    r28 = 'dank_mids._logging'
    r29 = dank_mids._batch.globals :: static
    r30 = CPyImport_ImportFromMany(r28, r27, r27, r29)
    if is_error(r30) goto L41 (error at <module>:7) else goto L8
L8:
    dank_mids._logging = r30 :: module
    dec_ref r30
    r31 = ('JSONRPCBatch', 'Multicall')
    r32 = 'dank_mids._requests'
    r33 = dank_mids._batch.globals :: static
    r34 = CPyImport_ImportFromMany(r32, r31, r31, r33)
    if is_error(r34) goto L41 (error at <module>:8) else goto L9
L9:
    dank_mids._requests = r34 :: module
    dec_ref r34
    r35 = ('RawResponse',)
    r36 = 'dank_mids.helpers._codec'
    r37 = dank_mids._batch.globals :: static
    r38 = CPyImport_ImportFromMany(r36, r35, r35, r37)
    if is_error(r38) goto L41 (error at <module>:9) else goto L10
L10:
    dank_mids.helpers._codec = r38 :: module
    dec_ref r38
    r39 = ('log_internal_error',)
    r40 = 'dank_mids.helpers._errors'
    r41 = dank_mids._batch.globals :: static
    r42 = CPyImport_ImportFromMany(r40, r39, r39, r41)
    if is_error(r42) goto L41 (error at <module>:10) else goto L11
L11:
    dank_mids.helpers._errors = r42 :: module
    dec_ref r42
    r43 = ('Multicalls',)
    r44 = 'dank_mids.types'
    r45 = dank_mids._batch.globals :: static
    r46 = CPyImport_ImportFromMany(r44, r43, r43, r45)
    if is_error(r46) goto L41 (error at <module>:11) else goto L12
L12:
    dank_mids.types = r46 :: module
    dec_ref r46
    if 0 goto L13 else goto L13 :: bool
L13:
    r47 = '__T'
    r48 = dank_mids._batch.globals :: static
    r49 = 'TypeVar'
    r50 = CPyDict_GetItem(r48, r49)
    if is_error(r50) goto L41 (error at <module>:17) else goto L14
L14:
    r51 = [r47]
    r52 = load_address r51
    r53 = PyObject_Vectorcall(r50, r52, 1, 0)
    dec_ref r50
    if is_error(r53) goto L41 (error at <module>:17) else goto L15
L15:
    r54 = dank_mids._batch.globals :: static
    r55 = '__T'
    r56 = CPyDict_SetItem(r54, r55, r53)
    dec_ref r53
    r57 = r56 >= 0 :: signed
    if not r57 goto L41 (error at <module>:17) else goto L16 :: bool
L16:
    r58 = dank_mids._batch.globals :: static
    r59 = 'Union'
    r60 = CPyDict_GetItem(r58, r59)
    if is_error(r60) goto L41 (error at <module>:19) else goto L17
L17:
    r61 = dank_mids._batch.globals :: static
    r62 = 'Multicall'
    r63 = CPyDict_GetItem(r61, r62)
    if is_error(r63) goto L42 (error at <module>:19) else goto L18
L18:
    r64 = dank_mids._batch.globals :: static
    r65 = 'JSONRPCBatch'
    r66 = CPyDict_GetItem(r64, r65)
    if is_error(r66) goto L43 (error at <module>:19) else goto L19
L19:
    r67 = dank_mids._batch.globals :: static
    r68 = 'Awaitable'
    r69 = CPyDict_GetItem(r67, r68)
    if is_error(r69) goto L44 (error at <module>:19) else goto L20
L20:
    r70 = dank_mids.helpers._codec.RawResponse :: type
    r71 = PyObject_GetItem(r69, r70)
    dec_ref r69
    if is_error(r71) goto L44 (error at <module>:19) else goto L21
L21:
    r72 = (r63, r66, r71)
    r73 = box(tuple[object, object, object], r72)
    r74 = PyObject_GetItem(r60, r73)
    dec_ref r60
    dec_ref r73
    if is_error(r74) goto L41 (error at <module>:19) else goto L22
L22:
    r75 = dank_mids._batch.globals :: static
    r76 = 'Coro'
    r77 = CPyDict_SetItem(r75, r76, r74)
    dec_ref r74
    r78 = r77 >= 0 :: signed
    if not r78 goto L41 (error at <module>:19) else goto L23 :: bool
L23:
    r79 = dank_mids._batch.globals :: static
    r80 = 'MIN_SIZE'
    r81 = object 1
    r82 = CPyDict_SetItem(r79, r80, r81)
    r83 = r82 >= 0 :: signed
    if not r83 goto L41 (error at <module>:22) else goto L24 :: bool
L24:
    r84 = dank_mids._batch.globals :: static
    r85 = 'CHECK'
    r86 = object 0
    r87 = CPyDict_SetItem(r84, r85, r86)
    r88 = r87 >= 0 :: signed
    if not r88 goto L41 (error at <module>:25) else goto L25 :: bool
L25:
    r89 = dank_mids._batch.globals :: static
    r90 = '__name__'
    r91 = CPyDict_GetItem(r89, r90)
    if is_error(r91) goto L41 (error at <module>:29) else goto L26
L26:
    r92 = cast(str, r91)
    if is_error(r92) goto L41 (error at <module>:29) else goto L27
L27:
    r93 = dank_mids._logging.getLogger :: static
    if is_error(r93) goto L45 else goto L30
L28:
    r94 = raise NameError('value for final name "getLogger" was not set')
    if not r94 goto L41 (error at <module>:29) else goto L29 :: bool
L29:
    unreachable
L30:
    r95 = [r92]
    r96 = load_address r95
    r97 = PyObject_Vectorcall(r93, r96, 1, 0)
    if is_error(r97) goto L46 (error at <module>:29) else goto L31
L31:
    dec_ref r92
    dank_mids._batch.logger = r97 :: static
    r98 = dank_mids._batch.globals :: static
    r99 = 'logger'
    r100 = CPyDict_SetItem(r98, r99, r97)
    dec_ref r97
    r101 = r100 >= 0 :: signed
    if not r101 goto L41 (error at <module>:29) else goto L32 :: bool
L32:
    r102 = dank_mids._batch.globals :: static
    r103 = 'a_sync'
    r104 = CPyDict_GetItem(r102, r103)
    if is_error(r104) goto L41 (error at <module>:31) else goto L33
L33:
    r105 = 'create_task'
    r106 = CPyObject_GetAttr(r104, r105)
    dec_ref r104
    if is_error(r106) goto L41 (error at <module>:31) else goto L34
L34:
    dank_mids._batch.create_task = r106 :: static
    r107 = dank_mids._batch.globals :: static
    r108 = 'create_task'
    r109 = CPyDict_SetItem(r107, r108, r106)
    dec_ref r106
    r110 = r109 >= 0 :: signed
    if not r110 goto L41 (error at <module>:31) else goto L35 :: bool
L35:
    r111 = <error> :: object
    r112 = 'dank_mids._batch'
    r113 = dank_mids._batch.DankBatch_template :: type
    r114 = CPyType_FromTemplate(r113, r111, r112)
    if is_error(r114) goto L41 (error at <module>:39) else goto L36
L36:
    r115 = DankBatch_trait_vtable_setup()
    if is_error(r115) goto L47 (error at <module>:-1) else goto L37
L37:
    r116 = '__mypyc_attrs__'
    r117 = 'controller'
    r118 = 'multicalls'
    r119 = 'rpc_calls'
    r120 = '_awaited'
    r121 = '_check_len'
    r122 = PyTuple_Pack(5, r117, r118, r119, r120, r121)
    if is_error(r122) goto L47 (error at <module>:39) else goto L38
L38:
    r123 = PyObject_SetAttr(r114, r116, r122)
    dec_ref r122
    r124 = r123 >= 0 :: signed
    if not r124 goto L47 (error at <module>:39) else goto L39 :: bool
L39:
    dank_mids._batch.DankBatch = r114 :: type
    r125 = dank_mids._batch.globals :: static
    r126 = 'DankBatch'
    r127 = CPyDict_SetItem(r125, r126, r114)
    dec_ref r114
    r128 = r127 >= 0 :: signed
    if not r128 goto L41 (error at <module>:39) else goto L40 :: bool
L40:
    return 1
L41:
    r129 = <error> :: None
    return r129
L42:
    dec_ref r60
    goto L41
L43:
    dec_ref r60
    dec_ref r63
    goto L41
L44:
    dec_ref r60
    dec_ref r63
    dec_ref r66
    goto L41
L45:
    dec_ref r92
    goto L28
L46:
    dec_ref r92
    goto L41
L47:
    dec_ref r114
    goto L41

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13, r14 :: object_ptr
    r15 :: object_ptr[2]
    r16 :: c_ptr
    r17 :: native_int[2]
    r18 :: c_ptr
    r19 :: object
    r20 :: dict
    r21, r22 :: str
    r23 :: bit
    r24 :: object
    r25 :: str
    r26 :: dict
    r27, r28 :: object
    r29 :: str
    r30 :: dict
    r31, r32 :: object
    r33 :: str
    r34 :: dict
    r35, r36 :: object
    r37 :: str
    r38 :: dict
    r39, r40 :: object
    r41 :: str
    r42 :: dict
    r43 :: object
    r44 :: str
    r45 :: object
    r46 :: bool
    r47 :: object[1]
    r48 :: object_ptr
    r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: dict
    r55 :: str
    r56 :: object
    r57 :: str
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: i32
    r62 :: bit
    r63 :: bool
    r64 :: object
    r65 :: bool
    r66 :: str
    r67 :: object[1]
    r68 :: object_ptr
    r69 :: object
    r70 :: bool
    r71 :: object
    r72 :: bool
    r73 :: dict
    r74 :: str
    r75, r76 :: object
    r77 :: str
    r78 :: object[2]
    r79 :: object_ptr
    r80, r81 :: object
    r82 :: bool
    r83 :: int
    r84 :: bool
    r85 :: str
    r86 :: object
    r87 :: object[2]
    r88 :: object_ptr
    r89 :: object
    r90 :: bool
    r91 :: object
    r92 :: bool
    r93 :: int
    r94 :: bool
    r95 :: str
    r96 :: object
    r97 :: object[2]
    r98 :: object_ptr
    r99, r100 :: object
    r101 :: bool
    r102, r103 :: str
    r104 :: object[2]
    r105 :: object_ptr
    r106 :: object
    r107 :: str
    r108 :: dict
    r109 :: str
    r110 :: object
    r111 :: str
    r112 :: object
    r113 :: bool
    r114 :: object
    r115 :: object[4]
    r116 :: object_ptr
    r117, r118 :: object
    r119 :: dict
    r120 :: str
    r121 :: i32
    r122 :: bit
    r123 :: str
    r124, r125 :: object
    r126 :: bool
    r127 :: object
    r128 :: object[3]
    r129 :: object_ptr
    r130, r131 :: object
    r132 :: dict
    r133 :: str
    r134 :: i32
    r135 :: bit
    r136 :: str
    r137, r138 :: object
    r139 :: bool
    r140 :: object
    r141 :: object[3]
    r142 :: object_ptr
    r143, r144 :: object
    r145 :: dict
    r146 :: str
    r147 :: i32
    r148 :: bit
    r149 :: str
    r150, r151 :: object
    r152 :: bool
    r153 :: object
    r154 :: object[3]
    r155 :: object_ptr
    r156, r157 :: object
    r158 :: dict
    r159 :: str
    r160 :: i32
    r161 :: bit
    r162 :: str
    r163, r164 :: object
    r165 :: bool
    r166 :: object
    r167 :: object[3]
    r168 :: object_ptr
    r169, r170 :: object
    r171 :: dict
    r172 :: str
    r173 :: i32
    r174 :: bit
    r175 :: object
    r176 :: bool
    r177 :: str
    r178 :: object
    r179 :: str
    r180, r181 :: object
    r182 :: object[5]
    r183 :: object_ptr
    r184, r185 :: object
    r186 :: dict
    r187 :: str
    r188 :: i32
    r189 :: bit
    r190 :: str
    r191, r192 :: object
    r193 :: bool
    r194 :: i32
    r195 :: bit
    r196 :: bool
    r197 :: object
    r198 :: bool
    r199, r200 :: object
    r201 :: object[4]
    r202 :: object_ptr
    r203, r204 :: object
    r205 :: dict
    r206 :: str
    r207 :: i32
    r208 :: bit
    r209 :: object
    r210 :: bool
    r211 :: str
    r212 :: object
    r213 :: str
    r214, r215 :: object
    r216 :: object[5]
    r217 :: object_ptr
    r218, r219 :: object
    r220 :: dict
    r221 :: str
    r222 :: i32
    r223 :: bit
    r224 :: str
    r225, r226 :: object
    r227 :: bool
    r228 :: i32
    r229 :: bit
    r230 :: bool
    r231 :: object
    r232 :: bool
    r233 :: object
    r234 :: object[3]
    r235 :: object_ptr
    r236, r237 :: object
    r238 :: dict
    r239 :: str
    r240 :: i32
    r241 :: bit
    r242 :: str
    r243, r244 :: object
    r245 :: bool
    r246 :: object
    r247 :: object[3]
    r248 :: object_ptr
    r249, r250 :: object
    r251 :: dict
    r252 :: str
    r253 :: i32
    r254 :: bit
    r255 :: object
    r256 :: bool
    r257 :: str
    r258 :: object
    r259 :: str
    r260, r261 :: object
    r262 :: object[5]
    r263 :: object_ptr
    r264, r265 :: object
    r266 :: dict
    r267 :: str
    r268 :: i32
    r269 :: bit
    r270 :: str
    r271 :: dict
    r272 :: str
    r273, r274 :: object
    r275 :: bool
    r276 :: object
    r277 :: bool
    r278 :: str
    r279 :: object
    r280 :: i32
    r281 :: bit
    r282 :: bool
    r283 :: object
    r284 :: bool
    r285 :: object
    r286 :: object[4]
    r287 :: object_ptr
    r288, r289 :: object
    r290 :: dict
    r291 :: str
    r292 :: i32
    r293 :: bit
    r294 :: str
    r295 :: dict
    r296 :: str
    r297, r298 :: object
    r299 :: bool
    r300 :: str
    r301, r302, r303, r304 :: object
    r305 :: bool
    r306 :: str
    r307 :: object
    r308 :: i32
    r309 :: bit
    r310 :: bool
    r311 :: object
    r312 :: bool
    r313 :: object
    r314 :: object[4]
    r315 :: object_ptr
    r316, r317 :: object
    r318 :: dict
    r319 :: str
    r320 :: i32
    r321 :: bit
    r322 :: str
    r323 :: dict
    r324 :: str
    r325, r326 :: object
    r327 :: bool
    r328 :: str
    r329 :: object
    r330 :: i32
    r331 :: bit
    r332 :: bool
    r333 :: int
    r334 :: object
    r335 :: bool
    r336 :: str
    r337 :: object
    r338 :: i32
    r339 :: bit
    r340 :: bool
    r341 :: object
    r342 :: bool
    r343, r344 :: object
    r345 :: object[4]
    r346 :: object_ptr
    r347, r348 :: object
    r349 :: dict
    r350 :: str
    r351 :: i32
    r352 :: bit
    r353 :: str
    r354 :: dict
    r355 :: str
    r356, r357 :: object
    r358 :: bool
    r359 :: str
    r360 :: object
    r361 :: i32
    r362 :: bit
    r363 :: bool
    r364 :: int
    r365 :: object
    r366 :: bool
    r367 :: str
    r368 :: object
    r369 :: i32
    r370 :: bit
    r371 :: bool
    r372 :: object
    r373 :: bool
    r374, r375 :: object
    r376 :: object[4]
    r377 :: object_ptr
    r378, r379 :: object
    r380 :: dict
    r381 :: str
    r382 :: i32
    r383 :: bit
    r384 :: str
    r385 :: dict
    r386 :: str
    r387, r388 :: object
    r389 :: bool
    r390 :: str
    r391 :: object
    r392 :: i32
    r393 :: bit
    r394 :: bool
    r395 :: int
    r396 :: object
    r397 :: bool
    r398 :: str
    r399 :: object
    r400 :: i32
    r401 :: bit
    r402 :: bool
    r403 :: object
    r404 :: bool
    r405, r406 :: object
    r407 :: object[4]
    r408 :: object_ptr
    r409, r410 :: object
    r411 :: dict
    r412 :: str
    r413 :: i32
    r414 :: bit
    r415 :: str
    r416, r417 :: object
    r418 :: bool
    r419 :: str
    r420 :: object
    r421 :: i32
    r422 :: bit
    r423 :: bool
    r424 :: int
    r425 :: object
    r426 :: bool
    r427 :: str
    r428 :: object
    r429 :: i32
    r430 :: bit
    r431 :: bool
    r432 :: object
    r433 :: bool
    r434, r435 :: object
    r436 :: object[4]
    r437 :: object_ptr
    r438, r439 :: object
    r440 :: dict
    r441 :: str
    r442 :: i32
    r443 :: bit
    r444 :: str
    r445, r446 :: object
    r447 :: bool
    r448, r449 :: object
    r450 :: object[4]
    r451 :: object_ptr
    r452, r453 :: object
    r454 :: dict
    r455 :: str
    r456 :: i32
    r457 :: bit
    r458 :: str
    r459, r460 :: object
    r461 :: bool
    r462, r463 :: object
    r464 :: object[4]
    r465 :: object_ptr
    r466, r467 :: object
    r468 :: dict
    r469 :: str
    r470 :: i32
    r471 :: bit
    r472 :: str
    r473, r474 :: object
    r475 :: bool
    r476, r477 :: object
    r478 :: object[4]
    r479 :: object_ptr
    r480, r481 :: object
    r482 :: dict
    r483 :: str
    r484 :: i32
    r485 :: bit
    r486 :: str
    r487, r488 :: object
    r489 :: bool
    r490 :: object
    r491 :: bool
    r492 :: i32
    r493 :: bit
    r494 :: bool
    r495 :: object
    r496 :: bool
    r497 :: object
    r498 :: object[4]
    r499 :: object_ptr
    r500, r501 :: object
    r502 :: dict
    r503 :: str
    r504 :: i32
    r505 :: bit
    r506 :: str
    r507, r508 :: object
    r509 :: bool
    r510 :: object
    r511 :: object[3]
    r512 :: object_ptr
    r513, r514 :: object
    r515 :: dict
    r516 :: str
    r517 :: i32
    r518 :: bit
    r519, r520 :: str
    r521 :: dict
    r522 :: str
    r523, r524 :: object
    r525 :: bool
    r526 :: str
    r527, r528 :: object
    r529 :: bool
    r530 :: object
    r531 :: object[4]
    r532 :: object_ptr
    r533, r534 :: object
    r535, r536 :: str
    r537 :: dict
    r538 :: str
    r539 :: object
    r540 :: str
    r541, r542 :: object
    r543 :: bool
    r544, r545 :: object
    r546 :: object[4]
    r547 :: object_ptr
    r548, r549 :: object
    r550, r551 :: str
    r552 :: dict
    r553 :: str
    r554 :: object
    r555 :: str
    r556, r557 :: object
    r558 :: bool
    r559, r560 :: object
    r561 :: object[4]
    r562 :: object_ptr
    r563, r564 :: object
    r565, r566 :: dict
    r567 :: str
    r568 :: i32
    r569 :: bit
    r570 :: dict
    r571 :: str
    r572 :: object
    r573 :: str
    r574 :: object
    r575 :: str
    r576 :: object
    r577 :: i32
    r578 :: bit
    r579 :: bool
    r580 :: object
    r581 :: bool
    r582, r583 :: str
    r584 :: object[2]
    r585 :: object_ptr
    r586, r587 :: object
    r588 :: bool
    r589, r590 :: str
    r591 :: object[2]
    r592 :: object_ptr
    r593, r594 :: object
    r595 :: bool
    r596 :: str
    r597 :: object
    r598 :: i32
    r599 :: bit
    r600 :: bool
    r601 :: object
    r602 :: bool
    r603, r604 :: str
    r605 :: object[2]
    r606 :: object_ptr
    r607, r608 :: object
    r609 :: bool
    r610 :: str
    r611 :: object
    r612 :: i32
    r613 :: bit
    r614 :: bool
    r615 :: dict
    r616 :: str
    r617 :: object
    r618 :: dict
    r619 :: str
    r620 :: object
    r621 :: dict
    r622 :: str
    r623 :: object
    r624 :: set
    r625 :: i32
    r626 :: bit
    r627 :: i32
    r628 :: bit
    r629 :: i32
    r630 :: bit
    r631, r632 :: object
    r633 :: dict
    r634 :: str
    r635 :: i32
    r636 :: bit
    r637 :: dict
    r638 :: str
    r639 :: object
    r640 :: str
    r641 :: object
    r642 :: i32
    r643 :: bit
    r644 :: bool
    r645 :: str
    r646 :: dict
    r647 :: str
    r648 :: object
    r649 :: str
    r650 :: object
    r651, r652, r653 :: str
    r654 :: object
    r655 :: str
    r656 :: object
    r657 :: object[1]
    r658 :: object_ptr
    r659 :: object
    r660 :: bit
    r661 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L332 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('StreamHandler',)
    r6 = 'logging'
    r7 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L332 (error at <module>:2) else goto L4
L4:
    logging = r8 :: module
    dec_ref r8
    r9 = ('Dict', 'Final')
    r10 = 'typing'
    r11 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L332 (error at <module>:3) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = load_address a_sync :: module
    r14 = load_address typed_envs :: module
    r15 = [r13, r14]
    r16 = load_address r15
    r17 = [5, 6]
    r18 = load_address r17
    r19 = (('a_sync', 'a_sync', 'a_sync'), ('typed_envs', 'typed_envs', 'typed_envs'))
    r20 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r21 = 'dank_mids/ENVIRONMENT_VARIABLES.py'
    r22 = '<module>'
    r23 = CPyImport_ImportMany(r19, r16, r20, r21, r22, r18)
    if not r23 goto L332 else goto L6 :: bool
L6:
    r24 = ('AsyncProcessPoolExecutor',)
    r25 = 'a_sync'
    r26 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r27 = CPyImport_ImportFromMany(r25, r24, r24, r26)
    if is_error(r27) goto L332 (error at <module>:7) else goto L7
L7:
    a_sync = r27 :: module
    dec_ref r27
    r28 = ('_envs',)
    r29 = 'dank_mids'
    r30 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r31 = CPyImport_ImportFromMany(r29, r28, r28, r30)
    if is_error(r31) goto L332 (error at <module>:9) else goto L8
L8:
    dank_mids = r31 :: module
    dec_ref r31
    r32 = ('INFO', 'getLogger')
    r33 = 'dank_mids._logging'
    r34 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r35 = CPyImport_ImportFromMany(r33, r32, r32, r34)
    if is_error(r35) goto L332 (error at <module>:10) else goto L9
L9:
    dank_mids._logging = r35 :: module
    dec_ref r35
    r36 = ('OperationMode',)
    r37 = 'dank_mids._mode'
    r38 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r39 = CPyImport_ImportFromMany(r37, r36, r36, r38)
    if is_error(r39) goto L332 (error at <module>:11) else goto L10
L10:
    dank_mids._mode = r39 :: module
    dec_ref r39
    r40 = ('BlockSemaphore',)
    r41 = 'dank_mids.semaphores'
    r42 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r43 = CPyImport_ImportFromMany(r41, r40, r40, r42)
    if is_error(r43) goto L332 (error at <module>:12) else goto L11
L11:
    dank_mids.semaphores = r43 :: module
    dec_ref r43
    r44 = 'dank_mids.envs'
    r45 = dank_mids._logging.getLogger :: static
    if is_error(r45) goto L12 else goto L14
L12:
    r46 = raise NameError('value for final name "getLogger" was not set')
    if not r46 goto L332 (error at <module>:15) else goto L13 :: bool
L13:
    unreachable
L14:
    r47 = [r44]
    r48 = load_address r47
    r49 = PyObject_Vectorcall(r45, r48, 1, 0)
    if is_error(r49) goto L332 (error at <module>:15) else goto L15
L15:
    dank_mids.ENVIRONMENT_VARIABLES.logger = r49 :: static
    r50 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r51 = 'logger'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L332 (error at <module>:15) else goto L16 :: bool
L16:
    r54 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r55 = 'typed_envs'
    r56 = CPyDict_GetItem(r54, r55)
    if is_error(r56) goto L332 (error at <module>:17) else goto L17
L17:
    r57 = 'logger'
    r58 = CPyObject_GetAttr(r56, r57)
    dec_ref r56
    if is_error(r58) goto L332 (error at <module>:17) else goto L18
L18:
    r59 = 'disabled'
    r60 = CPyObject_GetAttr(r58, r59)
    dec_ref r58
    if is_error(r60) goto L332 (error at <module>:17) else goto L19
L19:
    r61 = PyObject_IsTrue(r60)
    dec_ref r60
    r62 = r61 >= 0 :: signed
    if not r62 goto L332 (error at <module>:17) else goto L20 :: bool
L20:
    r63 = truncate r61: i32 to builtins.bool
    if r63 goto L55 else goto L21 :: bool
L21:
    r64 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r64) goto L22 else goto L24
L22:
    r65 = raise NameError('value for final name "logger" was not set')
    if not r65 goto L332 (error at <module>:18) else goto L23 :: bool
L23:
    unreachable
L24:
    r66 = 'hasHandlers'
    r67 = [r64]
    r68 = load_address r67
    r69 = PyObject_VectorcallMethod(r66, r68, 9223372036854775809, 0)
    if is_error(r69) goto L332 (error at <module>:18) else goto L25
L25:
    r70 = unbox(bool, r69)
    dec_ref r69
    if is_error(r70) goto L332 (error at <module>:18) else goto L26
L26:
    if r70 goto L34 else goto L27 :: bool
L27:
    r71 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r71) goto L28 else goto L30
L28:
    r72 = raise NameError('value for final name "logger" was not set')
    if not r72 goto L332 (error at <module>:19) else goto L29 :: bool
L29:
    unreachable
L30:
    r73 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r74 = 'StreamHandler'
    r75 = CPyDict_GetItem(r73, r74)
    if is_error(r75) goto L332 (error at <module>:19) else goto L31
L31:
    r76 = PyObject_Vectorcall(r75, 0, 0, 0)
    dec_ref r75
    if is_error(r76) goto L332 (error at <module>:19) else goto L32
L32:
    r77 = 'addHandler'
    r78 = [r71, r76]
    r79 = load_address r78
    r80 = PyObject_VectorcallMethod(r77, r79, 9223372036854775810, 0)
    if is_error(r80) goto L333 (error at <module>:19) else goto L334
L33:
    dec_ref r76
L34:
    r81 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r81) goto L35 else goto L37
L35:
    r82 = raise NameError('value for final name "logger" was not set')
    if not r82 goto L332 (error at <module>:20) else goto L36 :: bool
L36:
    unreachable
L37:
    r83 = dank_mids._logging.INFO :: static
    if is_error(r83) goto L38 else goto L40
L38:
    r84 = raise NameError('value for final name "INFO" was not set')
    if not r84 goto L332 (error at <module>:20) else goto L39 :: bool
L39:
    unreachable
L40:
    r85 = 'isEnabledFor'
    inc_ref r83 :: int
    r86 = box(int, r83)
    r87 = [r81, r86]
    r88 = load_address r87
    r89 = PyObject_VectorcallMethod(r85, r88, 9223372036854775810, 0)
    if is_error(r89) goto L335 (error at <module>:20) else goto L41
L41:
    dec_ref r86
    r90 = unbox(bool, r89)
    dec_ref r89
    if is_error(r90) goto L332 (error at <module>:20) else goto L42
L42:
    if r90 goto L51 else goto L43 :: bool
L43:
    r91 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r91) goto L44 else goto L46
L44:
    r92 = raise NameError('value for final name "logger" was not set')
    if not r92 goto L332 (error at <module>:21) else goto L45 :: bool
L45:
    unreachable
L46:
    r93 = dank_mids._logging.INFO :: static
    if is_error(r93) goto L47 else goto L49
L47:
    r94 = raise NameError('value for final name "INFO" was not set')
    if not r94 goto L332 (error at <module>:21) else goto L48 :: bool
L48:
    unreachable
L49:
    r95 = 'setLevel'
    inc_ref r93 :: int
    r96 = box(int, r93)
    r97 = [r91, r96]
    r98 = load_address r97
    r99 = PyObject_VectorcallMethod(r95, r98, 9223372036854775810, 0)
    if is_error(r99) goto L336 (error at <module>:21) else goto L337
L50:
    dec_ref r96
L51:
    r100 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r100) goto L52 else goto L54
L52:
    r101 = raise NameError('value for final name "logger" was not set')
    if not r101 goto L332 (error at <module>:22) else goto L53 :: bool
L53:
    unreachable
L54:
    r102 = 'For your information, you can tweak your configuration for optimal performance using any of the envs below:'
    r103 = 'info'
    r104 = [r100, r102]
    r105 = load_address r104
    r106 = PyObject_VectorcallMethod(r103, r105, 9223372036854775810, 0)
    if is_error(r106) goto L332 (error at <module>:22) else goto L338
L55:
    r107 = 'OPERATION_MODE'
    r108 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r109 = 'OperationMode'
    r110 = CPyDict_GetItem(r108, r109)
    if is_error(r110) goto L332 (error at <module>:35) else goto L56
L56:
    r111 = 'infura'
    r112 = dank_mids._envs.create_env :: static
    if is_error(r112) goto L339 else goto L59
L57:
    r113 = raise NameError('value for final name "create_env" was not set')
    if not r113 goto L332 (error at <module>:34) else goto L58 :: bool
L58:
    unreachable
L59:
    r114 = box(bool, 0)
    r115 = [r107, r110, r111, r114]
    r116 = load_address r115
    r117 = ('default', 'verbose')
    r118 = PyObject_Vectorcall(r112, r116, 2, r117)
    if is_error(r118) goto L340 (error at <module>:34) else goto L60
L60:
    dec_ref r110
    dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE = r118 :: static
    r119 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r120 = 'OPERATION_MODE'
    r121 = CPyDict_SetItem(r119, r120, r118)
    dec_ref r118
    r122 = r121 >= 0 :: signed
    if not r122 goto L332 (error at <module>:34) else goto L61 :: bool
L61:
    r123 = 'MAX_MULTICALL_SIZE'
    r124 = load_address PyLong_Type
    r125 = dank_mids._envs.create_env :: static
    if is_error(r125) goto L62 else goto L64
L62:
    r126 = raise NameError('value for final name "create_env" was not set')
    if not r126 goto L332 (error at <module>:39) else goto L63 :: bool
L63:
    unreachable
L64:
    r127 = object 10000
    r128 = [r123, r124, r127]
    r129 = load_address r128
    r130 = ('default',)
    r131 = PyObject_Vectorcall(r125, r129, 2, r130)
    if is_error(r131) goto L332 (error at <module>:39) else goto L65
L65:
    dank_mids.ENVIRONMENT_VARIABLES.MAX_MULTICALL_SIZE = r131 :: static
    r132 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r133 = 'MAX_MULTICALL_SIZE'
    r134 = CPyDict_SetItem(r132, r133, r131)
    dec_ref r131
    r135 = r134 >= 0 :: signed
    if not r135 goto L332 (error at <module>:39) else goto L66 :: bool
L66:
    r136 = 'MAX_JSONRPC_BATCH_SIZE'
    r137 = load_address PyLong_Type
    r138 = dank_mids._envs.create_env :: static
    if is_error(r138) goto L67 else goto L69
L67:
    r139 = raise NameError('value for final name "create_env" was not set')
    if not r139 goto L332 (error at <module>:41) else goto L68 :: bool
L68:
    unreachable
L69:
    r140 = object 500
    r141 = [r136, r137, r140]
    r142 = load_address r141
    r143 = ('default',)
    r144 = PyObject_Vectorcall(r138, r142, 2, r143)
    if is_error(r144) goto L332 (error at <module>:41) else goto L70
L70:
    dank_mids.ENVIRONMENT_VARIABLES.MAX_JSONRPC_BATCH_SIZE = r144 :: static
    r145 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r146 = 'MAX_JSONRPC_BATCH_SIZE'
    r147 = CPyDict_SetItem(r145, r146, r144)
    dec_ref r144
    r148 = r147 >= 0 :: signed
    if not r148 goto L332 (error at <module>:41) else goto L71 :: bool
L71:
    r149 = 'REQUESTS_PER_SECOND'
    r150 = load_address PyLong_Type
    r151 = dank_mids._envs.create_env :: static
    if is_error(r151) goto L72 else goto L74
L72:
    r152 = raise NameError('value for final name "create_env" was not set')
    if not r152 goto L332 (error at <module>:43) else goto L73 :: bool
L73:
    unreachable
L74:
    r153 = object 50
    r154 = [r149, r150, r153]
    r155 = load_address r154
    r156 = ('default',)
    r157 = PyObject_Vectorcall(r151, r155, 2, r156)
    if is_error(r157) goto L332 (error at <module>:43) else goto L75
L75:
    dank_mids.ENVIRONMENT_VARIABLES.REQUESTS_PER_SECOND = r157 :: static
    r158 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r159 = 'REQUESTS_PER_SECOND'
    r160 = CPyDict_SetItem(r158, r159, r157)
    dec_ref r157
    r161 = r160 >= 0 :: signed
    if not r161 goto L332 (error at <module>:43) else goto L76 :: bool
L76:
    r162 = 'MIN_REQUESTS_PER_SECOND'
    r163 = load_address PyLong_Type
    r164 = dank_mids._envs.create_env :: static
    if is_error(r164) goto L77 else goto L79
L77:
    r165 = raise NameError('value for final name "create_env" was not set')
    if not r165 goto L332 (error at <module>:45) else goto L78 :: bool
L78:
    unreachable
L79:
    r166 = object 10
    r167 = [r162, r163, r166]
    r168 = load_address r167
    r169 = ('default',)
    r170 = PyObject_Vectorcall(r164, r168, 2, r169)
    if is_error(r170) goto L332 (error at <module>:45) else goto L80
L80:
    dank_mids.ENVIRONMENT_VARIABLES.MIN_REQUESTS_PER_SECOND = r170 :: static
    r171 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r172 = 'MIN_REQUESTS_PER_SECOND'
    r173 = CPyDict_SetItem(r171, r172, r170)
    dec_ref r170
    r174 = r173 >= 0 :: signed
    if not r174 goto L332 (error at <module>:45) else goto L81 :: bool
L81:
    r175 = dank_mids._envs._deprecated_format :: static
    if is_error(r175) goto L82 else goto L84
L82:
    r176 = raise NameError('value for final name "_deprecated_format" was not set')
    if not r176 goto L332 (error at <module>:48) else goto L83 :: bool
L83:
    unreachable
L84:
    r177 = 'DEMO_MODE'
    r178 = load_address PyBool_Type
    r179 = 'create_env'
    r180 = box(bool, 0)
    r181 = box(bool, 0)
    r182 = [r175, r177, r178, r180, r181]
    r183 = load_address r182
    r184 = ('default', 'verbose')
    r185 = PyObject_VectorcallMethod(r179, r183, 9223372036854775811, r184)
    if is_error(r185) goto L332 (error at <module>:48) else goto L85
L85:
    dank_mids.ENVIRONMENT_VARIABLES.demo_mode = r185 :: static
    r186 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r187 = 'demo_mode'
    r188 = CPyDict_SetItem(r186, r187, r185)
    dec_ref r185
    r189 = r188 >= 0 :: signed
    if not r189 goto L332 (error at <module>:48) else goto L86 :: bool
L86:
    r190 = 'DEMO_MODE'
    r191 = load_address PyBool_Type
    r192 = dank_mids.ENVIRONMENT_VARIABLES.demo_mode :: static
    if is_error(r192) goto L87 else goto L89
L87:
    r193 = raise NameError('value for final name "demo_mode" was not set')
    if not r193 goto L332 (error at <module>:51) else goto L88 :: bool
L88:
    unreachable
L89:
    r194 = PyObject_IsTrue(r192)
    r195 = r194 >= 0 :: signed
    if not r195 goto L332 (error at <module>:51) else goto L90 :: bool
L90:
    r196 = truncate r194: i32 to builtins.bool
    r197 = dank_mids._envs.create_env :: static
    if is_error(r197) goto L91 else goto L93
L91:
    r198 = raise NameError('value for final name "create_env" was not set')
    if not r198 goto L332 (error at <module>:51) else goto L92 :: bool
L92:
    unreachable
L93:
    r199 = box(bool, r196)
    r200 = box(bool, 0)
    r201 = [r190, r191, r199, r200]
    r202 = load_address r201
    r203 = ('default', 'verbose')
    r204 = PyObject_Vectorcall(r197, r202, 2, r203)
    if is_error(r204) goto L332 (error at <module>:51) else goto L94
L94:
    dank_mids.ENVIRONMENT_VARIABLES.DEMO_MODE = r204 :: static
    r205 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r206 = 'DEMO_MODE'
    r207 = CPyDict_SetItem(r205, r206, r204)
    dec_ref r204
    r208 = r207 >= 0 :: signed
    if not r208 goto L332 (error at <module>:51) else goto L95 :: bool
L95:
    r209 = dank_mids._envs._deprecated_format :: static
    if is_error(r209) goto L96 else goto L98
L96:
    r210 = raise NameError('value for final name "_deprecated_format" was not set')
    if not r210 goto L332 (error at <module>:54) else goto L97 :: bool
L97:
    unreachable
L98:
    r211 = 'GANACHE_FORK'
    r212 = load_address PyBool_Type
    r213 = 'create_env'
    r214 = box(bool, 0)
    r215 = box(bool, 0)
    r216 = [r209, r211, r212, r214, r215]
    r217 = load_address r216
    r218 = ('default', 'verbose')
    r219 = PyObject_VectorcallMethod(r213, r217, 9223372036854775811, r218)
    if is_error(r219) goto L332 (error at <module>:54) else goto L99
L99:
    dank_mids.ENVIRONMENT_VARIABLES.ganache_fork = r219 :: static
    r220 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r221 = 'ganache_fork'
    r222 = CPyDict_SetItem(r220, r221, r219)
    dec_ref r219
    r223 = r222 >= 0 :: signed
    if not r223 goto L332 (error at <module>:54) else goto L100 :: bool
L100:
    r224 = 'GANACHE_FORK'
    r225 = load_address PyBool_Type
    r226 = dank_mids.ENVIRONMENT_VARIABLES.ganache_fork :: static
    if is_error(r226) goto L101 else goto L103
L101:
    r227 = raise NameError('value for final name "ganache_fork" was not set')
    if not r227 goto L332 (error at <module>:57) else goto L102 :: bool
L102:
    unreachable
L103:
    r228 = PyObject_IsTrue(r226)
    r229 = r228 >= 0 :: signed
    if not r229 goto L332 (error at <module>:57) else goto L104 :: bool
L104:
    r230 = truncate r228: i32 to builtins.bool
    r231 = dank_mids._envs.create_env :: static
    if is_error(r231) goto L105 else goto L107
L105:
    r232 = raise NameError('value for final name "create_env" was not set')
    if not r232 goto L332 (error at <module>:57) else goto L106 :: bool
L106:
    unreachable
L107:
    r233 = box(bool, r230)
    r234 = [r224, r225, r233]
    r235 = load_address r234
    r236 = ('default',)
    r237 = PyObject_Vectorcall(r231, r235, 2, r236)
    if is_error(r237) goto L332 (error at <module>:57) else goto L108
L108:
    dank_mids.ENVIRONMENT_VARIABLES.GANACHE_FORK = r237 :: static
    r238 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r239 = 'GANACHE_FORK'
    r240 = CPyDict_SetItem(r238, r239, r237)
    dec_ref r237
    r241 = r240 >= 0 :: signed
    if not r241 goto L332 (error at <module>:57) else goto L109 :: bool
L109:
    r242 = 'AIOHTTP_TIMEOUT'
    r243 = load_address PyLong_Type
    r244 = dank_mids._envs.create_env :: static
    if is_error(r244) goto L110 else goto L112
L110:
    r245 = raise NameError('value for final name "create_env" was not set')
    if not r245 goto L332 (error at <module>:61) else goto L111 :: bool
L111:
    unreachable
L112:
    r246 = object 1200
    r247 = [r242, r243, r246]
    r248 = load_address r247
    r249 = ('default',)
    r250 = PyObject_Vectorcall(r244, r248, 2, r249)
    if is_error(r250) goto L332 (error at <module>:61) else goto L113
L113:
    dank_mids.ENVIRONMENT_VARIABLES.AIOHTTP_TIMEOUT = r250 :: static
    r251 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r252 = 'AIOHTTP_TIMEOUT'
    r253 = CPyDict_SetItem(r251, r252, r250)
    dec_ref r250
    r254 = r253 >= 0 :: signed
    if not r254 goto L332 (error at <module>:61) else goto L114 :: bool
L114:
    r255 = dank_mids._envs._deprecated_format :: static
    if is_error(r255) goto L115 else goto L117
L115:
    r256 = raise NameError('value for final name "_deprecated_format" was not set')
    if not r256 goto L332 (error at <module>:67) else goto L116 :: bool
L116:
    unreachable
L117:
    r257 = 'BROWNIE_CALL_SEMAPHORE'
    r258 = load_address PyLong_Type
    r259 = 'create_env'
    r260 = object 100000
    r261 = box(bool, 0)
    r262 = [r255, r257, r258, r260, r261]
    r263 = load_address r262
    r264 = ('default', 'verbose')
    r265 = PyObject_VectorcallMethod(r259, r263, 9223372036854775811, r264)
    if is_error(r265) goto L332 (error at <module>:67) else goto L118
L118:
    dank_mids.ENVIRONMENT_VARIABLES.brownie_semaphore = r265 :: static
    r266 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r267 = 'brownie_semaphore'
    r268 = CPyDict_SetItem(r266, r267, r265)
    dec_ref r265
    r269 = r268 >= 0 :: signed
    if not r269 goto L332 (error at <module>:67) else goto L119 :: bool
L119:
    r270 = 'BROWNIE_CALL_SEMAPHORE'
    r271 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r272 = 'BlockSemaphore'
    r273 = CPyDict_GetItem(r271, r272)
    if is_error(r273) goto L332 (error at <module>:72) else goto L120
L120:
    r274 = dank_mids.ENVIRONMENT_VARIABLES.brownie_semaphore :: static
    if is_error(r274) goto L341 else goto L123
L121:
    r275 = raise NameError('value for final name "brownie_semaphore" was not set')
    if not r275 goto L332 (error at <module>:73) else goto L122 :: bool
L122:
    unreachable
L123:
    r276 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r276) goto L342 else goto L126
L124:
    r277 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r277 goto L332 (error at <module>:74) else goto L125 :: bool
L125:
    unreachable
L126:
    r278 = 'infura'
    r279 = CPyObject_GetAttr(r276, r278)
    if is_error(r279) goto L343 (error at <module>:74) else goto L127
L127:
    r280 = PyObject_Not(r279)
    dec_ref r279
    r281 = r280 >= 0 :: signed
    if not r281 goto L343 (error at <module>:74) else goto L128 :: bool
L128:
    r282 = truncate r280: i32 to builtins.bool
    r283 = dank_mids._envs.create_env :: static
    if is_error(r283) goto L344 else goto L131
L129:
    r284 = raise NameError('value for final name "create_env" was not set')
    if not r284 goto L332 (error at <module>:70) else goto L130 :: bool
L130:
    unreachable
L131:
    r285 = box(bool, r282)
    r286 = [r270, r273, r274, r285]
    r287 = load_address r286
    r288 = ('default', 'verbose')
    r289 = PyObject_Vectorcall(r283, r287, 2, r288)
    if is_error(r289) goto L343 (error at <module>:70) else goto L132
L132:
    dec_ref r273
    dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE = r289 :: static
    r290 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r291 = 'BROWNIE_CALL_SEMAPHORE'
    r292 = CPyDict_SetItem(r290, r291, r289)
    dec_ref r289
    r293 = r292 >= 0 :: signed
    if not r293 goto L332 (error at <module>:70) else goto L133 :: bool
L133:
    r294 = 'BROWNIE_ENCODER_SEMAPHORE'
    r295 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r296 = 'BlockSemaphore'
    r297 = CPyDict_GetItem(r295, r296)
    if is_error(r297) goto L332 (error at <module>:85) else goto L134
L134:
    r298 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE :: static
    if is_error(r298) goto L345 else goto L137
L135:
    r299 = raise NameError('value for final name "BROWNIE_CALL_SEMAPHORE" was not set')
    if not r299 goto L332 (error at <module>:86) else goto L136 :: bool
L136:
    unreachable
L137:
    r300 = '_default_value'
    r301 = CPyObject_GetAttr(r298, r300)
    if is_error(r301) goto L346 (error at <module>:86) else goto L138
L138:
    r302 = object 2
    r303 = PyNumber_Multiply(r301, r302)
    dec_ref r301
    if is_error(r303) goto L346 (error at <module>:86) else goto L139
L139:
    r304 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r304) goto L347 else goto L142
L140:
    r305 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r305 goto L332 (error at <module>:87) else goto L141 :: bool
L141:
    unreachable
L142:
    r306 = 'infura'
    r307 = CPyObject_GetAttr(r304, r306)
    if is_error(r307) goto L348 (error at <module>:87) else goto L143
L143:
    r308 = PyObject_Not(r307)
    dec_ref r307
    r309 = r308 >= 0 :: signed
    if not r309 goto L348 (error at <module>:87) else goto L144 :: bool
L144:
    r310 = truncate r308: i32 to builtins.bool
    r311 = dank_mids._envs.create_env :: static
    if is_error(r311) goto L349 else goto L147
L145:
    r312 = raise NameError('value for final name "create_env" was not set')
    if not r312 goto L332 (error at <module>:83) else goto L146 :: bool
L146:
    unreachable
L147:
    r313 = box(bool, r310)
    r314 = [r294, r297, r303, r313]
    r315 = load_address r314
    r316 = ('default', 'verbose')
    r317 = PyObject_Vectorcall(r311, r315, 2, r316)
    if is_error(r317) goto L348 (error at <module>:83) else goto L148
L148:
    dec_ref r297
    dec_ref r303
    dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_ENCODER_SEMAPHORE = r317 :: static
    r318 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r319 = 'BROWNIE_ENCODER_SEMAPHORE'
    r320 = CPyDict_SetItem(r318, r319, r317)
    dec_ref r317
    r321 = r320 >= 0 :: signed
    if not r321 goto L332 (error at <module>:83) else goto L149 :: bool
L149:
    r322 = 'BROWNIE_ENCODER_PROCESSES'
    r323 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r324 = 'AsyncProcessPoolExecutor'
    r325 = CPyDict_GetItem(r323, r324)
    if is_error(r325) goto L332 (error at <module>:101) else goto L150
L150:
    r326 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r326) goto L350 else goto L153
L151:
    r327 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r327 goto L332 (error at <module>:102) else goto L152 :: bool
L152:
    unreachable
L153:
    r328 = 'infura'
    r329 = CPyObject_GetAttr(r326, r328)
    if is_error(r329) goto L351 (error at <module>:102) else goto L154
L154:
    r330 = PyObject_IsTrue(r329)
    dec_ref r329
    r331 = r330 >= 0 :: signed
    if not r331 goto L351 (error at <module>:102) else goto L155 :: bool
L155:
    r332 = truncate r330: i32 to builtins.bool
    if r332 goto L156 else goto L157 :: bool
L156:
    r333 = 0
    goto L158
L157:
    r333 = 2
L158:
    r334 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r334) goto L352 else goto L161
L159:
    r335 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r335 goto L332 (error at <module>:103) else goto L160 :: bool
L160:
    unreachable
L161:
    r336 = 'infura'
    r337 = CPyObject_GetAttr(r334, r336)
    if is_error(r337) goto L353 (error at <module>:103) else goto L162
L162:
    r338 = PyObject_Not(r337)
    dec_ref r337
    r339 = r338 >= 0 :: signed
    if not r339 goto L353 (error at <module>:103) else goto L163 :: bool
L163:
    r340 = truncate r338: i32 to builtins.bool
    r341 = dank_mids._envs.create_env :: static
    if is_error(r341) goto L354 else goto L166
L164:
    r342 = raise NameError('value for final name "create_env" was not set')
    if not r342 goto L332 (error at <module>:99) else goto L165 :: bool
L165:
    unreachable
L166:
    r343 = box(int, r333)
    r344 = box(bool, r340)
    r345 = [r322, r325, r343, r344]
    r346 = load_address r345
    r347 = ('default', 'verbose')
    r348 = PyObject_Vectorcall(r341, r346, 2, r347)
    if is_error(r348) goto L355 (error at <module>:99) else goto L167
L167:
    dec_ref r325
    dec_ref r343
    r349 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r350 = 'BROWNIE_ENCODER_PROCESSES'
    r351 = CPyDict_SetItem(r349, r350, r348)
    dec_ref r348
    r352 = r351 >= 0 :: signed
    if not r352 goto L332 (error at <module>:99) else goto L168 :: bool
L168:
    r353 = 'BROWNIE_DECODER_PROCESSES'
    r354 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r355 = 'AsyncProcessPoolExecutor'
    r356 = CPyDict_GetItem(r354, r355)
    if is_error(r356) goto L332 (error at <module>:114) else goto L169
L169:
    r357 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r357) goto L356 else goto L172
L170:
    r358 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r358 goto L332 (error at <module>:115) else goto L171 :: bool
L171:
    unreachable
L172:
    r359 = 'infura'
    r360 = CPyObject_GetAttr(r357, r359)
    if is_error(r360) goto L357 (error at <module>:115) else goto L173
L173:
    r361 = PyObject_IsTrue(r360)
    dec_ref r360
    r362 = r361 >= 0 :: signed
    if not r362 goto L357 (error at <module>:115) else goto L174 :: bool
L174:
    r363 = truncate r361: i32 to builtins.bool
    if r363 goto L175 else goto L176 :: bool
L175:
    r364 = 0
    goto L177
L176:
    r364 = 2
L177:
    r365 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r365) goto L358 else goto L180
L178:
    r366 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r366 goto L332 (error at <module>:116) else goto L179 :: bool
L179:
    unreachable
L180:
    r367 = 'infura'
    r368 = CPyObject_GetAttr(r365, r367)
    if is_error(r368) goto L359 (error at <module>:116) else goto L181
L181:
    r369 = PyObject_Not(r368)
    dec_ref r368
    r370 = r369 >= 0 :: signed
    if not r370 goto L359 (error at <module>:116) else goto L182 :: bool
L182:
    r371 = truncate r369: i32 to builtins.bool
    r372 = dank_mids._envs.create_env :: static
    if is_error(r372) goto L360 else goto L185
L183:
    r373 = raise NameError('value for final name "create_env" was not set')
    if not r373 goto L332 (error at <module>:112) else goto L184 :: bool
L184:
    unreachable
L185:
    r374 = box(int, r364)
    r375 = box(bool, r371)
    r376 = [r353, r356, r374, r375]
    r377 = load_address r376
    r378 = ('default', 'verbose')
    r379 = PyObject_Vectorcall(r372, r377, 2, r378)
    if is_error(r379) goto L361 (error at <module>:112) else goto L186
L186:
    dec_ref r356
    dec_ref r374
    r380 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r381 = 'BROWNIE_DECODER_PROCESSES'
    r382 = CPyDict_SetItem(r380, r381, r379)
    dec_ref r379
    r383 = r382 >= 0 :: signed
    if not r383 goto L332 (error at <module>:112) else goto L187 :: bool
L187:
    r384 = 'MULTICALL_DECODER_PROCESSES'
    r385 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r386 = 'AsyncProcessPoolExecutor'
    r387 = CPyDict_GetItem(r385, r386)
    if is_error(r387) goto L332 (error at <module>:127) else goto L188
L188:
    r388 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r388) goto L362 else goto L191
L189:
    r389 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r389 goto L332 (error at <module>:128) else goto L190 :: bool
L190:
    unreachable
L191:
    r390 = 'infura'
    r391 = CPyObject_GetAttr(r388, r390)
    if is_error(r391) goto L363 (error at <module>:128) else goto L192
L192:
    r392 = PyObject_IsTrue(r391)
    dec_ref r391
    r393 = r392 >= 0 :: signed
    if not r393 goto L363 (error at <module>:128) else goto L193 :: bool
L193:
    r394 = truncate r392: i32 to builtins.bool
    if r394 goto L194 else goto L195 :: bool
L194:
    r395 = 0
    goto L196
L195:
    r395 = 2
L196:
    r396 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r396) goto L364 else goto L199
L197:
    r397 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r397 goto L332 (error at <module>:129) else goto L198 :: bool
L198:
    unreachable
L199:
    r398 = 'infura'
    r399 = CPyObject_GetAttr(r396, r398)
    if is_error(r399) goto L365 (error at <module>:129) else goto L200
L200:
    r400 = PyObject_Not(r399)
    dec_ref r399
    r401 = r400 >= 0 :: signed
    if not r401 goto L365 (error at <module>:129) else goto L201 :: bool
L201:
    r402 = truncate r400: i32 to builtins.bool
    r403 = dank_mids._envs.create_env :: static
    if is_error(r403) goto L366 else goto L204
L202:
    r404 = raise NameError('value for final name "create_env" was not set')
    if not r404 goto L332 (error at <module>:125) else goto L203 :: bool
L203:
    unreachable
L204:
    r405 = box(int, r395)
    r406 = box(bool, r402)
    r407 = [r384, r387, r405, r406]
    r408 = load_address r407
    r409 = ('default', 'verbose')
    r410 = PyObject_Vectorcall(r403, r408, 2, r409)
    if is_error(r410) goto L367 (error at <module>:125) else goto L205
L205:
    dec_ref r387
    dec_ref r405
    r411 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r412 = 'MULTICALL_DECODER_PROCESSES'
    r413 = CPyDict_SetItem(r411, r412, r410)
    dec_ref r410
    r414 = r413 >= 0 :: signed
    if not r414 goto L332 (error at <module>:125) else goto L206 :: bool
L206:
    r415 = 'COLLECTION_FACTOR'
    r416 = load_address PyLong_Type
    r417 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r417) goto L207 else goto L209
L207:
    r418 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r418 goto L332 (error at <module>:141) else goto L208 :: bool
L208:
    unreachable
L209:
    r419 = 'infura'
    r420 = CPyObject_GetAttr(r417, r419)
    if is_error(r420) goto L332 (error at <module>:141) else goto L210
L210:
    r421 = PyObject_IsTrue(r420)
    dec_ref r420
    r422 = r421 >= 0 :: signed
    if not r422 goto L332 (error at <module>:141) else goto L211 :: bool
L211:
    r423 = truncate r421: i32 to builtins.bool
    if r423 goto L212 else goto L213 :: bool
L212:
    r424 = 20
    goto L214
L213:
    r424 = 2
L214:
    r425 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r425) goto L368 else goto L217
L215:
    r426 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r426 goto L332 (error at <module>:142) else goto L216 :: bool
L216:
    unreachable
L217:
    r427 = 'infura'
    r428 = CPyObject_GetAttr(r425, r427)
    if is_error(r428) goto L369 (error at <module>:142) else goto L218
L218:
    r429 = PyObject_Not(r428)
    dec_ref r428
    r430 = r429 >= 0 :: signed
    if not r430 goto L369 (error at <module>:142) else goto L219 :: bool
L219:
    r431 = truncate r429: i32 to builtins.bool
    r432 = dank_mids._envs.create_env :: static
    if is_error(r432) goto L370 else goto L222
L220:
    r433 = raise NameError('value for final name "create_env" was not set')
    if not r433 goto L332 (error at <module>:138) else goto L221 :: bool
L221:
    unreachable
L222:
    r434 = box(int, r424)
    r435 = box(bool, r431)
    r436 = [r415, r416, r434, r435]
    r437 = load_address r436
    r438 = ('default', 'verbose')
    r439 = PyObject_Vectorcall(r432, r437, 2, r438)
    if is_error(r439) goto L371 (error at <module>:138) else goto L223
L223:
    dec_ref r434
    dank_mids.ENVIRONMENT_VARIABLES.COLLECTION_FACTOR = r439 :: static
    r440 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r441 = 'COLLECTION_FACTOR'
    r442 = CPyDict_SetItem(r440, r441, r439)
    dec_ref r439
    r443 = r442 >= 0 :: signed
    if not r443 goto L332 (error at <module>:138) else goto L224 :: bool
L224:
    r444 = 'USE_FULL_REQUEST'
    r445 = load_address PyBool_Type
    r446 = dank_mids._envs.create_env :: static
    if is_error(r446) goto L225 else goto L227
L225:
    r447 = raise NameError('value for final name "create_env" was not set')
    if not r447 goto L332 (error at <module>:148) else goto L226 :: bool
L226:
    unreachable
L227:
    r448 = box(bool, 0)
    r449 = box(bool, 0)
    r450 = [r444, r445, r448, r449]
    r451 = load_address r450
    r452 = ('default', 'verbose')
    r453 = PyObject_Vectorcall(r446, r451, 2, r452)
    if is_error(r453) goto L332 (error at <module>:148) else goto L228
L228:
    dank_mids.ENVIRONMENT_VARIABLES.USE_FULL_REQUEST = r453 :: static
    r454 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r455 = 'USE_FULL_REQUEST'
    r456 = CPyDict_SetItem(r454, r455, r453)
    dec_ref r453
    r457 = r456 >= 0 :: signed
    if not r457 goto L332 (error at <module>:148) else goto L229 :: bool
L229:
    r458 = 'DEBUG'
    r459 = load_address PyBool_Type
    r460 = dank_mids._envs.create_env :: static
    if is_error(r460) goto L230 else goto L232
L230:
    r461 = raise NameError('value for final name "create_env" was not set')
    if not r461 goto L332 (error at <module>:151) else goto L231 :: bool
L231:
    unreachable
L232:
    r462 = box(bool, 0)
    r463 = box(bool, 0)
    r464 = [r458, r459, r462, r463]
    r465 = load_address r464
    r466 = ('default', 'verbose')
    r467 = PyObject_Vectorcall(r460, r465, 2, r466)
    if is_error(r467) goto L332 (error at <module>:151) else goto L233
L233:
    dank_mids.ENVIRONMENT_VARIABLES.DEBUG = r467 :: static
    r468 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r469 = 'DEBUG'
    r470 = CPyDict_SetItem(r468, r469, r467)
    dec_ref r467
    r471 = r470 >= 0 :: signed
    if not r471 goto L332 (error at <module>:151) else goto L234 :: bool
L234:
    r472 = 'EXPORT_STATS'
    r473 = load_address PyBool_Type
    r474 = dank_mids._envs.create_env :: static
    if is_error(r474) goto L235 else goto L237
L235:
    r475 = raise NameError('value for final name "create_env" was not set')
    if not r475 goto L332 (error at <module>:154) else goto L236 :: bool
L236:
    unreachable
L237:
    r476 = box(bool, 0)
    r477 = box(bool, 0)
    r478 = [r472, r473, r476, r477]
    r479 = load_address r478
    r480 = ('default', 'verbose')
    r481 = PyObject_Vectorcall(r474, r479, 2, r480)
    if is_error(r481) goto L332 (error at <module>:154) else goto L238
L238:
    dank_mids.ENVIRONMENT_VARIABLES.EXPORT_STATS = r481 :: static
    r482 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r483 = 'EXPORT_STATS'
    r484 = CPyDict_SetItem(r482, r483, r481)
    dec_ref r481
    r485 = r484 >= 0 :: signed
    if not r485 goto L332 (error at <module>:154) else goto L239 :: bool
L239:
    r486 = 'COLLECT_STATS'
    r487 = load_address PyBool_Type
    r488 = dank_mids.ENVIRONMENT_VARIABLES.EXPORT_STATS :: static
    if is_error(r488) goto L240 else goto L242
L240:
    r489 = raise NameError('value for final name "EXPORT_STATS" was not set')
    if not r489 goto L332 (error at <module>:157) else goto L241 :: bool
L241:
    unreachable
L242:
    r490 = dank_mids.ENVIRONMENT_VARIABLES.EXPORT_STATS :: static
    if is_error(r490) goto L243 else goto L245
L243:
    r491 = raise NameError('value for final name "EXPORT_STATS" was not set')
    if not r491 goto L332 (error at <module>:157) else goto L244 :: bool
L244:
    unreachable
L245:
    r492 = PyObject_Not(r490)
    r493 = r492 >= 0 :: signed
    if not r493 goto L332 (error at <module>:157) else goto L246 :: bool
L246:
    r494 = truncate r492: i32 to builtins.bool
    r495 = dank_mids._envs.create_env :: static
    if is_error(r495) goto L247 else goto L249
L247:
    r496 = raise NameError('value for final name "create_env" was not set')
    if not r496 goto L332 (error at <module>:156) else goto L248 :: bool
L248:
    unreachable
L249:
    r497 = box(bool, r494)
    r498 = [r486, r487, r488, r497]
    r499 = load_address r498
    r500 = ('default', 'verbose')
    r501 = PyObject_Vectorcall(r495, r499, 2, r500)
    if is_error(r501) goto L332 (error at <module>:156) else goto L250
L250:
    dank_mids.ENVIRONMENT_VARIABLES.COLLECT_STATS = r501 :: static
    r502 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r503 = 'COLLECT_STATS'
    r504 = CPyDict_SetItem(r502, r503, r501)
    dec_ref r501
    r505 = r504 >= 0 :: signed
    if not r505 goto L332 (error at <module>:156) else goto L251 :: bool
L251:
    r506 = 'STUCK_CALL_TIMEOUT'
    r507 = load_address PyLong_Type
    r508 = dank_mids._envs.create_env :: static
    if is_error(r508) goto L252 else goto L254
L252:
    r509 = raise NameError('value for final name "create_env" was not set')
    if not r509 goto L332 (error at <module>:161) else goto L253 :: bool
L253:
    unreachable
L254:
    r510 = object 120
    r511 = [r506, r507, r510]
    r512 = load_address r511
    r513 = ('default',)
    r514 = PyObject_Vectorcall(r508, r512, 2, r513)
    if is_error(r514) goto L332 (error at <module>:161) else goto L255
L255:
    dank_mids.ENVIRONMENT_VARIABLES.STUCK_CALL_TIMEOUT = r514 :: static
    r515 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r516 = 'STUCK_CALL_TIMEOUT'
    r517 = CPyDict_SetItem(r515, r516, r514)
    dec_ref r514
    r518 = r517 >= 0 :: signed
    if not r518 goto L332 (error at <module>:161) else goto L256 :: bool
L256:
    r519 = 'eth_call'
    r520 = 'ETH_CALL_SEMAPHORE'
    r521 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r522 = 'BlockSemaphore'
    r523 = CPyDict_GetItem(r521, r522)
    if is_error(r523) goto L332 (error at <module>:167) else goto L257
L257:
    r524 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE :: static
    if is_error(r524) goto L372 else goto L260
L258:
    r525 = raise NameError('value for final name "BROWNIE_CALL_SEMAPHORE" was not set')
    if not r525 goto L332 (error at <module>:168) else goto L259 :: bool
L259:
    unreachable
L260:
    r526 = '_value'
    r527 = CPyObject_GetAttr(r524, r526)
    if is_error(r527) goto L373 (error at <module>:168) else goto L261
L261:
    r528 = dank_mids._envs.create_env :: static
    if is_error(r528) goto L374 else goto L264
L262:
    r529 = raise NameError('value for final name "create_env" was not set')
    if not r529 goto L332 (error at <module>:165) else goto L263 :: bool
L263:
    unreachable
L264:
    r530 = box(bool, 0)
    r531 = [r520, r523, r527, r530]
    r532 = load_address r531
    r533 = ('default', 'verbose')
    r534 = PyObject_Vectorcall(r528, r532, 2, r533)
    if is_error(r534) goto L375 (error at <module>:165) else goto L265
L265:
    dec_ref r523
    dec_ref r527
    r535 = 'eth_getBlock'
    r536 = 'ETH_GETBLOCK_SEMAPHORE'
    r537 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r538 = 'a_sync'
    r539 = CPyDict_GetItem(r537, r538)
    if is_error(r539) goto L376 (error at <module>:173) else goto L266
L266:
    r540 = 'Semaphore'
    r541 = CPyObject_GetAttr(r539, r540)
    dec_ref r539
    if is_error(r541) goto L376 (error at <module>:173) else goto L267
L267:
    r542 = dank_mids._envs.create_env :: static
    if is_error(r542) goto L377 else goto L270
L268:
    r543 = raise NameError('value for final name "create_env" was not set')
    if not r543 goto L332 (error at <module>:171) else goto L269 :: bool
L269:
    unreachable
L270:
    r544 = object 1000
    r545 = box(bool, 0)
    r546 = [r536, r541, r544, r545]
    r547 = load_address r546
    r548 = ('default', 'verbose')
    r549 = PyObject_Vectorcall(r542, r547, 2, r548)
    if is_error(r549) goto L378 (error at <module>:171) else goto L271
L271:
    dec_ref r541
    r550 = 'eth_getCode'
    r551 = 'ETH_GETCODE_SEMAPHORE'
    r552 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r553 = 'a_sync'
    r554 = CPyDict_GetItem(r552, r553)
    if is_error(r554) goto L379 (error at <module>:179) else goto L272
L272:
    r555 = 'Semaphore'
    r556 = CPyObject_GetAttr(r554, r555)
    dec_ref r554
    if is_error(r556) goto L379 (error at <module>:179) else goto L273
L273:
    r557 = dank_mids._envs.create_env :: static
    if is_error(r557) goto L380 else goto L276
L274:
    r558 = raise NameError('value for final name "create_env" was not set')
    if not r558 goto L332 (error at <module>:177) else goto L275 :: bool
L275:
    unreachable
L276:
    r559 = object 5000
    r560 = box(bool, 0)
    r561 = [r551, r556, r559, r560]
    r562 = load_address r561
    r563 = ('default', 'verbose')
    r564 = PyObject_Vectorcall(r557, r562, 2, r563)
    if is_error(r564) goto L381 (error at <module>:177) else goto L277
L277:
    dec_ref r556
    r565 = CPyDict_Build(3, r519, r534, r535, r549, r550, r564)
    dec_ref r534
    dec_ref r549
    dec_ref r564
    if is_error(r565) goto L332 (error at <module>:164) else goto L278
L278:
    dank_mids.ENVIRONMENT_VARIABLES.method_semaphores = r565 :: static
    r566 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r567 = 'method_semaphores'
    r568 = CPyDict_SetItem(r566, r567, r565)
    dec_ref r565
    r569 = r568 >= 0 :: signed
    if not r569 goto L332 (error at <module>:164) else goto L279 :: bool
L279:
    r570 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r571 = 'typed_envs'
    r572 = CPyDict_GetItem(r570, r571)
    if is_error(r572) goto L332 (error at <module>:185) else goto L280
L280:
    r573 = 'logger'
    r574 = CPyObject_GetAttr(r572, r573)
    dec_ref r572
    if is_error(r574) goto L332 (error at <module>:185) else goto L281
L281:
    r575 = 'disabled'
    r576 = CPyObject_GetAttr(r574, r575)
    dec_ref r574
    if is_error(r576) goto L332 (error at <module>:185) else goto L282
L282:
    r577 = PyObject_IsTrue(r576)
    dec_ref r576
    r578 = r577 >= 0 :: signed
    if not r578 goto L332 (error at <module>:185) else goto L283 :: bool
L283:
    r579 = truncate r577: i32 to builtins.bool
    if r579 goto L292 else goto L284 :: bool
L284:
    r580 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r580) goto L285 else goto L287
L285:
    r581 = raise NameError('value for final name "logger" was not set')
    if not r581 goto L332 (error at <module>:186) else goto L286 :: bool
L286:
    unreachable
L287:
    r582 = 'More details can be found in dank_mids/ENVIRONMENT_VARIABLES.py'
    r583 = 'info'
    r584 = [r580, r582]
    r585 = load_address r584
    r586 = PyObject_VectorcallMethod(r583, r585, 9223372036854775810, 0)
    if is_error(r586) goto L332 (error at <module>:186) else goto L382
L288:
    r587 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r587) goto L289 else goto L291
L289:
    r588 = raise NameError('value for final name "logger" was not set')
    if not r588 goto L332 (error at <module>:187) else goto L290 :: bool
L290:
    unreachable
L291:
    r589 = 'NOTE: You can disable these logs by setting the `TYPEDENVS_SHUTUP` env var to any value.'
    r590 = 'info'
    r591 = [r587, r589]
    r592 = load_address r591
    r593 = PyObject_VectorcallMethod(r590, r592, 9223372036854775810, 0)
    if is_error(r593) goto L332 (error at <module>:187) else goto L383
L292:
    r594 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r594) goto L293 else goto L295
L293:
    r595 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r595 goto L332 (error at <module>:195) else goto L294 :: bool
L294:
    unreachable
L295:
    r596 = 'infura'
    r597 = CPyObject_GetAttr(r594, r596)
    if is_error(r597) goto L332 (error at <module>:195) else goto L296
L296:
    r598 = PyObject_IsTrue(r597)
    dec_ref r597
    r599 = r598 >= 0 :: signed
    if not r599 goto L332 (error at <module>:195) else goto L297 :: bool
L297:
    r600 = truncate r598: i32 to builtins.bool
    if r600 goto L302 else goto L298 :: bool
L298:
    r601 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r601) goto L299 else goto L301
L299:
    r602 = raise NameError('value for final name "logger" was not set')
    if not r602 goto L332 (error at <module>:196) else goto L300 :: bool
L300:
    unreachable
L301:
    r603 = "Unless you know what you're doing, dank mids should be run in infura mode for now"
    r604 = 'warning'
    r605 = [r601, r603]
    r606 = load_address r605
    r607 = PyObject_VectorcallMethod(r604, r606, 9223372036854775810, 0)
    if is_error(r607) goto L332 (error at <module>:196) else goto L384
L302:
    r608 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r608) goto L303 else goto L305
L303:
    r609 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r609 goto L332 (error at <module>:200) else goto L304 :: bool
L304:
    unreachable
L305:
    r610 = 'infura'
    r611 = CPyObject_GetAttr(r608, r610)
    if is_error(r611) goto L332 (error at <module>:200) else goto L306
L306:
    r612 = PyObject_IsTrue(r611)
    dec_ref r611
    r613 = r612 >= 0 :: signed
    if not r613 goto L332 (error at <module>:200) else goto L307 :: bool
L307:
    r614 = truncate r612: i32 to builtins.bool
    if r614 goto L308 else goto L331 :: bool
L308:
    r615 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r616 = 'MULTICALL_DECODER_PROCESSES'
    r617 = CPyDict_GetItem(r615, r616)
    if is_error(r617) goto L332 (error at <module>:202) else goto L309
L309:
    r618 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r619 = 'BROWNIE_DECODER_PROCESSES'
    r620 = CPyDict_GetItem(r618, r619)
    if is_error(r620) goto L385 (error at <module>:203) else goto L310
L310:
    r621 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r622 = 'BROWNIE_ENCODER_PROCESSES'
    r623 = CPyDict_GetItem(r621, r622)
    if is_error(r623) goto L386 (error at <module>:204) else goto L311
L311:
    r624 = PySet_New(0)
    if is_error(r624) goto L387 (error at <module>:201) else goto L312
L312:
    r625 = PySet_Add(r624, r617)
    dec_ref r617
    r626 = r625 >= 0 :: signed
    if not r626 goto L388 (error at <module>:201) else goto L313 :: bool
L313:
    r627 = PySet_Add(r624, r620)
    dec_ref r620
    r628 = r627 >= 0 :: signed
    if not r628 goto L389 (error at <module>:201) else goto L314 :: bool
L314:
    r629 = PySet_Add(r624, r623)
    dec_ref r623
    r630 = r629 >= 0 :: signed
    if not r630 goto L390 (error at <module>:201) else goto L315 :: bool
L315:
    r631 = PyObject_GetIter(r624)
    dec_ref r624
    if is_error(r631) goto L332 (error at <module>:201) else goto L316
L316:
    r632 = PyIter_Next(r631)
    if is_error(r632) goto L391 else goto L317
L317:
    r633 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r634 = 'process_pool'
    r635 = CPyDict_SetItem(r633, r634, r632)
    dec_ref r632
    r636 = r635 >= 0 :: signed
    if not r636 goto L392 (error at <module>:201) else goto L318 :: bool
L318:
    r637 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r638 = 'process_pool'
    r639 = CPyDict_GetItem(r637, r638)
    if is_error(r639) goto L392 (error at <module>:206) else goto L319
L319:
    r640 = '_max_workers'
    r641 = CPyObject_GetAttr(r639, r640)
    dec_ref r639
    if is_error(r641) goto L392 (error at <module>:206) else goto L320
L320:
    r642 = PyObject_IsTrue(r641)
    dec_ref r641
    r643 = r642 >= 0 :: signed
    if not r643 goto L392 (error at <module>:206) else goto L321 :: bool
L321:
    r644 = truncate r642: i32 to builtins.bool
    if r644 goto L393 else goto L316 :: bool
L322:
    r645 = 'You cannot set env var '
    r646 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r647 = 'process_pool'
    r648 = CPyDict_GetItem(r646, r647)
    if is_error(r648) goto L332 (error at <module>:208) else goto L323
L323:
    r649 = 'name'
    r650 = CPyObject_GetAttr(r648, r649)
    dec_ref r648
    if is_error(r650) goto L332 (error at <module>:208) else goto L324
L324:
    r651 = PyObject_Str(r650)
    dec_ref r650
    if is_error(r651) goto L332 (error at <module>:208) else goto L325
L325:
    r652 = ' while running dank in infura mode.'
    r653 = CPyStr_Build(3, r645, r651, r652)
    dec_ref r651
    if is_error(r653) goto L332 (error at <module>:208) else goto L326
L326:
    r654 = builtins :: module
    r655 = 'ValueError'
    r656 = CPyObject_GetAttr(r654, r655)
    if is_error(r656) goto L394 (error at <module>:207) else goto L327
L327:
    r657 = [r653]
    r658 = load_address r657
    r659 = PyObject_Vectorcall(r656, r658, 1, 0)
    dec_ref r656
    if is_error(r659) goto L394 (error at <module>:207) else goto L328
L328:
    dec_ref r653
    CPy_Raise(r659)
    dec_ref r659
    if not 0 goto L332 (error at <module>:207) else goto L329 :: bool
L329:
    unreachable
L330:
    r660 = CPy_NoErrOccurred()
    if not r660 goto L332 (error at <module>:201) else goto L331 :: bool
L331:
    return 1
L332:
    r661 = <error> :: None
    return r661
L333:
    dec_ref r76
    goto L332
L334:
    dec_ref r80
    goto L33
L335:
    dec_ref r86
    goto L332
L336:
    dec_ref r96
    goto L332
L337:
    dec_ref r99
    goto L50
L338:
    dec_ref r106
    goto L55
L339:
    dec_ref r110
    goto L57
L340:
    dec_ref r110
    goto L332
L341:
    dec_ref r273
    goto L121
L342:
    dec_ref r273
    goto L124
L343:
    dec_ref r273
    goto L332
L344:
    dec_ref r273
    goto L129
L345:
    dec_ref r297
    goto L135
L346:
    dec_ref r297
    goto L332
L347:
    dec_ref r297
    dec_ref r303
    goto L140
L348:
    dec_ref r297
    dec_ref r303
    goto L332
L349:
    dec_ref r297
    dec_ref r303
    goto L145
L350:
    dec_ref r325
    goto L151
L351:
    dec_ref r325
    goto L332
L352:
    dec_ref r325
    dec_ref r333 :: int
    goto L159
L353:
    dec_ref r325
    dec_ref r333 :: int
    goto L332
L354:
    dec_ref r325
    dec_ref r333 :: int
    goto L164
L355:
    dec_ref r325
    dec_ref r343
    goto L332
L356:
    dec_ref r356
    goto L170
L357:
    dec_ref r356
    goto L332
L358:
    dec_ref r356
    dec_ref r364 :: int
    goto L178
L359:
    dec_ref r356
    dec_ref r364 :: int
    goto L332
L360:
    dec_ref r356
    dec_ref r364 :: int
    goto L183
L361:
    dec_ref r356
    dec_ref r374
    goto L332
L362:
    dec_ref r387
    goto L189
L363:
    dec_ref r387
    goto L332
L364:
    dec_ref r387
    dec_ref r395 :: int
    goto L197
L365:
    dec_ref r387
    dec_ref r395 :: int
    goto L332
L366:
    dec_ref r387
    dec_ref r395 :: int
    goto L202
L367:
    dec_ref r387
    dec_ref r405
    goto L332
L368:
    dec_ref r424 :: int
    goto L215
L369:
    dec_ref r424 :: int
    goto L332
L370:
    dec_ref r424 :: int
    goto L220
L371:
    dec_ref r434
    goto L332
L372:
    dec_ref r523
    goto L258
L373:
    dec_ref r523
    goto L332
L374:
    dec_ref r523
    dec_ref r527
    goto L262
L375:
    dec_ref r523
    dec_ref r527
    goto L332
L376:
    dec_ref r534
    goto L332
L377:
    dec_ref r534
    dec_ref r541
    goto L268
L378:
    dec_ref r534
    dec_ref r541
    goto L332
L379:
    dec_ref r534
    dec_ref r549
    goto L332
L380:
    dec_ref r534
    dec_ref r549
    dec_ref r556
    goto L274
L381:
    dec_ref r534
    dec_ref r549
    dec_ref r556
    goto L332
L382:
    dec_ref r586
    goto L288
L383:
    dec_ref r593
    goto L292
L384:
    dec_ref r607
    goto L302
L385:
    dec_ref r617
    goto L332
L386:
    dec_ref r617
    dec_ref r620
    goto L332
L387:
    dec_ref r617
    dec_ref r620
    dec_ref r623
    goto L332
L388:
    dec_ref r620
    dec_ref r623
    dec_ref r624
    goto L332
L389:
    dec_ref r623
    dec_ref r624
    goto L332
L390:
    dec_ref r624
    goto L332
L391:
    dec_ref r631
    goto L330
L392:
    dec_ref r631
    goto L332
L393:
    dec_ref r631
    goto L322
L394:
    dec_ref r653
    goto L332

def patch_eth_utils():
    r0 :: dict
    r1, r2 :: object
    r3 :: bit
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: str
    r9 :: object
    r10 :: i32
    r11 :: bit
    r12 :: dict
    r13 :: str
    r14 :: object
    r15 :: dict
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: str
    r21 :: i32
    r22 :: bit
    r23 :: dict
    r24, r25 :: object
    r26 :: bit
    r27 :: str
    r28 :: object
    r29 :: str
    r30 :: dict
    r31 :: str
    r32 :: object
    r33 :: i32
    r34 :: bit
    r35 :: dict
    r36 :: str
    r37 :: object
    r38 :: dict
    r39 :: str
    r40 :: object
    r41 :: str
    r42 :: object
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: dict
    r47 :: str
    r48 :: object
    r49 :: dict
    r50 :: str
    r51 :: object
    r52 :: str
    r53 :: object
    r54 :: str
    r55 :: i32
    r56 :: bit
    r57 :: dict
    r58, r59 :: object
    r60 :: bit
    r61 :: str
    r62 :: object
    r63 :: str
    r64 :: dict
    r65 :: str
    r66 :: object
    r67 :: i32
    r68 :: bit
    r69 :: dict
    r70 :: str
    r71 :: object
    r72 :: dict
    r73 :: str
    r74 :: object
    r75 :: str
    r76 :: object
    r77 :: str
    r78 :: object
    r79 :: str
    r80 :: i32
    r81 :: bit
    r82 :: dict
    r83, r84 :: object
    r85 :: bit
    r86 :: str
    r87 :: object
    r88 :: str
    r89 :: dict
    r90 :: str
    r91 :: object
    r92 :: i32
    r93 :: bit
    r94 :: dict
    r95 :: str
    r96 :: object
    r97 :: dict
    r98 :: str
    r99 :: object
    r100 :: str
    r101 :: object
    r102 :: str
    r103 :: object
    r104 :: str
    r105 :: i32
    r106 :: bit
    r107 :: dict
    r108, r109 :: object
    r110 :: bit
    r111 :: str
    r112 :: object
    r113 :: str
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: i32
    r118 :: bit
    r119 :: dict
    r120 :: str
    r121 :: object
    r122 :: dict
    r123 :: str
    r124 :: object
    r125 :: str
    r126 :: object
    r127 :: str
    r128 :: object
    r129 :: str
    r130 :: i32
    r131 :: bit
    r132 :: dict
    r133 :: str
    r134 :: object
    r135 :: dict
    r136 :: str
    r137 :: object
    r138 :: str
    r139 :: object
    r140 :: str
    r141 :: object
    r142 :: str
    r143 :: i32
    r144 :: bit
    r145 :: dict
    r146, r147 :: object
    r148 :: bit
    r149 :: str
    r150 :: object
    r151 :: str
    r152 :: dict
    r153 :: str
    r154 :: object
    r155 :: i32
    r156 :: bit
    r157 :: dict
    r158 :: str
    r159 :: object
    r160 :: dict
    r161 :: str
    r162 :: object
    r163 :: str
    r164 :: object
    r165 :: str
    r166 :: object
    r167 :: str
    r168 :: i32
    r169 :: bit
    r170 :: dict
    r171 :: str
    r172 :: object
    r173 :: dict
    r174 :: str
    r175 :: object
    r176 :: str
    r177 :: object
    r178 :: str
    r179 :: object
    r180 :: str
    r181 :: i32
    r182 :: bit
    r183 :: dict
    r184, r185 :: object
    r186 :: bit
    r187 :: str
    r188 :: object
    r189 :: str
    r190 :: dict
    r191 :: str
    r192 :: object
    r193 :: i32
    r194 :: bit
    r195 :: dict
    r196 :: str
    r197 :: object
    r198 :: dict
    r199 :: str
    r200 :: object
    r201 :: str
    r202 :: object
    r203 :: str
    r204 :: object
    r205 :: str
    r206 :: i32
    r207 :: bit
    r208 :: dict
    r209 :: str
    r210 :: object
    r211 :: dict
    r212 :: str
    r213 :: object
    r214 :: str
    r215 :: object
    r216 :: str
    r217 :: object
    r218 :: str
    r219 :: i32
    r220 :: bit
    r221 :: dict
    r222, r223 :: object
    r224 :: bit
    r225 :: str
    r226 :: object
    r227 :: str
    r228 :: dict
    r229 :: str
    r230 :: object
    r231 :: i32
    r232 :: bit
    r233 :: tuple[object, object, object]
    r234 :: object
    r235 :: str
    r236 :: object
    r237, r238 :: bit
    r239 :: dict
    r240 :: str
    r241 :: object
    r242 :: dict
    r243 :: str
    r244 :: object
    r245 :: str
    r246 :: object
    r247 :: str
    r248 :: object
    r249 :: str
    r250 :: i32
    r251 :: bit
    r252 :: dict
    r253 :: str
    r254 :: object
    r255 :: dict
    r256 :: str
    r257 :: object
    r258 :: str
    r259 :: object
    r260 :: str
    r261 :: object
    r262 :: str
    r263 :: i32
    r264 :: bit
    r265 :: None
L0:
    r0 = dank_mids._eth_utils.globals :: static
    r1 = eth_utils.crypto :: module
    r2 = load_address _Py_NoneStruct
    r3 = r1 != r2
    if r3 goto L3 else goto L1 :: bool
L1:
    r4 = 'eth_utils.crypto'
    r5 = PyImport_Import(r4)
    if is_error(r5) goto L110 (error at patch_eth_utils:25) else goto L2
L2:
    eth_utils.crypto = r5 :: module
    dec_ref r5
L3:
    r6 = 'eth_utils'
    r7 = PyImport_GetModuleDict()
    r8 = 'eth_utils'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L110 (error at patch_eth_utils:25) else goto L4
L4:
    r10 = CPyDict_SetItem(r0, r6, r9)
    dec_ref r9
    r11 = r10 >= 0 :: signed
    if not r11 goto L110 (error at patch_eth_utils:25) else goto L5 :: bool
L5:
    r12 = dank_mids._eth_utils.globals :: static
    r13 = 'to_bytes'
    r14 = CPyDict_GetItem(r12, r13)
    if is_error(r14) goto L110 (error at patch_eth_utils:27) else goto L6
L6:
    r15 = dank_mids._eth_utils.globals :: static
    r16 = 'eth_utils'
    r17 = CPyDict_GetItem(r15, r16)
    if is_error(r17) goto L111 (error at patch_eth_utils:27) else goto L7
L7:
    r18 = 'crypto'
    r19 = CPyObject_GetAttr(r17, r18)
    dec_ref r17
    if is_error(r19) goto L111 (error at patch_eth_utils:27) else goto L8
L8:
    r20 = 'to_bytes'
    r21 = PyObject_SetAttr(r19, r20, r14)
    dec_ref r19
    dec_ref r14
    r22 = r21 >= 0 :: signed
    if not r22 goto L110 (error at patch_eth_utils:27) else goto L9 :: bool
L9:
    r23 = dank_mids._eth_utils.globals :: static
    r24 = web3.main :: module
    r25 = load_address _Py_NoneStruct
    r26 = r24 != r25
    if r26 goto L12 else goto L10 :: bool
L10:
    r27 = 'web3.main'
    r28 = PyImport_Import(r27)
    if is_error(r28) goto L110 (error at patch_eth_utils:29) else goto L11
L11:
    web3.main = r28 :: module
    dec_ref r28
L12:
    r29 = 'web3'
    r30 = PyImport_GetModuleDict()
    r31 = 'web3'
    r32 = CPyDict_GetItem(r30, r31)
    if is_error(r32) goto L110 (error at patch_eth_utils:29) else goto L13
L13:
    r33 = CPyDict_SetItem(r23, r29, r32)
    dec_ref r32
    r34 = r33 >= 0 :: signed
    if not r34 goto L110 (error at patch_eth_utils:29) else goto L14 :: bool
L14:
    r35 = dank_mids._eth_utils.globals :: static
    r36 = 'to_hex'
    r37 = CPyDict_GetItem(r35, r36)
    if is_error(r37) goto L110 (error at patch_eth_utils:31) else goto L15
L15:
    r38 = dank_mids._eth_utils.globals :: static
    r39 = 'web3'
    r40 = CPyDict_GetItem(r38, r39)
    if is_error(r40) goto L112 (error at patch_eth_utils:31) else goto L16
L16:
    r41 = 'main'
    r42 = CPyObject_GetAttr(r40, r41)
    dec_ref r40
    if is_error(r42) goto L112 (error at patch_eth_utils:31) else goto L17
L17:
    r43 = 'to_hex'
    r44 = PyObject_SetAttr(r42, r43, r37)
    dec_ref r42
    dec_ref r37
    r45 = r44 >= 0 :: signed
    if not r45 goto L110 (error at patch_eth_utils:31) else goto L18 :: bool
L18:
    r46 = dank_mids._eth_utils.globals :: static
    r47 = 'to_bytes'
    r48 = CPyDict_GetItem(r46, r47)
    if is_error(r48) goto L110 (error at patch_eth_utils:32) else goto L19
L19:
    r49 = dank_mids._eth_utils.globals :: static
    r50 = 'web3'
    r51 = CPyDict_GetItem(r49, r50)
    if is_error(r51) goto L113 (error at patch_eth_utils:32) else goto L20
L20:
    r52 = 'main'
    r53 = CPyObject_GetAttr(r51, r52)
    dec_ref r51
    if is_error(r53) goto L113 (error at patch_eth_utils:32) else goto L21
L21:
    r54 = 'to_bytes'
    r55 = PyObject_SetAttr(r53, r54, r48)
    dec_ref r53
    dec_ref r48
    r56 = r55 >= 0 :: signed
    if not r56 goto L110 (error at patch_eth_utils:32) else goto L22 :: bool
L22:
    r57 = dank_mids._eth_utils.globals :: static
    r58 = web3.middleware.filter :: module
    r59 = load_address _Py_NoneStruct
    r60 = r58 != r59
    if r60 goto L25 else goto L23 :: bool
L23:
    r61 = 'web3.middleware.filter'
    r62 = PyImport_Import(r61)
    if is_error(r62) goto L110 (error at patch_eth_utils:34) else goto L24
L24:
    web3.middleware.filter = r62 :: module
    dec_ref r62
L25:
    r63 = 'web3'
    r64 = PyImport_GetModuleDict()
    r65 = 'web3'
    r66 = CPyDict_GetItem(r64, r65)
    if is_error(r66) goto L110 (error at patch_eth_utils:34) else goto L26
L26:
    r67 = CPyDict_SetItem(r57, r63, r66)
    dec_ref r66
    r68 = r67 >= 0 :: signed
    if not r68 goto L110 (error at patch_eth_utils:34) else goto L27 :: bool
L27:
    r69 = dank_mids._eth_utils.globals :: static
    r70 = 'to_hex'
    r71 = CPyDict_GetItem(r69, r70)
    if is_error(r71) goto L110 (error at patch_eth_utils:36) else goto L28
L28:
    r72 = dank_mids._eth_utils.globals :: static
    r73 = 'web3'
    r74 = CPyDict_GetItem(r72, r73)
    if is_error(r74) goto L114 (error at patch_eth_utils:36) else goto L29
L29:
    r75 = 'middleware'
    r76 = CPyObject_GetAttr(r74, r75)
    dec_ref r74
    if is_error(r76) goto L114 (error at patch_eth_utils:36) else goto L30
L30:
    r77 = 'filter'
    r78 = CPyObject_GetAttr(r76, r77)
    dec_ref r76
    if is_error(r78) goto L114 (error at patch_eth_utils:36) else goto L31
L31:
    r79 = 'to_hex'
    r80 = PyObject_SetAttr(r78, r79, r71)
    dec_ref r78
    dec_ref r71
    r81 = r80 >= 0 :: signed
    if not r81 goto L110 (error at patch_eth_utils:36) else goto L32 :: bool
L32:
    r82 = dank_mids._eth_utils.globals :: static
    r83 = web3.providers.base :: module
    r84 = load_address _Py_NoneStruct
    r85 = r83 != r84
    if r85 goto L35 else goto L33 :: bool
L33:
    r86 = 'web3.providers.base'
    r87 = PyImport_Import(r86)
    if is_error(r87) goto L110 (error at patch_eth_utils:38) else goto L34
L34:
    web3.providers.base = r87 :: module
    dec_ref r87
L35:
    r88 = 'web3'
    r89 = PyImport_GetModuleDict()
    r90 = 'web3'
    r91 = CPyDict_GetItem(r89, r90)
    if is_error(r91) goto L110 (error at patch_eth_utils:38) else goto L36
L36:
    r92 = CPyDict_SetItem(r82, r88, r91)
    dec_ref r91
    r93 = r92 >= 0 :: signed
    if not r93 goto L110 (error at patch_eth_utils:38) else goto L37 :: bool
L37:
    r94 = dank_mids._eth_utils.globals :: static
    r95 = 'to_bytes'
    r96 = CPyDict_GetItem(r94, r95)
    if is_error(r96) goto L110 (error at patch_eth_utils:40) else goto L38
L38:
    r97 = dank_mids._eth_utils.globals :: static
    r98 = 'web3'
    r99 = CPyDict_GetItem(r97, r98)
    if is_error(r99) goto L115 (error at patch_eth_utils:40) else goto L39
L39:
    r100 = 'providers'
    r101 = CPyObject_GetAttr(r99, r100)
    dec_ref r99
    if is_error(r101) goto L115 (error at patch_eth_utils:40) else goto L40
L40:
    r102 = 'base'
    r103 = CPyObject_GetAttr(r101, r102)
    dec_ref r101
    if is_error(r103) goto L115 (error at patch_eth_utils:40) else goto L41
L41:
    r104 = 'to_bytes'
    r105 = PyObject_SetAttr(r103, r104, r96)
    dec_ref r103
    dec_ref r96
    r106 = r105 >= 0 :: signed
    if not r106 goto L110 (error at patch_eth_utils:40) else goto L42 :: bool
L42:
    r107 = dank_mids._eth_utils.globals :: static
    r108 = web3._utils.encoding :: module
    r109 = load_address _Py_NoneStruct
    r110 = r108 != r109
    if r110 goto L45 else goto L43 :: bool
L43:
    r111 = 'web3._utils.encoding'
    r112 = PyImport_Import(r111)
    if is_error(r112) goto L110 (error at patch_eth_utils:42) else goto L44
L44:
    web3._utils.encoding = r112 :: module
    dec_ref r112
L45:
    r113 = 'web3'
    r114 = PyImport_GetModuleDict()
    r115 = 'web3'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L110 (error at patch_eth_utils:42) else goto L46
L46:
    r117 = CPyDict_SetItem(r107, r113, r116)
    dec_ref r116
    r118 = r117 >= 0 :: signed
    if not r118 goto L110 (error at patch_eth_utils:42) else goto L47 :: bool
L47:
    r119 = dank_mids._eth_utils.globals :: static
    r120 = 'to_hex'
    r121 = CPyDict_GetItem(r119, r120)
    if is_error(r121) goto L110 (error at patch_eth_utils:44) else goto L48
L48:
    r122 = dank_mids._eth_utils.globals :: static
    r123 = 'web3'
    r124 = CPyDict_GetItem(r122, r123)
    if is_error(r124) goto L116 (error at patch_eth_utils:44) else goto L49
L49:
    r125 = '_utils'
    r126 = CPyObject_GetAttr(r124, r125)
    dec_ref r124
    if is_error(r126) goto L116 (error at patch_eth_utils:44) else goto L50
L50:
    r127 = 'encoding'
    r128 = CPyObject_GetAttr(r126, r127)
    dec_ref r126
    if is_error(r128) goto L116 (error at patch_eth_utils:44) else goto L51
L51:
    r129 = 'to_hex'
    r130 = PyObject_SetAttr(r128, r129, r121)
    dec_ref r128
    dec_ref r121
    r131 = r130 >= 0 :: signed
    if not r131 goto L110 (error at patch_eth_utils:44) else goto L52 :: bool
L52:
    r132 = dank_mids._eth_utils.globals :: static
    r133 = 'to_bytes'
    r134 = CPyDict_GetItem(r132, r133)
    if is_error(r134) goto L110 (error at patch_eth_utils:45) else goto L53
L53:
    r135 = dank_mids._eth_utils.globals :: static
    r136 = 'web3'
    r137 = CPyDict_GetItem(r135, r136)
    if is_error(r137) goto L117 (error at patch_eth_utils:45) else goto L54
L54:
    r138 = '_utils'
    r139 = CPyObject_GetAttr(r137, r138)
    dec_ref r137
    if is_error(r139) goto L117 (error at patch_eth_utils:45) else goto L55
L55:
    r140 = 'encoding'
    r141 = CPyObject_GetAttr(r139, r140)
    dec_ref r139
    if is_error(r141) goto L117 (error at patch_eth_utils:45) else goto L56
L56:
    r142 = 'to_bytes'
    r143 = PyObject_SetAttr(r141, r142, r134)
    dec_ref r141
    dec_ref r134
    r144 = r143 >= 0 :: signed
    if not r144 goto L110 (error at patch_eth_utils:45) else goto L57 :: bool
L57:
    r145 = dank_mids._eth_utils.globals :: static
    r146 = web3._utils.events :: module
    r147 = load_address _Py_NoneStruct
    r148 = r146 != r147
    if r148 goto L60 else goto L58 :: bool
L58:
    r149 = 'web3._utils.events'
    r150 = PyImport_Import(r149)
    if is_error(r150) goto L110 (error at patch_eth_utils:47) else goto L59
L59:
    web3._utils.events = r150 :: module
    dec_ref r150
L60:
    r151 = 'web3'
    r152 = PyImport_GetModuleDict()
    r153 = 'web3'
    r154 = CPyDict_GetItem(r152, r153)
    if is_error(r154) goto L110 (error at patch_eth_utils:47) else goto L61
L61:
    r155 = CPyDict_SetItem(r145, r151, r154)
    dec_ref r154
    r156 = r155 >= 0 :: signed
    if not r156 goto L110 (error at patch_eth_utils:47) else goto L62 :: bool
L62:
    r157 = dank_mids._eth_utils.globals :: static
    r158 = 'to_hex'
    r159 = CPyDict_GetItem(r157, r158)
    if is_error(r159) goto L110 (error at patch_eth_utils:49) else goto L63
L63:
    r160 = dank_mids._eth_utils.globals :: static
    r161 = 'web3'
    r162 = CPyDict_GetItem(r160, r161)
    if is_error(r162) goto L118 (error at patch_eth_utils:49) else goto L64
L64:
    r163 = '_utils'
    r164 = CPyObject_GetAttr(r162, r163)
    dec_ref r162
    if is_error(r164) goto L118 (error at patch_eth_utils:49) else goto L65
L65:
    r165 = 'events'
    r166 = CPyObject_GetAttr(r164, r165)
    dec_ref r164
    if is_error(r166) goto L118 (error at patch_eth_utils:49) else goto L66
L66:
    r167 = 'to_hex'
    r168 = PyObject_SetAttr(r166, r167, r159)
    dec_ref r166
    dec_ref r159
    r169 = r168 >= 0 :: signed
    if not r169 goto L110 (error at patch_eth_utils:49) else goto L67 :: bool
L67:
    r170 = dank_mids._eth_utils.globals :: static
    r171 = 'to_bytes'
    r172 = CPyDict_GetItem(r170, r171)
    if is_error(r172) goto L110 (error at patch_eth_utils:50) else goto L68
L68:
    r173 = dank_mids._eth_utils.globals :: static
    r174 = 'web3'
    r175 = CPyDict_GetItem(r173, r174)
    if is_error(r175) goto L119 (error at patch_eth_utils:50) else goto L69
L69:
    r176 = '_utils'
    r177 = CPyObject_GetAttr(r175, r176)
    dec_ref r175
    if is_error(r177) goto L119 (error at patch_eth_utils:50) else goto L70
L70:
    r178 = 'events'
    r179 = CPyObject_GetAttr(r177, r178)
    dec_ref r177
    if is_error(r179) goto L119 (error at patch_eth_utils:50) else goto L71
L71:
    r180 = 'to_bytes'
    r181 = PyObject_SetAttr(r179, r180, r172)
    dec_ref r179
    dec_ref r172
    r182 = r181 >= 0 :: signed
    if not r182 goto L110 (error at patch_eth_utils:50) else goto L72 :: bool
L72:
    r183 = dank_mids._eth_utils.globals :: static
    r184 = web3._utils.normalizers :: module
    r185 = load_address _Py_NoneStruct
    r186 = r184 != r185
    if r186 goto L75 else goto L73 :: bool
L73:
    r187 = 'web3._utils.normalizers'
    r188 = PyImport_Import(r187)
    if is_error(r188) goto L110 (error at patch_eth_utils:52) else goto L74
L74:
    web3._utils.normalizers = r188 :: module
    dec_ref r188
L75:
    r189 = 'web3'
    r190 = PyImport_GetModuleDict()
    r191 = 'web3'
    r192 = CPyDict_GetItem(r190, r191)
    if is_error(r192) goto L110 (error at patch_eth_utils:52) else goto L76
L76:
    r193 = CPyDict_SetItem(r183, r189, r192)
    dec_ref r192
    r194 = r193 >= 0 :: signed
    if not r194 goto L110 (error at patch_eth_utils:52) else goto L77 :: bool
L77:
    r195 = dank_mids._eth_utils.globals :: static
    r196 = 'to_hex'
    r197 = CPyDict_GetItem(r195, r196)
    if is_error(r197) goto L110 (error at patch_eth_utils:54) else goto L78
L78:
    r198 = dank_mids._eth_utils.globals :: static
    r199 = 'web3'
    r200 = CPyDict_GetItem(r198, r199)
    if is_error(r200) goto L120 (error at patch_eth_utils:54) else goto L79
L79:
    r201 = '_utils'
    r202 = CPyObject_GetAttr(r200, r201)
    dec_ref r200
    if is_error(r202) goto L120 (error at patch_eth_utils:54) else goto L80
L80:
    r203 = 'normalizers'
    r204 = CPyObject_GetAttr(r202, r203)
    dec_ref r202
    if is_error(r204) goto L120 (error at patch_eth_utils:54) else goto L81
L81:
    r205 = 'to_hex'
    r206 = PyObject_SetAttr(r204, r205, r197)
    dec_ref r204
    dec_ref r197
    r207 = r206 >= 0 :: signed
    if not r207 goto L110 (error at patch_eth_utils:54) else goto L82 :: bool
L82:
    r208 = dank_mids._eth_utils.globals :: static
    r209 = 'to_bytes'
    r210 = CPyDict_GetItem(r208, r209)
    if is_error(r210) goto L110 (error at patch_eth_utils:55) else goto L83
L83:
    r211 = dank_mids._eth_utils.globals :: static
    r212 = 'web3'
    r213 = CPyDict_GetItem(r211, r212)
    if is_error(r213) goto L121 (error at patch_eth_utils:55) else goto L84
L84:
    r214 = '_utils'
    r215 = CPyObject_GetAttr(r213, r214)
    dec_ref r213
    if is_error(r215) goto L121 (error at patch_eth_utils:55) else goto L85
L85:
    r216 = 'normalizers'
    r217 = CPyObject_GetAttr(r215, r216)
    dec_ref r215
    if is_error(r217) goto L121 (error at patch_eth_utils:55) else goto L86
L86:
    r218 = 'to_bytes'
    r219 = PyObject_SetAttr(r217, r218, r210)
    dec_ref r217
    dec_ref r210
    r220 = r219 >= 0 :: signed
    if not r220 goto L110 (error at patch_eth_utils:55) else goto L87 :: bool
L87:
    r221 = dank_mids._eth_utils.globals :: static
    r222 = web3._utils.type_conversion :: module
    r223 = load_address _Py_NoneStruct
    r224 = r222 != r223
    if r224 goto L90 else goto L88 :: bool
L88:
    r225 = 'web3._utils.type_conversion'
    r226 = PyImport_Import(r225)
    if is_error(r226) goto L92 (error at patch_eth_utils:59) else goto L89
L89:
    web3._utils.type_conversion = r226 :: module
    dec_ref r226
L90:
    r227 = 'web3'
    r228 = PyImport_GetModuleDict()
    r229 = 'web3'
    r230 = CPyDict_GetItem(r228, r229)
    if is_error(r230) goto L92 (error at patch_eth_utils:59) else goto L91
L91:
    r231 = CPyDict_SetItem(r221, r227, r230)
    dec_ref r230
    r232 = r231 >= 0 :: signed
    if not r232 goto L92 (error at patch_eth_utils:59) else goto L99 :: bool
L92:
    r233 = CPy_CatchError()
    r234 = builtins :: module
    r235 = 'ModuleNotFoundError'
    r236 = CPyObject_GetAttr(r234, r235)
    if is_error(r236) goto L97 (error at patch_eth_utils:60) else goto L93
L93:
    r237 = CPy_ExceptionMatches(r236)
    dec_ref r236
    if r237 goto L96 else goto L94 :: bool
L94:
    CPy_Reraise()
    if not 0 goto L97 else goto L122 :: bool
L95:
    unreachable
L96:
    CPy_RestoreExcInfo(r233)
    dec_ref r233
    goto L109
L97:
    CPy_RestoreExcInfo(r233)
    dec_ref r233
    r238 = CPy_KeepPropagating()
    if not r238 goto L110 else goto L98 :: bool
L98:
    unreachable
L99:
    r239 = dank_mids._eth_utils.globals :: static
    r240 = 'to_hex'
    r241 = CPyDict_GetItem(r239, r240)
    if is_error(r241) goto L110 (error at patch_eth_utils:63) else goto L100
L100:
    r242 = dank_mids._eth_utils.globals :: static
    r243 = 'web3'
    r244 = CPyDict_GetItem(r242, r243)
    if is_error(r244) goto L123 (error at patch_eth_utils:63) else goto L101
L101:
    r245 = '_utils'
    r246 = CPyObject_GetAttr(r244, r245)
    dec_ref r244
    if is_error(r246) goto L123 (error at patch_eth_utils:63) else goto L102
L102:
    r247 = 'type_conversion'
    r248 = CPyObject_GetAttr(r246, r247)
    dec_ref r246
    if is_error(r248) goto L123 (error at patch_eth_utils:63) else goto L103
L103:
    r249 = 'to_hex'
    r250 = PyObject_SetAttr(r248, r249, r241)
    dec_ref r248
    dec_ref r241
    r251 = r250 >= 0 :: signed
    if not r251 goto L110 (error at patch_eth_utils:63) else goto L104 :: bool
L104:
    r252 = dank_mids._eth_utils.globals :: static
    r253 = 'to_bytes'
    r254 = CPyDict_GetItem(r252, r253)
    if is_error(r254) goto L110 (error at patch_eth_utils:64) else goto L105
L105:
    r255 = dank_mids._eth_utils.globals :: static
    r256 = 'web3'
    r257 = CPyDict_GetItem(r255, r256)
    if is_error(r257) goto L124 (error at patch_eth_utils:64) else goto L106
L106:
    r258 = '_utils'
    r259 = CPyObject_GetAttr(r257, r258)
    dec_ref r257
    if is_error(r259) goto L124 (error at patch_eth_utils:64) else goto L107
L107:
    r260 = 'type_conversion'
    r261 = CPyObject_GetAttr(r259, r260)
    dec_ref r259
    if is_error(r261) goto L124 (error at patch_eth_utils:64) else goto L108
L108:
    r262 = 'to_bytes'
    r263 = PyObject_SetAttr(r261, r262, r254)
    dec_ref r261
    dec_ref r254
    r264 = r263 >= 0 :: signed
    if not r264 goto L110 (error at patch_eth_utils:64) else goto L109 :: bool
L109:
    return 1
L110:
    r265 = <error> :: None
    return r265
L111:
    dec_ref r14
    goto L110
L112:
    dec_ref r37
    goto L110
L113:
    dec_ref r48
    goto L110
L114:
    dec_ref r71
    goto L110
L115:
    dec_ref r96
    goto L110
L116:
    dec_ref r121
    goto L110
L117:
    dec_ref r134
    goto L110
L118:
    dec_ref r159
    goto L110
L119:
    dec_ref r172
    goto L110
L120:
    dec_ref r197
    goto L110
L121:
    dec_ref r210
    goto L110
L122:
    dec_ref r233
    goto L95
L123:
    dec_ref r241
    goto L110
L124:
    dec_ref r254
    goto L110

def to_hex(primitive, hexstr, text):
    primitive, hexstr :: union[object, None]
    text :: union[str, None]
    r0, r1, r2, r3 :: object
    r4 :: bit
    r5 :: object
    r6 :: str
    r7 :: object[1]
    r8 :: object_ptr
    r9 :: object
    r10 :: str
    r11, r12 :: object
    r13 :: bit
    r14 :: str
    r15 :: bytes
    r16 :: object
    r17 :: bit
    r18 :: bool
    r19, r20, r21 :: str
    r22, r23 :: object
    r24 :: str
    r25 :: object
    r26 :: tuple[object, object]
    r27 :: object
    r28 :: i32
    r29 :: bit
    r30 :: bool
    r31, r32 :: object
    r33 :: str
    r34 :: object
    r35 :: i32
    r36 :: bit
    r37 :: bool
    r38 :: object
    r39 :: object[1]
    r40 :: object_ptr
    r41 :: object
    r42 :: bytes
    r43 :: object
    r44 :: bit
    r45 :: str
    r46 :: object
    r47 :: str
    r48 :: object
    r49 :: object[1]
    r50 :: object_ptr
    r51 :: object
    r52 :: bit
    r53 :: int
    r54 :: object
    r55 :: str
    r56, r57 :: object
    r58 :: object[1]
    r59 :: object_ptr
    r60 :: object
    r61, r62 :: str
    r63 :: object
    r64, r65, r66 :: str
    r67 :: object
    r68 :: str
    r69 :: object
    r70 :: object[1]
    r71 :: object_ptr
    r72, r73 :: object
L0:
    if is_error(primitive) goto L1 else goto L53
L1:
    r0 = box(None, 1)
    inc_ref r0
    primitive = r0
L2:
    if is_error(hexstr) goto L3 else goto L54
L3:
    r1 = box(None, 1)
    inc_ref r1
    hexstr = r1
L4:
    if is_error(text) goto L5 else goto L55
L5:
    r2 = box(None, 1)
    inc_ref r2
    text = r2
L6:
    r3 = load_address _Py_NoneStruct
    r4 = hexstr != r3
    if r4 goto L56 else goto L57 :: bool
L7:
    r5 = hexstr
    r6 = 'lower'
    r7 = [r5]
    r8 = load_address r7
    r9 = PyObject_VectorcallMethod(r6, r8, 9223372036854775809, 0)
    if is_error(r9) goto L58 (error at to_hex:78) else goto L8
L8:
    dec_ref r5
    r10 = cast(str, r9)
    if is_error(r10) goto L52 (error at to_hex:78) else goto L9
L9:
L10:
    r11 = add_0x_prefix(r10)
    dec_ref r10
    if is_error(r11) goto L52 (error at to_hex:78) else goto L11
L11:
    return r11
L12:
    r12 = load_address _Py_NoneStruct
    r13 = text != r12
    if r13 goto L59 else goto L60 :: bool
L13:
    r14 = cast(str, text)
    if is_error(r14) goto L52 (error at to_hex:81) else goto L14
L14:
    r15 = PyUnicode_AsUTF8String(r14)
    dec_ref r14
    if is_error(r15) goto L52 (error at to_hex:81) else goto L15
L15:
    r16 = encode_hex(r15)
    dec_ref r15
    if is_error(r16) goto L52 (error at to_hex:81) else goto L16
L16:
    return r16
L17:
    r17 = PyBool_Check(primitive)
    if r17 goto L18 else goto L23 :: bool
L18:
    r18 = unbox(bool, primitive)
    dec_ref primitive
    if is_error(r18) goto L52 (error at to_hex:84) else goto L19
L19:
    if r18 goto L20 else goto L21 :: bool
L20:
    r19 = '0x1'
    inc_ref r19
    r20 = r19
    goto L22
L21:
    r21 = '0x0'
    inc_ref r21
    r20 = r21
L22:
    return r20
L23:
    r22 = load_address PyBytes_Type
    r23 = builtins :: module
    r24 = 'bytearray'
    r25 = CPyObject_GetAttr(r23, r24)
    if is_error(r25) goto L61 (error at to_hex:86) else goto L24
L24:
    inc_ref r22
    r26 = (r22, r25)
    r27 = box(tuple[object, object], r26)
    r28 = PyObject_IsInstance(primitive, r27)
    dec_ref r27
    r29 = r28 >= 0 :: signed
    if not r29 goto L61 (error at to_hex:86) else goto L25 :: bool
L25:
    r30 = truncate r28: i32 to builtins.bool
    if r30 goto L26 else goto L28 :: bool
L26:
    r31 = encode_hex(primitive)
    dec_ref primitive
    if is_error(r31) goto L52 (error at to_hex:87) else goto L27
L27:
    return r31
L28:
    r32 = builtins :: module
    r33 = 'memoryview'
    r34 = CPyObject_GetAttr(r32, r33)
    if is_error(r34) goto L61 (error at to_hex:89) else goto L29
L29:
    r35 = PyObject_IsInstance(primitive, r34)
    dec_ref r34
    r36 = r35 >= 0 :: signed
    if not r36 goto L61 (error at to_hex:89) else goto L30 :: bool
L30:
    r37 = truncate r35: i32 to builtins.bool
    if r37 goto L31 else goto L35 :: bool
L31:
    r38 = load_address PyBytes_Type
    r39 = [primitive]
    r40 = load_address r39
    r41 = PyObject_Vectorcall(r38, r40, 1, 0)
    if is_error(r41) goto L61 (error at to_hex:90) else goto L32
L32:
    dec_ref primitive
    r42 = cast(bytes, r41)
    if is_error(r42) goto L52 (error at to_hex:90) else goto L33
L33:
    r43 = encode_hex(r42)
    dec_ref r42
    if is_error(r43) goto L52 (error at to_hex:90) else goto L34
L34:
    return r43
L35:
    r44 = PyUnicode_Check(primitive)
    if r44 goto L62 else goto L40 :: bool
L36:
    r45 = 'Unsupported type: The primitive argument must be one of: bytes,bytearray, int or bool and not str'
    r46 = builtins :: module
    r47 = 'TypeError'
    r48 = CPyObject_GetAttr(r46, r47)
    if is_error(r48) goto L52 (error at to_hex:93) else goto L37
L37:
    r49 = [r45]
    r50 = load_address r49
    r51 = PyObject_Vectorcall(r48, r50, 1, 0)
    dec_ref r48
    if is_error(r51) goto L52 (error at to_hex:93) else goto L38
L38:
    CPy_Raise(r51)
    dec_ref r51
    if not 0 goto L52 (error at to_hex:93) else goto L39 :: bool
L39:
    unreachable
L40:
    r52 = PyLong_Check(primitive)
    if r52 goto L41 else goto L46 :: bool
L41:
    r53 = unbox(int, primitive)
    dec_ref primitive
    if is_error(r53) goto L52 (error at to_hex:99) else goto L42
L42:
    r54 = builtins :: module
    r55 = 'hex'
    r56 = CPyObject_GetAttr(r54, r55)
    if is_error(r56) goto L63 (error at to_hex:99) else goto L43
L43:
    r57 = box(int, r53)
    r58 = [r57]
    r59 = load_address r58
    r60 = PyObject_Vectorcall(r56, r59, 1, 0)
    dec_ref r56
    if is_error(r60) goto L64 (error at to_hex:99) else goto L44
L44:
    dec_ref r57
    r61 = cast(str, r60)
    if is_error(r61) goto L52 (error at to_hex:99) else goto L45
L45:
    return r61
L46:
    r62 = "Unsupported type: '"
    r63 = PyObject_Type(primitive)
    dec_ref primitive
    r64 = PyObject_Repr(r63)
    dec_ref r63
    if is_error(r64) goto L52 (error at to_hex:102) else goto L47
L47:
    r65 = "'. Must be one of: bool, str, bytes, bytearray or int."
    r66 = CPyStr_Build(3, r62, r64, r65)
    dec_ref r64
    if is_error(r66) goto L52 (error at to_hex:102) else goto L48
L48:
    r67 = builtins :: module
    r68 = 'TypeError'
    r69 = CPyObject_GetAttr(r67, r68)
    if is_error(r69) goto L65 (error at to_hex:101) else goto L49
L49:
    r70 = [r66]
    r71 = load_address r70
    r72 = PyObject_Vectorcall(r69, r71, 1, 0)
    dec_ref r69
    if is_error(r72) goto L65 (error at to_hex:101) else goto L50
L50:
    dec_ref r66
    CPy_Raise(r72)
    dec_ref r72
    if not 0 goto L52 (error at to_hex:101) else goto L51 :: bool
L51:
    unreachable
L52:
    r73 = <error> :: object
    return r73
L53:
    inc_ref primitive
    goto L2
L54:
    inc_ref hexstr
    goto L4
L55:
    inc_ref text
    goto L6
L56:
    dec_ref primitive
    dec_ref text
    goto L7
L57:
    dec_ref hexstr
    goto L12
L58:
    dec_ref r5
    goto L52
L59:
    dec_ref primitive
    goto L13
L60:
    dec_ref text
    goto L17
L61:
    dec_ref primitive
    goto L52
L62:
    dec_ref primitive
    goto L36
L63:
    dec_ref r53 :: int
    goto L52
L64:
    dec_ref r57
    goto L52
L65:
    dec_ref r66
    goto L52

def to_bytes(primitive, hexstr, text):
    primitive, hexstr :: union[object, None]
    text :: union[str, None]
    r0, r1, r2 :: object
    r3 :: bit
    r4 :: bool
    r5, r6, r7 :: bytes
    r8 :: object
    r9 :: str
    r10, r11 :: object
    r12 :: str
    r13 :: object
    r14 :: tuple[object, object]
    r15 :: object
    r16 :: i32
    r17 :: bit
    r18 :: bool
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22 :: object
    r23 :: bytes
    r24 :: bit
    r25 :: bytes
    r26 :: bit
    r27 :: int
    r28 :: object
    r29 :: union[object, None]
    r30 :: union[str, None]
    r31 :: object
    r32 :: union[object, None]
    r33 :: union[str, None]
    r34 :: bytes
    r35 :: object
    r36 :: bit
    r37, r38 :: int
    r39 :: bit
    r40 :: str
    r41 :: object
    r42, r43, r44, r45 :: str
    r46 :: bytes
    r47 :: object
    r48 :: bit
    r49 :: str
    r50 :: bytes
    r51 :: str
    r52 :: object
    r53 :: str
    r54 :: object
    r55 :: object[1]
    r56 :: object_ptr
    r57 :: object
    r58 :: bytes
L0:
    if is_error(primitive) goto L1 else goto L48
L1:
    r0 = box(None, 1)
    inc_ref r0
    primitive = r0
L2:
    if is_error(hexstr) goto L3 else goto L49
L3:
    r1 = box(None, 1)
    inc_ref r1
    hexstr = r1
L4:
    if is_error(text) goto L5 else goto L50
L5:
    r2 = box(None, 1)
    inc_ref r2
    text = r2
L6:
    r3 = PyBool_Check(primitive)
    if r3 goto L51 else goto L12 :: bool
L7:
    r4 = unbox(bool, primitive)
    dec_ref primitive
    if is_error(r4) goto L47 (error at to_bytes:113) else goto L8
L8:
    if r4 goto L9 else goto L10 :: bool
L9:
    r5 = b'\x01'
    inc_ref r5
    r6 = r5
    goto L11
L10:
    r7 = b'\x00'
    inc_ref r7
    r6 = r7
L11:
    return r6
L12:
    r8 = builtins :: module
    r9 = 'bytearray'
    r10 = CPyObject_GetAttr(r8, r9)
    if is_error(r10) goto L52 (error at to_bytes:114) else goto L13
L13:
    r11 = builtins :: module
    r12 = 'memoryview'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L53 (error at to_bytes:114) else goto L14
L14:
    r14 = (r10, r13)
    r15 = box(tuple[object, object], r14)
    r16 = PyObject_IsInstance(primitive, r15)
    dec_ref r15
    r17 = r16 >= 0 :: signed
    if not r17 goto L52 (error at to_bytes:114) else goto L15 :: bool
L15:
    r18 = truncate r16: i32 to builtins.bool
    if r18 goto L54 else goto L19 :: bool
L16:
    r19 = load_address PyBytes_Type
    r20 = [primitive]
    r21 = load_address r20
    r22 = PyObject_Vectorcall(r19, r21, 1, 0)
    if is_error(r22) goto L55 (error at to_bytes:115) else goto L17
L17:
    dec_ref primitive
    r23 = cast(bytes, r22)
    if is_error(r23) goto L47 (error at to_bytes:115) else goto L18
L18:
    return r23
L19:
    r24 = PyBytes_Check(primitive)
    if r24 goto L56 else goto L22 :: bool
L20:
    r25 = cast(bytes, primitive)
    if is_error(r25) goto L47 (error at to_bytes:117) else goto L21
L21:
    return r25
L22:
    r26 = PyLong_Check(primitive)
    if r26 goto L57 else goto L58 :: bool
L23:
    r27 = unbox(int, primitive)
    dec_ref primitive
    if is_error(r27) goto L47 (error at to_bytes:119) else goto L24
L24:
    r28 = box(int, r27)
    r29 = <error> :: union[object, None]
    r30 = <error> :: union[str, None]
    r31 = to_hex(r28, r29, r30)
    dec_ref r28
    if is_error(r31) goto L47 (error at to_bytes:119) else goto L25
L25:
    r32 = <error> :: union[object, None]
    r33 = <error> :: union[str, None]
    r34 = to_bytes(r32, r31, r33)
    dec_ref r31
    if is_error(r34) goto L47 (error at to_bytes:119) else goto L26
L26:
    return r34
L27:
    r35 = load_address _Py_NoneStruct
    r36 = hexstr != r35
    if r36 goto L59 else goto L60 :: bool
L28:
    r37 = CPyObject_Size(hexstr)
    if is_error(r37) goto L61 (error at to_bytes:121) else goto L29
L29:
    r38 = CPyTagged_Remainder(r37, 4)
    dec_ref r37 :: int
    if is_error(r38) goto L61 (error at to_bytes:121) else goto L30
L30:
    r39 = r38 != 0
    dec_ref r38 :: int
    if r39 goto L31 else goto L35 :: bool
L31:
    r40 = '0x0'
    r41 = remove_0x_prefix(hexstr)
    dec_ref hexstr
    if is_error(r41) goto L47 (error at to_bytes:121) else goto L32
L32:
    r42 = PyObject_Str(r41)
    dec_ref r41
    if is_error(r42) goto L47 (error at to_bytes:121) else goto L33
L33:
    r43 = CPyStr_Build(2, r40, r42)
    dec_ref r42
    if is_error(r43) goto L47 (error at to_bytes:121) else goto L34
L34:
    r44 = r43
    goto L37
L35:
    r45 = cast(str, hexstr)
    if is_error(r45) goto L47 (error at to_bytes:121) else goto L36
L36:
    r44 = r45
L37:
    r46 = decode_hex(r44)
    dec_ref r44
    if is_error(r46) goto L47 (error at to_bytes:121) else goto L38
L38:
    return r46
L39:
    r47 = load_address _Py_NoneStruct
    r48 = text != r47
    if r48 goto L40 else goto L62 :: bool
L40:
    r49 = cast(str, text)
    if is_error(r49) goto L47 (error at to_bytes:123) else goto L41
L41:
    r50 = PyUnicode_AsUTF8String(r49)
    dec_ref r49
    if is_error(r50) goto L47 (error at to_bytes:123) else goto L42
L42:
    return r50
L43:
    r51 = 'expected a bool, int, byte or bytearray in first arg, or keyword of hexstr or text'
    r52 = builtins :: module
    r53 = 'TypeError'
    r54 = CPyObject_GetAttr(r52, r53)
    if is_error(r54) goto L47 (error at to_bytes:124) else goto L44
L44:
    r55 = [r51]
    r56 = load_address r55
    r57 = PyObject_Vectorcall(r54, r56, 1, 0)
    dec_ref r54
    if is_error(r57) goto L47 (error at to_bytes:124) else goto L45
L45:
    CPy_Raise(r57)
    dec_ref r57
    if not 0 goto L47 (error at to_bytes:124) else goto L46 :: bool
L46:
    unreachable
L47:
    r58 = <error> :: bytes
    return r58
L48:
    inc_ref primitive
    goto L2
L49:
    inc_ref hexstr
    goto L4
L50:
    inc_ref text
    goto L6
L51:
    dec_ref hexstr
    dec_ref text
    goto L7
L52:
    dec_ref primitive
    dec_ref hexstr
    dec_ref text
    goto L47
L53:
    dec_ref primitive
    dec_ref hexstr
    dec_ref text
    dec_ref r10
    goto L47
L54:
    dec_ref hexstr
    dec_ref text
    goto L16
L55:
    dec_ref primitive
    goto L47
L56:
    dec_ref hexstr
    dec_ref text
    goto L20
L57:
    dec_ref hexstr
    dec_ref text
    goto L23
L58:
    dec_ref primitive
    goto L27
L59:
    dec_ref text
    goto L28
L60:
    dec_ref hexstr
    goto L39
L61:
    dec_ref hexstr
    goto L47
L62:
    dec_ref text
    goto L43

def decode_hex(value):
    value :: str
    r0 :: bit
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
    r9, r10 :: str
    r11 :: object[2]
    r12 :: object_ptr
    r13 :: object
    r14 :: bytes
    r15 :: object
    r16 :: bool
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20, r21 :: bytes
L0:
    r0 = PyUnicode_Check(value)
    if r0 goto L5 else goto L1 :: bool
L1:
    r1 = 'Value must be an instance of str'
    r2 = builtins :: module
    r3 = 'TypeError'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L14 (error at decode_hex:131) else goto L2
L2:
    r5 = [r1]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r4, r6, 1, 0)
    dec_ref r4
    if is_error(r7) goto L14 (error at decode_hex:131) else goto L3
L3:
    CPy_Raise(r7)
    dec_ref r7
    if not 0 goto L14 (error at decode_hex:131) else goto L4 :: bool
L4:
    unreachable
L5:
    r8 = remove_0x_prefix(value)
    if is_error(r8) goto L14 (error at decode_hex:132) else goto L6
L6:
    r9 = 'ascii'
    r10 = 'encode'
    r11 = [r8, r9]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775810, 0)
    if is_error(r13) goto L15 (error at decode_hex:134) else goto L7
L7:
    dec_ref r8
    r14 = cast(bytes, r13)
    if is_error(r14) goto L14 (error at decode_hex:134) else goto L8
L8:
    r15 = dank_mids._eth_utils.unhexlify :: static
    if is_error(r15) goto L16 else goto L11
L9:
    r16 = raise NameError('value for final name "unhexlify" was not set')
    if not r16 goto L14 (error at decode_hex:135) else goto L10 :: bool
L10:
    unreachable
L11:
    r17 = [r14]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r15, r18, 1, 0)
    if is_error(r19) goto L17 (error at decode_hex:135) else goto L12
L12:
    dec_ref r14
    r20 = cast(bytes, r19)
    if is_error(r20) goto L14 (error at decode_hex:135) else goto L13
L13:
    return r20
L14:
    r21 = <error> :: bytes
    return r21
L15:
    dec_ref r8
    goto L14
L16:
    dec_ref r14
    goto L9
L17:
    dec_ref r14
    goto L14

def encode_hex(value):
    value :: object
    r0 :: bit
    r1 :: bytes
    ascii_bytes :: object
    r2 :: bit
    r3 :: str
    r4 :: bytes
    r5 :: bit
    r6 :: object
    r7 :: object[1]
    r8 :: object_ptr
    r9 :: object
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16, r17 :: object
    r18 :: bool
    r19 :: object[1]
    r20 :: object_ptr
    r21 :: object
    r22 :: bytes
    r23, r24 :: str
    r25, r26 :: object
L0:
    r0 = PyBytes_Check(value)
    if r0 goto L1 else goto L3 :: bool
L1:
    inc_ref value
    r1 = cast(bytes, value)
    if is_error(r1) goto L22 (error at encode_hex:141) else goto L2
L2:
    ascii_bytes = r1
    goto L14
L3:
    r2 = PyUnicode_Check(value)
    if r2 goto L4 else goto L7 :: bool
L4:
    inc_ref value
    r3 = cast(str, value)
    if is_error(r3) goto L22 (error at encode_hex:143) else goto L5
L5:
    r4 = PyUnicode_AsASCIIString(r3)
    dec_ref r3
    if is_error(r4) goto L22 (error at encode_hex:143) else goto L6
L6:
    ascii_bytes = r4
    goto L14
L7:
    r5 = PyByteArray_Check(value)
    if r5 goto L8 else goto L10 :: bool
L8:
    r6 = load_address PyBytes_Type
    r7 = [value]
    r8 = load_address r7
    r9 = PyObject_Vectorcall(r6, r8, 1, 0)
    if is_error(r9) goto L22 (error at encode_hex:145) else goto L9
L9:
    ascii_bytes = r9
    goto L14
L10:
    r10 = 'Value must be an instance of str or unicode'
    r11 = builtins :: module
    r12 = 'TypeError'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L22 (error at encode_hex:147) else goto L11
L11:
    r14 = [r10]
    r15 = load_address r14
    r16 = PyObject_Vectorcall(r13, r15, 1, 0)
    dec_ref r13
    if is_error(r16) goto L22 (error at encode_hex:147) else goto L12
L12:
    CPy_Raise(r16)
    dec_ref r16
    if not 0 goto L22 (error at encode_hex:147) else goto L13 :: bool
L13:
    unreachable
L14:
    r17 = dank_mids._eth_utils.hexlify :: static
    if is_error(r17) goto L23 else goto L17
L15:
    r18 = raise NameError('value for final name "hexlify" was not set')
    if not r18 goto L22 (error at encode_hex:148) else goto L16 :: bool
L16:
    unreachable
L17:
    r19 = [ascii_bytes]
    r20 = load_address r19
    r21 = PyObject_Vectorcall(r17, r20, 1, 0)
    if is_error(r21) goto L24 (error at encode_hex:148) else goto L18
L18:
    dec_ref ascii_bytes
    r22 = cast(bytes, r21)
    if is_error(r22) goto L22 (error at encode_hex:148) else goto L19
L19:
    r23 = 'ascii'
    r24 = CPy_Decode(r22, r23, 0)
    dec_ref r22
    if is_error(r24) goto L22 (error at encode_hex:148) else goto L20
L20:
    r25 = add_0x_prefix(r24)
    dec_ref r24
    if is_error(r25) goto L22 (error at encode_hex:149) else goto L21
L21:
    return r25
L22:
    r26 = <error> :: object
    return r26
L23:
    dec_ref ascii_bytes
    goto L15
L24:
    dec_ref ascii_bytes
    goto L22

def is_0x_prefixed(value):
    value :: str
    r0 :: bit
    r1, r2, r3, r4, r5, r6 :: str
    r7 :: object[3]
    r8 :: object_ptr
    r9 :: object
    r10 :: list
    r11, r12, r13 :: ptr
    r14 :: str
    r15 :: object
    r16 :: str
    r17 :: object
    r18 :: object[1]
    r19 :: object_ptr
    r20 :: object
    r21, r22 :: str
    r23 :: tuple[str, str]
    r24 :: object
    r25, r26 :: bool
L0:
    r0 = PyUnicode_Check(value)
    if r0 goto L9 else goto L1 :: bool
L1:
    r1 = ''
    r2 = 'is_0x_prefixed requires text typed arguments. Got: '
    r3 = '{:{}}'
    r4 = PyObject_Repr(value)
    if is_error(r4) goto L11 (error at is_0x_prefixed:154) else goto L2
L2:
    r5 = ''
    r6 = 'format'
    r7 = [r3, r4, r5]
    r8 = load_address r7
    r9 = PyObject_VectorcallMethod(r6, r8, 9223372036854775811, 0)
    if is_error(r9) goto L12 (error at is_0x_prefixed:154) else goto L3
L3:
    dec_ref r4
    r10 = PyList_New(2)
    if is_error(r10) goto L13 (error at is_0x_prefixed:154) else goto L4
L4:
    r11 = get_element_ptr r10 ob_item :: PyListObject
    r12 = load_mem r11 :: ptr*
    inc_ref r2
    set_mem r12, r2 :: builtins.object*
    r13 = r12 + 8
    set_mem r13, r9 :: builtins.object*
    r14 = PyUnicode_Join(r1, r10)
    dec_ref r10
    if is_error(r14) goto L11 (error at is_0x_prefixed:154) else goto L5
L5:
    r15 = builtins :: module
    r16 = 'TypeError'
    r17 = CPyObject_GetAttr(r15, r16)
    if is_error(r17) goto L14 (error at is_0x_prefixed:154) else goto L6
L6:
    r18 = [r14]
    r19 = load_address r18
    r20 = PyObject_Vectorcall(r17, r19, 1, 0)
    dec_ref r17
    if is_error(r20) goto L14 (error at is_0x_prefixed:154) else goto L7
L7:
    dec_ref r14
    CPy_Raise(r20)
    dec_ref r20
    if not 0 goto L11 (error at is_0x_prefixed:154) else goto L8 :: bool
L8:
    unreachable
L9:
    r21 = '0x'
    r22 = '0X'
    inc_ref r21
    inc_ref r22
    r23 = (r21, r22)
    r24 = box(tuple[str, str], r23)
    r25 = CPyStr_Startswith(value, r24)
    dec_ref r24
    if is_error(r25) goto L11 (error at is_0x_prefixed:155) else goto L10
L10:
    return r25
L11:
    r26 = <error> :: bool
    return r26
L12:
    dec_ref r4
    goto L11
L13:
    dec_ref r9
    goto L11
L14:
    dec_ref r14
    goto L11

def remove_0x_prefix(value):
    value :: object
    r0 :: str
    r1 :: bool
    r2, r3, r4, r5, r6 :: object
    r7 :: str
    r8 :: object
L0:
    inc_ref value
    r0 = cast(str, value)
    if is_error(r0) goto L8 (error at remove_0x_prefix:160) else goto L1
L1:
    r1 = is_0x_prefixed(r0)
    dec_ref r0
    if is_error(r1) goto L8 (error at remove_0x_prefix:160) else goto L2
L2:
    if r1 goto L3 else goto L7 :: bool
L3:
    r2 = load_address _Py_NoneStruct
    r3 = load_address _Py_NoneStruct
    r4 = object 2
    r5 = PySlice_New(r4, r2, r3)
    if is_error(r5) goto L8 (error at remove_0x_prefix:161) else goto L4
L4:
    r6 = PyObject_GetItem(value, r5)
    dec_ref r5
    if is_error(r6) goto L8 (error at remove_0x_prefix:161) else goto L5
L5:
    r7 = cast(str, r6)
    if is_error(r7) goto L8 (error at remove_0x_prefix:161) else goto L6
L6:
    return r7
L7:
    inc_ref value
    return value
L8:
    r8 = <error> :: object
    return r8

def add_0x_prefix(value):
    value :: object
    r0 :: str
    r1 :: bool
    r2, r3, r4 :: str
    r5 :: object
L0:
    inc_ref value
    r0 = cast(str, value)
    if is_error(r0) goto L7 (error at add_0x_prefix:167) else goto L1
L1:
    r1 = is_0x_prefixed(r0)
    dec_ref r0
    if is_error(r1) goto L7 (error at add_0x_prefix:167) else goto L2
L2:
    if r1 goto L3 else goto L4 :: bool
L3:
    inc_ref value
    return value
L4:
    r2 = '0x'
    r3 = PyObject_Str(value)
    if is_error(r3) goto L7 (error at add_0x_prefix:169) else goto L5
L5:
    r4 = CPyStr_Build(2, r2, r3)
    dec_ref r3
    if is_error(r4) goto L7 (error at add_0x_prefix:169) else goto L6
L6:
    return r4
L7:
    r5 = <error> :: object
    return r5

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: dict
    r34 :: str
    r35 :: i32
    r36 :: bit
    r37 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L11 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address binascii :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [8]
    r9 = load_address r8
    r10 = (('binascii', 'binascii', 'binascii'),)
    r11 = dank_mids._eth_utils.globals :: static
    r12 = 'dank_mids/_eth_utils.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L11 else goto L4 :: bool
L4:
    r15 = ('Any', 'AnyStr', 'Final', 'Optional')
    r16 = 'typing'
    r17 = dank_mids._eth_utils.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L11 (error at <module>:9) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = ('HexStr',)
    r20 = 'eth_typing'
    r21 = dank_mids._eth_utils.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L11 (error at <module>:11) else goto L6
L6:
    eth_typing = r22 :: module
    dec_ref r22
    r23 = binascii :: module
    r24 = 'hexlify'
    r25 = CPyObject_GetAttr(r23, r24)
    if is_error(r25) goto L11 (error at <module>:14) else goto L7
L7:
    dank_mids._eth_utils.hexlify = r25 :: static
    r26 = dank_mids._eth_utils.globals :: static
    r27 = 'hexlify'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L11 (error at <module>:14) else goto L8 :: bool
L8:
    r30 = binascii :: module
    r31 = 'unhexlify'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L11 (error at <module>:15) else goto L9
L9:
    dank_mids._eth_utils.unhexlify = r32 :: static
    r33 = dank_mids._eth_utils.globals :: static
    r34 = 'unhexlify'
    r35 = CPyDict_SetItem(r33, r34, r32)
    dec_ref r32
    r36 = r35 >= 0 :: signed
    if not r36 goto L11 (error at <module>:15) else goto L10 :: bool
L10:
    return 1
L11:
    r37 = <error> :: None
    return r37

def WeakList.__init__(self, data):
    self :: dank_mids.helpers._weaklist.WeakList
    data :: union[object, None]
    r0 :: object
    r1 :: dict
    r2 :: bool
    r3 :: object
    r4 :: bit
    r5, r6 :: None
L0:
    if is_error(data) goto L1 else goto L8
L1:
    r0 = box(None, 1)
    inc_ref r0
    data = r0
L2:
    r1 = PyDict_New()
    if is_error(r1) goto L9 (error at __init__:14) else goto L3
L3:
    self._refs = r1; r2 = is_error
    if not r2 goto L9 (error at __init__:14) else goto L4 :: bool
L4:
    r3 = load_address _Py_NoneStruct
    r4 = data != r3
    if r4 goto L5 else goto L10 :: bool
L5:
    r5 = self.extend(data)
    dec_ref data
    if is_error(r5) goto L7 (error at __init__:16) else goto L6
L6:
    return 1
L7:
    r6 = <error> :: None
    return r6
L8:
    inc_ref data
    goto L2
L9:
    dec_ref data
    goto L7
L10:
    dec_ref data
    goto L6

def WeakList.__repr__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: object
    r1 :: str
    r2 :: object
    r3, r4, r5 :: str
    r6 :: object
    r7 :: str
    r8, r9 :: object
    r10 :: str
    r11 :: object
    r12 :: object[2]
    r13 :: object_ptr
    r14 :: object
    r15, r16, r17, r18 :: str
L0:
    r0 = PyObject_Type(self)
    r1 = '__name__'
    r2 = CPyObject_GetAttr(r0, r1)
    dec_ref r0
    if is_error(r2) goto L8 (error at __repr__:20) else goto L1
L1:
    r3 = cast(str, r2)
    if is_error(r3) goto L8 (error at __repr__:20) else goto L2
L2:
    r4 = '(['
    r5 = ', '
    r6 = builtins :: module
    r7 = 'repr'
    r8 = CPyObject_GetAttr(r6, r7)
    if is_error(r8) goto L9 (error at __repr__:20) else goto L3
L3:
    r9 = builtins :: module
    r10 = 'map'
    r11 = CPyObject_GetAttr(r9, r10)
    if is_error(r11) goto L10 (error at __repr__:20) else goto L4
L4:
    r12 = [r8, self]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r11, r13, 2, 0)
    dec_ref r11
    if is_error(r14) goto L10 (error at __repr__:20) else goto L5
L5:
    dec_ref r8
    r15 = PyUnicode_Join(r5, r14)
    dec_ref r14
    if is_error(r15) goto L9 (error at __repr__:20) else goto L6
L6:
    r16 = '])'
    r17 = CPyStr_Build(4, r3, r4, r15, r16)
    dec_ref r3
    dec_ref r15
    if is_error(r17) goto L8 (error at __repr__:20) else goto L7
L7:
    return r17
L8:
    r18 = <error> :: str
    return r18
L9:
    dec_ref r3
    goto L8
L10:
    dec_ref r3
    dec_ref r8
    goto L8

def WeakList.__len__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: dict
    r1 :: native_int
    r2 :: short_int
    r3 :: int
L0:
    r0 = self._refs
    if is_error(r0) goto L2 (error at __len__:23) else goto L1
L1:
    r1 = PyDict_Size(r0)
    dec_ref r0
    r2 = r1 << 1
    return r2
L2:
    r3 = <error> :: int
    return r3

def WeakList.__bool__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: object
    r1 :: str
    r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bool
L0:
    r0 = builtins :: module
    r1 = 'any'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L4 (error at __bool__:26) else goto L1
L1:
    r3 = [self]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r2, r4, 1, 0)
    dec_ref r2
    if is_error(r5) goto L4 (error at __bool__:26) else goto L2
L2:
    r6 = unbox(bool, r5)
    dec_ref r5
    if is_error(r6) goto L4 (error at __bool__:26) else goto L3
L3:
    return r6
L4:
    r7 = <error> :: bool
    return r7

def WeakList.__contains__(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: dict
    r1 :: int
    r2, r3 :: object
    reference :: union[object, None]
    r4 :: object
    r5 :: bit
    r6 :: bool
    r7 :: weakref.ReferenceType
    r8 :: object
    r9 :: bit
    r10 :: bool
L0:
    r0 = self._refs
    if is_error(r0) goto L8 (error at __contains__:29) else goto L1
L1:
    r1 = CPyTagged_Id(item)
    r2 = box(int, r1)
    r3 = CPyDict_GetWithNone(r0, r2)
    dec_ref r0
    dec_ref r2
    if is_error(r3) goto L8 (error at __contains__:29) else goto L2
L2:
    reference = r3
    r4 = load_address _Py_NoneStruct
    r5 = reference == r4
    if r5 goto L9 else goto L4 :: bool
L3:
    r6 = 0
    goto L7
L4:
    r7 = cast(weakref.ReferenceType, reference)
    if is_error(r7) goto L8 (error at __contains__:30) else goto L5
L5:
    r8 = CPyWeakref_GetRef(r7)
    dec_ref r7
    if is_error(r8) goto L8 (error at __contains__:30) else goto L6
L6:
    r9 = r8 == item
    dec_ref r8
    r6 = r9
L7:
    return r6
L8:
    r10 = <error> :: bool
    return r10
L9:
    dec_ref reference
    goto L3

def __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0 :: i32
    r1 :: object
    r2 :: bit
    r3 :: dank_mids.helpers._weaklist.WeakList
    r4 :: dict
    r5, r6 :: bool
    r7 :: dict
    r8 :: native_int
    r9 :: bool
    r10 :: object
    r11 :: bool
    r12 :: object
    r13 :: short_int
    r14 :: tuple[bool, short_int, object]
    r15 :: short_int
    r16, r17 :: bool
    r18 :: object
    r19 :: bool
    r20 :: object
    r21 :: weakref.ReferenceType
    r22 :: object
    r23 :: bool
    r24 :: union[object, None]
    r25 :: object
    r26 :: bit
    r27 :: union[object, None]
    r28 :: bool
    r29 :: object
    r30 :: bit
    r31 :: dict
    r32 :: native_int
    r33, r34 :: bit
    r35 :: object
    r36 :: bool
    r37, r38 :: bit
    r39 :: bool
    r40 :: object
L0:
    r0 = __mypyc_self__.__mypyc_next_label__
    goto L37
L1:
    r1 = load_address _Py_NoneStruct
    r2 = type != r1
    if r2 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L41 (error at __iter__:32) else goto L3 :: bool
L3:
    unreachable
L4:
    r3 = __mypyc_self__.self
    if is_error(r3) goto L41 (error at __iter__:33) else goto L5
L5:
    r4 = r3._refs
    dec_ref r3
    if is_error(r4) goto L41 (error at __iter__:33) else goto L6
L6:
    inc_ref r4
    __mypyc_self__.__mypyc_temp__0 = r4; r5 = is_error
    if not r5 goto L42 (error at __iter__:-1) else goto L7 :: bool
L7:
    __mypyc_self__.__mypyc_temp__1 = 0; r6 = is_error
    if not r6 goto L42 (error at __iter__:-1) else goto L8 :: bool
L8:
    r7 = __mypyc_self__.__mypyc_temp__0
    if is_error(r7) goto L42 (error at __iter__:33) else goto L9
L9:
    r8 = PyDict_Size(r7)
    dec_ref r7
    __mypyc_self__.__mypyc_temp__2 = r8; r9 = is_error
    if not r9 goto L42 (error at __iter__:-1) else goto L10 :: bool
L10:
    r10 = CPyDict_GetValuesIter(r4)
    dec_ref r4
    if is_error(r10) goto L41 (error at __iter__:33) else goto L11
L11:
    __mypyc_self__.__mypyc_temp__3 = r10; r11 = is_error
    if not r11 goto L41 (error at __iter__:-1) else goto L12 :: bool
L12:
    r12 = __mypyc_self__.__mypyc_temp__3
    if is_error(r12) goto L41 (error at __iter__:33) else goto L13
L13:
    r13 = __mypyc_self__.__mypyc_temp__1
    if is_error(r13) goto L43 (error at __iter__:33) else goto L14
L14:
    r14 = CPyDict_NextValue(r12, r13)
    dec_ref r12
    r15 = r14[1]
    __mypyc_self__.__mypyc_temp__1 = r15; r16 = is_error
    if not r16 goto L44 (error at __iter__:33) else goto L15 :: bool
L15:
    r17 = r14[0]
    if r17 goto L16 else goto L45 :: bool
L16:
    r18 = r14[2]
    dec_ref r14
    __mypyc_self__.reference = r18; r19 = is_error
    if not r19 goto L41 (error at __iter__:33) else goto L17 :: bool
L17:
    r20 = __mypyc_self__.reference
    if is_error(r20) goto L41 (error at __iter__:34) else goto L18
L18:
    r21 = cast(weakref.ReferenceType, r20)
    if is_error(r21) goto L41 (error at __iter__:34) else goto L19
L19:
    r22 = CPyWeakref_GetRef(r21)
    dec_ref r21
    if is_error(r22) goto L41 (error at __iter__:34) else goto L20
L20:
    __mypyc_self__.obj = r22; r23 = is_error
    if not r23 goto L41 (error at __iter__:34) else goto L21 :: bool
L21:
    r24 = __mypyc_self__.obj
    if is_error(r24) goto L41 (error at __iter__:35) else goto L22
L22:
    r25 = load_address _Py_NoneStruct
    r26 = r24 != r25
    dec_ref r24
    if r26 goto L23 else goto L28 :: bool
L23:
    r27 = __mypyc_self__.obj
    if is_error(r27) goto L41 (error at __iter__:36) else goto L24
L24:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r27
L25:
    r29 = load_address _Py_NoneStruct
    r30 = type != r29
    if r30 goto L26 else goto L28 :: bool
L26:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L41 (error at __iter__:36) else goto L27 :: bool
L27:
    unreachable
L28:
    r31 = __mypyc_self__.__mypyc_temp__0
    if is_error(r31) goto L41 (error at __iter__:33) else goto L29
L29:
    r32 = __mypyc_self__.__mypyc_temp__2
    if is_error(r32) goto L46 (error at __iter__:33) else goto L30
L30:
    r33 = CPyDict_CheckSize(r31, r32)
    dec_ref r31
    if not r33 goto L41 (error at __iter__:33) else goto L12 :: bool
L31:
    r34 = CPy_NoErrOccurred()
    if not r34 goto L41 (error at __iter__:33) else goto L32 :: bool
L32:
    r35 = box(None, 1)
    __mypyc_self__.__mypyc_next_label__ = -1
L33:
    if is_error(stop_iter_ptr) goto L34 else goto L36
L34:
    CPyGen_SetStopIterationValue(r35)
    if not 0 goto L41 else goto L35 :: bool
L35:
    unreachable
L36:
    inc_ref r35
    set_mem stop_iter_ptr, r35 :: builtins.object*
    return 0
L37:
    r37 = r0 == 0
    if r37 goto L1 else goto L38 :: bool
L38:
    r38 = r0 == 1
    if r38 goto L25 else goto L39 :: bool
L39:
    r39 = raise StopIteration
    if not r39 goto L41 (error at __iter__:32) else goto L40 :: bool
L40:
    unreachable
L41:
    r40 = <error> :: object
    return r40
L42:
    dec_ref r4
    goto L41
L43:
    dec_ref r12
    goto L41
L44:
    dec_ref r14
    goto L41
L45:
    dec_ref r14
    goto L31
L46:
    dec_ref r31
    goto L41

def __iter___WeakList_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __iter___WeakList_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __iter___WeakList_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def __iter___WeakList_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def __iter___WeakList_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def WeakList.__iter__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    r1, r2 :: bool
    r3 :: dank_mids.helpers._weaklist.__iter___WeakList_gen
L0:
    r0 = __iter___WeakList_gen()
    if is_error(r0) goto L3 (error at __iter__:32) else goto L1
L1:
    r0.__mypyc_next_label__ = 0
    inc_ref self
    r0.self = self; r2 = is_error
    if not r2 goto L4 (error at __iter__:32) else goto L2 :: bool
L2:
    return r0
L3:
    r3 = <error> :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    return r3
L4:
    dec_ref r0
    goto L3

def WeakList.append(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: str
    r1 :: object
    r2 :: weakref.ReferenceType
    r3 :: dict
    r4 :: int
    r5 :: object
    r6 :: i32
    r7 :: bit
    r8 :: None
L0:
    r0 = '_gc_callback'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L5 (error at append:40) else goto L1
L1:
    r2 = PyWeakref_NewRef(item, r1)
    dec_ref r1
    if is_error(r2) goto L5 (error at append:40) else goto L2
L2:
    r3 = self._refs
    if is_error(r3) goto L6 (error at append:40) else goto L3
L3:
    r4 = CPyTagged_Id(item)
    r5 = box(int, r4)
    r6 = CPyDict_SetItem(r3, r5, r2)
    dec_ref r3
    dec_ref r5
    dec_ref r2
    r7 = r6 >= 0 :: signed
    if not r7 goto L5 (error at append:40) else goto L4 :: bool
L4:
    return 1
L5:
    r8 = <error> :: None
    return r8
L6:
    dec_ref r2
    goto L5

def WeakList.extend(self, items):
    self :: dank_mids.helpers._weaklist.WeakList
    items :: object
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: list
    r4, r5 :: object
    r6 :: int
    r7 :: weakref.ReferenceType
    r8, r9 :: tuple[int, weakref.ReferenceType]
    r10 :: object
    r11 :: i32
    r12, r13 :: bit
    r14 :: i32
    r15 :: bit
    r16 :: None
L0:
    r0 = '_gc_callback'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L10 (error at extend:43) else goto L1
L1:
    r2 = self._refs
    if is_error(r2) goto L11 (error at extend:44) else goto L2
L2:
    r3 = PyList_New(0)
    if is_error(r3) goto L12 (error at extend:44) else goto L3
L3:
    r4 = PyObject_GetIter(items)
    if is_error(r4) goto L13 (error at extend:44) else goto L4
L4:
    r5 = PyIter_Next(r4)
    if is_error(r5) goto L14 else goto L5
L5:
    r6 = CPyTagged_Id(r5)
    r7 = PyWeakref_NewRef(r5, r1)
    dec_ref r5
    if is_error(r7) goto L15 (error at extend:44) else goto L6
L6:
    inc_ref r6 :: int
    inc_ref r7
    r8 = (r6, r7)
    dec_ref r8
    r9 = (r6, r7)
    r10 = box(tuple[int, weakref.ReferenceType], r9)
    r11 = PyList_Append(r3, r10)
    dec_ref r10
    r12 = r11 >= 0 :: signed
    if not r12 goto L16 (error at extend:44) else goto L4 :: bool
L7:
    r13 = CPy_NoErrOccurred()
    if not r13 goto L17 (error at extend:44) else goto L8 :: bool
L8:
    r14 = CPyDict_UpdateFromAny(r2, r3)
    dec_ref r2
    dec_ref r3
    r15 = r14 >= 0 :: signed
    if not r15 goto L10 (error at extend:44) else goto L9 :: bool
L9:
    return 1
L10:
    r16 = <error> :: None
    return r16
L11:
    dec_ref r1
    goto L10
L12:
    dec_ref r1
    dec_ref r2
    goto L10
L13:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    goto L10
L14:
    dec_ref r1
    dec_ref r4
    goto L7
L15:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    dec_ref r6 :: int
    goto L10
L16:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    goto L10
L17:
    dec_ref r2
    dec_ref r3
    goto L10

def WeakList.remove(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: int
    r1 :: dict
    r2, r3 :: object
    reference :: union[object, None]
    r4 :: object
    r5 :: bit
    r6 :: weakref.ReferenceType
    r7 :: object
    r8, r9 :: bit
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: dict
    r18 :: object
    r19 :: i32
    r20 :: bit
    r21 :: None
L0:
    r0 = CPyTagged_Id(item)
    r1 = self._refs
    if is_error(r1) goto L14 (error at remove:48) else goto L1
L1:
    inc_ref r0 :: int
    r2 = box(int, r0)
    r3 = CPyDict_GetWithNone(r1, r2)
    dec_ref r1
    dec_ref r2
    if is_error(r3) goto L14 (error at remove:48) else goto L2
L2:
    reference = r3
    r4 = load_address _Py_NoneStruct
    r5 = reference == r4
    if r5 goto L15 else goto L3 :: bool
L3:
    r6 = cast(weakref.ReferenceType, reference)
    if is_error(r6) goto L14 (error at remove:49) else goto L4
L4:
    r7 = CPyWeakref_GetRef(r6)
    dec_ref r6
    if is_error(r7) goto L14 (error at remove:49) else goto L5
L5:
    r8 = r7 == item
    dec_ref r7
    r9 = r8 ^ 1
    if r9 goto L16 else goto L10 :: bool
L6:
    r10 = 'list.remove(x): x not in list'
    r11 = builtins :: module
    r12 = 'ValueError'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L13 (error at remove:50) else goto L7
L7:
    r14 = [r10]
    r15 = load_address r14
    r16 = PyObject_Vectorcall(r13, r15, 1, 0)
    dec_ref r13
    if is_error(r16) goto L13 (error at remove:50) else goto L8
L8:
    CPy_Raise(r16)
    dec_ref r16
    if not 0 goto L13 (error at remove:50) else goto L9 :: bool
L9:
    unreachable
L10:
    r17 = self._refs
    if is_error(r17) goto L14 (error at remove:51) else goto L11
L11:
    r18 = box(int, r0)
    r19 = PyObject_DelItem(r17, r18)
    dec_ref r17
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L13 (error at remove:51) else goto L12 :: bool
L12:
    return 1
L13:
    r21 = <error> :: None
    return r21
L14:
    dec_ref r0 :: int
    goto L13
L15:
    dec_ref r0 :: int
    dec_ref reference
    goto L6
L16:
    dec_ref r0 :: int
    goto L6

def WeakList._gc_callback(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: dict
    r1 :: int
    r2 :: str
    r3, r4 :: object
    r5 :: object[3]
    r6 :: object_ptr
    r7 :: object
    r8 :: None
L0:
    r0 = self._refs
    if is_error(r0) goto L3 (error at _gc_callback:55) else goto L1
L1:
    r1 = CPyTagged_Id(item)
    r2 = 'pop'
    r3 = box(int, r1)
    r4 = box(None, 1)
    r5 = [r0, r3, r4]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r2, r6, 9223372036854775811, 0)
    if is_error(r7) goto L4 (error at _gc_callback:55) else goto L5
L2:
    dec_ref r0
    dec_ref r3
    return 1
L3:
    r8 = <error> :: None
    return r8
L4:
    dec_ref r0
    dec_ref r3
    goto L3
L5:
    dec_ref r7
    goto L2

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13 :: str
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20 :: dict
    r21 :: str
    r22 :: i32
    r23 :: bit
    r24 :: dict
    r25 :: str
    r26 :: object
    r27 :: dict
    r28 :: str
    r29 :: object
    r30 :: list
    r31, r32 :: ptr
    r33 :: object
    r34 :: tuple[list, object]
    r35, r36 :: object
    r37 :: dict
    r38 :: str
    r39 :: i32
    r40 :: bit
    r41 :: dict
    r42 :: str
    r43 :: object
    r44 :: dict
    r45 :: str
    r46, r47 :: object
    r48 :: tuple
    r49 :: str
    r50, r51 :: object
    r52 :: bool
    r53, r54, r55 :: str
    r56 :: tuple
    r57 :: i32
    r58 :: bit
    r59 :: dict
    r60 :: str
    r61 :: i32
    r62 :: bit
    r63 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L23 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Callable', 'Dict', 'Final', 'Generic', 'Iterable', 'Iterator', 'Optional', 'TypeVar', 'final')
    r6 = 'typing'
    r7 = dank_mids.helpers._weaklist.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L23 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ref',)
    r10 = 'weakref'
    r11 = dank_mids.helpers._weaklist.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L23 (error at <module>:2) else goto L5
L5:
    weakref = r12 :: module
    dec_ref r12
    r13 = '_T'
    r14 = dank_mids.helpers._weaklist.globals :: static
    r15 = 'TypeVar'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L23 (error at <module>:5) else goto L6
L6:
    r17 = [r13]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r16, r18, 1, 0)
    dec_ref r16
    if is_error(r19) goto L23 (error at <module>:5) else goto L7
L7:
    r20 = dank_mids.helpers._weaklist.globals :: static
    r21 = '_T'
    r22 = CPyDict_SetItem(r20, r21, r19)
    dec_ref r19
    r23 = r22 >= 0 :: signed
    if not r23 goto L23 (error at <module>:5) else goto L8 :: bool
L8:
    r24 = dank_mids.helpers._weaklist.globals :: static
    r25 = 'Callable'
    r26 = CPyDict_GetItem(r24, r25)
    if is_error(r26) goto L23 (error at <module>:7) else goto L9
L9:
    r27 = dank_mids.helpers._weaklist.globals :: static
    r28 = 'Any'
    r29 = CPyDict_GetItem(r27, r28)
    if is_error(r29) goto L24 (error at <module>:7) else goto L10
L10:
    r30 = PyList_New(1)
    if is_error(r30) goto L25 (error at <module>:7) else goto L11
L11:
    r31 = get_element_ptr r30 ob_item :: PyListObject
    r32 = load_mem r31 :: ptr*
    set_mem r32, r29 :: builtins.object*
    r33 = box(None, 1)
    inc_ref r33
    r34 = (r30, r33)
    r35 = box(tuple[list, object], r34)
    r36 = PyObject_GetItem(r26, r35)
    dec_ref r26
    dec_ref r35
    if is_error(r36) goto L23 (error at <module>:7) else goto L12
L12:
    r37 = dank_mids.helpers._weaklist.globals :: static
    r38 = 'GCCallback'
    r39 = CPyDict_SetItem(r37, r38, r36)
    dec_ref r36
    r40 = r39 >= 0 :: signed
    if not r40 goto L23 (error at <module>:7) else goto L13 :: bool
L13:
    r41 = dank_mids.helpers._weaklist.globals :: static
    r42 = 'Generic'
    r43 = CPyDict_GetItem(r41, r42)
    if is_error(r43) goto L23 (error at <module>:11) else goto L14
L14:
    r44 = dank_mids.helpers._weaklist.globals :: static
    r45 = '_T'
    r46 = CPyDict_GetItem(r44, r45)
    if is_error(r46) goto L26 (error at <module>:11) else goto L15
L15:
    r47 = PyObject_GetItem(r43, r46)
    dec_ref r43
    dec_ref r46
    if is_error(r47) goto L23 (error at <module>:11) else goto L16
L16:
    r48 = PyTuple_Pack(1, r47)
    dec_ref r47
    if is_error(r48) goto L23 (error at <module>:11) else goto L17
L17:
    r49 = 'dank_mids.helpers._weaklist'
    r50 = dank_mids.helpers._weaklist.WeakList_template :: type
    r51 = CPyType_FromTemplate(r50, r48, r49)
    dec_ref r48
    if is_error(r51) goto L23 (error at <module>:11) else goto L18
L18:
    r52 = WeakList_trait_vtable_setup()
    if is_error(r52) goto L27 (error at <module>:-1) else goto L19
L19:
    r53 = '__mypyc_attrs__'
    r54 = '_refs'
    r55 = '__dict__'
    r56 = PyTuple_Pack(2, r54, r55)
    if is_error(r56) goto L27 (error at <module>:11) else goto L20
L20:
    r57 = PyObject_SetAttr(r51, r53, r56)
    dec_ref r56
    r58 = r57 >= 0 :: signed
    if not r58 goto L27 (error at <module>:11) else goto L21 :: bool
L21:
    dank_mids.helpers._weaklist.WeakList = r51 :: type
    r59 = dank_mids.helpers._weaklist.globals :: static
    r60 = 'WeakList'
    r61 = CPyDict_SetItem(r59, r60, r51)
    dec_ref r51
    r62 = r61 >= 0 :: signed
    if not r62 goto L23 (error at <module>:11) else goto L22 :: bool
L22:
    return 1
L23:
    r63 = <error> :: None
    return r63
L24:
    dec_ref r26
    goto L23
L25:
    dec_ref r26
    dec_ref r29
    goto L23
L26:
    dec_ref r43
    goto L23
L27:
    dec_ref r51
    goto L23

def coroutine__patch_overloaded_method_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def coroutine_gen___23.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine_gen___23
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1 :: object
    r2 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_env
    r3 :: i32
    r4 :: dank_mids.brownie_patch.overloaded._patch_overloaded_method_env
    r5 :: object
    r6 :: bit
    r7 :: object
    r8 :: tuple
    r9 :: str
    r10 :: object[2]
    r11 :: object_ptr
    r12 :: object
    r13 :: bool
    r14 :: tuple[object, object, object]
    r15 :: bool
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: bit
    r20 :: object
    r21 :: bool
    r22 :: object
    r23 :: str
    r24 :: bool
    r25 :: str
    r26 :: object
    r27 :: str
    r28 :: object
    r29, r30, r31 :: str
    r32 :: object
    r33 :: str
    r34 :: object
    r35, r36 :: str
    r37 :: tuple[str, str]
    r38, r39 :: bool
    r40 :: tuple[str, str]
    r41, r42 :: object
    r43, r44 :: bool
    r45, r46 :: object
    r47 :: str
    r48 :: bool
    r49, r50 :: str
    r51 :: i32
    r52 :: bit
    r53, r54 :: bool
    r55 :: bit
    r56, r57 :: str
    r58 :: int
    r59 :: bool
    r60 :: str
    r61 :: int
    r62 :: object
    r63, r64, r65 :: str
    r66 :: int
    r67 :: object
    r68, r69 :: str
    r70 :: object
    r71 :: str
    r72 :: object
    r73 :: object[1]
    r74 :: object_ptr
    r75 :: object
    r76 :: tuple[object, object, object]
    r77 :: bit
    r78 :: str
    r79 :: union[int, str, bytes, None]
    r80 :: str
    r81 :: union[int, None]
    r82 :: str
    r83 :: union[dict, None]
    r84 :: dict
    r85 :: bool
    r86 :: dict
    r87 :: bool
    r88 :: dict
    r89, r90 :: bool
    r91 :: dict
    r92 :: native_int
    r93 :: bool
    r94 :: object
    r95 :: bool
    r96 :: object
    r97 :: short_int
    r98 :: tuple[bool, short_int, object, object]
    r99 :: short_int
    r100, r101 :: bool
    r102, r103 :: object
    r104 :: str
    r105 :: union[int, str, bytes, None, dict]
    r106, r107 :: bool
    r108 :: union[int, str, bytes, None, dict]
    r109 :: object
    r110 :: bit
    r111 :: str
    r112 :: union[int, str, bytes, None, dict]
    r113 :: union[int, str, bytes, dict]
    r114 :: dict
    r115 :: i32
    r116 :: bit
    r117 :: dict
    r118 :: native_int
    r119, r120 :: bit
    r121 :: dict
    r122 :: bool
    r123 :: object
    r124 :: tuple
    r125 :: dict
    r126 :: str
    r127 :: object
    r128 :: list
    r129 :: object
    r130 :: dict
    r131 :: i32
    r132 :: bit
    r133 :: tuple
    r134, r135 :: object
    r136 :: bool
    r137, r138, r139, r140, r141 :: object
    r142 :: bool
    r143 :: object
    r144 :: bool
    r145 :: object
    r146 :: bit
    r147 :: tuple[object, object, object]
    r148 :: bool
    r149 :: object_ptr
    r150 :: object
    r151 :: bool
    r152, r153, r154 :: tuple[object, object, object]
    r155 :: bit
    r156, r157, r158 :: object
    r159 :: bool
    r160, r161 :: bit
    r162 :: bool
    r163 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_env__
    if is_error(r2) goto L146 (error at coroutine:23) else goto L1
L1:
    r3 = r2.__mypyc_next_label__
    r4 = r2.__mypyc_env__
    if is_error(r4) goto L147 (error at coroutine:23) else goto L141
L2:
    r5 = load_address _Py_NoneStruct
    r6 = type != r5
    if r6 goto L148 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L145 (error at coroutine:23) else goto L4 :: bool
L4:
    unreachable
L5:
    r7 = r2.self
    if is_error(r7) goto L9 (error at coroutine:44) else goto L6
L6:
    r8 = r2.args
    if is_error(r8) goto L149 (error at coroutine:44) else goto L7
L7:
    r9 = '_get_fn_from_args'
    r10 = [r7, r8]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775810, 0)
    if is_error(r12) goto L150 (error at coroutine:44) else goto L8
L8:
    dec_ref r7
    dec_ref r8
    r2.fn = r12; r13 = is_error
    if not r13 goto L9 (error at coroutine:44) else goto L151 :: bool
L9:
    r14 = CPy_CatchError()
    r2.__mypyc_temp__0 = r14; r15 = is_error
    if not r15 goto L152 (error at coroutine:-1) else goto L10 :: bool
L10:
    r16 = builtins :: module
    r17 = 'ValueError'
    r18 = CPyObject_GetAttr(r16, r17)
    if is_error(r18) goto L152 (error at coroutine:45) else goto L11
L11:
    r19 = CPy_ExceptionMatches(r18)
    dec_ref r18
    if r19 goto L12 else goto L153 :: bool
L12:
    r20 = CPy_GetExcValue()
    r2.e = r20; r21 = is_error
    if not r21 goto L152 (error at coroutine:45) else goto L13 :: bool
L13:
    r22 = r2.e
    if is_error(r22) goto L152 (error at coroutine:46) else goto L14
L14:
    r23 = PyObject_Str(r22)
    dec_ref r22
    if is_error(r23) goto L152 (error at coroutine:46) else goto L15
L15:
    r2.exc_str = r23; r24 = is_error
    if not r24 goto L152 (error at coroutine:46) else goto L16 :: bool
L16:
    r25 = "Contract has more than one function '."
    r26 = r4.call
    if is_error(r26) goto L152 (error at coroutine:48) else goto L17
L17:
    r27 = '_name'
    r28 = CPyObject_GetAttr(r26, r27)
    dec_ref r26
    if is_error(r28) goto L152 (error at coroutine:48) else goto L18
L18:
    r29 = PyObject_Str(r28)
    dec_ref r28
    if is_error(r29) goto L152 (error at coroutine:48) else goto L19
L19:
    r30 = CPyStr_Build(2, r25, r29)
    dec_ref r29
    if is_error(r30) goto L152 (error at coroutine:48) else goto L20
L20:
    r31 = 'You must explicitly declare which function you are calling, e.g. .'
    r32 = r4.call
    dec_ref r4
    if is_error(r32) goto L154 (error at coroutine:49) else goto L21
L21:
    r33 = '_name'
    r34 = CPyObject_GetAttr(r32, r33)
    dec_ref r32
    if is_error(r34) goto L154 (error at coroutine:49) else goto L22
L22:
    r35 = PyObject_Str(r34)
    dec_ref r34
    if is_error(r35) goto L154 (error at coroutine:49) else goto L23
L23:
    r36 = CPyStr_Build(2, r31, r35)
    dec_ref r35
    if is_error(r36) goto L154 (error at coroutine:49) else goto L24
L24:
    r37 = (r30, r36)
    r2.match_on = r37; r38 = is_error
    if not r38 goto L60 (error at coroutine:47) else goto L25 :: bool
L25:
    r39 = 1
    r40 = r2.match_on
    if is_error(r40) goto L60 (error at coroutine:51) else goto L26
L26:
    inc_ref r40
    r41 = box(tuple[str, str], r40)
    r42 = PyObject_GetIter(r41)
    dec_ref r41
    if is_error(r42) goto L155 (error at coroutine:51) else goto L27
L27:
    r2.__mypyc_temp__1 = r40; r43 = is_error
    if not r43 goto L156 (error at coroutine:-1) else goto L28 :: bool
L28:
    r2.__mypyc_temp__2 = r42; r44 = is_error
    if not r44 goto L60 (error at coroutine:-1) else goto L29 :: bool
L29:
    r45 = r2.__mypyc_temp__2
    if is_error(r45) goto L60 (error at coroutine:51) else goto L30
L30:
    r46 = PyIter_Next(r45)
    dec_ref r45
    if is_error(r46) goto L38 else goto L31
L31:
    r47 = cast(str, r46)
    if is_error(r47) goto L60 (error at coroutine:51) else goto L32
L32:
    r2.s = r47; r48 = is_error
    if not r48 goto L60 (error at coroutine:51) else goto L33 :: bool
L33:
    r49 = r2.s
    if is_error(r49) goto L60 (error at coroutine:51) else goto L34
L34:
    r50 = r2.exc_str
    if is_error(r50) goto L157 (error at coroutine:51) else goto L35
L35:
    r51 = PyUnicode_Contains(r50, r49)
    dec_ref r50
    dec_ref r49
    r52 = r51 >= 0 :: signed
    if not r52 goto L60 (error at coroutine:51) else goto L36 :: bool
L36:
    r53 = truncate r51: i32 to builtins.bool
    r54 = r53 ^ 1
    if r54 goto L37 else goto L29 :: bool
L37:
    r39 = 0
    goto L39
L38:
    r55 = CPy_NoErrOccurred()
    if not r55 goto L60 (error at coroutine:51) else goto L39 :: bool
L39:
    if r39 goto L40 else goto L56 :: bool
L40:
    r56 = r2.exc_str
    if is_error(r56) goto L60 (error at coroutine:52) else goto L41
L41:
    r57 = '(*args)'
    r58 = CPyStr_Find(r56, r57, 0, 1)
    dec_ref r56
    if is_error(r58) goto L60 (error at coroutine:52) else goto L42
L42:
    r2.breakpoint = r58; r59 = is_error
    if not r59 goto L60 (error at coroutine:52) else goto L43 :: bool
L43:
    r60 = r2.exc_str
    if is_error(r60) goto L60 (error at coroutine:53) else goto L44
L44:
    r61 = r2.breakpoint
    if is_error(r61) goto L158 (error at coroutine:53) else goto L45
L45:
    r62 = CPyStr_GetSlice(r60, 0, r61)
    dec_ref r60
    dec_ref r61 :: int
    if is_error(r62) goto L60 (error at coroutine:53) else goto L46
L46:
    r63 = cast(str, r62)
    if is_error(r63) goto L60 (error at coroutine:53) else goto L47
L47:
    r64 = '.coroutine'
    r65 = r2.exc_str
    if is_error(r65) goto L159 (error at coroutine:53) else goto L48
L48:
    r66 = r2.breakpoint
    if is_error(r66) goto L160 (error at coroutine:53) else goto L49
L49:
    r67 = CPyStr_GetSlice(r65, r66, 9223372036854775806)
    dec_ref r65
    dec_ref r66 :: int
    if is_error(r67) goto L159 (error at coroutine:53) else goto L50
L50:
    r68 = cast(str, r67)
    if is_error(r68) goto L159 (error at coroutine:53) else goto L51
L51:
    r69 = CPyStr_Build(3, r63, r64, r68)
    dec_ref r63
    dec_ref r68
    if is_error(r69) goto L60 (error at coroutine:53) else goto L52
L52:
    r70 = builtins :: module
    r71 = 'ValueError'
    r72 = CPyObject_GetAttr(r70, r71)
    if is_error(r72) goto L161 (error at coroutine:53) else goto L53
L53:
    r73 = [r69]
    r74 = load_address r73
    r75 = PyObject_Vectorcall(r72, r74, 1, 0)
    dec_ref r72
    if is_error(r75) goto L161 (error at coroutine:53) else goto L54
L54:
    dec_ref r69
    CPy_Raise(r75)
    dec_ref r75
    if not 0 goto L60 (error at coroutine:53) else goto L162 :: bool
L55:
    unreachable
L56:
    CPy_Reraise()
    if not 0 goto L60 else goto L163 :: bool
L57:
    unreachable
L58:
    CPy_Reraise()
    if not 0 goto L60 else goto L164 :: bool
L59:
    unreachable
L60:
    r76 = r2.__mypyc_temp__0
    dec_ref r2
    if is_error(r76) goto L145 (error at coroutine:-1) else goto L61
L61:
    CPy_RestoreExcInfo(r76)
    dec_ref r76
    r77 = CPy_KeepPropagating()
    if not r77 goto L145 else goto L62 :: bool
L62:
    unreachable
L63:
    r78 = 'block_identifier'
    r79 = r2.block_identifier
    if is_error(r79) goto L165 (error at coroutine:56) else goto L64
L64:
    r80 = 'decimals'
    r81 = r2.decimals
    if is_error(r81) goto L166 (error at coroutine:56) else goto L65
L65:
    r82 = 'override'
    r83 = r2.override
    if is_error(r83) goto L167 (error at coroutine:56) else goto L66
L66:
    r84 = CPyDict_Build(3, r78, r79, r80, r81, r82, r83)
    dec_ref r79
    dec_ref r81
    dec_ref r83
    if is_error(r84) goto L165 (error at coroutine:56) else goto L67
L67:
    r2.kwargs = r84; r85 = is_error
    if not r85 goto L165 (error at coroutine:56) else goto L68 :: bool
L68:
    r86 = PyDict_New()
    if is_error(r86) goto L165 (error at coroutine:57) else goto L69
L69:
    r2.__mypyc_temp__3 = r86; r87 = is_error
    if not r87 goto L165 (error at coroutine:-1) else goto L70 :: bool
L70:
    r88 = r2.kwargs
    if is_error(r88) goto L165 (error at coroutine:57) else goto L71
L71:
    inc_ref r88
    r2.__mypyc_temp__4 = r88; r89 = is_error
    if not r89 goto L168 (error at coroutine:-1) else goto L72 :: bool
L72:
    r2.__mypyc_temp__5 = 0; r90 = is_error
    if not r90 goto L168 (error at coroutine:-1) else goto L73 :: bool
L73:
    r91 = r2.__mypyc_temp__4
    if is_error(r91) goto L168 (error at coroutine:57) else goto L74
L74:
    r92 = PyDict_Size(r91)
    dec_ref r91
    r2.__mypyc_temp__6 = r92; r93 = is_error
    if not r93 goto L168 (error at coroutine:-1) else goto L75 :: bool
L75:
    r94 = CPyDict_GetItemsIter(r88)
    dec_ref r88
    if is_error(r94) goto L165 (error at coroutine:57) else goto L76
L76:
    r2.__mypyc_temp__7 = r94; r95 = is_error
    if not r95 goto L165 (error at coroutine:-1) else goto L77 :: bool
L77:
    r96 = r2.__mypyc_temp__7
    if is_error(r96) goto L165 (error at coroutine:57) else goto L78
L78:
    r97 = r2.__mypyc_temp__5
    if is_error(r97) goto L169 (error at coroutine:57) else goto L79
L79:
    r98 = CPyDict_NextItem(r96, r97)
    dec_ref r96
    r99 = r98[1]
    r2.__mypyc_temp__5 = r99; r100 = is_error
    if not r100 goto L170 (error at coroutine:57) else goto L80 :: bool
L80:
    r101 = r98[0]
    if r101 goto L81 else goto L171 :: bool
L81:
    r102 = r98[2]
    r103 = r98[3]
    dec_ref r98
    r104 = cast(str, r102)
    if is_error(r104) goto L172 (error at coroutine:57) else goto L82
L82:
    r105 = cast(union[int, str, bytes, None, dict], r103)
    if is_error(r105) goto L173 (error at coroutine:57) else goto L83
L83:
    r2.k = r104; r106 = is_error
    if not r106 goto L174 (error at coroutine:57) else goto L84 :: bool
L84:
    r2.v = r105; r107 = is_error
    if not r107 goto L165 (error at coroutine:57) else goto L85 :: bool
L85:
    r108 = r2.v
    if is_error(r108) goto L165 (error at coroutine:57) else goto L86
L86:
    r109 = load_address _Py_NoneStruct
    r110 = r108 != r109
    dec_ref r108
    if r110 goto L87 else goto L92 :: bool
L87:
    r111 = r2.k
    if is_error(r111) goto L165 (error at coroutine:57) else goto L88
L88:
    r112 = r2.v
    if is_error(r112) goto L175 (error at coroutine:57) else goto L89
L89:
    r113 = cast(union[int, str, bytes, dict], r112)
    if is_error(r113) goto L175 (error at coroutine:57) else goto L90
L90:
    r114 = r2.__mypyc_temp__3
    if is_error(r114) goto L176 (error at coroutine:-1) else goto L91
L91:
    r115 = CPyDict_SetItem(r114, r111, r113)
    dec_ref r114
    dec_ref r111
    dec_ref r113
    r116 = r115 >= 0 :: signed
    if not r116 goto L165 (error at coroutine:57) else goto L92 :: bool
L92:
    r117 = r2.__mypyc_temp__4
    if is_error(r117) goto L165 (error at coroutine:57) else goto L93
L93:
    r118 = r2.__mypyc_temp__6
    if is_error(r118) goto L177 (error at coroutine:57) else goto L94
L94:
    r119 = CPyDict_CheckSize(r117, r118)
    dec_ref r117
    if not r119 goto L165 (error at coroutine:57) else goto L77 :: bool
L95:
    r120 = CPy_NoErrOccurred()
    if not r120 goto L165 (error at coroutine:57) else goto L96 :: bool
L96:
    r121 = r2.__mypyc_temp__3
    if is_error(r121) goto L165 (error at coroutine:-1) else goto L97
L97:
    r2.kwargs = r121; r122 = is_error
    if not r122 goto L165 (error at coroutine:57) else goto L98 :: bool
L98:
    r123 = r2.fn
    if is_error(r123) goto L165 (error at coroutine:58) else goto L99
L99:
    r124 = r2.args
    if is_error(r124) goto L178 (error at coroutine:58) else goto L100
L100:
    r125 = r2.kwargs
    if is_error(r125) goto L179 (error at coroutine:58) else goto L101
L101:
    r126 = 'coroutine'
    r127 = CPyObject_GetAttr(r123, r126)
    dec_ref r123
    if is_error(r127) goto L180 (error at coroutine:58) else goto L102
L102:
    r128 = PyList_New(0)
    if is_error(r128) goto L181 (error at coroutine:58) else goto L103
L103:
    r129 = CPyList_Extend(r128, r124)
    dec_ref r124
    if is_error(r129) goto L182 (error at coroutine:58) else goto L183
L104:
    r130 = PyDict_New()
    if is_error(r130) goto L182 (error at coroutine:58) else goto L105
L105:
    r131 = CPyDict_UpdateInDisplay(r130, r125)
    dec_ref r125
    r132 = r131 >= 0 :: signed
    if not r132 goto L184 (error at coroutine:58) else goto L106 :: bool
L106:
    r133 = PyList_AsTuple(r128)
    dec_ref r128
    if is_error(r133) goto L185 (error at coroutine:58) else goto L107
L107:
    r134 = PyObject_Call(r127, r133, r130)
    dec_ref r127
    dec_ref r133
    dec_ref r130
    if is_error(r134) goto L165 (error at coroutine:58) else goto L108
L108:
    r135 = CPy_GetCoro(r134)
    dec_ref r134
    if is_error(r135) goto L165 (error at coroutine:58) else goto L109
L109:
    r2.__mypyc_temp__8 = r135; r136 = is_error
    if not r136 goto L165 (error at coroutine:-1) else goto L110 :: bool
L110:
    r137 = r2.__mypyc_temp__8
    if is_error(r137) goto L165 (error at coroutine:-1) else goto L111
L111:
    r138 = CPyIter_Next(r137)
    dec_ref r137
    if is_error(r138) goto L112 else goto L114
L112:
    r139 = CPy_FetchStopIterationValue()
    if is_error(r139) goto L165 (error at coroutine:58) else goto L113
L113:
    r140 = r139
    r141 = <error> :: object
    r2.__mypyc_temp__8 = r141; r142 = is_error
    if not r142 goto L186 (error at coroutine:58) else goto L136 :: bool
L114:
    r143 = r138
L115:
    r2.__mypyc_next_label__ = 1
    dec_ref r2
    return r143
L116:
    r145 = load_address _Py_NoneStruct
    r146 = type != r145
    if r146 goto L117 else goto L187 :: bool
L117:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L120 (error at coroutine:58) else goto L188 :: bool
L118:
    unreachable
L119:
    inc_ref arg
    goto L131
L120:
    r147 = CPy_CatchError()
    r2.__mypyc_temp__9 = r147; r148 = is_error
    if not r148 goto L189 (error at coroutine:-1) else goto L121 :: bool
L121:
    r149 = load_address r1
    r150 = r2.__mypyc_temp__8
    if is_error(r150) goto L189 (error at coroutine:-1) else goto L122
L122:
    r151 = CPy_YieldFromErrorHandle(r150, r149)
    dec_ref r150
    if is_error(r151) goto L189 (error at coroutine:58) else goto L123
L123:
    if r151 goto L126 else goto L124 :: bool
L124:
    r143 = r1
    r152 = r2.__mypyc_temp__9
    if is_error(r152) goto L190 (error at coroutine:-1) else goto L125
L125:
    CPy_RestoreExcInfo(r152)
    dec_ref r152
    goto L115
L126:
    r140 = r1
    r153 = r2.__mypyc_temp__9
    if is_error(r153) goto L191 (error at coroutine:-1) else goto L127
L127:
    CPy_RestoreExcInfo(r153)
    dec_ref r153
    goto L136
L128:
    r154 = r2.__mypyc_temp__9
    dec_ref r2
    if is_error(r154) goto L145 (error at coroutine:-1) else goto L129
L129:
    CPy_RestoreExcInfo(r154)
    dec_ref r154
    r155 = CPy_KeepPropagating()
    if not r155 goto L145 else goto L130 :: bool
L130:
    unreachable
L131:
    r156 = r2.__mypyc_temp__8
    if is_error(r156) goto L192 (error at coroutine:-1) else goto L132
L132:
    r157 = CPyIter_Send(r156, arg)
    dec_ref r156
    dec_ref arg
    if is_error(r157) goto L134 else goto L133
L133:
    r143 = r157
    goto L115
L134:
    r158 = CPy_FetchStopIterationValue()
    if is_error(r158) goto L165 (error at coroutine:58) else goto L135
L135:
    r140 = r158
L136:
    r2.__mypyc_next_label__ = -1
    dec_ref r2
L137:
    if is_error(stop_iter_ptr) goto L138 else goto L140
L138:
    CPyGen_SetStopIterationValue(r140)
    dec_ref r140
    if not 0 goto L145 else goto L139 :: bool
L139:
    unreachable
L140:
    set_mem stop_iter_ptr, r140 :: builtins.object*
    return 0
L141:
    r160 = r3 == 0
    if r160 goto L193 else goto L194 :: bool
L142:
    r161 = r3 == 1
    if r161 goto L116 else goto L195 :: bool
L143:
    r162 = raise StopIteration
    if not r162 goto L145 (error at coroutine:23) else goto L144 :: bool
L144:
    unreachable
L145:
    r163 = <error> :: object
    return r163
L146:
    xdec_ref r1
    goto L145
L147:
    xdec_ref r1
    dec_ref r2
    goto L145
L148:
    dec_ref r2
    dec_ref r4
    goto L3
L149:
    dec_ref r7
    goto L9
L150:
    dec_ref r7
    dec_ref r8
    goto L9
L151:
    dec_ref r4
    goto L63
L152:
    dec_ref r4
    goto L60
L153:
    dec_ref r4
    goto L58
L154:
    dec_ref r30
    goto L60
L155:
    dec_ref r40
    goto L60
L156:
    dec_ref r42
    goto L60
L157:
    dec_ref r49
    goto L60
L158:
    dec_ref r60
    goto L60
L159:
    dec_ref r63
    goto L60
L160:
    dec_ref r63
    dec_ref r65
    goto L60
L161:
    dec_ref r69
    goto L60
L162:
    dec_ref r2
    goto L55
L163:
    dec_ref r2
    goto L57
L164:
    dec_ref r2
    goto L59
L165:
    dec_ref r2
    goto L145
L166:
    dec_ref r2
    dec_ref r79
    goto L145
L167:
    dec_ref r2
    dec_ref r79
    dec_ref r81
    goto L145
L168:
    dec_ref r2
    dec_ref r88
    goto L145
L169:
    dec_ref r2
    dec_ref r96
    goto L145
L170:
    dec_ref r2
    dec_ref r98
    goto L145
L171:
    dec_ref r98
    goto L95
L172:
    dec_ref r2
    dec_ref r103
    goto L145
L173:
    dec_ref r2
    dec_ref r104
    goto L145
L174:
    dec_ref r2
    dec_ref r105
    goto L145
L175:
    dec_ref r2
    dec_ref r111
    goto L145
L176:
    dec_ref r2
    dec_ref r111
    dec_ref r113
    goto L145
L177:
    dec_ref r2
    dec_ref r117
    goto L145
L178:
    dec_ref r2
    dec_ref r123
    goto L145
L179:
    dec_ref r2
    dec_ref r123
    dec_ref r124
    goto L145
L180:
    dec_ref r2
    dec_ref r124
    dec_ref r125
    goto L145
L181:
    dec_ref r2
    dec_ref r124
    dec_ref r125
    dec_ref r127
    goto L145
L182:
    dec_ref r2
    dec_ref r125
    dec_ref r127
    dec_ref r128
    goto L145
L183:
    dec_ref r129
    goto L104
L184:
    dec_ref r2
    dec_ref r127
    dec_ref r128
    dec_ref r130
    goto L145
L185:
    dec_ref r2
    dec_ref r127
    dec_ref r130
    goto L145
L186:
    dec_ref r2
    dec_ref r140
    goto L145
L187:
    xdec_ref r1
    goto L119
L188:
    xdec_ref r1
    dec_ref r2
    goto L118
L189:
    xdec_ref r1
    goto L128
L190:
    dec_ref r143
    goto L128
L191:
    dec_ref r140
    goto L128
L192:
    dec_ref r2
    dec_ref arg
    goto L145
L193:
    xdec_ref r1
    goto L2
L194:
    dec_ref r4
    goto L142
L195:
    xdec_ref r1
    dec_ref r2
    goto L143

def coroutine_gen___23.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine_gen___23
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine_gen___23.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine_gen___23.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine_gen___23
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine_gen___23.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine_gen___23.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine_gen___23
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine_gen___23.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine_gen___23
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutine_gen___23.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutine_gen___23.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine_gen___23
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def coroutine_gen___23.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine_gen___23
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine__patch_overloaded_method_obj.__call__(__mypyc_self__, self, args, block_identifier, decimals, override):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_obj
    self :: object
    args :: tuple
    block_identifier :: union[int, str, bytes, None]
    decimals :: union[int, None]
    override :: union[dict, None]
    r0 :: dank_mids.brownie_patch.overloaded._patch_overloaded_method_env
    r1, r2, r3 :: object
    r4 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_env
    r5, r6, r7, r8, r9, r10 :: bool
    r11 :: dank_mids.brownie_patch.overloaded.coroutine_gen___23
    r12, r13 :: bool
    r14 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L17 (error at coroutine:23) else goto L1
L1:
    if is_error(block_identifier) goto L2 else goto L18
L2:
    r1 = box(None, 1)
    inc_ref r1
    block_identifier = r1
L3:
    if is_error(decimals) goto L4 else goto L19
L4:
    r2 = box(None, 1)
    inc_ref r2
    decimals = r2
L5:
    if is_error(override) goto L6 else goto L20
L6:
    r3 = box(None, 1)
    inc_ref r3
    override = r3
L7:
    r4 = coroutine__patch_overloaded_method_env()
    if is_error(r4) goto L21 (error at coroutine:23) else goto L8
L8:
    r4.__mypyc_env__ = r0; r5 = is_error
    if not r5 goto L22 (error at coroutine:23) else goto L9 :: bool
L9:
    inc_ref self
    r4.self = self; r6 = is_error
    if not r6 goto L22 (error at coroutine:23) else goto L10 :: bool
L10:
    inc_ref args
    r4.args = args; r7 = is_error
    if not r7 goto L22 (error at coroutine:23) else goto L11 :: bool
L11:
    r4.block_identifier = block_identifier; r8 = is_error
    if not r8 goto L23 (error at coroutine:23) else goto L12 :: bool
L12:
    r4.decimals = decimals; r9 = is_error
    if not r9 goto L24 (error at coroutine:23) else goto L13 :: bool
L13:
    r4.override = override; r10 = is_error
    if not r10 goto L25 (error at coroutine:23) else goto L14 :: bool
L14:
    r11 = coroutine_gen___23()
    if is_error(r11) goto L25 (error at coroutine:23) else goto L15
L15:
    inc_ref r4
    r11.__mypyc_env__ = r4; r12 = is_error
    if not r12 goto L26 (error at coroutine:23) else goto L16 :: bool
L16:
    r4.__mypyc_next_label__ = 0
    dec_ref r4
    return r11
L17:
    r14 = <error> :: object
    return r14
L18:
    inc_ref block_identifier
    goto L3
L19:
    inc_ref decimals
    goto L5
L20:
    inc_ref override
    goto L7
L21:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r0
    goto L17
L22:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L17
L23:
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L17
L24:
    dec_ref override
    dec_ref r4
    goto L17
L25:
    dec_ref r4
    goto L17
L26:
    dec_ref r4
    dec_ref r11
    goto L17

def _patch_overloaded_method(call, w3):
    call, w3 :: object
    r0 :: dank_mids.brownie_patch.overloaded._patch_overloaded_method_env
    r1 :: bool
    r2 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_obj
    r3 :: bool
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: i32
    r17 :: bit
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: str
    r24 :: object[1]
    r25 :: object_ptr
    r26, r27, r28 :: object
    r29 :: dict
    r30 :: str
    r31 :: object
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: tuple[object, object]
    r36 :: object
    r37 :: i32
    r38 :: bit
    r39 :: bool
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: object
    r45 :: set
    r46 :: i32
    r47 :: bit
    r48 :: bool
    r49 :: str
    r50 :: object
    r51 :: i32
    r52 :: bit
    r53 :: str
    r54 :: object
    r55 :: str
    r56 :: object
    r57 :: int
    r58 :: dict
    r59 :: str
    r60, r61 :: object
    r62 :: object[2]
    r63 :: object_ptr
    r64 :: object
    r65 :: dict
    r66 :: str
    r67 :: object
    r68 :: object[2]
    r69 :: object_ptr
    r70 :: object
    r71 :: str
    r72 :: i32
    r73, r74 :: bit
    r75 :: object
    r76 :: dict
    r77 :: str
    r78 :: object
    r79 :: object[2]
    r80 :: object_ptr
    r81, r82 :: object
    r83 :: str
    r84 :: i32
    r85 :: bit
    r86 :: None
L0:
    r0 = _patch_overloaded_method_env()
    if is_error(r0) goto L39 (error at _patch_overloaded_method:11) else goto L1
L1:
    inc_ref call
    r0.call = call; r1 = is_error
    if not r1 goto L40 (error at _patch_overloaded_method:11) else goto L2 :: bool
L2:
    r2 = coroutine__patch_overloaded_method_obj()
    if is_error(r2) goto L40 (error at _patch_overloaded_method:23) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L41 (error at _patch_overloaded_method:23) else goto L4 :: bool
L4:
    r4 = r0.call
    if is_error(r4) goto L41 (error at _patch_overloaded_method:22) else goto L5
L5:
    r5 = dank_mids.brownie_patch.overloaded.globals :: static
    r6 = 'wraps'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L42 (error at _patch_overloaded_method:22) else goto L6
L6:
    r8 = [r4]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L42 (error at _patch_overloaded_method:22) else goto L7
L7:
    dec_ref r4
    r11 = [r2]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r10, r12, 1, 0)
    dec_ref r10
    if is_error(r13) goto L41 (error at _patch_overloaded_method:23) else goto L8
L8:
    dec_ref r2
    inc_ref r13
    r14 = dank_mids.brownie_patch.overloaded.globals :: static
    r15 = 'coroutine'
    r16 = CPyDict_SetItem(r14, r15, r13)
    dec_ref r13
    r17 = r16 >= 0 :: signed
    if not r17 goto L43 (error at _patch_overloaded_method:23) else goto L9 :: bool
L9:
    r18 = r0.call
    if is_error(r18) goto L43 (error at _patch_overloaded_method:60) else goto L10
L10:
    r19 = '__dict__'
    r20 = CPyObject_GetAttr(r18, r19)
    dec_ref r18
    if is_error(r20) goto L43 (error at _patch_overloaded_method:60) else goto L11
L11:
    r21 = 'methods'
    r22 = PyObject_GetItem(r20, r21)
    dec_ref r20
    if is_error(r22) goto L43 (error at _patch_overloaded_method:60) else goto L12
L12:
    r23 = 'values'
    r24 = [r22]
    r25 = load_address r24
    r26 = PyObject_VectorcallMethod(r23, r25, 9223372036854775809, 0)
    if is_error(r26) goto L44 (error at _patch_overloaded_method:60) else goto L13
L13:
    dec_ref r22
    r27 = PyObject_GetIter(r26)
    dec_ref r26
    if is_error(r27) goto L43 (error at _patch_overloaded_method:60) else goto L14
L14:
    r28 = PyIter_Next(r27)
    if is_error(r28) goto L45 else goto L15
L15:
    r29 = dank_mids.brownie_patch.overloaded.globals :: static
    r30 = 'ContractCall'
    r31 = CPyDict_GetItem(r29, r30)
    if is_error(r31) goto L46 (error at _patch_overloaded_method:61) else goto L16
L16:
    r32 = dank_mids.brownie_patch.overloaded.globals :: static
    r33 = 'ContractTx'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L47 (error at _patch_overloaded_method:61) else goto L17
L17:
    r35 = (r31, r34)
    r36 = box(tuple[object, object], r35)
    r37 = PyObject_IsInstance(r28, r36)
    dec_ref r36
    r38 = r37 >= 0 :: signed
    if not r38 goto L46 (error at _patch_overloaded_method:61) else goto L18 :: bool
L18:
    r39 = truncate r37: i32 to builtins.bool
    if r39 goto L19 else goto L48 :: bool
L19:
    r40 = '_address'
    r41 = CPyObject_GetAttr(r28, r40)
    if is_error(r41) goto L46 (error at _patch_overloaded_method:62) else goto L20
L20:
    r42 = dank_mids.brownie_patch.overloaded.globals :: static
    r43 = '_skip_proc_pool'
    r44 = CPyDict_GetItem(r42, r43)
    if is_error(r44) goto L49 (error at _patch_overloaded_method:62) else goto L21
L21:
    r45 = cast(set, r44)
    if is_error(r45) goto L49 (error at _patch_overloaded_method:62) else goto L22
L22:
    r46 = PySet_Contains(r45, r41)
    dec_ref r45
    dec_ref r41
    r47 = r46 >= 0 :: signed
    if not r47 goto L46 (error at _patch_overloaded_method:62) else goto L23 :: bool
L23:
    r48 = truncate r46: i32 to builtins.bool
    r49 = '_skip_decoder_proc_pool'
    r50 = box(bool, r48)
    r51 = PyObject_SetAttr(r28, r49, r50)
    r52 = r51 >= 0 :: signed
    if not r52 goto L46 (error at _patch_overloaded_method:62) else goto L24 :: bool
L24:
    r53 = 'abi'
    r54 = CPyObject_GetAttr(r28, r53)
    if is_error(r54) goto L46 (error at _patch_overloaded_method:63) else goto L25
L25:
    r55 = 'inputs'
    r56 = PyObject_GetItem(r54, r55)
    dec_ref r54
    if is_error(r56) goto L46 (error at _patch_overloaded_method:63) else goto L26
L26:
    r57 = CPyObject_Size(r56)
    dec_ref r56
    if is_error(r57) goto L46 (error at _patch_overloaded_method:63) else goto L27
L27:
    r58 = dank_mids.brownie_patch.overloaded.globals :: static
    r59 = '_get_coroutine_fn'
    r60 = CPyDict_GetItem(r58, r59)
    if is_error(r60) goto L50 (error at _patch_overloaded_method:63) else goto L28
L28:
    r61 = box(int, r57)
    r62 = [w3, r61]
    r63 = load_address r62
    r64 = PyObject_Vectorcall(r60, r63, 2, 0)
    dec_ref r60
    if is_error(r64) goto L51 (error at _patch_overloaded_method:63) else goto L29
L29:
    dec_ref r61
    r65 = dank_mids.brownie_patch.overloaded.globals :: static
    r66 = 'MethodType'
    r67 = CPyDict_GetItem(r65, r66)
    if is_error(r67) goto L52 (error at _patch_overloaded_method:63) else goto L30
L30:
    r68 = [r64, r28]
    r69 = load_address r68
    r70 = PyObject_Vectorcall(r67, r69, 2, 0)
    dec_ref r67
    if is_error(r70) goto L52 (error at _patch_overloaded_method:63) else goto L31
L31:
    dec_ref r64
    r71 = 'coroutine'
    r72 = PyObject_SetAttr(r28, r71, r70)
    dec_ref r28
    dec_ref r70
    r73 = r72 >= 0 :: signed
    if not r73 goto L53 (error at _patch_overloaded_method:63) else goto L14 :: bool
L32:
    r74 = CPy_NoErrOccurred()
    if not r74 goto L43 (error at _patch_overloaded_method:60) else goto L33 :: bool
L33:
    r75 = r0.call
    if is_error(r75) goto L43 (error at _patch_overloaded_method:68) else goto L34
L34:
    r76 = dank_mids.brownie_patch.overloaded.globals :: static
    r77 = 'MethodType'
    r78 = CPyDict_GetItem(r76, r77)
    if is_error(r78) goto L54 (error at _patch_overloaded_method:68) else goto L35
L35:
    r79 = [r13, r75]
    r80 = load_address r79
    r81 = PyObject_Vectorcall(r78, r80, 2, 0)
    dec_ref r78
    if is_error(r81) goto L54 (error at _patch_overloaded_method:68) else goto L36
L36:
    dec_ref r13
    dec_ref r75
    r82 = r0.call
    dec_ref r0
    if is_error(r82) goto L55 (error at _patch_overloaded_method:68) else goto L37
L37:
    r83 = 'coroutine'
    r84 = PyObject_SetAttr(r82, r83, r81)
    dec_ref r82
    dec_ref r81
    r85 = r84 >= 0 :: signed
    if not r85 goto L39 (error at _patch_overloaded_method:68) else goto L38 :: bool
L38:
    return 1
L39:
    r86 = <error> :: None
    return r86
L40:
    dec_ref r0
    goto L39
L41:
    dec_ref r0
    dec_ref r2
    goto L39
L42:
    dec_ref r0
    dec_ref r2
    dec_ref r4
    goto L39
L43:
    dec_ref r0
    dec_ref r13
    goto L39
L44:
    dec_ref r0
    dec_ref r13
    dec_ref r22
    goto L39
L45:
    dec_ref r27
    goto L32
L46:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    goto L39
L47:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r31
    goto L39
L48:
    dec_ref r28
    goto L14
L49:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r41
    goto L39
L50:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r57 :: int
    goto L39
L51:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r61
    goto L39
L52:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r64
    goto L39
L53:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    goto L39
L54:
    dec_ref r0
    dec_ref r13
    dec_ref r75
    goto L39
L55:
    dec_ref r81
    goto L39

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24, r25 :: object
    r26 :: str
    r27 :: dict
    r28, r29 :: object
    r30 :: str
    r31 :: dict
    r32 :: object
    r33 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L11 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('wraps',)
    r6 = 'functools'
    r7 = dank_mids.brownie_patch.overloaded.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L11 (error at <module>:1) else goto L4
L4:
    functools = r8 :: module
    dec_ref r8
    r9 = ('MethodType',)
    r10 = 'types'
    r11 = dank_mids.brownie_patch.overloaded.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L11 (error at <module>:2) else goto L5
L5:
    types = r12 :: module
    dec_ref r12
    r13 = ('Any', 'Dict', 'Optional', 'Union')
    r14 = 'typing'
    r15 = dank_mids.brownie_patch.overloaded.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L11 (error at <module>:3) else goto L6
L6:
    typing = r16 :: module
    dec_ref r16
    r17 = ('Contract',)
    r18 = 'brownie'
    r19 = dank_mids.brownie_patch.overloaded.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L11 (error at <module>:5) else goto L7
L7:
    brownie = r20 :: module
    dec_ref r20
    r21 = ('ContractCall', 'ContractTx', 'OverloadedMethod')
    r22 = 'brownie.network.contract'
    r23 = dank_mids.brownie_patch.overloaded.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L11 (error at <module>:6) else goto L8
L8:
    brownie.network.contract = r24 :: module
    dec_ref r24
    r25 = ('_get_coroutine_fn', '_skip_proc_pool')
    r26 = 'dank_mids.brownie_patch.call'
    r27 = dank_mids.brownie_patch.overloaded.globals :: static
    r28 = CPyImport_ImportFromMany(r26, r25, r25, r27)
    if is_error(r28) goto L11 (error at <module>:7) else goto L9
L9:
    dank_mids.brownie_patch.call = r28 :: module
    dec_ref r28
    r29 = ('DankWeb3',)
    r30 = 'dank_mids.helpers._helpers'
    r31 = dank_mids.brownie_patch.overloaded.globals :: static
    r32 = CPyImport_ImportFromMany(r30, r29, r29, r31)
    if is_error(r32) goto L11 (error at <module>:8) else goto L10
L10:
    dank_mids.helpers._helpers = r32 :: module
    dec_ref r32
    return 1
L11:
    r33 = <error> :: None
    return r33

def log_errd_batch(batch):
    batch :: object
    r0 :: dank_mids.stats._Collector
    r1 :: bool
    r2 :: object
    r3 :: str
    r4 :: object[2]
    r5 :: object_ptr
    r6 :: object
    r7 :: dank_mids.stats._StatsLogger
    r8 :: bool
    r9, r10 :: str
    r11 :: object
    r12 :: union[int, str]
    r13, r14 :: str
    r15 :: int
    r16, r17, r18 :: str
    r19 :: object
    r20 :: int
    r21, r22, r23, r24, r25 :: str
    r26 :: object
    r27 :: dict
    r28, r29, r30 :: str
    r31 :: tuple
    r32 :: dict
    r33, r34 :: None
L0:
    r0 = dank_mids.stats.collector :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "collector" was not set')
    if not r1 goto L25 (error at log_errd_batch:83) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = r0.errd_batches
    r3 = 'append'
    r4 = [r2, batch]
    r5 = load_address r4
    r6 = PyObject_VectorcallMethod(r3, r5, 9223372036854775810, 0)
    if is_error(r6) goto L26 (error at log_errd_batch:83) else goto L27
L4:
    dec_ref r2
    r7 = dank_mids.stats.logger :: static
    if is_error(r7) goto L5 else goto L7
L5:
    r8 = raise NameError('value for final name "logger" was not set')
    if not r8 goto L25 (error at log_errd_batch:84) else goto L6 :: bool
L6:
    unreachable
L7:
    r9 = 'jsonrpc batch failed\njson batch id: '
    r10 = 'jid'
    r11 = CPyObject_GetAttr(batch, r10)
    if is_error(r11) goto L25 (error at log_errd_batch:85) else goto L8
L8:
    r12 = cast(union[int, str], r11)
    if is_error(r12) goto L25 (error at log_errd_batch:85) else goto L9
L9:
    r13 = PyObject_Str(r12)
    dec_ref r12
    if is_error(r13) goto L25 (error at log_errd_batch:85) else goto L10
L10:
    r14 = ' | len: '
    r15 = CPyObject_Size(batch)
    if is_error(r15) goto L28 (error at log_errd_batch:85) else goto L11
L11:
    r16 = CPyTagged_Str(r15)
    dec_ref r15 :: int
    if is_error(r16) goto L28 (error at log_errd_batch:85) else goto L12
L12:
    r17 = ' | total calls: '
    r18 = 'total_calls'
    r19 = CPyObject_GetAttr(batch, r18)
    if is_error(r19) goto L29 (error at log_errd_batch:85) else goto L13
L13:
    r20 = unbox(int, r19)
    dec_ref r19
    if is_error(r20) goto L29 (error at log_errd_batch:85) else goto L14
L14:
    r21 = CPyTagged_Str(r20)
    dec_ref r20 :: int
    if is_error(r21) goto L29 (error at log_errd_batch:85) else goto L15
L15:
    r22 = '\n'
    r23 = CPyStr_Build(7, r9, r13, r14, r16, r17, r21, r22)
    dec_ref r13
    dec_ref r16
    dec_ref r21
    if is_error(r23) goto L25 (error at log_errd_batch:85) else goto L16
L16:
    r24 = 'methods called: '
    r25 = 'method_counts'
    r26 = CPyObject_GetAttr(batch, r25)
    if is_error(r26) goto L30 (error at log_errd_batch:86) else goto L17
L17:
    r27 = cast(dict, r26)
    if is_error(r27) goto L30 (error at log_errd_batch:86) else goto L18
L18:
    r28 = PyObject_Str(r27)
    dec_ref r27
    if is_error(r28) goto L30 (error at log_errd_batch:86) else goto L19
L19:
    r29 = CPyStr_Build(2, r24, r28)
    dec_ref r28
    if is_error(r29) goto L30 (error at log_errd_batch:86) else goto L20
L20:
    r30 = PyUnicode_Concat(r23, r29)
    dec_ref r23
    dec_ref r29
    if is_error(r30) goto L25 (error at log_errd_batch:85) else goto L21
L21:
    r31 = PyTuple_Pack(0)
    if is_error(r31) goto L31 (error at log_errd_batch:84) else goto L22
L22:
    r32 = PyDict_New()
    if is_error(r32) goto L32 (error at log_errd_batch:84) else goto L23
L23:
    r33 = r7.devhint(r30, r31, r32)
    dec_ref r30
    dec_ref r31
    dec_ref r32
    if is_error(r33) goto L25 (error at log_errd_batch:84) else goto L24
L24:
    return 1
L25:
    r34 = <error> :: None
    return r34
L26:
    dec_ref r2
    goto L25
L27:
    dec_ref r6
    goto L4
L28:
    dec_ref r13
    goto L25
L29:
    dec_ref r13
    dec_ref r16
    goto L25
L30:
    dec_ref r23
    goto L25
L31:
    dec_ref r30
    goto L25
L32:
    dec_ref r30
    dec_ref r31
    goto L25

def log_duration(work_descriptor, start, level):
    work_descriptor :: str
    start :: float
    level :: int
    r0 :: dank_mids.stats._StatsLogger
    r1 :: bool
    r2 :: str
    r3 :: object
    r4 :: object[2]
    r5 :: object_ptr
    r6 :: object
    r7 :: bool
    r8 :: dict
    r9 :: str
    r10 :: object
    r11 :: bool
    r12 :: dict
    r13 :: str
    r14, r15 :: object
    r16 :: float
    r17 :: bit
    r18 :: float
    r19 :: dict
    r20 :: str
    r21, r22 :: object
    r23 :: bool
    r24 :: dank_mids.stats._Collector
    r25 :: bool
    r26 :: dict
    r27 :: object
    r28 :: str
    r29 :: object
    r30 :: object[2]
    r31 :: object_ptr
    r32 :: object
    r33 :: dank_mids.stats._StatsLogger
    r34 :: bool
    r35 :: str
    r36 :: object
    r37, r38 :: str
    r39 :: tuple
    r40 :: dict
    r41, r42 :: None
L0:
    if is_error(level) goto L1 else goto L35
L1:
    level = 26
L2:
    r0 = dank_mids.stats.logger :: static
    if is_error(r0) goto L36 else goto L5
L3:
    r1 = raise NameError('value for final name "logger" was not set')
    if not r1 goto L34 (error at log_duration:100) else goto L4 :: bool
L4:
    unreachable
L5:
    r2 = 'isEnabledFor'
    inc_ref level :: int
    r3 = box(int, level)
    r4 = [r0, r3]
    r5 = load_address r4
    r6 = PyObject_VectorcallMethod(r2, r5, 9223372036854775810, 0)
    if is_error(r6) goto L37 (error at log_duration:100) else goto L6
L6:
    dec_ref r3
    r7 = unbox(bool, r6)
    dec_ref r6
    if is_error(r7) goto L38 (error at log_duration:100) else goto L7
L7:
    r8 = dank_mids.stats.globals :: static
    r9 = 'COLLECT_STATS'
    r10 = CPyDict_GetItem(r8, r9)
    if is_error(r10) goto L38 (error at log_duration:101) else goto L8
L8:
    r11 = unbox(bool, r10)
    dec_ref r10
    if is_error(r11) goto L38 (error at log_duration:101) else goto L9
L9:
    if r11 goto L11 else goto L10 :: bool
L10:
    if r7 goto L11 else goto L39 :: bool
L11:
    r12 = dank_mids.stats.globals :: static
    r13 = 'time'
    r14 = CPyDict_GetItem(r12, r13)
    if is_error(r14) goto L38 (error at log_duration:102) else goto L12
L12:
    r15 = PyObject_Vectorcall(r14, 0, 0, 0)
    dec_ref r14
    if is_error(r15) goto L38 (error at log_duration:102) else goto L13
L13:
    r16 = unbox(float, r15)
    dec_ref r15
    r17 = r16 == -113.0
    if r17 goto L15 else goto L14 :: bool
L14:
    r18 = r16 - start
    r19 = dank_mids.stats.globals :: static
    r20 = 'COLLECT_STATS'
    r21 = CPyDict_GetItem(r19, r20)
    if is_error(r21) goto L38 (error at log_duration:103) else goto L16
L15:
    r22 = PyErr_Occurred()
    if not is_error(r22) goto L38 (error at log_duration:102) else goto L14
L16:
    r23 = unbox(bool, r21)
    dec_ref r21
    if is_error(r23) goto L38 (error at log_duration:103) else goto L17
L17:
    if r23 goto L18 else goto L24 :: bool
L18:
    r24 = dank_mids.stats.collector :: static
    if is_error(r24) goto L40 else goto L21
L19:
    r25 = raise NameError('value for final name "collector" was not set')
    if not r25 goto L34 (error at log_duration:104) else goto L20 :: bool
L20:
    unreachable
L21:
    r26 = r24.durations
    r27 = CPyDict_GetItem(r26, work_descriptor)
    dec_ref r26
    if is_error(r27) goto L38 (error at log_duration:104) else goto L22
L22:
    r28 = 'append'
    r29 = box(float, r18)
    r30 = [r27, r29]
    r31 = load_address r30
    r32 = PyObject_VectorcallMethod(r28, r31, 9223372036854775810, 0)
    if is_error(r32) goto L41 (error at log_duration:104) else goto L42
L23:
    dec_ref r27
    dec_ref r29
L24:
    if r7 goto L25 else goto L39 :: bool
L25:
    r33 = dank_mids.stats.logger :: static
    if is_error(r33) goto L43 else goto L28
L26:
    r34 = raise NameError('value for final name "logger" was not set')
    if not r34 goto L34 (error at log_duration:106) else goto L27 :: bool
L27:
    unreachable
L28:
    r35 = ' took '
    r36 = box(float, r18)
    r37 = PyObject_Str(r36)
    dec_ref r36
    if is_error(r37) goto L38 (error at log_duration:106) else goto L29
L29:
    r38 = CPyStr_Build(3, work_descriptor, r35, r37)
    dec_ref r37
    if is_error(r38) goto L38 (error at log_duration:106) else goto L30
L30:
    r39 = PyTuple_Pack(0)
    if is_error(r39) goto L44 (error at log_duration:106) else goto L31
L31:
    r40 = PyDict_New()
    if is_error(r40) goto L45 (error at log_duration:106) else goto L32
L32:
    r41 = r33._log_nocheck(level, r38, r39, r40)
    dec_ref level :: int
    dec_ref r38
    dec_ref r39
    dec_ref r40
    if is_error(r41) goto L34 (error at log_duration:106) else goto L33
L33:
    return 1
L34:
    r42 = <error> :: None
    return r42
L35:
    inc_ref level :: int
    goto L2
L36:
    dec_ref level :: int
    goto L3
L37:
    dec_ref level :: int
    dec_ref r3
    goto L34
L38:
    dec_ref level :: int
    goto L34
L39:
    dec_ref level :: int
    goto L33
L40:
    dec_ref level :: int
    goto L19
L41:
    dec_ref level :: int
    dec_ref r27
    dec_ref r29
    goto L34
L42:
    dec_ref r32
    goto L23
L43:
    dec_ref level :: int
    goto L26
L44:
    dec_ref level :: int
    dec_ref r38
    goto L34
L45:
    dec_ref level :: int
    dec_ref r38
    dec_ref r39
    goto L34

def _StatsLogger.enabled(self):
    self :: dank_mids.stats._StatsLogger
    r0 :: None
    r1 :: str
    r2 :: object
    r3 :: object[2]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bool
L0:
    r0 = self._ensure_daemon()
    if is_error(r0) goto L4 (error at enabled:134) else goto L1
L1:
    r1 = 'isEnabledFor'
    r2 = object 13
    r3 = [self, r2]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r1, r4, 9223372036854775810, 0)
    if is_error(r5) goto L4 (error at enabled:135) else goto L2
L2:
    r6 = unbox(bool, r5)
    dec_ref r5
    if is_error(r6) goto L4 (error at enabled:135) else goto L3
L3:
    return r6
L4:
    r7 = <error> :: bool
    return r7

def _StatsLogger.stats(self, msg, args, kwargs):
    self :: dank_mids.stats._StatsLogger
    msg :: str
    args :: tuple
    kwargs :: dict
    r0 :: bool
    r1 :: str
    r2 :: object
    r3 :: dict
    r4 :: i32
    r5 :: bit
    r6 :: object
    r7 :: tuple
    r8 :: object
    r9 :: None
L0:
    r0 = self.enabled
    if is_error(r0) goto L8 (error at stats:151) else goto L1
L1:
    if r0 goto L2 else goto L7 :: bool
L2:
    r1 = '_log_nocheck'
    r2 = CPyObject_GetAttr(self, r1)
    if is_error(r2) goto L8 (error at stats:152) else goto L3
L3:
    r3 = PyDict_New()
    if is_error(r3) goto L9 (error at stats:152) else goto L4
L4:
    r4 = CPyDict_UpdateInDisplay(r3, kwargs)
    r5 = r4 >= 0 :: signed
    if not r5 goto L10 (error at stats:152) else goto L5 :: bool
L5:
    r6 = object 13
    r7 = PyTuple_Pack(3, r6, msg, args)
    if is_error(r7) goto L10 (error at stats:152) else goto L6
L6:
    r8 = PyObject_Call(r2, r7, r3)
    dec_ref r2
    dec_ref r7
    dec_ref r3
    if is_error(r8) goto L8 (error at stats:152) else goto L11
L7:
    return 1
L8:
    r9 = <error> :: None
    return r9
L9:
    dec_ref r2
    goto L8
L10:
    dec_ref r2
    dec_ref r3
    goto L8
L11:
    dec_ref r8
    goto L7

def _StatsLogger.devhint(self, msg, args, kwargs):
    self :: dank_mids.stats._StatsLogger
    msg :: str
    args :: tuple
    kwargs :: dict
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: i32
    r4 :: bit
    r5 :: object
    r6 :: tuple
    r7 :: object
    r8 :: None
L0:
    r0 = '_log'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L6 (error at devhint:166) else goto L1
L1:
    r2 = PyDict_New()
    if is_error(r2) goto L7 (error at devhint:166) else goto L2
L2:
    r3 = CPyDict_UpdateInDisplay(r2, kwargs)
    r4 = r3 >= 0 :: signed
    if not r4 goto L8 (error at devhint:166) else goto L3 :: bool
L3:
    r5 = object 15
    r6 = PyTuple_Pack(3, r5, msg, args)
    if is_error(r6) goto L8 (error at devhint:166) else goto L4
L4:
    r7 = PyObject_Call(r1, r6, r2)
    dec_ref r1
    dec_ref r6
    dec_ref r2
    if is_error(r7) goto L6 (error at devhint:166) else goto L9
L5:
    return 1
L6:
    r8 = <error> :: None
    return r8
L7:
    dec_ref r1
    goto L6
L8:
    dec_ref r1
    dec_ref r2
    goto L6
L9:
    dec_ref r7
    goto L5

def _StatsLogger.log_brownie_stats(self, level):
    self :: dank_mids.stats._StatsLogger
    level :: int
    r0 :: object
    r1 :: str
    r2 :: object
    r3 :: tuple
    r4 :: dict
    r5, r6 :: None
L0:
    if is_error(level) goto L1 else goto L8
L1:
    level = 26
L2:
    r0 = dank_mids.stats._Writer :: type
    r1 = 'brownie'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L9 (error at log_brownie_stats:180) else goto L3
L3:
    r3 = PyTuple_Pack(0)
    if is_error(r3) goto L10 (error at log_brownie_stats:180) else goto L4
L4:
    r4 = PyDict_New()
    if is_error(r4) goto L11 (error at log_brownie_stats:180) else goto L5
L5:
    r5 = self._log_fn_result(level, r2, r3, r4)
    dec_ref level :: int
    dec_ref r2
    dec_ref r3
    dec_ref r4
    if is_error(r5) goto L7 (error at log_brownie_stats:180) else goto L6
L6:
    return 1
L7:
    r6 = <error> :: None
    return r6
L8:
    inc_ref level :: int
    goto L2
L9:
    dec_ref level :: int
    goto L7
L10:
    dec_ref level :: int
    dec_ref r2
    goto L7
L11:
    dec_ref level :: int
    dec_ref r2
    dec_ref r3
    goto L7

def _StatsLogger.log_event_loop_stats(self, level):
    self :: dank_mids.stats._StatsLogger
    level :: int
    r0 :: object
    r1 :: str
    r2 :: object
    r3 :: tuple
    r4 :: dict
    r5, r6 :: None
L0:
    if is_error(level) goto L1 else goto L8
L1:
    level = 26
L2:
    r0 = dank_mids.stats._Writer :: type
    r1 = 'event_loop'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L9 (error at log_event_loop_stats:192) else goto L3
L3:
    r3 = PyTuple_Pack(0)
    if is_error(r3) goto L10 (error at log_event_loop_stats:192) else goto L4
L4:
    r4 = PyDict_New()
    if is_error(r4) goto L11 (error at log_event_loop_stats:192) else goto L5
L5:
    r5 = self._log_fn_result(level, r2, r3, r4)
    dec_ref level :: int
    dec_ref r2
    dec_ref r3
    dec_ref r4
    if is_error(r5) goto L7 (error at log_event_loop_stats:192) else goto L6
L6:
    return 1
L7:
    r6 = <error> :: None
    return r6
L8:
    inc_ref level :: int
    goto L2
L9:
    dec_ref level :: int
    goto L7
L10:
    dec_ref level :: int
    dec_ref r2
    goto L7
L11:
    dec_ref level :: int
    dec_ref r2
    dec_ref r3
    goto L7

def _StatsLogger.log_subprocess_stats(self, level):
    self :: dank_mids.stats._StatsLogger
    level :: int
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: str
    r14 :: object
    r15 :: set
    r16 :: i32
    r17 :: bit
    r18 :: i32
    r19 :: bit
    r20 :: i32
    r21 :: bit
    r22, r23, r24 :: object
    r25 :: str
    r26 :: object
    r27 :: tuple
    r28 :: dict
    r29 :: None
    r30 :: bit
    r31 :: None
L0:
    if is_error(level) goto L1 else goto L21
L1:
    level = 26
L2:
    r0 = dank_mids.stats.globals :: static
    r1 = 'ENVS'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L22 (error at log_subprocess_stats:204) else goto L3
L3:
    r3 = 'BROWNIE_ENCODER_PROCESSES'
    r4 = CPyObject_GetAttr(r2, r3)
    dec_ref r2
    if is_error(r4) goto L22 (error at log_subprocess_stats:204) else goto L4
L4:
    r5 = dank_mids.stats.globals :: static
    r6 = 'ENVS'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L23 (error at log_subprocess_stats:204) else goto L5
L5:
    r8 = 'BROWNIE_DECODER_PROCESSES'
    r9 = CPyObject_GetAttr(r7, r8)
    dec_ref r7
    if is_error(r9) goto L23 (error at log_subprocess_stats:204) else goto L6
L6:
    r10 = dank_mids.stats.globals :: static
    r11 = 'ENVS'
    r12 = CPyDict_GetItem(r10, r11)
    if is_error(r12) goto L24 (error at log_subprocess_stats:204) else goto L7
L7:
    r13 = 'MULTICALL_DECODER_PROCESSES'
    r14 = CPyObject_GetAttr(r12, r13)
    dec_ref r12
    if is_error(r14) goto L24 (error at log_subprocess_stats:204) else goto L8
L8:
    r15 = PySet_New(0)
    if is_error(r15) goto L25 (error at log_subprocess_stats:204) else goto L9
L9:
    r16 = PySet_Add(r15, r4)
    dec_ref r4
    r17 = r16 >= 0 :: signed
    if not r17 goto L26 (error at log_subprocess_stats:204) else goto L10 :: bool
L10:
    r18 = PySet_Add(r15, r9)
    dec_ref r9
    r19 = r18 >= 0 :: signed
    if not r19 goto L27 (error at log_subprocess_stats:204) else goto L11 :: bool
L11:
    r20 = PySet_Add(r15, r14)
    dec_ref r14
    r21 = r20 >= 0 :: signed
    if not r21 goto L28 (error at log_subprocess_stats:204) else goto L12 :: bool
L12:
    r22 = PyObject_GetIter(r15)
    dec_ref r15
    if is_error(r22) goto L22 (error at log_subprocess_stats:204) else goto L13
L13:
    r23 = PyIter_Next(r22)
    if is_error(r23) goto L29 else goto L14
L14:
    r24 = dank_mids.stats._Writer :: type
    r25 = 'queue'
    r26 = CPyObject_GetAttr(r24, r25)
    if is_error(r26) goto L30 (error at log_subprocess_stats:205) else goto L15
L15:
    r27 = PyTuple_Pack(1, r23)
    dec_ref r23
    if is_error(r27) goto L31 (error at log_subprocess_stats:205) else goto L16
L16:
    r28 = PyDict_New()
    if is_error(r28) goto L32 (error at log_subprocess_stats:205) else goto L17
L17:
    r29 = self._log_fn_result(level, r26, r27, r28)
    dec_ref r26
    dec_ref r27
    dec_ref r28
    if is_error(r29) goto L33 (error at log_subprocess_stats:205) else goto L13
L18:
    r30 = CPy_NoErrOccurred()
    if not r30 goto L20 (error at log_subprocess_stats:204) else goto L19 :: bool
L19:
    return 1
L20:
    r31 = <error> :: None
    return r31
L21:
    inc_ref level :: int
    goto L2
L22:
    dec_ref level :: int
    goto L20
L23:
    dec_ref level :: int
    dec_ref r4
    goto L20
L24:
    dec_ref level :: int
    dec_ref r4
    dec_ref r9
    goto L20
L25:
    dec_ref level :: int
    dec_ref r4
    dec_ref r9
    dec_ref r14
    goto L20
L26:
    dec_ref level :: int
    dec_ref r9
    dec_ref r14
    dec_ref r15
    goto L20
L27:
    dec_ref level :: int
    dec_ref r14
    dec_ref r15
    goto L20
L28:
    dec_ref level :: int
    dec_ref r15
    goto L20
L29:
    dec_ref level :: int
    dec_ref r22
    goto L18
L30:
    dec_ref level :: int
    dec_ref r22
    dec_ref r23
    goto L20
L31:
    dec_ref level :: int
    dec_ref r22
    dec_ref r26
    goto L20
L32:
    dec_ref level :: int
    dec_ref r22
    dec_ref r26
    dec_ref r27
    goto L20
L33:
    dec_ref level :: int
    dec_ref r22
    goto L20

def _StatsLogger._log(self, level, msg, args, kwargs):
    self :: dank_mids.stats._StatsLogger
    level :: int
    msg :: str
    args :: tuple
    kwargs :: dict
    r0 :: tuple[]
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: object[2]
    r5 :: object_ptr
    r6 :: object
    r7 :: bool
    r8 :: str
    r9 :: object
    r10 :: list
    r11 :: object
    r12, r13, r14 :: ptr
    r15 :: object
    r16 :: dict
    r17 :: i32
    r18 :: bit
    r19 :: tuple
    r20 :: object
    r21, r22 :: None
L0:
    if is_error(args) goto L1 else goto L16
L1:
    r0 = ()
    r1 = box(tuple[], r0)
    args = r1
L2:
    r2 = 'isEnabledFor'
    inc_ref level :: int
    r3 = box(int, level)
    r4 = [self, r3]
    r5 = load_address r4
    r6 = PyObject_VectorcallMethod(r2, r5, 9223372036854775810, 0)
    if is_error(r6) goto L17 (error at _log:218) else goto L3
L3:
    dec_ref r3
    r7 = unbox(bool, r6)
    dec_ref r6
    if is_error(r7) goto L18 (error at _log:218) else goto L4
L4:
    if r7 goto L5 else goto L19 :: bool
L5:
    r8 = '_log_nocheck'
    r9 = CPyObject_GetAttr(self, r8)
    if is_error(r9) goto L18 (error at _log:219) else goto L6
L6:
    r10 = PyList_New(2)
    if is_error(r10) goto L20 (error at _log:219) else goto L7
L7:
    inc_ref level :: int
    r11 = box(int, level)
    r12 = get_element_ptr r10 ob_item :: PyListObject
    r13 = load_mem r12 :: ptr*
    set_mem r13, r11 :: builtins.object*
    inc_ref msg
    r14 = r13 + 8
    set_mem r14, msg :: builtins.object*
    r15 = CPyList_Extend(r10, args)
    dec_ref args
    if is_error(r15) goto L21 (error at _log:219) else goto L22
L8:
    r16 = PyDict_New()
    if is_error(r16) goto L21 (error at _log:219) else goto L9
L9:
    r17 = CPyDict_UpdateInDisplay(r16, kwargs)
    r18 = r17 >= 0 :: signed
    if not r18 goto L23 (error at _log:219) else goto L10 :: bool
L10:
    r19 = PyList_AsTuple(r10)
    dec_ref r10
    if is_error(r19) goto L24 (error at _log:219) else goto L11
L11:
    r20 = PyObject_Call(r9, r19, r16)
    dec_ref r9
    dec_ref r19
    dec_ref r16
    if is_error(r20) goto L15 (error at _log:219) else goto L12
L12:
    r21 = unbox(None, r20)
    dec_ref r20
    if is_error(r21) goto L15 (error at _log:219) else goto L13
L13:
    return r21
L14:
    return 1
L15:
    r22 = <error> :: None
    return r22
L16:
    inc_ref args
    goto L2
L17:
    dec_ref args
    dec_ref r3
    goto L15
L18:
    dec_ref args
    goto L15
L19:
    dec_ref args
    goto L14
L20:
    dec_ref args
    dec_ref r9
    goto L15
L21:
    dec_ref r9
    dec_ref r10
    goto L15
L22:
    dec_ref r15
    goto L8
L23:
    dec_ref r9
    dec_ref r10
    dec_ref r16
    goto L15
L24:
    dec_ref r9
    dec_ref r16
    goto L15

def _StatsLogger._log_nocheck(self, level, msg, args, kwargs):
    self :: dank_mids.stats._StatsLogger
    level :: int
    msg :: str
    args :: tuple
    kwargs :: dict
    r0 :: object
    r1 :: str
    r2, r3 :: object
    r4 :: object[2]
    r5 :: object_ptr
    r6 :: object
    r7 :: str
    r8 :: object
    r9 :: dict
    r10 :: i32
    r11 :: bit
    r12 :: object
    r13 :: tuple
    r14 :: object
    r15, r16 :: None
L0:
    r0 = builtins :: module
    r1 = 'super'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L9 (error at _log_nocheck:233) else goto L1
L1:
    r3 = dank_mids.stats._StatsLogger :: type
    r4 = [r3, self]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r2, r5, 2, 0)
    dec_ref r2
    if is_error(r6) goto L9 (error at _log_nocheck:233) else goto L2
L2:
    r7 = '_log'
    r8 = CPyObject_GetAttr(r6, r7)
    dec_ref r6
    if is_error(r8) goto L9 (error at _log_nocheck:233) else goto L3
L3:
    r9 = PyDict_New()
    if is_error(r9) goto L10 (error at _log_nocheck:233) else goto L4
L4:
    r10 = CPyDict_UpdateInDisplay(r9, kwargs)
    r11 = r10 >= 0 :: signed
    if not r11 goto L11 (error at _log_nocheck:233) else goto L5 :: bool
L5:
    inc_ref level :: int
    r12 = box(int, level)
    r13 = PyTuple_Pack(3, r12, msg, args)
    dec_ref r12
    if is_error(r13) goto L11 (error at _log_nocheck:233) else goto L6
L6:
    r14 = PyObject_Call(r8, r13, r9)
    dec_ref r8
    dec_ref r13
    dec_ref r9
    if is_error(r14) goto L9 (error at _log_nocheck:233) else goto L7
L7:
    r15 = unbox(None, r14)
    dec_ref r14
    if is_error(r15) goto L9 (error at _log_nocheck:233) else goto L8
L8:
    return r15
L9:
    r16 = <error> :: None
    return r16
L10:
    dec_ref r8
    goto L9
L11:
    dec_ref r8
    dec_ref r9
    goto L9

def _StatsLogger._log_fn_result(self, level, callable, callable_args, logging_kwargs):
    self :: dank_mids.stats._StatsLogger
    level :: int
    callable :: object
    callable_args :: tuple
    logging_kwargs :: dict
    r0 :: str
    r1 :: object
    r2 :: object[2]
    r3 :: object_ptr
    r4 :: object
    r5 :: bool
    r6 :: list
    r7 :: object
    r8 :: tuple
    r9 :: dict
    r10 :: object
    r11 :: str
    r12 :: tuple[]
    r13 :: str
    r14 :: object
    r15 :: dict
    r16 :: i32
    r17 :: bit
    r18, r19 :: object
    r20 :: tuple
    r21 :: object
    r22, r23 :: None
L0:
    r0 = 'isEnabledFor'
    inc_ref level :: int
    r1 = box(int, level)
    r2 = [self, r1]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r0, r3, 9223372036854775810, 0)
    if is_error(r4) goto L18 (error at _log_fn_result:251) else goto L1
L1:
    dec_ref r1
    r5 = unbox(bool, r4)
    dec_ref r4
    if is_error(r5) goto L17 (error at _log_fn_result:251) else goto L2
L2:
    if r5 goto L3 else goto L16 :: bool
L3:
    r6 = PyList_New(0)
    if is_error(r6) goto L17 (error at _log_fn_result:252) else goto L4
L4:
    r7 = CPyList_Extend(r6, callable_args)
    if is_error(r7) goto L19 (error at _log_fn_result:252) else goto L20
L5:
    r8 = PyList_AsTuple(r6)
    dec_ref r6
    if is_error(r8) goto L17 (error at _log_fn_result:252) else goto L6
L6:
    r9 = PyDict_New()
    if is_error(r9) goto L21 (error at _log_fn_result:252) else goto L7
L7:
    r10 = PyObject_Call(callable, r8, r9)
    dec_ref r8
    dec_ref r9
    if is_error(r10) goto L17 (error at _log_fn_result:252) else goto L8
L8:
    r11 = cast(str, r10)
    if is_error(r11) goto L17 (error at _log_fn_result:252) else goto L9
L9:
    r12 = ()
    r13 = '_log_nocheck'
    r14 = CPyObject_GetAttr(self, r13)
    if is_error(r14) goto L22 (error at _log_fn_result:252) else goto L10
L10:
    r15 = PyDict_New()
    if is_error(r15) goto L23 (error at _log_fn_result:252) else goto L11
L11:
    r16 = CPyDict_UpdateInDisplay(r15, logging_kwargs)
    r17 = r16 >= 0 :: signed
    if not r17 goto L24 (error at _log_fn_result:252) else goto L12 :: bool
L12:
    inc_ref level :: int
    r18 = box(int, level)
    r19 = box(tuple[], r12)
    r20 = PyTuple_Pack(3, r18, r11, r19)
    dec_ref r18
    dec_ref r11
    dec_ref r19
    if is_error(r20) goto L25 (error at _log_fn_result:252) else goto L13
L13:
    r21 = PyObject_Call(r14, r20, r15)
    dec_ref r14
    dec_ref r20
    dec_ref r15
    if is_error(r21) goto L17 (error at _log_fn_result:252) else goto L14
L14:
    r22 = unbox(None, r21)
    dec_ref r21
    if is_error(r22) goto L17 (error at _log_fn_result:252) else goto L15
L15:
    return r22
L16:
    return 1
L17:
    r23 = <error> :: None
    return r23
L18:
    dec_ref r1
    goto L17
L19:
    dec_ref r6
    goto L17
L20:
    dec_ref r7
    goto L5
L21:
    dec_ref r8
    goto L17
L22:
    dec_ref r11
    goto L17
L23:
    dec_ref r11
    dec_ref r14
    goto L17
L24:
    dec_ref r11
    dec_ref r14
    dec_ref r15
    goto L17
L25:
    dec_ref r14
    dec_ref r15
    goto L17

def _StatsLogger._ensure_daemon(self):
    self :: dank_mids.stats._StatsLogger
    r0 :: object
    r1 :: bool
    r2 :: i32
    r3 :: bit
    r4, r5 :: bool
    r6, r7 :: object
    r8 :: bit
    r9 :: dank_mids.stats._stats_daemon__StatsLogger_gen
    r10 :: str
    r11 :: dict
    r12 :: str
    r13 :: object
    r14 :: object[2]
    r15 :: object_ptr
    r16, r17 :: object
    r18 :: bool
    r19 :: object
    r20 :: str
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: bool
    r25 :: object
    r26 :: str
    r27 :: object[1]
    r28 :: object_ptr
    r29 :: object
    r30 :: None
L0:
    r0 = dank_mids.ENVIRONMENT_VARIABLES.COLLECT_STATS :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "COLLECT_STATS" was not set')
    if not r1 goto L22 (error at _ensure_daemon:265) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = PyObject_IsTrue(r0)
    r3 = r2 >= 0 :: signed
    if not r3 goto L22 (error at _ensure_daemon:265) else goto L4 :: bool
L4:
    r4 = truncate r2: i32 to builtins.bool
    if r4 goto L7 else goto L5 :: bool
L5:
    r5 = self.enabled
    if is_error(r5) goto L22 (error at _ensure_daemon:265) else goto L6
L6:
    if r5 goto L7 else goto L13 :: bool
L7:
    r6 = borrow self._daemon
    if is_error(r6) goto L22 (error at _ensure_daemon:265) else goto L8
L8:
    r7 = load_address _Py_NoneStruct
    r8 = r6 == r7
    if r8 goto L9 else goto L13 :: bool
L9:
    r9 = self._stats_daemon()
    if is_error(r9) goto L22 (error at _ensure_daemon:266) else goto L10
L10:
    r10 = '_StatsLogger debug daemon'
    r11 = dank_mids.stats.globals :: static
    r12 = 'create_task'
    r13 = CPyDict_GetItem(r11, r12)
    if is_error(r13) goto L23 (error at _ensure_daemon:266) else goto L11
L11:
    r14 = [r9, r10]
    r15 = load_address r14
    r16 = ('name',)
    r17 = PyObject_Vectorcall(r13, r15, 1, r16)
    dec_ref r13
    if is_error(r17) goto L23 (error at _ensure_daemon:266) else goto L12
L12:
    dec_ref r9
    self._daemon = r17; r18 = is_error
    if not r18 goto L22 (error at _ensure_daemon:266) else goto L21 :: bool
L13:
    r19 = self._daemon
    if is_error(r19) goto L22 (error at _ensure_daemon:267) else goto L14
L14:
    r20 = 'done'
    r21 = [r19]
    r22 = load_address r21
    r23 = PyObject_VectorcallMethod(r20, r22, 9223372036854775809, 0)
    if is_error(r23) goto L24 (error at _ensure_daemon:267) else goto L15
L15:
    dec_ref r19
    r24 = unbox(bool, r23)
    dec_ref r23
    if is_error(r24) goto L22 (error at _ensure_daemon:267) else goto L16
L16:
    if r24 goto L17 else goto L21 :: bool
L17:
    r25 = self._daemon
    if is_error(r25) goto L22 (error at _ensure_daemon:268) else goto L18
L18:
    r26 = 'exception'
    r27 = [r25]
    r28 = load_address r27
    r29 = PyObject_VectorcallMethod(r26, r28, 9223372036854775809, 0)
    if is_error(r29) goto L25 (error at _ensure_daemon:268) else goto L19
L19:
    dec_ref r25
    CPy_Raise(r29)
    dec_ref r29
    if not 0 goto L22 (error at _ensure_daemon:268) else goto L20 :: bool
L20:
    unreachable
L21:
    return 1
L22:
    r30 = <error> :: None
    return r30
L23:
    dec_ref r9
    goto L22
L24:
    dec_ref r19
    goto L22
L25:
    dec_ref r25
    goto L22

def _stats_daemon__StatsLogger_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg, stop_iter_ptr):
    __mypyc_self__ :: dank_mids.stats._stats_daemon__StatsLogger_gen
    type, value, traceback, arg :: object
    stop_iter_ptr :: object_ptr
    r0, r1 :: object
    r2 :: i32
    r3 :: object
    r4 :: bit
    r5 :: dict
    r6 :: str
    r7, r8 :: object
    r9 :: float
    r10 :: bit
    r11 :: bool
    r12 :: object
    r13 :: bool
    r14 :: object
    r15 :: bool
    r16, r17 :: object
    r18 :: bool
    r19, r20, r21, r22, r23 :: object
    r24 :: bool
    r25 :: object
    r26 :: bool
    r27 :: object
    r28 :: bit
    r29 :: tuple[object, object, object]
    r30 :: bool
    r31 :: object_ptr
    r32 :: object
    r33 :: bool
    r34, r35, r36 :: tuple[object, object, object]
    r37 :: bit
    r38, r39, r40 :: object
    r41 :: dict
    r42 :: str
    r43, r44 :: object
    r45 :: float
    r46 :: bit
    r47 :: bool
    r48 :: object
    r49 :: float
    r50 :: bit
    r51 :: float
    r52 :: bit
    r53 :: object
    r54 :: float
    r55 :: bool
    r56 :: object
    r57 :: dank_mids.stats._Collector
    r58 :: bool
    r59 :: object
    r60 :: float
    r61 :: bit
    r62 :: str
    r63 :: object
    r64 :: object[2]
    r65 :: object_ptr
    r66, r67 :: object
    r68 :: dict
    r69 :: str
    r70, r71 :: object
    r72 :: float
    r73 :: bit
    r74 :: bool
    r75 :: object
    r76 :: float
    r77 :: bit
    r78 :: float
    r79 :: bit
    r80 :: object
    r81 :: float
    r82 :: bool
    r83 :: object
    r84 :: float
    r85, r86 :: bit
    r87 :: object
    r88 :: dank_mids.stats._StatsLogger
    r89 :: None
    r90 :: dank_mids.stats._StatsLogger
    r91 :: None
    r92 :: dank_mids.stats._StatsLogger
    r93 :: None
    r94 :: bool
    r95 :: object
    r96 :: bool
    r97, r98 :: bit
    r99 :: bool
    r100 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_next_label__
    goto L84
L1:
    r3 = load_address _Py_NoneStruct
    r4 = type != r3
    if r4 goto L2 else goto L4 :: bool
L2:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L88 (error at _stats_daemon:270) else goto L3 :: bool
L3:
    unreachable
L4:
    r5 = dank_mids.stats.globals :: static
    r6 = 'time'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L88 (error at _stats_daemon:278) else goto L5
L5:
    r8 = PyObject_Vectorcall(r7, 0, 0, 0)
    dec_ref r7
    if is_error(r8) goto L88 (error at _stats_daemon:278) else goto L6
L6:
    r9 = unbox(float, r8)
    dec_ref r8
    r10 = r9 == -113.0
    if r10 goto L8 else goto L7 :: bool
L7:
    __mypyc_self__.start = r9; r11 = is_error
    if not r11 goto L88 (error at _stats_daemon:278) else goto L9 :: bool
L8:
    r12 = PyErr_Occurred()
    if not is_error(r12) goto L88 (error at _stats_daemon:278) else goto L7
L9:
    __mypyc_self__.time_since_notified = 0.0; r13 = is_error
    if not r13 goto L88 (error at _stats_daemon:279) else goto L10 :: bool
L10:
    if 1 goto L11 else goto L79 :: bool
L11:
    r14 = dank_mids.stats.yield_to_loop :: static
    if is_error(r14) goto L12 else goto L14
L12:
    r15 = raise NameError('value for final name "yield_to_loop" was not set')
    if not r15 goto L88 (error at _stats_daemon:281) else goto L13 :: bool
L13:
    unreachable
L14:
    r16 = PyObject_Vectorcall(r14, 0, 0, 0)
    if is_error(r16) goto L88 (error at _stats_daemon:281) else goto L15
L15:
    r17 = CPy_GetCoro(r16)
    dec_ref r16
    if is_error(r17) goto L88 (error at _stats_daemon:281) else goto L16
L16:
    __mypyc_self__.__mypyc_temp__0 = r17; r18 = is_error
    if not r18 goto L88 (error at _stats_daemon:-1) else goto L17 :: bool
L17:
    r19 = __mypyc_self__.__mypyc_temp__0
    if is_error(r19) goto L88 (error at _stats_daemon:-1) else goto L18
L18:
    r20 = CPyIter_Next(r19)
    dec_ref r19
    if is_error(r20) goto L19 else goto L21
L19:
    r21 = CPy_FetchStopIterationValue()
    if is_error(r21) goto L88 (error at _stats_daemon:281) else goto L20
L20:
    r22 = r21
    dec_ref r22
    r23 = <error> :: object
    __mypyc_self__.__mypyc_temp__0 = r23; r24 = is_error
    if not r24 goto L88 (error at _stats_daemon:281) else goto L43 :: bool
L21:
    r25 = r20
L22:
    __mypyc_self__.__mypyc_next_label__ = 1
    return r25
L23:
    r27 = load_address _Py_NoneStruct
    r28 = type != r27
    if r28 goto L24 else goto L89 :: bool
L24:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L27 (error at _stats_daemon:281) else goto L90 :: bool
L25:
    unreachable
L26:
    inc_ref arg
    goto L38
L27:
    r29 = CPy_CatchError()
    __mypyc_self__.__mypyc_temp__1 = r29; r30 = is_error
    if not r30 goto L91 (error at _stats_daemon:-1) else goto L28 :: bool
L28:
    r31 = load_address r1
    r32 = __mypyc_self__.__mypyc_temp__0
    if is_error(r32) goto L91 (error at _stats_daemon:-1) else goto L29
L29:
    r33 = CPy_YieldFromErrorHandle(r32, r31)
    dec_ref r32
    if is_error(r33) goto L91 (error at _stats_daemon:281) else goto L30
L30:
    if r33 goto L33 else goto L31 :: bool
L31:
    r25 = r1
    r34 = __mypyc_self__.__mypyc_temp__1
    if is_error(r34) goto L92 (error at _stats_daemon:-1) else goto L32
L32:
    CPy_RestoreExcInfo(r34)
    dec_ref r34
    goto L22
L33:
    r22 = r1
    dec_ref r22
    r35 = __mypyc_self__.__mypyc_temp__1
    if is_error(r35) goto L35 (error at _stats_daemon:-1) else goto L34
L34:
    CPy_RestoreExcInfo(r35)
    dec_ref r35
    goto L43
L35:
    r36 = __mypyc_self__.__mypyc_temp__1
    if is_error(r36) goto L88 (error at _stats_daemon:-1) else goto L36
L36:
    CPy_RestoreExcInfo(r36)
    dec_ref r36
    r37 = CPy_KeepPropagating()
    if not r37 goto L88 else goto L37 :: bool
L37:
    unreachable
L38:
    r38 = __mypyc_self__.__mypyc_temp__0
    if is_error(r38) goto L93 (error at _stats_daemon:-1) else goto L39
L39:
    r39 = CPyIter_Send(r38, arg)
    dec_ref r38
    dec_ref arg
    if is_error(r39) goto L41 else goto L40
L40:
    r25 = r39
    goto L22
L41:
    r40 = CPy_FetchStopIterationValue()
    if is_error(r40) goto L88 (error at _stats_daemon:281) else goto L42
L42:
    r22 = r40
    dec_ref r22
L43:
    r41 = dank_mids.stats.globals :: static
    r42 = 'time'
    r43 = CPyDict_GetItem(r41, r42)
    if is_error(r43) goto L88 (error at _stats_daemon:282) else goto L44
L44:
    r44 = PyObject_Vectorcall(r43, 0, 0, 0)
    dec_ref r43
    if is_error(r44) goto L88 (error at _stats_daemon:282) else goto L45
L45:
    r45 = unbox(float, r44)
    dec_ref r44
    r46 = r45 == -113.0
    if r46 goto L47 else goto L46 :: bool
L46:
    __mypyc_self__.now = r45; r47 = is_error
    if not r47 goto L88 (error at _stats_daemon:282) else goto L48 :: bool
L47:
    r48 = PyErr_Occurred()
    if not is_error(r48) goto L88 (error at _stats_daemon:282) else goto L46
L48:
    r49 = __mypyc_self__.now
    r50 = r49 == -113.0
    if r50 goto L50 else goto L49 :: bool
L49:
    r51 = __mypyc_self__.start
    r52 = r51 == -113.0
    if r52 goto L52 else goto L51 :: bool
L50:
    r53 = PyErr_Occurred()
    if not is_error(r53) goto L88 (error at _stats_daemon:283) else goto L49
L51:
    r54 = r49 - r51
    __mypyc_self__.duration = r54; r55 = is_error
    if not r55 goto L88 (error at _stats_daemon:283) else goto L53 :: bool
L52:
    r56 = PyErr_Occurred()
    if not is_error(r56) goto L88 (error at _stats_daemon:283) else goto L51
L53:
    r57 = dank_mids.stats.collector :: static
    if is_error(r57) goto L54 else goto L56
L54:
    r58 = raise NameError('value for final name "collector" was not set')
    if not r58 goto L88 (error at _stats_daemon:284) else goto L55 :: bool
L55:
    unreachable
L56:
    r59 = r57.event_loop_times
    r60 = __mypyc_self__.duration
    r61 = r60 == -113.0
    if r61 goto L58 else goto L57 :: bool
L57:
    r62 = 'append'
    r63 = box(float, r60)
    r64 = [r59, r63]
    r65 = load_address r64
    r66 = PyObject_VectorcallMethod(r62, r65, 9223372036854775810, 0)
    if is_error(r66) goto L94 (error at _stats_daemon:284) else goto L95
L58:
    r67 = PyErr_Occurred()
    if not is_error(r67) goto L96 (error at _stats_daemon:284) else goto L57
L59:
    dec_ref r59
    dec_ref r63
    r68 = dank_mids.stats.globals :: static
    r69 = 'time'
    r70 = CPyDict_GetItem(r68, r69)
    if is_error(r70) goto L88 (error at _stats_daemon:285) else goto L60
L60:
    r71 = PyObject_Vectorcall(r70, 0, 0, 0)
    dec_ref r70
    if is_error(r71) goto L88 (error at _stats_daemon:285) else goto L61
L61:
    r72 = unbox(float, r71)
    dec_ref r71
    r73 = r72 == -113.0
    if r73 goto L63 else goto L62 :: bool
L62:
    __mypyc_self__.start = r72; r74 = is_error
    if not r74 goto L88 (error at _stats_daemon:285) else goto L64 :: bool
L63:
    r75 = PyErr_Occurred()
    if not is_error(r75) goto L88 (error at _stats_daemon:285) else goto L62
L64:
    r76 = __mypyc_self__.time_since_notified
    r77 = r76 == -113.0
    if r77 goto L66 else goto L65 :: bool
L65:
    r78 = __mypyc_self__.duration
    r79 = r78 == -113.0
    if r79 goto L68 else goto L67 :: bool
L66:
    r80 = PyErr_Occurred()
    if not is_error(r80) goto L88 (error at _stats_daemon:286) else goto L65
L67:
    r81 = r76 + r78
    __mypyc_self__.time_since_notified = r81; r82 = is_error
    if not r82 goto L88 (error at _stats_daemon:286) else goto L69 :: bool
L68:
    r83 = PyErr_Occurred()
    if not is_error(r83) goto L88 (error at _stats_daemon:286) else goto L67
L69:
    r84 = __mypyc_self__.time_since_notified
    r85 = r84 == -113.0
    if r85 goto L71 else goto L70 :: bool
L70:
    r86 = r84 > 300.0
    if r86 goto L72 else goto L10 :: bool
L71:
    r87 = PyErr_Occurred()
    if not is_error(r87) goto L88 (error at _stats_daemon:287) else goto L70
L72:
    r88 = __mypyc_self__.self
    if is_error(r88) goto L88 (error at _stats_daemon:288) else goto L73
L73:
    r89 = r88.log_subprocess_stats(40)
    dec_ref r88
    if is_error(r89) goto L88 (error at _stats_daemon:288) else goto L74
L74:
    r90 = __mypyc_self__.self
    if is_error(r90) goto L88 (error at _stats_daemon:289) else goto L75
L75:
    r91 = r90.log_brownie_stats(40)
    dec_ref r90
    if is_error(r91) goto L88 (error at _stats_daemon:289) else goto L76
L76:
    r92 = __mypyc_self__.self
    if is_error(r92) goto L88 (error at _stats_daemon:290) else goto L77
L77:
    r93 = r92.log_event_loop_stats(40)
    dec_ref r92
    if is_error(r93) goto L88 (error at _stats_daemon:290) else goto L78
L78:
    __mypyc_self__.time_since_notified = 0.0; r94 = is_error
    if not r94 goto L88 (error at _stats_daemon:291) else goto L10 :: bool
L79:
    r95 = box(None, 1)
    __mypyc_self__.__mypyc_next_label__ = -1
L80:
    if is_error(stop_iter_ptr) goto L81 else goto L83
L81:
    CPyGen_SetStopIterationValue(r95)
    if not 0 goto L88 else goto L82 :: bool
L82:
    unreachable
L83:
    inc_ref r95
    set_mem stop_iter_ptr, r95 :: builtins.object*
    return 0
L84:
    r97 = r2 == 0
    if r97 goto L97 else goto L85 :: bool
L85:
    r98 = r2 == 1
    if r98 goto L23 else goto L98 :: bool
L86:
    r99 = raise StopIteration
    if not r99 goto L88 (error at _stats_daemon:270) else goto L87 :: bool
L87:
    unreachable
L88:
    r100 = <error> :: object
    return r100
L89:
    xdec_ref r1
    goto L26
L90:
    xdec_ref r1
    goto L25
L91:
    xdec_ref r1
    goto L35
L92:
    dec_ref r25
    goto L35
L93:
    dec_ref arg
    goto L88
L94:
    dec_ref r59
    dec_ref r63
    goto L88
L95:
    dec_ref r66
    goto L59
L96:
    dec_ref r59
    goto L88
L97:
    xdec_ref r1
    goto L1
L98:
    xdec_ref r1
    goto L86

def _stats_daemon__StatsLogger_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.stats._stats_daemon__StatsLogger_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _stats_daemon__StatsLogger_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _stats_daemon__StatsLogger_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.stats._stats_daemon__StatsLogger_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _stats_daemon__StatsLogger_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg, 0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _stats_daemon__StatsLogger_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.stats._stats_daemon__StatsLogger_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _stats_daemon__StatsLogger_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.stats._stats_daemon__StatsLogger_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = _stats_daemon__StatsLogger_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0, 0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def _stats_daemon__StatsLogger_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.stats._stats_daemon__StatsLogger_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def _stats_daemon__StatsLogger_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.stats._stats_daemon__StatsLogger_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _StatsLogger._stats_daemon(self):
    self :: dank_mids.stats._StatsLogger
    r0 :: dank_mids.stats._stats_daemon__StatsLogger_gen
    r1, r2 :: bool
    r3 :: dank_mids.stats._stats_daemon__StatsLogger_gen
L0:
    r0 = _stats_daemon__StatsLogger_gen()
    if is_error(r0) goto L3 (error at _stats_daemon:270) else goto L1
L1:
    r0.__mypyc_next_label__ = 0
    inc_ref self
    r0.self = self; r2 = is_error
    if not r2 goto L4 (error at _stats_daemon:270) else goto L2 :: bool
L2:
    return r0
L3:
    r3 = <error> :: dank_mids.stats._stats_daemon__StatsLogger_gen
    return r3
L4:
    dec_ref r0
    goto L3

def _StatsLogger.log_validation_error(self, method, e):
    self :: dank_mids.stats._StatsLogger
    method, e :: object
    r0 :: str
    r1 :: object
    r2 :: object[2]
    r3 :: object_ptr
    r4 :: object
    r5 :: bool
    r6 :: dict
    r7 :: str
    r8 :: object
    r9 :: bool
    r10 :: dank_mids.stats._Collector
    r11 :: bool
    r12 :: dict
    r13 :: object
    r14 :: str
    r15 :: object[2]
    r16 :: object_ptr
    r17 :: object
    r18 :: str
    r19 :: tuple[object]
    r20 :: dict
    r21 :: object
    r22, r23 :: None
L0:
    r0 = 'isEnabledFor'
    r1 = object 15
    r2 = [self, r1]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r0, r3, 9223372036854775810, 0)
    if is_error(r4) goto L16 (error at log_validation_error:306) else goto L1
L1:
    r5 = unbox(bool, r4)
    dec_ref r4
    if is_error(r5) goto L16 (error at log_validation_error:306) else goto L2
L2:
    r6 = dank_mids.stats.globals :: static
    r7 = 'COLLECT_STATS'
    r8 = CPyDict_GetItem(r6, r7)
    if is_error(r8) goto L16 (error at log_validation_error:307) else goto L3
L3:
    r9 = unbox(bool, r8)
    dec_ref r8
    if is_error(r9) goto L16 (error at log_validation_error:307) else goto L4
L4:
    if r9 goto L6 else goto L5 :: bool
L5:
    if r5 goto L6 else goto L12 :: bool
L6:
    r10 = dank_mids.stats.collector :: static
    if is_error(r10) goto L7 else goto L9
L7:
    r11 = raise NameError('value for final name "collector" was not set')
    if not r11 goto L16 (error at log_validation_error:308) else goto L8 :: bool
L8:
    unreachable
L9:
    r12 = r10.validation_errors
    r13 = CPyDict_GetItem(r12, method)
    dec_ref r12
    if is_error(r13) goto L16 (error at log_validation_error:308) else goto L10
L10:
    r14 = 'append'
    r15 = [r13, e]
    r16 = load_address r15
    r17 = PyObject_VectorcallMethod(r14, r16, 9223372036854775810, 0)
    if is_error(r17) goto L17 (error at log_validation_error:308) else goto L18
L11:
    dec_ref r13
L12:
    if r5 goto L13 else goto L15 :: bool
L13:
    r18 = "ValidationError when decoding response for %s. This *should* not impact your script. If it does, you'll know."
    inc_ref method
    r19 = (method)
    r20 = PyDict_New()
    if is_error(r20) goto L19 (error at log_validation_error:310) else goto L14
L14:
    r21 = box(tuple[object], r19)
    r22 = self._log(30, r18, r21, r20)
    dec_ref r21
    dec_ref r20
    if is_error(r22) goto L16 (error at log_validation_error:310) else goto L15
L15:
    return 1
L16:
    r23 = <error> :: None
    return r23
L17:
    dec_ref r13
    goto L16
L18:
    dec_ref r17
    goto L11
L19:
    dec_ref r19
    goto L16

def _StatsLogger.log_types(self, method, decoded):
    self :: dank_mids.stats._StatsLogger
    method, decoded :: object
    r0 :: set
    r1 :: str
    r2 :: object[1]
    r3 :: object_ptr
    r4, r5, r6, r7 :: object
    r8 :: i32
    r9, r10 :: bit
    r11, r12, r13, r14, r15 :: str
    r16 :: tuple
    r17 :: dict
    r18 :: None
    r19 :: object
    r20 :: i32
    r21 :: bit
    r22 :: bool
    r23 :: str
    r24 :: object[1]
    r25 :: object_ptr
    r26 :: object
    r27 :: int
    r28 :: None
    r29 :: dank_mids.stats._Collector
    r30 :: bool
    r31 :: set
    r32 :: i32
    r33 :: bit
    r34 :: None
L0:
    r0 = PySet_New(0)
    if is_error(r0) goto L21 (error at log_types:332) else goto L1
L1:
    r1 = 'values'
    r2 = [decoded]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775809, 0)
    if is_error(r4) goto L22 (error at log_types:332) else goto L2
L2:
    r5 = PyObject_GetIter(r4)
    dec_ref r4
    if is_error(r5) goto L22 (error at log_types:332) else goto L3
L3:
    r6 = PyIter_Next(r5)
    if is_error(r6) goto L23 else goto L4
L4:
    r7 = PyObject_Type(r6)
    dec_ref r6
    r8 = PySet_Add(r0, r7)
    dec_ref r7
    r9 = r8 >= 0 :: signed
    if not r9 goto L24 (error at log_types:332) else goto L3 :: bool
L5:
    r10 = CPy_NoErrOccurred()
    if not r10 goto L22 (error at log_types:332) else goto L6 :: bool
L6:
    r11 = 'my method and types: '
    r12 = PyObject_Str(method)
    if is_error(r12) goto L25 (error at log_types:333) else goto L7
L7:
    r13 = ' '
    r14 = PyObject_Str(r0)
    if is_error(r14) goto L26 (error at log_types:333) else goto L8
L8:
    r15 = CPyStr_Build(4, r11, r12, r13, r14)
    dec_ref r12
    dec_ref r14
    if is_error(r15) goto L25 (error at log_types:333) else goto L9
L9:
    r16 = PyTuple_Pack(0)
    if is_error(r16) goto L27 (error at log_types:333) else goto L10
L10:
    r17 = PyDict_New()
    if is_error(r17) goto L28 (error at log_types:333) else goto L11
L11:
    r18 = self.devhint(r15, r16, r17)
    dec_ref r15
    dec_ref r16
    dec_ref r17
    if is_error(r18) goto L25 (error at log_types:333) else goto L12
L12:
    r19 = load_address PyList_Type
    r20 = PySet_Contains(r0, r19)
    r21 = r20 >= 0 :: signed
    if not r21 goto L25 (error at log_types:334) else goto L13 :: bool
L13:
    r22 = truncate r20: i32 to builtins.bool
    if r22 goto L14 else goto L16 :: bool
L14:
    r23 = 'values'
    r24 = [decoded]
    r25 = load_address r24
    r26 = PyObject_VectorcallMethod(r23, r25, 9223372036854775809, 0)
    if is_error(r26) goto L25 (error at log_types:335) else goto L15
L15:
    r27 = <error> :: int
    r28 = self._log_list_types(r26, r27)
    dec_ref r26
    if is_error(r28) goto L25 (error at log_types:335) else goto L16
L16:
    r29 = dank_mids.stats.collector :: static
    if is_error(r29) goto L29 else goto L19
L17:
    r30 = raise NameError('value for final name "collector" was not set')
    if not r30 goto L21 (error at log_types:336) else goto L18 :: bool
L18:
    unreachable
L19:
    r31 = r29.types
    r32 = _PySet_Update(r31, r0)
    dec_ref r31
    dec_ref r0
    r33 = r32 >= 0 :: signed
    if not r33 goto L21 (error at log_types:336) else goto L20 :: bool
L20:
    return 1
L21:
    r34 = <error> :: None
    return r34
L22:
    dec_ref r0
    goto L21
L23:
    dec_ref r5
    goto L5
L24:
    dec_ref r0
    dec_ref r5
    goto L21
L25:
    dec_ref r0
    goto L21
L26:
    dec_ref r0
    dec_ref r12
    goto L21
L27:
    dec_ref r0
    dec_ref r15
    goto L21
L28:
    dec_ref r0
    dec_ref r15
    dec_ref r16
    goto L21
L29:
    dec_ref r0
    goto L17

def _StatsLogger._log_list_types(self, values, level):
    self :: dank_mids.stats._StatsLogger
    values :: object
    level :: int
    r0 :: set
    r1, r2 :: object
    r3 :: bit
    r4 :: list
    r5 :: native_int
    r6 :: ptr
    r7 :: native_int
    r8 :: bit
    r9, r10 :: ptr
    r11 :: native_int
    r12 :: ptr
    r13, r14 :: object
    r15 :: i32
    r16 :: bit
    r17 :: native_int
    r18 :: bit
    r19 :: dank_mids.stats._Collector
    r20 :: bool
    r21 :: set
    r22 :: i32
    r23 :: bit
    r24 :: str
    r25 :: object
    r26 :: object[2]
    r27 :: object_ptr
    r28 :: object
    r29 :: bool
    r30, r31, r32 :: str
    r33 :: dict
    r34 :: tuple
    r35, r36 :: None
L0:
    if is_error(level) goto L1 else goto L25
L1:
    level = 30
L2:
    r0 = PySet_New(0)
    if is_error(r0) goto L26 (error at _log_list_types:353) else goto L3
L3:
    r1 = PyObject_GetIter(values)
    if is_error(r1) goto L27 (error at _log_list_types:353) else goto L4
L4:
    r2 = PyIter_Next(r1)
    if is_error(r2) goto L28 else goto L5
L5:
    r3 = PyList_Check(r2)
    if r3 goto L6 else goto L29 :: bool
L6:
    r4 = cast(list, r2)
    if is_error(r4) goto L30 (error at _log_list_types:353) else goto L7
L7:
    r5 = 0
L8:
    r6 = get_element_ptr r4 ob_size :: PyVarObject
    r7 = load_mem r6 :: native_int*
    r8 = r5 < r7 :: signed
    if r8 goto L9 else goto L31 :: bool
L9:
    r9 = get_element_ptr r4 ob_item :: PyListObject
    r10 = load_mem r9 :: ptr*
    r11 = r5 * 8
    r12 = r10 + r11
    r13 = load_mem r12 :: builtins.object*
    r14 = PyObject_Type(r13)
    dec_ref r13
    r15 = PySet_Add(r0, r14)
    dec_ref r14
    r16 = r15 >= 0 :: signed
    if not r16 goto L32 (error at _log_list_types:353) else goto L10 :: bool
L10:
    r17 = r5 + 1
    r5 = r17
    goto L8
L11:
    r18 = CPy_NoErrOccurred()
    if not r18 goto L27 (error at _log_list_types:353) else goto L12 :: bool
L12:
    r19 = dank_mids.stats.collector :: static
    if is_error(r19) goto L33 else goto L15
L13:
    r20 = raise NameError('value for final name "collector" was not set')
    if not r20 goto L24 (error at _log_list_types:354) else goto L14 :: bool
L14:
    unreachable
L15:
    r21 = r19.types
    r22 = _PySet_Update(r21, r0)
    dec_ref r21
    r23 = r22 >= 0 :: signed
    if not r23 goto L34 (error at _log_list_types:354) else goto L16 :: bool
L16:
    r24 = 'isEnabledFor'
    inc_ref level :: int
    r25 = box(int, level)
    r26 = [self, r25]
    r27 = load_address r26
    r28 = PyObject_VectorcallMethod(r24, r27, 9223372036854775810, 0)
    if is_error(r28) goto L35 (error at _log_list_types:355) else goto L17
L17:
    dec_ref r25
    r29 = unbox(bool, r28)
    dec_ref r28
    if is_error(r29) goto L34 (error at _log_list_types:355) else goto L18
L18:
    if r29 goto L19 else goto L36 :: bool
L19:
    r30 = 'list types: '
    r31 = PyObject_Str(r0)
    dec_ref r0
    if is_error(r31) goto L26 (error at _log_list_types:356) else goto L20
L20:
    r32 = CPyStr_Build(2, r30, r31)
    dec_ref r31
    if is_error(r32) goto L26 (error at _log_list_types:356) else goto L21
L21:
    r33 = PyDict_New()
    if is_error(r33) goto L37 (error at _log_list_types:356) else goto L22
L22:
    r34 = <error> :: tuple
    r35 = self._log(level, r32, r34, r33)
    dec_ref level :: int
    dec_ref r32
    dec_ref r33
    if is_error(r35) goto L24 (error at _log_list_types:356) else goto L23
L23:
    return 1
L24:
    r36 = <error> :: None
    return r36
L25:
    inc_ref level :: int
    goto L2
L26:
    dec_ref level :: int
    goto L24
L27:
    dec_ref level :: int
    dec_ref r0
    goto L24
L28:
    dec_ref r1
    goto L11
L29:
    dec_ref r2
    goto L4
L30:
    dec_ref level :: int
    dec_ref r0
    dec_ref r1
    goto L24
L31:
    dec_ref r4
    goto L4
L32:
    dec_ref level :: int
    dec_ref r0
    dec_ref r1
    dec_ref r4
    goto L24
L33:
    dec_ref level :: int
    dec_ref r0
    goto L13
L34:
    dec_ref level :: int
    dec_ref r0
    goto L24
L35:
    dec_ref level :: int
    dec_ref r0
    dec_ref r25
    goto L24
L36:
    dec_ref level :: int
    dec_ref r0
    goto L23
L37:
    dec_ref level :: int
    dec_ref r32
    goto L24

def __mypyc_lambda__0___init____Collector_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__0___init____Collector_obj.__call__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.stats.__mypyc_lambda__0___init____Collector_obj
    r0 :: dank_mids.stats.__init____Collector_env
    r1 :: dict
    r2 :: str
    r3, r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8, r9 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L4 (error at <lambda>:373) else goto L5
L1:
    r1 = dank_mids.stats.globals :: static
    r2 = 'deque'
    r3 = CPyDict_GetItem(r1, r2)
    if is_error(r3) goto L4 (error at <lambda>:373) else goto L2
L2:
    r4 = object 50000
    r5 = [r4]
    r6 = load_address r5
    r7 = ('maxlen',)
    r8 = PyObject_Vectorcall(r3, r6, 0, r7)
    dec_ref r3
    if is_error(r8) goto L4 (error at <lambda>:373) else goto L3
L3:
    return r8
L4:
    r9 = <error> :: object
    return r9
L5:
    dec_ref r0
    goto L1

def __mypyc_lambda__1___init____Collector_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__1___init____Collector_obj.__call__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.stats.__mypyc_lambda__1___init____Collector_obj
    r0 :: dank_mids.stats.__init____Collector_env
    r1 :: dict
    r2 :: str
    r3, r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8, r9 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L4 (error at <lambda>:394) else goto L5
L1:
    r1 = dank_mids.stats.globals :: static
    r2 = 'deque'
    r3 = CPyDict_GetItem(r1, r2)
    if is_error(r3) goto L4 (error at <lambda>:394) else goto L2
L2:
    r4 = object 100
    r5 = [r4]
    r6 = load_address r5
    r7 = ('maxlen',)
    r8 = PyObject_Vectorcall(r3, r6, 0, r7)
    dec_ref r3
    if is_error(r8) goto L4 (error at <lambda>:394) else goto L3
L3:
    return r8
L4:
    r9 = <error> :: object
    return r9
L5:
    dec_ref r0
    goto L1

def _Collector.__init__(self):
    self :: dank_mids.stats._Collector
    r0 :: dank_mids.stats.__init____Collector_env
    r1 :: dict
    r2 :: str
    r3, r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
    r9 :: dank_mids.stats.__mypyc_lambda__0___init____Collector_obj
    r10 :: bool
    r11 :: dict
    r12 :: str
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: dict
    r18 :: set
    r19 :: dict
    r20 :: str
    r21, r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25, r26 :: object
    r27 :: dank_mids.stats.__mypyc_lambda__1___init____Collector_obj
    r28 :: bool
    r29 :: dict
    r30 :: str
    r31 :: object
    r32 :: object[1]
    r33 :: object_ptr
    r34 :: object
    r35 :: dict
    r36 :: None
L0:
    r0 = __init____Collector_env()
    if is_error(r0) goto L17 (error at __init__:366) else goto L1
L1:
    r1 = dank_mids.stats.globals :: static
    r2 = 'deque'
    r3 = CPyDict_GetItem(r1, r2)
    if is_error(r3) goto L18 (error at __init__:367) else goto L2
L2:
    r4 = object 500
    r5 = [r4]
    r6 = load_address r5
    r7 = ('maxlen',)
    r8 = PyObject_Vectorcall(r3, r6, 0, r7)
    dec_ref r3
    if is_error(r8) goto L18 (error at __init__:367) else goto L3
L3:
    self.errd_batches = r8
    r9 = __mypyc_lambda__0___init____Collector_obj()
    if is_error(r9) goto L18 (error at __init__:373) else goto L4
L4:
    inc_ref r0
    r9.__mypyc_env__ = r0; r10 = is_error
    if not r10 goto L19 (error at __init__:373) else goto L5 :: bool
L5:
    r11 = dank_mids.stats.globals :: static
    r12 = 'defaultdict'
    r13 = CPyDict_GetItem(r11, r12)
    if is_error(r13) goto L19 (error at __init__:373) else goto L6
L6:
    r14 = [r9]
    r15 = load_address r14
    r16 = PyObject_Vectorcall(r13, r15, 1, 0)
    dec_ref r13
    if is_error(r16) goto L19 (error at __init__:373) else goto L7
L7:
    dec_ref r9
    r17 = cast(dict, r16)
    if is_error(r17) goto L18 (error at __init__:373) else goto L8
L8:
    self.durations = r17
    r18 = PySet_New(0)
    if is_error(r18) goto L18 (error at __init__:380) else goto L9
L9:
    self.types = r18
    r19 = dank_mids.stats.globals :: static
    r20 = 'deque'
    r21 = CPyDict_GetItem(r19, r20)
    if is_error(r21) goto L18 (error at __init__:386) else goto L10
L10:
    r22 = object 50000
    r23 = [r22]
    r24 = load_address r23
    r25 = ('maxlen',)
    r26 = PyObject_Vectorcall(r21, r24, 0, r25)
    dec_ref r21
    if is_error(r26) goto L18 (error at __init__:386) else goto L11
L11:
    self.event_loop_times = r26
    r27 = __mypyc_lambda__1___init____Collector_obj()
    if is_error(r27) goto L18 (error at __init__:394) else goto L12
L12:
    r27.__mypyc_env__ = r0; r28 = is_error
    if not r28 goto L20 (error at __init__:394) else goto L13 :: bool
L13:
    r29 = dank_mids.stats.globals :: static
    r30 = 'defaultdict'
    r31 = CPyDict_GetItem(r29, r30)
    if is_error(r31) goto L20 (error at __init__:394) else goto L14
L14:
    r32 = [r27]
    r33 = load_address r32
    r34 = PyObject_Vectorcall(r31, r33, 1, 0)
    dec_ref r31
    if is_error(r34) goto L20 (error at __init__:394) else goto L15
L15:
    dec_ref r27
    r35 = cast(dict, r34)
    if is_error(r35) goto L17 (error at __init__:394) else goto L16
L16:
    self.validation_errors = r35
    return 1
L17:
    r36 = <error> :: None
    return r36
L18:
    dec_ref r0
    goto L17
L19:
    dec_ref r0
    dec_ref r9
    goto L17
L20:
    dec_ref r27
    goto L17

def _Collector.avg_loop_time(self):
    self, r0 :: dank_mids.stats._Collector
    r1 :: bool
    r2, r3 :: object
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8 :: object
    r9 :: union[float, int]
    r10 :: dank_mids.stats._Collector
    r11 :: bool
    r12 :: object
    r13 :: int
    r14, r15 :: object
    r16 :: float
    r17 :: bit
    r18 :: object
    r19 :: float
L0:
    r0 = dank_mids.stats.collector :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "collector" was not set')
    if not r1 goto L14 (error at avg_loop_time:413) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = r0.event_loop_times
    r3 = builtins :: module
    r4 = 'sum'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L15 (error at avg_loop_time:413) else goto L4
L4:
    r6 = [r2]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r5, r7, 1, 0)
    dec_ref r5
    if is_error(r8) goto L15 (error at avg_loop_time:413) else goto L5
L5:
    dec_ref r2
    r9 = cast(union[float, int], r8)
    if is_error(r9) goto L14 (error at avg_loop_time:413) else goto L6
L6:
    r10 = dank_mids.stats.collector :: static
    if is_error(r10) goto L16 else goto L9
L7:
    r11 = raise NameError('value for final name "collector" was not set')
    if not r11 goto L14 (error at avg_loop_time:413) else goto L8 :: bool
L8:
    unreachable
L9:
    r12 = r10.event_loop_times
    r13 = CPyObject_Size(r12)
    dec_ref r12
    if is_error(r13) goto L17 (error at avg_loop_time:413) else goto L10
L10:
    r14 = box(int, r13)
    r15 = PyNumber_TrueDivide(r9, r14)
    dec_ref r9
    dec_ref r14
    if is_error(r15) goto L14 (error at avg_loop_time:413) else goto L11
L11:
    r16 = unbox(float, r15)
    dec_ref r15
    r17 = r16 == -113.0
    if r17 goto L13 else goto L12 :: bool
L12:
    return r16
L13:
    r18 = PyErr_Occurred()
    if not is_error(r18) goto L14 (error at avg_loop_time:413) else goto L12
L14:
    r19 = <error> :: float
    return r19
L15:
    dec_ref r2
    goto L14
L16:
    dec_ref r9
    goto L7
L17:
    dec_ref r9
    goto L14

def _Collector.count_active_brownie_calls(self):
    self :: dank_mids.stats._Collector
    r0 :: object
    r1 :: bool
    r2 :: str
    r3, r4 :: object
    r5 :: bool
    r6 :: str
    r7 :: object
    r8 :: str
    r9, r10 :: object
    r11, r12 :: int
L0:
    r0 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "BROWNIE_CALL_SEMAPHORE" was not set')
    if not r1 goto L12 (error at count_active_brownie_calls:426) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = 'default_value'
    r3 = CPyObject_GetAttr(r0, r2)
    if is_error(r3) goto L12 (error at count_active_brownie_calls:426) else goto L4
L4:
    r4 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE :: static
    if is_error(r4) goto L13 else goto L7
L5:
    r5 = raise NameError('value for final name "BROWNIE_CALL_SEMAPHORE" was not set')
    if not r5 goto L12 (error at count_active_brownie_calls:426) else goto L6 :: bool
L6:
    unreachable
L7:
    r6 = 'semaphore'
    r7 = CPyObject_GetAttr(r4, r6)
    if is_error(r7) goto L14 (error at count_active_brownie_calls:426) else goto L8
L8:
    r8 = '_value'
    r9 = CPyObject_GetAttr(r7, r8)
    dec_ref r7
    if is_error(r9) goto L14 (error at count_active_brownie_calls:426) else goto L9
L9:
    r10 = PyNumber_Subtract(r3, r9)
    dec_ref r3
    dec_ref r9
    if is_error(r10) goto L12 (error at count_active_brownie_calls:426) else goto L10
L10:
    r11 = unbox(int, r10)
    dec_ref r10
    if is_error(r11) goto L12 (error at count_active_brownie_calls:426) else goto L11
L11:
    return r11
L12:
    r12 = <error> :: int
    return r12
L13:
    dec_ref r3
    goto L5
L14:
    dec_ref r3
    goto L12

def _Collector.count_queued_brownie_calls(self):
    self :: dank_mids.stats._Collector
    r0 :: object
    r1 :: bool
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6, r7 :: int
L0:
    r0 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "BROWNIE_CALL_SEMAPHORE" was not set')
    if not r1 goto L7 (error at count_queued_brownie_calls:439) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = 'semaphore'
    r3 = CPyObject_GetAttr(r0, r2)
    if is_error(r3) goto L7 (error at count_queued_brownie_calls:439) else goto L4
L4:
    r4 = '_waiters'
    r5 = CPyObject_GetAttr(r3, r4)
    dec_ref r3
    if is_error(r5) goto L7 (error at count_queued_brownie_calls:439) else goto L5
L5:
    r6 = CPyObject_Size(r5)
    dec_ref r5
    if is_error(r6) goto L7 (error at count_queued_brownie_calls:439) else goto L6
L6:
    return r6
L7:
    r7 = <error> :: int
    return r7

def _Collector.encoder_queue_len(self):
    self :: dank_mids.stats._Collector
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: str
    r6 :: object
    r7, r8 :: int
L0:
    r0 = dank_mids.stats.globals :: static
    r1 = 'ENVS'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L5 (error at encoder_queue_len:452) else goto L1
L1:
    r3 = 'BROWNIE_ENCODER_PROCESSES'
    r4 = CPyObject_GetAttr(r2, r3)
    dec_ref r2
    if is_error(r4) goto L5 (error at encoder_queue_len:452) else goto L2
L2:
    r5 = '_queue_count'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L5 (error at encoder_queue_len:452) else goto L3
L3:
    r7 = unbox(int, r6)
    dec_ref r6
    if is_error(r7) goto L5 (error at encoder_queue_len:452) else goto L4
L4:
    return r7
L5:
    r8 = <error> :: int
    return r8

def _Collector.decoder_queue_len(self):
    self :: dank_mids.stats._Collector
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: str
    r6 :: object
    r7, r8 :: int
L0:
    r0 = dank_mids.stats.globals :: static
    r1 = 'ENVS'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L5 (error at decoder_queue_len:465) else goto L1
L1:
    r3 = 'BROWNIE_DECODER_PROCESSES'
    r4 = CPyObject_GetAttr(r2, r3)
    dec_ref r2
    if is_error(r4) goto L5 (error at decoder_queue_len:465) else goto L2
L2:
    r5 = '_queue_count'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L5 (error at decoder_queue_len:465) else goto L3
L3:
    r7 = unbox(int, r6)
    dec_ref r6
    if is_error(r7) goto L5 (error at decoder_queue_len:465) else goto L4
L4:
    return r7
L5:
    r8 = <error> :: int
    return r8

def _Collector.mcall_decoder_queue_len(self):
    self :: dank_mids.stats._Collector
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: str
    r6 :: object
    r7, r8 :: int
L0:
    r0 = dank_mids.stats.globals :: static
    r1 = 'ENVS'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L5 (error at mcall_decoder_queue_len:478) else goto L1
L1:
    r3 = 'MULTICALL_DECODER_PROCESSES'
    r4 = CPyObject_GetAttr(r2, r3)
    dec_ref r2
    if is_error(r4) goto L5 (error at mcall_decoder_queue_len:478) else goto L2
L2:
    r5 = '_queue_count'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L5 (error at mcall_decoder_queue_len:478) else goto L3
L3:
    r7 = unbox(int, r6)
    dec_ref r6
    if is_error(r7) goto L5 (error at mcall_decoder_queue_len:478) else goto L4
L4:
    return r7
L5:
    r8 = <error> :: int
    return r8

def _Writer.event_loop(self):
    self :: dank_mids.stats._Writer
    r0 :: str
    r1 :: dank_mids.stats._Collector
    r2 :: bool
    r3 :: float
    r4 :: bit
    r5 :: object
    r6 :: str
    r7 :: object
    r8, r9 :: str
L0:
    r0 = 'Average event loop time: '
    r1 = dank_mids.stats.collector :: static
    if is_error(r1) goto L1 else goto L3
L1:
    r2 = raise NameError('value for final name "collector" was not set')
    if not r2 goto L8 (error at event_loop:498) else goto L2 :: bool
L2:
    unreachable
L3:
    r3 = r1.avg_loop_time
    r4 = r3 == -113.0
    if r4 goto L5 else goto L4 :: bool
L4:
    r5 = box(float, r3)
    r6 = PyObject_Str(r5)
    dec_ref r5
    if is_error(r6) goto L8 (error at event_loop:498) else goto L6
L5:
    r7 = PyErr_Occurred()
    if not is_error(r7) goto L8 (error at event_loop:498) else goto L4
L6:
    r8 = CPyStr_Build(2, r0, r6)
    dec_ref r6
    if is_error(r8) goto L8 (error at event_loop:498) else goto L7
L7:
    return r8
L8:
    r9 = <error> :: str
    return r9

def _Writer.brownie(self):
    self :: dank_mids.stats._Writer
    r0 :: dank_mids.stats._Collector
    r1 :: bool
    r2 :: int
    r3, r4 :: str
    r5 :: dank_mids.stats._Collector
    r6 :: bool
    r7 :: int
    r8, r9 :: str
    r10 :: object
    r11 :: bool
    r12, r13, r14, r15 :: str
L0:
    r0 = dank_mids.stats.collector :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "collector" was not set')
    if not r1 goto L16 (error at brownie:510) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = r0.count_active_brownie_calls
    if is_error(r2) goto L16 (error at brownie:510) else goto L4
L4:
    r3 = CPyTagged_Str(r2)
    dec_ref r2 :: int
    if is_error(r3) goto L16 (error at brownie:510) else goto L5
L5:
    r4 = ' brownie calls are processing, '
    r5 = dank_mids.stats.collector :: static
    if is_error(r5) goto L17 else goto L8
L6:
    r6 = raise NameError('value for final name "collector" was not set')
    if not r6 goto L16 (error at brownie:510) else goto L7 :: bool
L7:
    unreachable
L8:
    r7 = r5.count_queued_brownie_calls
    if is_error(r7) goto L18 (error at brownie:510) else goto L9
L9:
    r8 = CPyTagged_Str(r7)
    dec_ref r7 :: int
    if is_error(r8) goto L18 (error at brownie:510) else goto L10
L10:
    r9 = ' are queued in '
    r10 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE :: static
    if is_error(r10) goto L19 else goto L13
L11:
    r11 = raise NameError('value for final name "BROWNIE_CALL_SEMAPHORE" was not set')
    if not r11 goto L16 (error at brownie:510) else goto L12 :: bool
L12:
    unreachable
L13:
    r12 = PyObject_Str(r10)
    if is_error(r12) goto L20 (error at brownie:510) else goto L14
L14:
    r13 = '.'
    r14 = CPyStr_Build(6, r3, r4, r8, r9, r12, r13)
    dec_ref r3
    dec_ref r8
    dec_ref r12
    if is_error(r14) goto L16 (error at brownie:510) else goto L15
L15:
    return r14
L16:
    r15 = <error> :: str
    return r15
L17:
    dec_ref r3
    goto L6
L18:
    dec_ref r3
    goto L16
L19:
    dec_ref r3
    dec_ref r8
    goto L11
L20:
    dec_ref r3
    dec_ref r8
    goto L16

def _Writer.queue(self, pool):
    self :: dank_mids.stats._Writer
    pool :: object
    r0, r1, r2 :: str
    r3 :: object
    r4 :: int
    r5, r6, r7, r8 :: str
L0:
    r0 = PyObject_Str(pool)
    if is_error(r0) goto L6 (error at queue:525) else goto L1
L1:
    r1 = ' has '
    r2 = '_queue_count'
    r3 = CPyObject_GetAttr(pool, r2)
    if is_error(r3) goto L7 (error at queue:525) else goto L2
L2:
    r4 = unbox(int, r3)
    dec_ref r3
    if is_error(r4) goto L7 (error at queue:525) else goto L3
L3:
    r5 = CPyTagged_Str(r4)
    dec_ref r4 :: int
    if is_error(r5) goto L7 (error at queue:525) else goto L4
L4:
    r6 = ' items in its queue'
    r7 = CPyStr_Build(4, r0, r1, r5, r6)
    dec_ref r0
    dec_ref r5
    if is_error(r7) goto L6 (error at queue:525) else goto L5
L5:
    return r7
L6:
    r8 = <error> :: str
    return r8
L7:
    dec_ref r0
    goto L6

def _SentryExporter.push_measurements(self):
    self :: dank_mids.stats._SentryExporter
    r0 :: union[object, None]
    r1 :: object
    r2 :: bit
    r3 :: object
    r4 :: i32
    r5 :: bit
    r6 :: bool
    r7 :: union[object, None]
    r8 :: dict
    r9 :: str
    r10 :: object
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: union[object, None]
    r15 :: object
    r16 :: str
    r17 :: object
    r18 :: union[object, None]
    r19 :: str
    r20 :: object[2]
    r21 :: object_ptr
    r22 :: object
    r23 :: dict
    r24 :: short_int
    r25 :: native_int
    r26 :: object
    r27 :: tuple[bool, short_int, object, object]
    r28 :: short_int
    r29 :: bool
    r30, r31 :: object
    r32, r33 :: str
    r34 :: dank_mids.stats._Collector
    r35 :: bool
    r36, attr, r37 :: object
    r38 :: str
    r39 :: object
    r40 :: object[1]
    r41 :: object_ptr
    r42 :: object
    r43 :: bool
    r44 :: object
    r45 :: dict
    r46 :: object
    r47 :: union[str, None]
    r48 :: union[object, None]
    r49 :: object[3]
    r50 :: object_ptr
    r51 :: object
    r52, r53 :: bit
    r54 :: None
L0:
    r0 = self._exc
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L1 else goto L33 :: bool
L1:
    r3 = cast(object, r0)
    if is_error(r3) goto L32 (error at push_measurements:556) else goto L2
L2:
    r4 = PyObject_IsTrue(r3)
    dec_ref r3
    r5 = r4 >= 0 :: signed
    if not r5 goto L32 (error at push_measurements:556) else goto L3 :: bool
L3:
    r6 = truncate r4: i32 to builtins.bool
    if r6 goto L4 else goto L11 :: bool
L4:
    r7 = self._exc
    r8 = dank_mids.stats.globals :: static
    r9 = 'deepcopy'
    r10 = CPyDict_GetItem(r8, r9)
    if is_error(r10) goto L34 (error at push_measurements:557) else goto L5
L5:
    r11 = [r7]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r10, r12, 1, 0)
    dec_ref r10
    if is_error(r13) goto L34 (error at push_measurements:557) else goto L6
L6:
    dec_ref r7
    r14 = self._exc
    r15 = r14
    r16 = '__traceback__'
    r17 = CPyObject_GetAttr(r15, r16)
    dec_ref r15
    if is_error(r17) goto L35 (error at push_measurements:557) else goto L7
L7:
    r18 = r17
L8:
    r19 = 'with_traceback'
    r20 = [r13, r18]
    r21 = load_address r20
    r22 = PyObject_VectorcallMethod(r19, r21, 9223372036854775810, 0)
    if is_error(r22) goto L36 (error at push_measurements:557) else goto L9
L9:
    dec_ref r13
    dec_ref r18
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L32 (error at push_measurements:557) else goto L10 :: bool
L10:
    unreachable
L11:
    r23 = self.metrics
    r24 = 0
    r25 = PyDict_Size(r23)
    r26 = CPyDict_GetItemsIter(r23)
    if is_error(r26) goto L37 (error at push_measurements:558) else goto L12
L12:
    r27 = CPyDict_NextItem(r26, r24)
    r28 = r27[1]
    r24 = r28
    r29 = r27[0]
    if r29 goto L13 else goto L38 :: bool
L13:
    r30 = r27[2]
    r31 = r27[3]
    dec_ref r27
    r32 = cast(str, r30)
    if is_error(r32) goto L39 (error at push_measurements:558) else goto L14
L14:
    r33 = cast(str, r31)
    if is_error(r33) goto L40 (error at push_measurements:558) else goto L15
L15:
    r34 = dank_mids.stats.collector :: static
    if is_error(r34) goto L41 else goto L18
L16:
    r35 = raise NameError('value for final name "collector" was not set')
    if not r35 goto L32 (error at push_measurements:559) else goto L17 :: bool
L17:
    unreachable
L18:
    r36 = CPyObject_GetAttr(r34, r33)
    if is_error(r36) goto L42 (error at push_measurements:559) else goto L19
L19:
    attr = r36
    r37 = builtins :: module
    r38 = 'callable'
    r39 = CPyObject_GetAttr(r37, r38)
    if is_error(r39) goto L43 (error at push_measurements:560) else goto L20
L20:
    r40 = [attr]
    r41 = load_address r40
    r42 = PyObject_Vectorcall(r39, r41, 1, 0)
    dec_ref r39
    if is_error(r42) goto L43 (error at push_measurements:560) else goto L21
L21:
    r43 = unbox(bool, r42)
    dec_ref r42
    if is_error(r43) goto L43 (error at push_measurements:560) else goto L22
L22:
    if r43 goto L23 else goto L25 :: bool
L23:
    r44 = PyObject_Vectorcall(attr, 0, 0, 0)
    dec_ref attr
    if is_error(r44) goto L42 (error at push_measurements:561) else goto L24
L24:
    attr = r44
L25:
    r45 = self.units
    r46 = CPyDict_GetWithNone(r45, r33)
    dec_ref r45
    dec_ref r33
    if is_error(r46) goto L44 (error at push_measurements:562) else goto L26
L26:
    r47 = cast(union[str, None], r46)
    if is_error(r47) goto L44 (error at push_measurements:562) else goto L27
L27:
    r48 = self.set_measurement
    r49 = [r32, attr, r47]
    r50 = load_address r49
    r51 = PyObject_Vectorcall(r48, r50, 3, 0)
    dec_ref r48
    if is_error(r51) goto L45 (error at push_measurements:562) else goto L46
L28:
    dec_ref r32
    dec_ref attr
    dec_ref r47
L29:
    r52 = CPyDict_CheckSize(r23, r25)
    if not r52 goto L47 (error at push_measurements:558) else goto L12 :: bool
L30:
    r53 = CPy_NoErrOccurred()
    if not r53 goto L32 (error at push_measurements:558) else goto L31 :: bool
L31:
    return 1
L32:
    r54 = <error> :: None
    return r54
L33:
    dec_ref r0
    goto L11
L34:
    dec_ref r7
    goto L32
L35:
    dec_ref r13
    goto L32
L36:
    dec_ref r13
    dec_ref r18
    goto L32
L37:
    dec_ref r23
    goto L32
L38:
    dec_ref r23
    dec_ref r26
    dec_ref r27
    goto L30
L39:
    dec_ref r23
    dec_ref r26
    dec_ref r31
    goto L32
L40:
    dec_ref r23
    dec_ref r26
    dec_ref r32
    goto L32
L41:
    dec_ref r23
    dec_ref r26
    dec_ref r32
    dec_ref r33
    goto L16
L42:
    dec_ref r23
    dec_ref r26
    dec_ref r32
    dec_ref r33
    goto L32
L43:
    dec_ref r23
    dec_ref r26
    dec_ref r32
    dec_ref r33
    dec_ref attr
    goto L32
L44:
    dec_ref r23
    dec_ref r26
    dec_ref r32
    dec_ref attr
    goto L32
L45:
    dec_ref r23
    dec_ref r26
    dec_ref r32
    dec_ref attr
    dec_ref r47
    goto L32
L46:
    dec_ref r51
    goto L28
L47:
    dec_ref r23
    dec_ref r26
    goto L32

def _SentryExporter.push_envs(self):
    self :: dank_mids.stats._SentryExporter
    r0 :: object
    r1 :: bool
    r2 :: str
    r3 :: object[1]
    r4 :: object_ptr
    r5, r6, r7, r8, r9 :: object
    r10 :: bool
    r11 :: object
    r12 :: bool
    r13 :: object
    r14 :: bool
    r15 :: union[object, None]
    r16 :: object[2]
    r17 :: object_ptr
    r18 :: object
    r19 :: tuple[object, object, object]
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: bit
    r24 :: object
    r25 :: dank_mids.stats._StatsLogger
    r26 :: bool
    r27, r28, r29, r30, r31, r32 :: str
    r33 :: object
    r34 :: str
    r35 :: object
    r36, r37, r38, r39 :: str
    r40 :: object[2]
    r41 :: object_ptr
    r42 :: object
    r43 :: dank_mids.stats._StatsLogger
    r44 :: bool
    r45 :: str
    r46 :: object
    r47 :: object[3]
    r48 :: object_ptr
    r49, r50 :: object
    r51, r52 :: bit
    r53 :: None
L0:
    r0 = dank_mids.stats._ENVS :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_ENVS" was not set')
    if not r1 goto L42 (error at push_envs:573) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = 'items'
    r3 = [r0]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r2, r4, 9223372036854775809, 0)
    if is_error(r5) goto L42 (error at push_envs:573) else goto L4
L4:
    r6 = PyObject_GetIter(r5)
    dec_ref r5
    if is_error(r6) goto L42 (error at push_envs:573) else goto L5
L5:
    r7 = PyIter_Next(r6)
    if is_error(r7) goto L43 else goto L6
L6:
    r8 = PyObject_GetIter(r7)
    dec_ref r7
    if is_error(r8) goto L44 (error at push_envs:573) else goto L7
L7:
    r9 = PyIter_Next(r8)
    if is_error(r9) goto L45 else goto L10
L8:
    r10 = raise ValueError('not enough values to unpack')
    if not r10 goto L42 (error at push_envs:573) else goto L9 :: bool
L9:
    unreachable
L10:
    r11 = PyIter_Next(r8)
    if is_error(r11) goto L46 else goto L13
L11:
    r12 = raise ValueError('not enough values to unpack')
    if not r12 goto L42 (error at push_envs:573) else goto L12 :: bool
L12:
    unreachable
L13:
    r13 = PyIter_Next(r8)
    dec_ref r8
    if is_error(r13) goto L16 else goto L47
L14:
    r14 = raise ValueError('too many values to unpack')
    if not r14 goto L42 (error at push_envs:573) else goto L15 :: bool
L15:
    unreachable
L16:
    r15 = self.set_tag
    r16 = [r9, r11]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r15, r17, 2, 0)
    dec_ref r15
    if is_error(r18) goto L18 (error at push_envs:575) else goto L48
L17:
    dec_ref r9
    dec_ref r11
    goto L5
L18:
    r19 = CPy_CatchError()
    r20 = builtins :: module
    r21 = 'Exception'
    r22 = CPyObject_GetAttr(r20, r21)
    if is_error(r22) goto L49 (error at push_envs:576) else goto L19
L19:
    r23 = CPy_ExceptionMatches(r22)
    dec_ref r22
    if r23 goto L20 else goto L50 :: bool
L20:
    r24 = CPy_GetExcValue()
    r25 = dank_mids.stats.logger :: static
    if is_error(r25) goto L51 else goto L23
L21:
    r26 = raise NameError('value for final name "logger" was not set')
    if not r26 goto L38 (error at push_envs:577) else goto L52 :: bool
L22:
    unreachable
L23:
    r27 = 'Unable to set sentry tag '
    r28 = PyObject_Str(r9)
    dec_ref r9
    if is_error(r28) goto L53 (error at push_envs:578) else goto L24
L24:
    r29 = ' to '
    r30 = PyObject_Str(r11)
    dec_ref r11
    if is_error(r30) goto L54 (error at push_envs:578) else goto L25
L25:
    r31 = '. See '
    r32 = '__class__'
    r33 = CPyObject_GetAttr(r24, r32)
    if is_error(r33) goto L55 (error at push_envs:578) else goto L26
L26:
    r34 = '__name__'
    r35 = CPyObject_GetAttr(r33, r34)
    dec_ref r33
    if is_error(r35) goto L55 (error at push_envs:578) else goto L27
L27:
    r36 = cast(str, r35)
    if is_error(r36) goto L55 (error at push_envs:578) else goto L28
L28:
    r37 = ' below:'
    r38 = CPyStr_Build(7, r27, r28, r29, r30, r31, r36, r37)
    dec_ref r28
    dec_ref r30
    dec_ref r36
    if is_error(r38) goto L56 (error at push_envs:578) else goto L29
L29:
    r39 = 'warning'
    r40 = [r25, r38]
    r41 = load_address r40
    r42 = PyObject_VectorcallMethod(r39, r41, 9223372036854775810, 0)
    if is_error(r42) goto L57 (error at push_envs:577) else goto L58
L30:
    dec_ref r38
    r43 = dank_mids.stats.logger :: static
    if is_error(r43) goto L59 else goto L33
L31:
    r44 = raise NameError('value for final name "logger" was not set')
    if not r44 goto L38 (error at push_envs:580) else goto L60 :: bool
L32:
    unreachable
L33:
    r45 = 'info'
    r46 = box(bool, 1)
    r47 = [r43, r24, r46]
    r48 = load_address r47
    r49 = ('exc_info',)
    r50 = PyObject_VectorcallMethod(r45, r48, 9223372036854775810, r49)
    if is_error(r50) goto L56 (error at push_envs:580) else goto L61
L34:
    dec_ref r24
    goto L37
L35:
    CPy_Reraise()
    if not 0 goto L38 else goto L62 :: bool
L36:
    unreachable
L37:
    CPy_RestoreExcInfo(r19)
    dec_ref r19
    goto L5
L38:
    CPy_RestoreExcInfo(r19)
    dec_ref r19
    r51 = CPy_KeepPropagating()
    if not r51 goto L42 else goto L39 :: bool
L39:
    unreachable
L40:
    r52 = CPy_NoErrOccurred()
    if not r52 goto L42 (error at push_envs:573) else goto L41 :: bool
L41:
    return 1
L42:
    r53 = <error> :: None
    return r53
L43:
    dec_ref r6
    goto L40
L44:
    dec_ref r6
    goto L42
L45:
    dec_ref r6
    dec_ref r8
    goto L8
L46:
    dec_ref r6
    dec_ref r8
    dec_ref r9
    goto L11
L47:
    dec_ref r6
    dec_ref r9
    dec_ref r11
    dec_ref r13
    goto L14
L48:
    dec_ref r18
    goto L17
L49:
    dec_ref r6
    dec_ref r9
    dec_ref r11
    goto L38
L50:
    dec_ref r6
    dec_ref r9
    dec_ref r11
    goto L35
L51:
    dec_ref r6
    dec_ref r9
    dec_ref r11
    dec_ref r24
    goto L21
L52:
    dec_ref r19
    goto L22
L53:
    dec_ref r6
    dec_ref r11
    dec_ref r24
    goto L38
L54:
    dec_ref r6
    dec_ref r24
    dec_ref r28
    goto L38
L55:
    dec_ref r6
    dec_ref r24
    dec_ref r28
    dec_ref r30
    goto L38
L56:
    dec_ref r6
    dec_ref r24
    goto L38
L57:
    dec_ref r6
    dec_ref r24
    dec_ref r38
    goto L38
L58:
    dec_ref r42
    goto L30
L59:
    dec_ref r6
    dec_ref r24
    goto L31
L60:
    dec_ref r19
    goto L32
L61:
    dec_ref r50
    goto L34
L62:
    dec_ref r19
    goto L36

def _SentryExporter.__mypyc_defaults_setup(__mypyc_self__):
    __mypyc_self__ :: dank_mids.stats._SentryExporter
    r0, r1, r2, r3, r4, r5, r6, r7, r8, r9 :: str
    r10 :: dict
    r11, r12 :: str
    r13, r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: dict
    r20 :: str
    r21 :: object
    r22 :: str
    r23 :: object
    r24 :: dict
    r25 :: str
    r26 :: object
    r27 :: str
    r28 :: object
    r29 :: bool
L0:
    r0 = 'active_eth_calls'
    r1 = 'count_active_brownie_calls'
    r2 = 'queued_eth_calls'
    r3 = 'count_queued_brownie_calls'
    r4 = 'encoder_queue'
    r5 = 'encoder_queue_len'
    r6 = 'decoder_queue'
    r7 = 'decoder_queue_len'
    r8 = 'loop_time'
    r9 = 'avg_loop_time'
    r10 = CPyDict_Build(5, r0, r1, r2, r3, r4, r5, r6, r7, r8, r9)
    if is_error(r10) goto L9 else goto L1
L1:
    __mypyc_self__.metrics = r10
    r11 = 'loop_time'
    r12 = 'seconds'
    r13 = CPyDict_Build(1, r11, r12)
    if is_error(r13) goto L9 else goto L2
L2:
    __mypyc_self__.units = r13
    r14 = dank_mids.stats.globals :: static
    r15 = '_nocompile'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L9 else goto L3
L3:
    r17 = 'set_tag'
    r18 = CPyObject_GetAttr(r16, r17)
    dec_ref r16
    if is_error(r18) goto L9 else goto L4
L4:
    __mypyc_self__.set_tag = r18
    r19 = dank_mids.stats.globals :: static
    r20 = '_nocompile'
    r21 = CPyDict_GetItem(r19, r20)
    if is_error(r21) goto L9 else goto L5
L5:
    r22 = 'set_measurement'
    r23 = CPyObject_GetAttr(r21, r22)
    dec_ref r21
    if is_error(r23) goto L9 else goto L6
L6:
    __mypyc_self__.set_measurement = r23
    r24 = dank_mids.stats.globals :: static
    r25 = '_nocompile'
    r26 = CPyDict_GetItem(r24, r25)
    if is_error(r26) goto L9 else goto L7
L7:
    r27 = 'exc'
    r28 = CPyObject_GetAttr(r26, r27)
    dec_ref r26
    if is_error(r28) goto L9 else goto L8
L8:
    __mypyc_self__._exc = r28
    return 1
L9:
    r29 = <error> :: bool
    return r29

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: dict
    r30, r31 :: object
    r32 :: str
    r33 :: dict
    r34, r35 :: object
    r36 :: str
    r37 :: dict
    r38 :: object
    r39 :: object_ptr
    r40 :: object_ptr[1]
    r41 :: c_ptr
    r42 :: native_int[1]
    r43 :: c_ptr
    r44 :: object
    r45 :: dict
    r46, r47 :: str
    r48 :: bit
    r49 :: object
    r50 :: str
    r51 :: dict
    r52, r53 :: object
    r54 :: str
    r55 :: dict
    r56, r57 :: object
    r58 :: str
    r59 :: dict
    r60, r61, r62 :: object
    r63 :: str
    r64 :: dict
    r65, r66 :: object
    r67 :: str
    r68 :: dict
    r69, r70 :: object
    r71 :: dict
    r72 :: str
    r73 :: i32
    r74 :: bit
    r75 :: str
    r76 :: dict
    r77 :: str
    r78 :: object
    r79 :: object[1]
    r80 :: object_ptr
    r81 :: object
    r82 :: dict
    r83 :: str
    r84 :: i32
    r85 :: bit
    r86 :: dict
    r87 :: str
    r88 :: object
    r89 :: i32
    r90 :: bit
    r91 :: dict
    r92 :: str
    r93 :: object
    r94 :: i32
    r95 :: bit
    r96 :: dict
    r97 :: str
    r98 :: object
    r99 :: i32
    r100 :: bit
    r101 :: dict
    r102 :: str
    r103 :: object
    r104 :: dict
    r105 :: str
    r106 :: i32
    r107 :: bit
    r108 :: dict
    r109 :: str
    r110 :: object
    r111 :: dict
    r112 :: str
    r113 :: i32
    r114 :: bit
    r115 :: object
    r116 :: str
    r117 :: object
    r118 :: tuple
    r119 :: str
    r120, r121 :: object
    r122 :: bool
    r123, r124, r125 :: str
    r126 :: tuple
    r127 :: i32
    r128 :: bit
    r129 :: dict
    r130 :: str
    r131 :: i32
    r132 :: bit
    r133 :: dict
    r134 :: str
    r135, r136, r137 :: object
    r138 :: dict
    r139 :: str
    r140 :: i32
    r141 :: bit
    r142 :: object
    r143 :: str
    r144, r145 :: object
    r146 :: bool
    r147, r148, r149, r150, r151, r152 :: str
    r153 :: tuple
    r154 :: i32
    r155 :: bit
    r156 :: dict
    r157 :: str
    r158 :: i32
    r159 :: bit
    r160 :: object
    r161 :: str
    r162, r163 :: object
    r164 :: bool
    r165 :: str
    r166 :: tuple
    r167 :: i32
    r168 :: bit
    r169 :: dict
    r170 :: str
    r171 :: i32
    r172 :: bit
    r173 :: object
    r174 :: str
    r175, r176 :: object
    r177 :: bool
    r178, r179, r180, r181, r182, r183 :: str
    r184 :: tuple
    r185 :: i32
    r186 :: bit
    r187 :: dict
    r188 :: str
    r189 :: i32
    r190 :: bit
    r191 :: object
    r192, r193, r194, r195, r196, r197, r198, r199, r200, r201 :: str
    r202 :: dict
    r203 :: str
    r204 :: i32
    r205 :: bit
    r206 :: object
    r207, r208 :: str
    r209 :: dict
    r210 :: str
    r211 :: i32
    r212 :: bit
    r213 :: object
    r214 :: dict
    r215 :: str
    r216 :: object
    r217 :: str
    r218 :: object
    r219 :: str
    r220 :: i32
    r221 :: bit
    r222 :: object
    r223 :: dict
    r224 :: str
    r225 :: object
    r226 :: str
    r227 :: object
    r228 :: str
    r229 :: i32
    r230 :: bit
    r231 :: object
    r232 :: dict
    r233 :: str
    r234 :: object
    r235 :: str
    r236 :: object
    r237 :: str
    r238 :: i32
    r239 :: bit
    r240 :: dict
    r241 :: str
    r242 :: object
    r243 :: str
    r244 :: tuple
    r245 :: dict
    r246 :: dank_mids.stats._StatsLogger
    r247 :: dict
    r248 :: str
    r249 :: i32
    r250 :: bit
    r251 :: dank_mids.stats._StatsLogger
    r252 :: bool
    r253 :: str
    r254 :: object
    r255 :: dict
    r256 :: str
    r257 :: i32
    r258 :: bit
    r259 :: dank_mids.stats._StatsLogger
    r260 :: bool
    r261 :: str
    r262 :: object
    r263 :: dict
    r264 :: str
    r265 :: i32
    r266 :: bit
    r267 :: dank_mids.stats._Collector
    r268 :: dict
    r269 :: str
    r270 :: i32
    r271 :: bit
    r272 :: dank_mids.stats._SentryExporter
    r273 :: dict
    r274 :: str
    r275 :: i32
    r276 :: bit
    r277 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L87 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address logging :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [19]
    r9 = load_address r8
    r10 = (('logging', 'logging', 'logging'),)
    r11 = dank_mids.stats.globals :: static
    r12 = 'dank_mids/stats/__init__.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L87 else goto L4 :: bool
L4:
    r15 = ('create_task',)
    r16 = 'asyncio'
    r17 = dank_mids.stats.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L87 (error at <module>:20) else goto L5
L5:
    asyncio = r18 :: module
    dec_ref r18
    r19 = ('defaultdict', 'deque')
    r20 = 'collections'
    r21 = dank_mids.stats.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L87 (error at <module>:21) else goto L6
L6:
    collections = r22 :: module
    dec_ref r22
    r23 = ('ProcessPoolExecutor',)
    r24 = 'concurrent.futures'
    r25 = dank_mids.stats.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L87 (error at <module>:22) else goto L7
L7:
    concurrent.futures = r26 :: module
    dec_ref r26
    r27 = ('deepcopy',)
    r28 = 'copy'
    r29 = dank_mids.stats.globals :: static
    r30 = CPyImport_ImportFromMany(r28, r27, r27, r29)
    if is_error(r30) goto L87 (error at <module>:23) else goto L8
L8:
    copy = r30 :: module
    dec_ref r30
    r31 = ('time',)
    r32 = 'time'
    r33 = dank_mids.stats.globals :: static
    r34 = CPyImport_ImportFromMany(r32, r31, r31, r33)
    if is_error(r34) goto L87 (error at <module>:24) else goto L9
L9:
    time = r34 :: module
    dec_ref r34
    r35 = ('TYPE_CHECKING', 'Any', 'Callable', 'DefaultDict', 'Deque', 'Final', 'Iterable', 'Set', 'Tuple', 'Type', 'TypeVar', 'final')
    r36 = 'typing'
    r37 = dank_mids.stats.globals :: static
    r38 = CPyImport_ImportFromMany(r36, r35, r35, r37)
    if is_error(r38) goto L87 (error at <module>:25) else goto L10
L10:
    typing = r38 :: module
    dec_ref r38
    r39 = load_address msgspec :: module
    r40 = [r39]
    r41 = load_address r40
    r42 = [40]
    r43 = load_address r42
    r44 = (('msgspec', 'msgspec', 'msgspec'),)
    r45 = dank_mids.stats.globals :: static
    r46 = 'dank_mids/stats/__init__.py'
    r47 = '<module>'
    r48 = CPyImport_ImportMany(r44, r41, r45, r46, r47, r43)
    if not r48 goto L87 else goto L11 :: bool
L11:
    r49 = ('sleep0',)
    r50 = 'a_sync.asyncio'
    r51 = dank_mids.stats.globals :: static
    r52 = CPyImport_ImportFromMany(r50, r49, r49, r51)
    if is_error(r52) goto L87 (error at <module>:41) else goto L12
L12:
    a_sync.asyncio = r52 :: module
    dec_ref r52
    r53 = ('_ENVIRONMENT_VARIABLES_SET_BY_USER',)
    r54 = 'typed_envs.registry'
    r55 = dank_mids.stats.globals :: static
    r56 = CPyImport_ImportFromMany(r54, r53, r53, r55)
    if is_error(r56) goto L87 (error at <module>:42) else goto L13
L13:
    typed_envs.registry = r56 :: module
    dec_ref r56
    r57 = ('RPCEndpoint',)
    r58 = 'web3.types'
    r59 = dank_mids.stats.globals :: static
    r60 = CPyImport_ImportFromMany(r58, r57, r57, r59)
    if is_error(r60) goto L87 (error at <module>:43) else goto L14
L14:
    web3.types = r60 :: module
    dec_ref r60
    r61 = ('ENVIRONMENT_VARIABLES',)
    r62 = ('ENVS',)
    r63 = 'dank_mids'
    r64 = dank_mids.stats.globals :: static
    r65 = CPyImport_ImportFromMany(r63, r61, r62, r64)
    if is_error(r65) goto L87 (error at <module>:45) else goto L15
L15:
    dank_mids = r65 :: module
    dec_ref r65
    r66 = ('_nocompile',)
    r67 = 'dank_mids.stats'
    r68 = dank_mids.stats.globals :: static
    r69 = CPyImport_ImportFromMany(r67, r66, r66, r68)
    if is_error(r69) goto L87 (error at <module>:46) else goto L16
L16:
    dank_mids.stats = r69 :: module
    dec_ref r69
    if 0 goto L17 else goto L17 :: bool
L17:
    r70 = load_address PyLong_Type
    r71 = dank_mids.stats.globals :: static
    r72 = '_LogLevel'
    r73 = CPyDict_SetItem(r71, r72, r70)
    r74 = r73 >= 0 :: signed
    if not r74 goto L87 (error at <module>:52) else goto L18 :: bool
L18:
    r75 = 'T'
    r76 = dank_mids.stats.globals :: static
    r77 = 'TypeVar'
    r78 = CPyDict_GetItem(r76, r77)
    if is_error(r78) goto L87 (error at <module>:54) else goto L19
L19:
    r79 = [r75]
    r80 = load_address r79
    r81 = PyObject_Vectorcall(r78, r80, 1, 0)
    dec_ref r78
    if is_error(r81) goto L87 (error at <module>:54) else goto L20
L20:
    r82 = dank_mids.stats.globals :: static
    r83 = 'T'
    r84 = CPyDict_SetItem(r82, r83, r81)
    dec_ref r81
    r85 = r84 >= 0 :: signed
    if not r85 goto L87 (error at <module>:54) else goto L21 :: bool
L21:
    r86 = dank_mids.stats.globals :: static
    r87 = 'STATS'
    r88 = object 13
    r89 = CPyDict_SetItem(r86, r87, r88)
    r90 = r89 >= 0 :: signed
    if not r90 goto L87 (error at <module>:58) else goto L22 :: bool
L22:
    r91 = dank_mids.stats.globals :: static
    r92 = 'DEVHINT'
    r93 = object 15
    r94 = CPyDict_SetItem(r91, r92, r93)
    r95 = r94 >= 0 :: signed
    if not r95 goto L87 (error at <module>:61) else goto L23 :: bool
L23:
    r96 = dank_mids.stats.globals :: static
    r97 = 'COLLECT_STATS'
    r98 = box(bool, 0)
    r99 = CPyDict_SetItem(r96, r97, r98)
    r100 = r99 >= 0 :: signed
    if not r100 goto L87 (error at <module>:64) else goto L24 :: bool
L24:
    r101 = dank_mids.stats.globals :: static
    r102 = '_ENVIRONMENT_VARIABLES_SET_BY_USER'
    r103 = CPyDict_GetItem(r101, r102)
    if is_error(r103) goto L87 (error at <module>:67) else goto L25
L25:
    dank_mids.stats._ENVS = r103 :: static
    r104 = dank_mids.stats.globals :: static
    r105 = '_ENVS'
    r106 = CPyDict_SetItem(r104, r105, r103)
    dec_ref r103
    r107 = r106 >= 0 :: signed
    if not r107 goto L87 (error at <module>:67) else goto L26 :: bool
L26:
    r108 = dank_mids.stats.globals :: static
    r109 = 'sleep0'
    r110 = CPyDict_GetItem(r108, r109)
    if is_error(r110) goto L87 (error at <module>:69) else goto L27
L27:
    dank_mids.stats.yield_to_loop = r110 :: static
    r111 = dank_mids.stats.globals :: static
    r112 = 'yield_to_loop'
    r113 = CPyDict_SetItem(r111, r112, r110)
    dec_ref r110
    r114 = r113 >= 0 :: signed
    if not r114 goto L87 (error at <module>:69) else goto L28 :: bool
L28:
    r115 = logging :: module
    r116 = 'Logger'
    r117 = CPyObject_GetAttr(r115, r116)
    if is_error(r117) goto L87 (error at <module>:110) else goto L29
L29:
    r118 = PyTuple_Pack(1, r117)
    dec_ref r117
    if is_error(r118) goto L87 (error at <module>:110) else goto L30
L30:
    r119 = 'dank_mids.stats'
    r120 = dank_mids.stats._StatsLogger_template :: type
    r121 = CPyType_FromTemplate(r120, r118, r119)
    dec_ref r118
    if is_error(r121) goto L87 (error at <module>:110) else goto L31
L31:
    r122 = _StatsLogger_trait_vtable_setup()
    if is_error(r122) goto L88 (error at <module>:-1) else goto L32
L32:
    r123 = '__mypyc_attrs__'
    r124 = '_daemon'
    r125 = '__dict__'
    r126 = PyTuple_Pack(2, r124, r125)
    if is_error(r126) goto L88 (error at <module>:110) else goto L33
L33:
    r127 = PyObject_SetAttr(r121, r123, r126)
    dec_ref r126
    r128 = r127 >= 0 :: signed
    if not r128 goto L88 (error at <module>:110) else goto L34 :: bool
L34:
    dank_mids.stats._StatsLogger = r121 :: type
    r129 = dank_mids.stats.globals :: static
    r130 = '_StatsLogger'
    r131 = CPyDict_SetItem(r129, r130, r121)
    dec_ref r121
    r132 = r131 >= 0 :: signed
    if not r132 goto L87 (error at <module>:110) else goto L35 :: bool
L35:
    r133 = dank_mids.stats.globals :: static
    r134 = 'Deque'
    r135 = CPyDict_GetItem(r133, r134)
    if is_error(r135) goto L87 (error at <module>:359) else goto L36
L36:
    r136 = load_address PyFloat_Type
    r137 = PyObject_GetItem(r135, r136)
    dec_ref r135
    if is_error(r137) goto L87 (error at <module>:359) else goto L37
L37:
    r138 = dank_mids.stats.globals :: static
    r139 = '_Times'
    r140 = CPyDict_SetItem(r138, r139, r137)
    dec_ref r137
    r141 = r140 >= 0 :: signed
    if not r141 goto L87 (error at <module>:359) else goto L38 :: bool
L38:
    r142 = <error> :: object
    r143 = 'dank_mids.stats'
    r144 = dank_mids.stats._Collector_template :: type
    r145 = CPyType_FromTemplate(r144, r142, r143)
    if is_error(r145) goto L87 (error at <module>:363) else goto L39
L39:
    r146 = _Collector_trait_vtable_setup()
    if is_error(r146) goto L89 (error at <module>:-1) else goto L40
L40:
    r147 = '__mypyc_attrs__'
    r148 = 'errd_batches'
    r149 = 'durations'
    r150 = 'types'
    r151 = 'event_loop_times'
    r152 = 'validation_errors'
    r153 = PyTuple_Pack(5, r148, r149, r150, r151, r152)
    if is_error(r153) goto L89 (error at <module>:363) else goto L41
L41:
    r154 = PyObject_SetAttr(r145, r147, r153)
    dec_ref r153
    r155 = r154 >= 0 :: signed
    if not r155 goto L89 (error at <module>:363) else goto L42 :: bool
L42:
    dank_mids.stats._Collector = r145 :: type
    r156 = dank_mids.stats.globals :: static
    r157 = '_Collector'
    r158 = CPyDict_SetItem(r156, r157, r145)
    dec_ref r145
    r159 = r158 >= 0 :: signed
    if not r159 goto L87 (error at <module>:363) else goto L43 :: bool
L43:
    r160 = <error> :: object
    r161 = 'dank_mids.stats'
    r162 = dank_mids.stats._Writer_template :: type
    r163 = CPyType_FromTemplate(r162, r160, r161)
    if is_error(r163) goto L87 (error at <module>:482) else goto L44
L44:
    r164 = _Writer_trait_vtable_setup()
    if is_error(r164) goto L90 (error at <module>:-1) else goto L45
L45:
    r165 = '__mypyc_attrs__'
    r166 = PyTuple_Pack(0)
    if is_error(r166) goto L90 (error at <module>:482) else goto L46
L46:
    r167 = PyObject_SetAttr(r163, r165, r166)
    dec_ref r166
    r168 = r167 >= 0 :: signed
    if not r168 goto L90 (error at <module>:482) else goto L47 :: bool
L47:
    dank_mids.stats._Writer = r163 :: type
    r169 = dank_mids.stats.globals :: static
    r170 = '_Writer'
    r171 = CPyDict_SetItem(r169, r170, r163)
    dec_ref r163
    r172 = r171 >= 0 :: signed
    if not r172 goto L87 (error at <module>:482) else goto L48 :: bool
L48:
    r173 = <error> :: object
    r174 = 'dank_mids.stats'
    r175 = dank_mids.stats._SentryExporter_template :: type
    r176 = CPyType_FromTemplate(r175, r173, r174)
    if is_error(r176) goto L87 (error at <module>:529) else goto L49
L49:
    r177 = _SentryExporter_trait_vtable_setup()
    if is_error(r177) goto L91 (error at <module>:-1) else goto L50
L50:
    r178 = '__mypyc_attrs__'
    r179 = 'metrics'
    r180 = 'units'
    r181 = 'set_tag'
    r182 = 'set_measurement'
    r183 = '_exc'
    r184 = PyTuple_Pack(5, r179, r180, r181, r182, r183)
    if is_error(r184) goto L91 (error at <module>:529) else goto L51
L51:
    r185 = PyObject_SetAttr(r176, r178, r184)
    dec_ref r184
    r186 = r185 >= 0 :: signed
    if not r186 goto L91 (error at <module>:529) else goto L52 :: bool
L52:
    dank_mids.stats._SentryExporter = r176 :: type
    r187 = dank_mids.stats.globals :: static
    r188 = '_SentryExporter'
    r189 = CPyDict_SetItem(r187, r188, r176)
    dec_ref r176
    r190 = r189 >= 0 :: signed
    if not r190 goto L87 (error at <module>:529) else goto L53 :: bool
L53:
    r191 = dank_mids.stats._SentryExporter :: type
    r192 = 'active_eth_calls'
    r193 = 'count_active_brownie_calls'
    r194 = 'queued_eth_calls'
    r195 = 'count_queued_brownie_calls'
    r196 = 'encoder_queue'
    r197 = 'encoder_queue_len'
    r198 = 'decoder_queue'
    r199 = 'decoder_queue_len'
    r200 = 'loop_time'
    r201 = 'avg_loop_time'
    r202 = CPyDict_Build(5, r192, r193, r194, r195, r196, r197, r198, r199, r200, r201)
    if is_error(r202) goto L87 (error at <module>:543) else goto L54
L54:
    r203 = 'metrics'
    r204 = PyObject_SetAttr(r191, r203, r202)
    r205 = r204 >= 0 :: signed
    if not r205 goto L92 (error at <module>:543) else goto L55 :: bool
L55:
    dank_mids.stats._SentryExporter.metrics = r202 :: static
    dec_ref r202
    r206 = dank_mids.stats._SentryExporter :: type
    r207 = 'loop_time'
    r208 = 'seconds'
    r209 = CPyDict_Build(1, r207, r208)
    if is_error(r209) goto L87 (error at <module>:550) else goto L56
L56:
    r210 = 'units'
    r211 = PyObject_SetAttr(r206, r210, r209)
    r212 = r211 >= 0 :: signed
    if not r212 goto L93 (error at <module>:550) else goto L57 :: bool
L57:
    dank_mids.stats._SentryExporter.units = r209 :: static
    dec_ref r209
    r213 = dank_mids.stats._SentryExporter :: type
    r214 = dank_mids.stats.globals :: static
    r215 = '_nocompile'
    r216 = CPyDict_GetItem(r214, r215)
    if is_error(r216) goto L87 (error at <module>:582) else goto L58
L58:
    r217 = 'set_tag'
    r218 = CPyObject_GetAttr(r216, r217)
    dec_ref r216
    if is_error(r218) goto L87 (error at <module>:582) else goto L59
L59:
    r219 = 'set_tag'
    r220 = PyObject_SetAttr(r213, r219, r218)
    r221 = r220 >= 0 :: signed
    if not r221 goto L94 (error at <module>:582) else goto L60 :: bool
L60:
    dank_mids.stats._SentryExporter.set_tag = r218 :: static
    dec_ref r218
    r222 = dank_mids.stats._SentryExporter :: type
    r223 = dank_mids.stats.globals :: static
    r224 = '_nocompile'
    r225 = CPyDict_GetItem(r223, r224)
    if is_error(r225) goto L87 (error at <module>:593) else goto L61
L61:
    r226 = 'set_measurement'
    r227 = CPyObject_GetAttr(r225, r226)
    dec_ref r225
    if is_error(r227) goto L87 (error at <module>:593) else goto L62
L62:
    r228 = 'set_measurement'
    r229 = PyObject_SetAttr(r222, r228, r227)
    r230 = r229 >= 0 :: signed
    if not r230 goto L95 (error at <module>:593) else goto L63 :: bool
L63:
    dank_mids.stats._SentryExporter.set_measurement = r227 :: static
    dec_ref r227
    r231 = dank_mids.stats._SentryExporter :: type
    r232 = dank_mids.stats.globals :: static
    r233 = '_nocompile'
    r234 = CPyDict_GetItem(r232, r233)
    if is_error(r234) goto L87 (error at <module>:604) else goto L64
L64:
    r235 = 'exc'
    r236 = CPyObject_GetAttr(r234, r235)
    dec_ref r234
    if is_error(r236) goto L87 (error at <module>:604) else goto L65
L65:
    r237 = '_exc'
    r238 = PyObject_SetAttr(r231, r237, r236)
    r239 = r238 >= 0 :: signed
    if not r239 goto L96 (error at <module>:604) else goto L66 :: bool
L66:
    dank_mids.stats._SentryExporter._exc = r236 :: static
    dec_ref r236
    r240 = dank_mids.stats.globals :: static
    r241 = '__name__'
    r242 = CPyDict_GetItem(r240, r241)
    if is_error(r242) goto L87 (error at <module>:611) else goto L67
L67:
    r243 = cast(str, r242)
    if is_error(r243) goto L87 (error at <module>:611) else goto L68
L68:
    r244 = PyTuple_Pack(1, r243)
    dec_ref r243
    if is_error(r244) goto L87 (error at <module>:611) else goto L69
L69:
    r245 = PyDict_New()
    if is_error(r245) goto L97 (error at <module>:611) else goto L70
L70:
    r246 = _StatsLogger(r244, r245)
    dec_ref r244
    dec_ref r245
    if is_error(r246) goto L87 (error at <module>:611) else goto L71
L71:
    dank_mids.stats.logger = r246 :: static
    r247 = dank_mids.stats.globals :: static
    r248 = 'logger'
    r249 = CPyDict_SetItem(r247, r248, r246)
    dec_ref r246
    r250 = r249 >= 0 :: signed
    if not r250 goto L87 (error at <module>:611) else goto L72 :: bool
L72:
    r251 = dank_mids.stats.logger :: static
    if is_error(r251) goto L73 else goto L75
L73:
    r252 = raise NameError('value for final name "logger" was not set')
    if not r252 goto L87 (error at <module>:612) else goto L74 :: bool
L74:
    unreachable
L75:
    r253 = 'stats'
    r254 = CPyObject_GetAttr(r251, r253)
    if is_error(r254) goto L87 (error at <module>:612) else goto L76
L76:
    dank_mids.stats.log = r254 :: static
    r255 = dank_mids.stats.globals :: static
    r256 = 'log'
    r257 = CPyDict_SetItem(r255, r256, r254)
    dec_ref r254
    r258 = r257 >= 0 :: signed
    if not r258 goto L87 (error at <module>:612) else goto L77 :: bool
L77:
    r259 = dank_mids.stats.logger :: static
    if is_error(r259) goto L78 else goto L80
L78:
    r260 = raise NameError('value for final name "logger" was not set')
    if not r260 goto L87 (error at <module>:613) else goto L79 :: bool
L79:
    unreachable
L80:
    r261 = 'devhint'
    r262 = CPyObject_GetAttr(r259, r261)
    if is_error(r262) goto L87 (error at <module>:613) else goto L81
L81:
    dank_mids.stats.devhint = r262 :: static
    r263 = dank_mids.stats.globals :: static
    r264 = 'devhint'
    r265 = CPyDict_SetItem(r263, r264, r262)
    dec_ref r262
    r266 = r265 >= 0 :: signed
    if not r266 goto L87 (error at <module>:613) else goto L82 :: bool
L82:
    r267 = _Collector()
    if is_error(r267) goto L87 (error at <module>:614) else goto L83
L83:
    dank_mids.stats.collector = r267 :: static
    r268 = dank_mids.stats.globals :: static
    r269 = 'collector'
    r270 = CPyDict_SetItem(r268, r269, r267)
    dec_ref r267
    r271 = r270 >= 0 :: signed
    if not r271 goto L87 (error at <module>:614) else goto L84 :: bool
L84:
    r272 = _SentryExporter()
    if is_error(r272) goto L87 (error at <module>:615) else goto L85
L85:
    dank_mids.stats.sentry = r272 :: static
    r273 = dank_mids.stats.globals :: static
    r274 = 'sentry'
    r275 = CPyDict_SetItem(r273, r274, r272)
    dec_ref r272
    r276 = r275 >= 0 :: signed
    if not r276 goto L87 (error at <module>:615) else goto L86 :: bool
L86:
    return 1
L87:
    r277 = <error> :: None
    return r277
L88:
    dec_ref r121
    goto L87
L89:
    dec_ref r145
    goto L87
L90:
    dec_ref r163
    goto L87
L91:
    dec_ref r176
    goto L87
L92:
    dec_ref r202
    goto L87
L93:
    dec_ref r209
    goto L87
L94:
    dec_ref r218
    goto L87
L95:
    dec_ref r227
    goto L87
L96:
    dec_ref r236
    goto L87
L97:
    dec_ref r244
    goto L87
