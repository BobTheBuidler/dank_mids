def UIDGenerator.__init__(self):
    self :: dank_mids._uid.UIDGenerator
    r0 :: str
    r1 :: dict
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6, r7 :: object
    r8 :: None
L0:
    self._value = -2
    r0 = 'uid'
    r1 = dank_mids._uid.globals :: static
    r2 = 'AlertingRLock'
    r3 = CPyDict_GetItem(r1, r2)
    if is_error(r3) goto L3 (error at __init__:24) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = ('name',)
    r7 = PyObject_Vectorcall(r3, r5, 0, r6)
    dec_ref r3
    if is_error(r7) goto L3 (error at __init__:24) else goto L2
L2:
    self._lock = r7
    return 1
L3:
    r8 = <error> :: None
    return r8

def UIDGenerator.latest(self):
    self :: dank_mids._uid.UIDGenerator
    r0 :: int
L0:
    r0 = self._value
    return r0

def UIDGenerator.next(self):
    self :: dank_mids._uid.UIDGenerator
    r0, r1 :: object
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8 :: object
    r9, r10 :: int
    r11 :: bool
    r12, r13 :: tuple[object, object, object]
    r14 :: object
    r15 :: object[4]
    r16 :: object_ptr
    r17 :: object
    r18 :: bit
    r19 :: int
L0:
    r0 = self._lock
    r1 = PyObject_Type(r0)
    r2 = '__exit__'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L20 (error at next:48) else goto L1
L1:
    r4 = '__enter__'
    r5 = CPyObject_GetAttr(r1, r4)
    dec_ref r1
    if is_error(r5) goto L21 (error at next:48) else goto L2
L2:
    r6 = [r0]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r5, r7, 1, 0)
    dec_ref r5
    if is_error(r8) goto L21 (error at next:48) else goto L22
L3:
L4:
    r9 = borrow self._value
    r10 = CPyTagged_Add(r9, 2)
    inc_ref r10 :: int
    self._value = r10
L5:
    r12 = <error> :: tuple[object, object, object]
    r13 = r12
L6:
    if 1 goto L7 else goto L23 :: bool
L7:
    r14 = load_address _Py_NoneStruct
    r15 = [r0, r14, r14, r14]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r3, r16, 4, 0)
    dec_ref r3
    if is_error(r17) goto L24 (error at next:48) else goto L25
L8:
    dec_ref r0
L9:
    if is_error(r13) goto L12 else goto L26
L10:
    CPy_Reraise()
    if not 0 goto L14 else goto L27 :: bool
L11:
    unreachable
L12:
    if is_error(r10) goto L18 else goto L13
L13:
    return r10
L14:
    if is_error(r13) goto L16 else goto L15
L15:
    CPy_RestoreExcInfo(r13)
    xdec_ref r13
L16:
    r18 = CPy_KeepPropagating()
    if not r18 goto L19 else goto L17 :: bool
L17:
    unreachable
L18:
    unreachable
L19:
    r19 = <error> :: int
    return r19
L20:
    dec_ref r0
    dec_ref r1
    goto L19
L21:
    dec_ref r0
    dec_ref r3
    goto L19
L22:
    dec_ref r8
    goto L3
L23:
    dec_ref r0
    dec_ref r3
    goto L9
L24:
    dec_ref r0
    xdec_ref r10 :: int
    goto L14
L25:
    dec_ref r17
    goto L8
L26:
    xdec_ref r10 :: int
    goto L10
L27:
    xdec_ref r13
    goto L11

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11, r12 :: object
    r13 :: bool
    r14, r15, r16 :: str
    r17 :: tuple
    r18 :: i32
    r19 :: bit
    r20 :: dict
    r21 :: str
    r22 :: i32
    r23 :: bit
    r24 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L10 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('AlertingRLock',)
    r6 = 'dank_mids.helpers._lock'
    r7 = dank_mids._uid.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L10 (error at <module>:1) else goto L4
L4:
    dank_mids.helpers._lock = r8 :: module
    dec_ref r8
    r9 = <error> :: object
    r10 = 'dank_mids._uid'
    r11 = dank_mids._uid.UIDGenerator_template :: type
    r12 = CPyType_FromTemplate(r11, r9, r10)
    if is_error(r12) goto L10 (error at <module>:4) else goto L5
L5:
    r13 = UIDGenerator_trait_vtable_setup()
    if is_error(r13) goto L11 (error at <module>:-1) else goto L6
L6:
    r14 = '__mypyc_attrs__'
    r15 = '_value'
    r16 = '_lock'
    r17 = PyTuple_Pack(2, r15, r16)
    if is_error(r17) goto L11 (error at <module>:4) else goto L7
L7:
    r18 = PyObject_SetAttr(r12, r14, r17)
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L11 (error at <module>:4) else goto L8 :: bool
L8:
    dank_mids._uid.UIDGenerator = r12 :: type
    r20 = dank_mids._uid.globals :: static
    r21 = 'UIDGenerator'
    r22 = CPyDict_SetItem(r20, r21, r12)
    dec_ref r12
    r23 = r22 >= 0 :: signed
    if not r23 goto L10 (error at <module>:4) else goto L9 :: bool
L9:
    return 1
L10:
    r24 = <error> :: None
    return r24
L11:
    dec_ref r12
    goto L10

def DummyLogger.info(args, kwargs):
    args :: tuple
    kwargs :: dict
L0:
    return 1

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19, r20 :: object
    r21 :: bool
    r22 :: str
    r23 :: tuple
    r24 :: i32
    r25 :: bit
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: bool
    r32 :: i32
    r33 :: bit
    r34 :: bool
    r35 :: str
    r36 :: object
    r37 :: bool
    r38 :: object[1]
    r39 :: object_ptr
    r40 :: object
    r41 :: dict
    r42 :: str
    r43 :: i32
    r44 :: bit
    r45 :: dank_mids._demo_mode.DummyLogger
    r46 :: dict
    r47 :: str
    r48 :: i32
    r49 :: bit
    r50 :: dict
    r51 :: str
    r52 :: object
    r53 :: dict
    r54 :: str
    r55 :: i32
    r56 :: bit
    r57 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L26 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Final', 'final')
    r6 = 'typing'
    r7 = dank_mids._demo_mode.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L26 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ENVIRONMENT_VARIABLES',)
    r10 = 'dank_mids'
    r11 = dank_mids._demo_mode.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L26 (error at <module>:3) else goto L5
L5:
    dank_mids = r12 :: module
    dec_ref r12
    r13 = ('getLogger',)
    r14 = 'dank_mids._logging'
    r15 = dank_mids._demo_mode.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L26 (error at <module>:4) else goto L6
L6:
    dank_mids._logging = r16 :: module
    dec_ref r16
    r17 = <error> :: object
    r18 = 'dank_mids._demo_mode'
    r19 = dank_mids._demo_mode.DummyLogger_template :: type
    r20 = CPyType_FromTemplate(r19, r17, r18)
    if is_error(r20) goto L26 (error at <module>:8) else goto L7
L7:
    r21 = DummyLogger_trait_vtable_setup()
    if is_error(r21) goto L27 (error at <module>:-1) else goto L8
L8:
    r22 = '__mypyc_attrs__'
    r23 = PyTuple_Pack(0)
    if is_error(r23) goto L27 (error at <module>:8) else goto L9
L9:
    r24 = PyObject_SetAttr(r20, r22, r23)
    dec_ref r23
    r25 = r24 >= 0 :: signed
    if not r25 goto L27 (error at <module>:8) else goto L10 :: bool
L10:
    dank_mids._demo_mode.DummyLogger = r20 :: type
    r26 = dank_mids._demo_mode.globals :: static
    r27 = 'DummyLogger'
    r28 = CPyDict_SetItem(r26, r27, r20)
    dec_ref r20
    r29 = r28 >= 0 :: signed
    if not r29 goto L26 (error at <module>:8) else goto L11 :: bool
L11:
    r30 = dank_mids.ENVIRONMENT_VARIABLES.DEMO_MODE :: static
    if is_error(r30) goto L12 else goto L14
L12:
    r31 = raise NameError('value for final name "DEMO_MODE" was not set')
    if not r31 goto L26 (error at <module>:30) else goto L13 :: bool
L13:
    unreachable
L14:
    r32 = PyObject_IsTrue(r30)
    r33 = r32 >= 0 :: signed
    if not r33 goto L26 (error at <module>:30) else goto L15 :: bool
L15:
    r34 = truncate r32: i32 to builtins.bool
    if r34 goto L16 else goto L21 :: bool
L16:
    r35 = 'dank_mids.demo'
    r36 = dank_mids._logging.getLogger :: static
    if is_error(r36) goto L17 else goto L19
L17:
    r37 = raise NameError('value for final name "getLogger" was not set')
    if not r37 goto L26 (error at <module>:31) else goto L18 :: bool
L18:
    unreachable
L19:
    r38 = [r35]
    r39 = load_address r38
    r40 = PyObject_Vectorcall(r36, r39, 1, 0)
    if is_error(r40) goto L26 (error at <module>:31) else goto L20
L20:
    r41 = dank_mids._demo_mode.globals :: static
    r42 = '_logger'
    r43 = CPyDict_SetItem(r41, r42, r40)
    dec_ref r40
    r44 = r43 >= 0 :: signed
    if not r44 goto L26 (error at <module>:31) else goto L23 :: bool
L21:
    r45 = DummyLogger()
    if is_error(r45) goto L26 (error at <module>:33) else goto L22
L22:
    r46 = dank_mids._demo_mode.globals :: static
    r47 = '_logger'
    r48 = CPyDict_SetItem(r46, r47, r45)
    dec_ref r45
    r49 = r48 >= 0 :: signed
    if not r49 goto L26 (error at <module>:33) else goto L23 :: bool
L23:
    r50 = dank_mids._demo_mode.globals :: static
    r51 = '_logger'
    r52 = CPyDict_GetItem(r50, r51)
    if is_error(r52) goto L26 (error at <module>:35) else goto L24
L24:
    dank_mids._demo_mode.demo_logger = r52 :: static
    r53 = dank_mids._demo_mode.globals :: static
    r54 = 'demo_logger'
    r55 = CPyDict_SetItem(r53, r54, r52)
    dec_ref r52
    r56 = r55 >= 0 :: signed
    if not r56 goto L26 (error at <module>:35) else goto L25 :: bool
L25:
    return 1
L26:
    r57 = <error> :: None
    return r57
L27:
    dec_ref r20
    goto L26

def BadResponse.__init__(self, response):
    self :: dank_mids._exceptions.BadResponse
    response :: object
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    r12 :: str
    r13 :: object[3]
    r14 :: object_ptr
    r15 :: object
    r16 :: None
L0:
    r0 = 'response'
    r1 = PyObject_SetAttr(self, r0, response)
    r2 = r1 >= 0 :: signed
    if not r2 goto L6 (error at __init__:21) else goto L1 :: bool
L1:
    r3 = builtins :: module
    r4 = 'BaseException'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L6 (error at __init__:22) else goto L2
L2:
    r6 = 'error'
    r7 = CPyObject_GetAttr(response, r6)
    if is_error(r7) goto L7 (error at __init__:22) else goto L3
L3:
    r8 = 'to_dict'
    r9 = [r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775809, 0)
    if is_error(r11) goto L8 (error at __init__:22) else goto L4
L4:
    dec_ref r7
    r12 = '__init__'
    r13 = [r5, self, r11]
    r14 = load_address r13
    r15 = PyObject_VectorcallMethod(r12, r14, 9223372036854775811, 0)
    if is_error(r15) goto L9 (error at __init__:22) else goto L10
L5:
    dec_ref r5
    dec_ref r11
    return 1
L6:
    r16 = <error> :: None
    return r16
L7:
    dec_ref r5
    goto L6
L8:
    dec_ref r5
    dec_ref r7
    goto L6
L9:
    dec_ref r5
    dec_ref r11
    goto L6
L10:
    dec_ref r15
    goto L5

def ExecutionReverted.__init__(self, response):
    self :: dank_mids._exceptions.ExecutionReverted
    response :: object
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: str
    r6 :: object
    r7, message, r8, r9 :: str
    r10 :: object[2]
    r11 :: object_ptr
    r12 :: object
    r13 :: int
    r14 :: bit
    r15 :: str
    r16 :: list
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: str
    r21 :: object
    r22 :: str
    r23 :: object[3]
    r24 :: object_ptr
    r25 :: object
    r26 :: None
L0:
    r0 = 'response'
    r1 = PyObject_SetAttr(self, r0, response)
    r2 = r1 >= 0 :: signed
    if not r2 goto L14 (error at __init__:35) else goto L1 :: bool
L1:
    r3 = 'error'
    r4 = CPyObject_GetAttr(response, r3)
    if is_error(r4) goto L14 (error at __init__:36) else goto L2
L2:
    r5 = 'message'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L14 (error at __init__:36) else goto L3
L3:
    r7 = cast(str, r6)
    if is_error(r7) goto L14 (error at __init__:36) else goto L4
L4:
    message = r7
    r8 = ':'
    r9 = 'count'
    r10 = [message, r8]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775810, 0)
    if is_error(r12) goto L15 (error at __init__:37) else goto L5
L5:
    r13 = unbox(int, r12)
    dec_ref r12
    if is_error(r13) goto L15 (error at __init__:37) else goto L6
L6:
    r14 = r13 == 2
    dec_ref r13 :: int
    if r14 goto L7 else goto L11 :: bool
L7:
    r15 = ':'
    r16 = PyUnicode_Split(message, r15, -1)
    dec_ref message
    if is_error(r16) goto L14 (error at __init__:38) else goto L8
L8:
    r17 = CPyList_GetItemShort(r16, 2)
    dec_ref r16
    if is_error(r17) goto L14 (error at __init__:38) else goto L9
L9:
    r18 = cast(str, r17)
    if is_error(r18) goto L14 (error at __init__:38) else goto L10
L10:
    message = r18
L11:
    r19 = builtins :: module
    r20 = 'BaseException'
    r21 = CPyObject_GetAttr(r19, r20)
    if is_error(r21) goto L15 (error at __init__:39) else goto L12
L12:
    r22 = '__init__'
    r23 = [r21, self, message]
    r24 = load_address r23
    r25 = PyObject_VectorcallMethod(r22, r24, 9223372036854775811, 0)
    if is_error(r25) goto L16 (error at __init__:39) else goto L17
L13:
    dec_ref r21
    dec_ref message
    return 1
L14:
    r26 = <error> :: None
    return r26
L15:
    dec_ref message
    goto L14
L16:
    dec_ref message
    dec_ref r21
    goto L14
L17:
    dec_ref r25
    goto L13

def ExceedsMaxBatchSize.limit(self):
    self :: dank_mids._exceptions.ExceedsMaxBatchSize
    r0, r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: str
    r6, r7 :: object
    r8 :: str
    r9 :: object
    r10 :: object[2]
    r11 :: object_ptr
    r12, r13, r14, r15 :: object
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19, r20 :: int
L0:
    r0 = 'batch limit (\\d+) exceeded'
    r1 = 'response'
    r2 = CPyObject_GetAttr(self, r1)
    if is_error(r2) goto L9 (error at limit:59) else goto L1
L1:
    r3 = 'error'
    r4 = CPyObject_GetAttr(r2, r3)
    dec_ref r2
    if is_error(r4) goto L9 (error at limit:59) else goto L2
L2:
    r5 = 'message'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L9 (error at limit:59) else goto L3
L3:
    r7 = re :: module
    r8 = 'search'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L10 (error at limit:59) else goto L4
L4:
    r10 = [r0, r6]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r9, r11, 2, 0)
    dec_ref r9
    if is_error(r12) goto L10 (error at limit:59) else goto L5
L5:
    dec_ref r6
    r13 = object 1
    r14 = PyObject_GetItem(r12, r13)
    dec_ref r12
    if is_error(r14) goto L9 (error at limit:59) else goto L6
L6:
    r15 = load_address PyLong_Type
    r16 = [r14]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r15, r17, 1, 0)
    if is_error(r18) goto L11 (error at limit:59) else goto L7
L7:
    dec_ref r14
    r19 = unbox(int, r18)
    dec_ref r18
    if is_error(r19) goto L9 (error at limit:59) else goto L8
L8:
    return r19
L9:
    r20 = <error> :: int
    return r20
L10:
    dec_ref r6
    goto L9
L11:
    dec_ref r14
    goto L9

def DankMidsClientResponseError.__init__(self, exc, request):
    self :: dank_mids._exceptions.DankMidsClientResponseError
    exc, request :: object
    r0 :: tuple
    r1 :: list
    r2 :: object
    r3 :: i32
    r4 :: bit
    r5 :: tuple
    r6 :: object
    r7 :: str
    r8, r9 :: object
    r10 :: object[2]
    r11 :: object_ptr
    r12 :: object
    r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: object[5]
    r26 :: object_ptr
    r27, r28 :: object
    r29 :: None
L0:
    inc_ref request
    self.request = request
    r0 = self.args
    if is_error(r0) goto L15 (error at __init__:77) else goto L1
L1:
    r1 = PyList_New(0)
    if is_error(r1) goto L16 (error at __init__:77) else goto L2
L2:
    r2 = CPyList_Extend(r1, r0)
    dec_ref r0
    if is_error(r2) goto L17 (error at __init__:77) else goto L18
L3:
    r3 = PyList_Append(r1, request)
    r4 = r3 >= 0 :: signed
    if not r4 goto L17 (error at __init__:77) else goto L4 :: bool
L4:
    r5 = PyList_AsTuple(r1)
    dec_ref r1
    if is_error(r5) goto L15 (error at __init__:77) else goto L5
L5:
    self.args = r5
    inc_ref exc
    self._exception = exc
    r6 = builtins :: module
    r7 = 'super'
    r8 = CPyObject_GetAttr(r6, r7)
    if is_error(r8) goto L15 (error at __init__:85) else goto L6
L6:
    r9 = dank_mids._exceptions.DankMidsClientResponseError :: type
    r10 = [r9, self]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r8, r11, 2, 0)
    dec_ref r8
    if is_error(r12) goto L15 (error at __init__:85) else goto L7
L7:
    r13 = '__init__'
    r14 = CPyObject_GetAttr(r12, r13)
    dec_ref r12
    if is_error(r14) goto L15 (error at __init__:85) else goto L8
L8:
    r15 = 'request_info'
    r16 = CPyObject_GetAttr(exc, r15)
    if is_error(r16) goto L19 (error at __init__:86) else goto L9
L9:
    r17 = 'history'
    r18 = CPyObject_GetAttr(exc, r17)
    if is_error(r18) goto L20 (error at __init__:87) else goto L10
L10:
    r19 = 'status'
    r20 = CPyObject_GetAttr(exc, r19)
    if is_error(r20) goto L21 (error at __init__:88) else goto L11
L11:
    r21 = 'message'
    r22 = CPyObject_GetAttr(exc, r21)
    if is_error(r22) goto L22 (error at __init__:89) else goto L12
L12:
    r23 = 'headers'
    r24 = CPyObject_GetAttr(exc, r23)
    if is_error(r24) goto L23 (error at __init__:90) else goto L13
L13:
    r25 = [r16, r18, r20, r22, r24]
    r26 = load_address r25
    r27 = ('status', 'message', 'headers')
    r28 = PyObject_Vectorcall(r14, r26, 2, r27)
    dec_ref r14
    if is_error(r28) goto L24 (error at __init__:85) else goto L25
L14:
    dec_ref r16
    dec_ref r18
    dec_ref r20
    dec_ref r22
    dec_ref r24
    return 1
L15:
    r29 = <error> :: None
    return r29
L16:
    dec_ref r0
    goto L15
L17:
    dec_ref r1
    goto L15
L18:
    dec_ref r2
    goto L3
L19:
    dec_ref r14
    goto L15
L20:
    dec_ref r14
    dec_ref r16
    goto L15
L21:
    dec_ref r14
    dec_ref r16
    dec_ref r18
    goto L15
L22:
    dec_ref r14
    dec_ref r16
    dec_ref r18
    dec_ref r20
    goto L15
L23:
    dec_ref r14
    dec_ref r16
    dec_ref r18
    dec_ref r20
    dec_ref r22
    goto L15
L24:
    dec_ref r16
    dec_ref r18
    dec_ref r20
    dec_ref r22
    dec_ref r24
    goto L15
L25:
    dec_ref r28
    goto L14

def DankMidsInternalError.__init__(self, exc):
    self :: dank_mids._exceptions.DankMidsInternalError
    exc, r0 :: object
    r1 :: bool
    r2, r3, r4, r5 :: str
    r6 :: object
    r7 :: object[3]
    r8 :: object_ptr
    r9, r10 :: object
    r11 :: str
    r12 :: i32
    r13 :: bit
    r14 :: object
    r15 :: str
    r16, r17 :: object
    r18 :: object[2]
    r19 :: object_ptr
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: str
    r24 :: object[1]
    r25 :: object_ptr
    r26 :: object
    r27 :: None
L0:
    r0 = dank_mids._exceptions.logger :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "logger" was not set')
    if not r1 goto L13 (error at __init__:104) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = 'unhandled exception inside dank mids internals: '
    r3 = PyObject_Str(exc)
    if is_error(r3) goto L13 (error at __init__:104) else goto L4
L4:
    r4 = CPyStr_Build(2, r2, r3)
    dec_ref r3
    if is_error(r4) goto L13 (error at __init__:104) else goto L5
L5:
    r5 = 'warning'
    r6 = box(bool, 1)
    r7 = [r0, r4, r6]
    r8 = load_address r7
    r9 = ('exc_info',)
    r10 = PyObject_VectorcallMethod(r5, r8, 9223372036854775810, r9)
    if is_error(r10) goto L14 (error at __init__:104) else goto L15
L6:
    dec_ref r4
    r11 = '_original_exception'
    r12 = PyObject_SetAttr(self, r11, exc)
    r13 = r12 >= 0 :: signed
    if not r13 goto L13 (error at __init__:106) else goto L7 :: bool
L7:
    r14 = builtins :: module
    r15 = 'super'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L13 (error at __init__:112) else goto L8
L8:
    r17 = dank_mids._exceptions.DankMidsInternalError :: type
    r18 = [r17, self]
    r19 = load_address r18
    r20 = PyObject_Vectorcall(r16, r19, 2, 0)
    dec_ref r16
    if is_error(r20) goto L13 (error at __init__:112) else goto L9
L9:
    r21 = '__init__'
    r22 = CPyObject_GetAttr(r20, r21)
    dec_ref r20
    if is_error(r22) goto L13 (error at __init__:112) else goto L10
L10:
    r23 = PyObject_Repr(exc)
    if is_error(r23) goto L16 (error at __init__:112) else goto L11
L11:
    r24 = [r23]
    r25 = load_address r24
    r26 = PyObject_Vectorcall(r22, r25, 1, 0)
    dec_ref r22
    if is_error(r26) goto L17 (error at __init__:112) else goto L18
L12:
    dec_ref r23
    return 1
L13:
    r27 = <error> :: None
    return r27
L14:
    dec_ref r4
    goto L13
L15:
    dec_ref r10
    goto L6
L16:
    dec_ref r22
    goto L13
L17:
    dec_ref r23
    goto L13
L18:
    dec_ref r26
    goto L12

def BatchResponseSortError.__init__(self, controller, calls, response):
    self :: dank_mids._exceptions.BatchResponseSortError
    controller, calls :: object
    response :: list
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: ptr
    r4 :: native_int
    r5 :: list
    r6 :: short_int
    r7 :: ptr
    r8 :: native_int
    r9 :: short_int
    r10 :: bit
    r11 :: native_int
    r12, r13 :: ptr
    r14 :: native_int
    r15 :: ptr
    r16 :: object
    r17 :: dank_mids.helpers._codec.RawResponse
    r18 :: bool
    r19 :: object
    r20 :: bit
    r21 :: short_int
    r22 :: str
    r23 :: i32
    r24 :: bit
    r25 :: object
    r26 :: str
    r27, r28 :: object
    r29 :: object[2]
    r30 :: object_ptr
    r31 :: object
    r32 :: str
    r33 :: object
    r34, r35 :: str
    r36 :: object
    r37, r38, r39 :: str
    r40 :: object
    r41, r42 :: str
    r43 :: list
    r44, r45 :: object
    r46 :: str
    r47 :: object
    r48 :: i32
    r49, r50 :: bit
    r51, r52, r53 :: str
    r54 :: object
    r55 :: list
    r56, r57 :: str
    r58 :: object[1]
    r59 :: object_ptr
    r60 :: object
    r61 :: None
L0:
    r0 = 'calls'
    r1 = PyObject_SetAttr(self, r0, calls)
    r2 = r1 >= 0 :: signed
    if not r2 goto L29 (error at __init__:128) else goto L1 :: bool
L1:
    r3 = get_element_ptr response ob_size :: PyVarObject
    r4 = load_mem r3 :: native_int*
    r5 = PyList_New(r4)
    if is_error(r5) goto L29 (error at __init__:134) else goto L2
L2:
    r6 = 0
L3:
    r7 = get_element_ptr response ob_size :: PyVarObject
    r8 = load_mem r7 :: native_int*
    r9 = r8 << 1
    r10 = r6 < r9 :: signed
    if r10 goto L4 else goto L8 :: bool
L4:
    r11 = r6 >> 1
    r12 = get_element_ptr response ob_item :: PyListObject
    r13 = load_mem r12 :: ptr*
    r14 = r11 * 8
    r15 = r13 + r14
    r16 = load_mem r15 :: builtins.object*
    inc_ref r16
    r17 = cast(dank_mids.helpers._codec.RawResponse, r16)
    if is_error(r17) goto L30 (error at __init__:134) else goto L5
L5:
    r18 = <error> :: bool
    r19 = r17.decode(r18)
    dec_ref r17
    if is_error(r19) goto L30 (error at __init__:134) else goto L6
L6:
    r20 = CPyList_SetItemUnsafe(r5, r6, r19)
    if not r20 goto L30 (error at __init__:134) else goto L7 :: bool
L7:
    r21 = r6 + 2
    r6 = r21
    goto L3
L8:
    r22 = 'results'
    r23 = PyObject_SetAttr(self, r22, r5)
    dec_ref r5
    r24 = r23 >= 0 :: signed
    if not r24 goto L29 (error at __init__:134) else goto L9 :: bool
L9:
    r25 = builtins :: module
    r26 = 'super'
    r27 = CPyObject_GetAttr(r25, r26)
    if is_error(r27) goto L29 (error at __init__:140) else goto L10
L10:
    r28 = dank_mids._exceptions.BatchResponseSortError :: type
    r29 = [r28, self]
    r30 = load_address r29
    r31 = PyObject_Vectorcall(r27, r30, 2, 0)
    dec_ref r27
    if is_error(r31) goto L29 (error at __init__:140) else goto L11
L11:
    r32 = '__init__'
    r33 = CPyObject_GetAttr(r31, r32)
    dec_ref r31
    if is_error(r33) goto L29 (error at __init__:140) else goto L12
L12:
    r34 = 'This will not mess up your run but will make things needlessly slow. Please show this to Bob.\nendpoint='
    r35 = 'endpoint'
    r36 = CPyObject_GetAttr(controller, r35)
    if is_error(r36) goto L31 (error at __init__:142) else goto L13
L13:
    r37 = cast(str, r36)
    if is_error(r37) goto L31 (error at __init__:142) else goto L14
L14:
    r38 = '\nclient_version='
    r39 = 'client_version'
    r40 = CPyObject_GetAttr(controller, r39)
    if is_error(r40) goto L32 (error at __init__:143) else goto L15
L15:
    r41 = cast(str, r40)
    if is_error(r41) goto L32 (error at __init__:143) else goto L16
L16:
    r42 = '\ncalls='
    r43 = PyList_New(0)
    if is_error(r43) goto L33 (error at __init__:144) else goto L17
L17:
    r44 = PyObject_GetIter(calls)
    if is_error(r44) goto L34 (error at __init__:144) else goto L18
L18:
    r45 = PyIter_Next(r44)
    if is_error(r45) goto L35 else goto L19
L19:
    r46 = 'uid'
    r47 = CPyObject_GetAttr(r45, r46)
    dec_ref r45
    if is_error(r47) goto L36 (error at __init__:144) else goto L20
L20:
    r48 = PyList_Append(r43, r47)
    dec_ref r47
    r49 = r48 >= 0 :: signed
    if not r49 goto L36 (error at __init__:144) else goto L18 :: bool
L21:
    r50 = CPy_NoErrOccurred()
    if not r50 goto L34 (error at __init__:144) else goto L22 :: bool
L22:
    r51 = PyObject_Str(r43)
    dec_ref r43
    if is_error(r51) goto L33 (error at __init__:141) else goto L23
L23:
    r52 = '\nresponse='
    r53 = 'results'
    r54 = CPyObject_GetAttr(self, r53)
    if is_error(r54) goto L37 (error at __init__:145) else goto L24
L24:
    r55 = cast(list, r54)
    if is_error(r55) goto L37 (error at __init__:145) else goto L25
L25:
    r56 = PyObject_Str(r55)
    dec_ref r55
    if is_error(r56) goto L37 (error at __init__:141) else goto L26
L26:
    r57 = CPyStr_Build(8, r34, r37, r38, r41, r42, r51, r52, r56)
    dec_ref r37
    dec_ref r41
    dec_ref r51
    dec_ref r56
    if is_error(r57) goto L31 (error at __init__:141) else goto L27
L27:
    r58 = [r57]
    r59 = load_address r58
    r60 = PyObject_Vectorcall(r33, r59, 1, 0)
    dec_ref r33
    if is_error(r60) goto L38 (error at __init__:140) else goto L39
L28:
    dec_ref r57
    return 1
L29:
    r61 = <error> :: None
    return r61
L30:
    dec_ref r5
    goto L29
L31:
    dec_ref r33
    goto L29
L32:
    dec_ref r33
    dec_ref r37
    goto L29
L33:
    dec_ref r33
    dec_ref r37
    dec_ref r41
    goto L29
L34:
    dec_ref r33
    dec_ref r37
    dec_ref r41
    dec_ref r43
    goto L29
L35:
    dec_ref r44
    goto L21
L36:
    dec_ref r33
    dec_ref r37
    dec_ref r41
    dec_ref r43
    dec_ref r44
    goto L29
L37:
    dec_ref r33
    dec_ref r37
    dec_ref r41
    dec_ref r51
    goto L29
L38:
    dec_ref r57
    goto L29
L39:
    dec_ref r60
    goto L28

def ChainstackRateLimitError.try_again_in(self):
    self :: dank_mids._exceptions.ChainstackRateLimitError
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: float
    r9 :: bit
    r10 :: object
    r11 :: float
L0:
    r0 = 'response'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L7 (error at try_again_in:168) else goto L1
L1:
    r2 = 'error'
    r3 = CPyObject_GetAttr(r1, r2)
    dec_ref r1
    if is_error(r3) goto L7 (error at try_again_in:168) else goto L2
L2:
    r4 = 'data'
    r5 = CPyObject_GetAttr(r3, r4)
    dec_ref r3
    if is_error(r5) goto L7 (error at try_again_in:168) else goto L3
L3:
    r6 = 'try_again_in'
    r7 = CPyObject_GetAttr(r5, r6)
    dec_ref r5
    if is_error(r7) goto L7 (error at try_again_in:168) else goto L4
L4:
    r8 = unbox(float, r7)
    dec_ref r7
    r9 = r8 == -113.0
    if r9 goto L6 else goto L5 :: bool
L5:
    return r8
L6:
    r10 = PyErr_Occurred()
    if not is_error(r10) goto L7 (error at try_again_in:168) else goto L5
L7:
    r11 = <error> :: float
    return r11

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5, r6 :: object_ptr
    r7 :: object_ptr[2]
    r8 :: c_ptr
    r9 :: native_int[2]
    r10 :: c_ptr
    r11 :: object
    r12 :: dict
    r13, r14 :: str
    r15 :: bit
    r16 :: object
    r17 :: str
    r18 :: dict
    r19, r20 :: object
    r21 :: str
    r22 :: dict
    r23 :: object
    r24 :: str
    r25 :: object
    r26 :: str
    r27 :: object
    r28 :: object[1]
    r29 :: object_ptr
    r30 :: object
    r31 :: dict
    r32 :: str
    r33 :: i32
    r34 :: bit
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: tuple
    r39 :: str
    r40, r41 :: object
    r42, r43 :: str
    r44 :: tuple
    r45 :: i32
    r46 :: bit
    r47 :: dict
    r48 :: str
    r49 :: i32
    r50 :: bit
    r51 :: object
    r52 :: str
    r53 :: object
    r54 :: tuple
    r55 :: str
    r56, r57 :: object
    r58, r59 :: str
    r60 :: tuple
    r61 :: i32
    r62 :: bit
    r63 :: dict
    r64 :: str
    r65 :: i32
    r66 :: bit
    r67 :: object
    r68 :: tuple
    r69 :: str
    r70, r71 :: object
    r72, r73 :: str
    r74 :: tuple
    r75 :: i32
    r76 :: bit
    r77 :: dict
    r78 :: str
    r79 :: i32
    r80 :: bit
    r81 :: object
    r82 :: tuple
    r83 :: str
    r84, r85 :: object
    r86, r87 :: str
    r88 :: tuple
    r89 :: i32
    r90 :: bit
    r91 :: dict
    r92 :: str
    r93 :: i32
    r94 :: bit
    r95 :: object
    r96 :: tuple
    r97 :: str
    r98, r99 :: object
    r100, r101 :: str
    r102 :: tuple
    r103 :: i32
    r104 :: bit
    r105 :: dict
    r106 :: str
    r107 :: i32
    r108 :: bit
    r109 :: object
    r110 :: tuple
    r111 :: str
    r112, r113 :: object
    r114, r115 :: str
    r116 :: tuple
    r117 :: i32
    r118 :: bit
    r119 :: dict
    r120 :: str
    r121 :: i32
    r122 :: bit
    r123 :: dict
    r124 :: str
    r125 :: object
    r126 :: tuple
    r127 :: str
    r128, r129 :: object
    r130 :: bool
    r131, r132, r133, r134 :: str
    r135 :: tuple
    r136 :: i32
    r137 :: bit
    r138 :: dict
    r139 :: str
    r140 :: i32
    r141 :: bit
    r142 :: dict
    r143 :: str
    r144, r145 :: object
    r146 :: str
    r147, r148 :: object
    r149 :: str
    r150, r151 :: object
    r152 :: str
    r153, r154 :: object
    r155 :: str
    r156, r157 :: object
    r158 :: str
    r159, r160 :: object
    r161 :: str
    r162 :: object
    r163 :: tuple[object, object, object, object, object, object]
    r164, r165 :: object
    r166 :: dict
    r167 :: str
    r168 :: i32
    r169 :: bit
    r170 :: dict
    r171 :: str
    r172 :: object
    r173 :: dict
    r174 :: str
    r175 :: i32
    r176 :: bit
    r177 :: object
    r178 :: str
    r179 :: object
    r180 :: tuple
    r181 :: str
    r182, r183 :: object
    r184, r185 :: str
    r186 :: tuple
    r187 :: i32
    r188 :: bit
    r189 :: dict
    r190 :: str
    r191 :: i32
    r192 :: bit
    r193 :: object
    r194 :: str
    r195 :: object
    r196 :: tuple
    r197 :: str
    r198, r199 :: object
    r200, r201 :: str
    r202 :: tuple
    r203 :: i32
    r204 :: bit
    r205 :: dict
    r206 :: str
    r207 :: i32
    r208 :: bit
    r209 :: object
    r210 :: tuple
    r211 :: str
    r212, r213 :: object
    r214, r215 :: str
    r216 :: tuple
    r217 :: i32
    r218 :: bit
    r219 :: dict
    r220 :: str
    r221 :: i32
    r222 :: bit
    r223 :: object
    r224 :: tuple
    r225 :: str
    r226, r227 :: object
    r228, r229 :: str
    r230 :: tuple
    r231 :: i32
    r232 :: bit
    r233 :: dict
    r234 :: str
    r235 :: i32
    r236 :: bit
    r237 :: object
    r238 :: tuple
    r239 :: str
    r240, r241 :: object
    r242, r243 :: str
    r244 :: tuple
    r245 :: i32
    r246 :: bit
    r247 :: dict
    r248 :: str
    r249 :: i32
    r250 :: bit
    r251 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L88 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address logging :: module
    r6 = load_address re :: module
    r7 = [r5, r6]
    r8 = load_address r7
    r9 = [1, 2]
    r10 = load_address r9
    r11 = (('logging', 'logging', 'logging'), ('re', 're', 're'))
    r12 = dank_mids._exceptions.globals :: static
    r13 = 'dank_mids\\_exceptions.py'
    r14 = '<module>'
    r15 = CPyImport_ImportMany(r11, r8, r12, r13, r14, r10)
    if not r15 goto L88 else goto L4 :: bool
L4:
    r16 = ('TYPE_CHECKING', 'Final', 'List', 'Sequence', 'Union', 'final')
    r17 = 'typing'
    r18 = dank_mids._exceptions.globals :: static
    r19 = CPyImport_ImportFromMany(r17, r16, r16, r18)
    if is_error(r19) goto L88 (error at <module>:3) else goto L5
L5:
    typing = r19 :: module
    dec_ref r19
    r20 = ('ClientResponseError',)
    r21 = 'aiohttp.client_exceptions'
    r22 = dank_mids._exceptions.globals :: static
    r23 = CPyImport_ImportFromMany(r21, r20, r20, r22)
    if is_error(r23) goto L88 (error at <module>:5) else goto L6
L6:
    aiohttp.client_exceptions = r23 :: module
    dec_ref r23
    if 0 goto L7 else goto L7 :: bool
L7:
    r24 = 'dank_mids.exceptions'
    r25 = logging :: module
    r26 = 'getLogger'
    r27 = CPyObject_GetAttr(r25, r26)
    if is_error(r27) goto L88 (error at <module>:14) else goto L8
L8:
    r28 = [r24]
    r29 = load_address r28
    r30 = PyObject_Vectorcall(r27, r29, 1, 0)
    dec_ref r27
    if is_error(r30) goto L88 (error at <module>:14) else goto L9
L9:
    dank_mids._exceptions.logger = r30 :: static
    r31 = dank_mids._exceptions.globals :: static
    r32 = 'logger'
    r33 = CPyDict_SetItem(r31, r32, r30)
    dec_ref r30
    r34 = r33 >= 0 :: signed
    if not r34 goto L88 (error at <module>:14) else goto L10 :: bool
L10:
    r35 = builtins :: module
    r36 = 'ValueError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L88 (error at <module>:17) else goto L11
L11:
    r38 = PyTuple_Pack(1, r37)
    dec_ref r37
    if is_error(r38) goto L88 (error at <module>:17) else goto L12
L12:
    r39 = 'dank_mids._exceptions'
    r40 = dank_mids._exceptions.BadResponse_template :: type
    r41 = CPyType_FromTemplate(r40, r38, r39)
    dec_ref r38
    if is_error(r41) goto L88 (error at <module>:17) else goto L13
L13:
    r42 = '__mypyc_attrs__'
    r43 = '__dict__'
    r44 = PyTuple_Pack(1, r43)
    if is_error(r44) goto L89 (error at <module>:17) else goto L14
L14:
    r45 = PyObject_SetAttr(r41, r42, r44)
    dec_ref r44
    r46 = r45 >= 0 :: signed
    if not r46 goto L89 (error at <module>:17) else goto L15 :: bool
L15:
    dank_mids._exceptions.BadResponse = r41 :: type
    r47 = dank_mids._exceptions.globals :: static
    r48 = 'BadResponse'
    r49 = CPyDict_SetItem(r47, r48, r41)
    dec_ref r41
    r50 = r49 >= 0 :: signed
    if not r50 goto L88 (error at <module>:17) else goto L16 :: bool
L16:
    r51 = builtins :: module
    r52 = 'ValueError'
    r53 = CPyObject_GetAttr(r51, r52)
    if is_error(r53) goto L88 (error at <module>:26) else goto L17
L17:
    r54 = PyTuple_Pack(1, r53)
    dec_ref r53
    if is_error(r54) goto L88 (error at <module>:26) else goto L18
L18:
    r55 = 'dank_mids._exceptions'
    r56 = dank_mids._exceptions.EmptyBatch_template :: type
    r57 = CPyType_FromTemplate(r56, r54, r55)
    dec_ref r54
    if is_error(r57) goto L88 (error at <module>:26) else goto L19
L19:
    r58 = '__mypyc_attrs__'
    r59 = '__dict__'
    r60 = PyTuple_Pack(1, r59)
    if is_error(r60) goto L90 (error at <module>:26) else goto L20
L20:
    r61 = PyObject_SetAttr(r57, r58, r60)
    dec_ref r60
    r62 = r61 >= 0 :: signed
    if not r62 goto L90 (error at <module>:26) else goto L21 :: bool
L21:
    dank_mids._exceptions.EmptyBatch = r57 :: type
    r63 = dank_mids._exceptions.globals :: static
    r64 = 'EmptyBatch'
    r65 = CPyDict_SetItem(r63, r64, r57)
    dec_ref r57
    r66 = r65 >= 0 :: signed
    if not r66 goto L88 (error at <module>:26) else goto L22 :: bool
L22:
    r67 = dank_mids._exceptions.BadResponse :: type
    r68 = PyTuple_Pack(1, r67)
    if is_error(r68) goto L88 (error at <module>:31) else goto L23
L23:
    r69 = 'dank_mids._exceptions'
    r70 = dank_mids._exceptions.ExecutionReverted_template :: type
    r71 = CPyType_FromTemplate(r70, r68, r69)
    dec_ref r68
    if is_error(r71) goto L88 (error at <module>:31) else goto L24
L24:
    r72 = '__mypyc_attrs__'
    r73 = '__dict__'
    r74 = PyTuple_Pack(1, r73)
    if is_error(r74) goto L91 (error at <module>:31) else goto L25
L25:
    r75 = PyObject_SetAttr(r71, r72, r74)
    dec_ref r74
    r76 = r75 >= 0 :: signed
    if not r76 goto L91 (error at <module>:31) else goto L26 :: bool
L26:
    dank_mids._exceptions.ExecutionReverted = r71 :: type
    r77 = dank_mids._exceptions.globals :: static
    r78 = 'ExecutionReverted'
    r79 = CPyDict_SetItem(r77, r78, r71)
    dec_ref r71
    r80 = r79 >= 0 :: signed
    if not r80 goto L88 (error at <module>:31) else goto L27 :: bool
L27:
    r81 = dank_mids._exceptions.BadResponse :: type
    r82 = PyTuple_Pack(1, r81)
    if is_error(r82) goto L88 (error at <module>:43) else goto L28
L28:
    r83 = 'dank_mids._exceptions'
    r84 = dank_mids._exceptions.OutOfGas_template :: type
    r85 = CPyType_FromTemplate(r84, r82, r83)
    dec_ref r82
    if is_error(r85) goto L88 (error at <module>:43) else goto L29
L29:
    r86 = '__mypyc_attrs__'
    r87 = '__dict__'
    r88 = PyTuple_Pack(1, r87)
    if is_error(r88) goto L92 (error at <module>:43) else goto L30
L30:
    r89 = PyObject_SetAttr(r85, r86, r88)
    dec_ref r88
    r90 = r89 >= 0 :: signed
    if not r90 goto L92 (error at <module>:43) else goto L31 :: bool
L31:
    dank_mids._exceptions.OutOfGas = r85 :: type
    r91 = dank_mids._exceptions.globals :: static
    r92 = 'OutOfGas'
    r93 = CPyDict_SetItem(r91, r92, r85)
    dec_ref r85
    r94 = r93 >= 0 :: signed
    if not r94 goto L88 (error at <module>:43) else goto L32 :: bool
L32:
    r95 = dank_mids._exceptions.BadResponse :: type
    r96 = PyTuple_Pack(1, r95)
    if is_error(r96) goto L88 (error at <module>:48) else goto L33
L33:
    r97 = 'dank_mids._exceptions'
    r98 = dank_mids._exceptions.PayloadTooLarge_template :: type
    r99 = CPyType_FromTemplate(r98, r96, r97)
    dec_ref r96
    if is_error(r99) goto L88 (error at <module>:48) else goto L34
L34:
    r100 = '__mypyc_attrs__'
    r101 = '__dict__'
    r102 = PyTuple_Pack(1, r101)
    if is_error(r102) goto L93 (error at <module>:48) else goto L35
L35:
    r103 = PyObject_SetAttr(r99, r100, r102)
    dec_ref r102
    r104 = r103 >= 0 :: signed
    if not r104 goto L93 (error at <module>:48) else goto L36 :: bool
L36:
    dank_mids._exceptions.PayloadTooLarge = r99 :: type
    r105 = dank_mids._exceptions.globals :: static
    r106 = 'PayloadTooLarge'
    r107 = CPyDict_SetItem(r105, r106, r99)
    dec_ref r99
    r108 = r107 >= 0 :: signed
    if not r108 goto L88 (error at <module>:48) else goto L37 :: bool
L37:
    r109 = dank_mids._exceptions.BadResponse :: type
    r110 = PyTuple_Pack(1, r109)
    if is_error(r110) goto L88 (error at <module>:53) else goto L38
L38:
    r111 = 'dank_mids._exceptions'
    r112 = dank_mids._exceptions.ExceedsMaxBatchSize_template :: type
    r113 = CPyType_FromTemplate(r112, r110, r111)
    dec_ref r110
    if is_error(r113) goto L88 (error at <module>:53) else goto L39
L39:
    r114 = '__mypyc_attrs__'
    r115 = '__dict__'
    r116 = PyTuple_Pack(1, r115)
    if is_error(r116) goto L94 (error at <module>:53) else goto L40
L40:
    r117 = PyObject_SetAttr(r113, r114, r116)
    dec_ref r116
    r118 = r117 >= 0 :: signed
    if not r118 goto L94 (error at <module>:53) else goto L41 :: bool
L41:
    dank_mids._exceptions.ExceedsMaxBatchSize = r113 :: type
    r119 = dank_mids._exceptions.globals :: static
    r120 = 'ExceedsMaxBatchSize'
    r121 = CPyDict_SetItem(r119, r120, r113)
    dec_ref r113
    r122 = r121 >= 0 :: signed
    if not r122 goto L88 (error at <module>:53) else goto L42 :: bool
L42:
    r123 = dank_mids._exceptions.globals :: static
    r124 = 'ClientResponseError'
    r125 = CPyDict_GetItem(r123, r124)
    if is_error(r125) goto L88 (error at <module>:63) else goto L43
L43:
    r126 = PyTuple_Pack(1, r125)
    dec_ref r125
    if is_error(r126) goto L88 (error at <module>:63) else goto L44
L44:
    r127 = 'dank_mids._exceptions'
    r128 = dank_mids._exceptions.DankMidsClientResponseError_template :: type
    r129 = CPyType_FromTemplate(r128, r126, r127)
    dec_ref r126
    if is_error(r129) goto L88 (error at <module>:63) else goto L45
L45:
    r130 = DankMidsClientResponseError_trait_vtable_setup()
    if is_error(r130) goto L95 (error at <module>:-1) else goto L46
L46:
    r131 = '__mypyc_attrs__'
    r132 = 'request'
    r133 = 'args'
    r134 = '_exception'
    r135 = PyTuple_Pack(3, r132, r133, r134)
    if is_error(r135) goto L95 (error at <module>:63) else goto L47
L47:
    r136 = PyObject_SetAttr(r129, r131, r135)
    dec_ref r135
    r137 = r136 >= 0 :: signed
    if not r137 goto L95 (error at <module>:63) else goto L48 :: bool
L48:
    dank_mids._exceptions.DankMidsClientResponseError = r129 :: type
    r138 = dank_mids._exceptions.globals :: static
    r139 = 'DankMidsClientResponseError'
    r140 = CPyDict_SetItem(r138, r139, r129)
    dec_ref r129
    r141 = r140 >= 0 :: signed
    if not r141 goto L88 (error at <module>:63) else goto L49 :: bool
L49:
    r142 = dank_mids._exceptions.globals :: static
    r143 = 'Union'
    r144 = CPyDict_GetItem(r142, r143)
    if is_error(r144) goto L88 (error at <module>:94) else goto L50
L50:
    r145 = builtins :: module
    r146 = 'AttributeError'
    r147 = CPyObject_GetAttr(r145, r146)
    if is_error(r147) goto L96 (error at <module>:95) else goto L51
L51:
    r148 = builtins :: module
    r149 = 'TypeError'
    r150 = CPyObject_GetAttr(r148, r149)
    if is_error(r150) goto L97 (error at <module>:95) else goto L52
L52:
    r151 = builtins :: module
    r152 = 'UnboundLocalError'
    r153 = CPyObject_GetAttr(r151, r152)
    if is_error(r153) goto L98 (error at <module>:95) else goto L53
L53:
    r154 = builtins :: module
    r155 = 'NotImplementedError'
    r156 = CPyObject_GetAttr(r154, r155)
    if is_error(r156) goto L99 (error at <module>:95) else goto L54
L54:
    r157 = builtins :: module
    r158 = 'RuntimeError'
    r159 = CPyObject_GetAttr(r157, r158)
    if is_error(r159) goto L100 (error at <module>:95) else goto L55
L55:
    r160 = builtins :: module
    r161 = 'SyntaxError'
    r162 = CPyObject_GetAttr(r160, r161)
    if is_error(r162) goto L101 (error at <module>:95) else goto L56
L56:
    r163 = (r147, r150, r153, r156, r159, r162)
    r164 = box(tuple[object, object, object, object, object, object], r163)
    r165 = PyObject_GetItem(r144, r164)
    dec_ref r144
    dec_ref r164
    if is_error(r165) goto L88 (error at <module>:94) else goto L57
L57:
    r166 = dank_mids._exceptions.globals :: static
    r167 = '_internal_err_types'
    r168 = CPyDict_SetItem(r166, r167, r165)
    dec_ref r165
    r169 = r168 >= 0 :: signed
    if not r169 goto L88 (error at <module>:94) else goto L58 :: bool
L58:
    r170 = dank_mids._exceptions.globals :: static
    r171 = '_internal_err_types'
    r172 = CPyDict_GetItem(r170, r171)
    if is_error(r172) goto L88 (error at <module>:97) else goto L59
L59:
    dank_mids._exceptions.internal_err_types = r172 :: static
    r173 = dank_mids._exceptions.globals :: static
    r174 = 'internal_err_types'
    r175 = CPyDict_SetItem(r173, r174, r172)
    dec_ref r172
    r176 = r175 >= 0 :: signed
    if not r176 goto L88 (error at <module>:97) else goto L60 :: bool
L60:
    r177 = builtins :: module
    r178 = 'Exception'
    r179 = CPyObject_GetAttr(r177, r178)
    if is_error(r179) goto L88 (error at <module>:100) else goto L61
L61:
    r180 = PyTuple_Pack(1, r179)
    dec_ref r179
    if is_error(r180) goto L88 (error at <module>:100) else goto L62
L62:
    r181 = 'dank_mids._exceptions'
    r182 = dank_mids._exceptions.DankMidsInternalError_template :: type
    r183 = CPyType_FromTemplate(r182, r180, r181)
    dec_ref r180
    if is_error(r183) goto L88 (error at <module>:100) else goto L63
L63:
    r184 = '__mypyc_attrs__'
    r185 = '__dict__'
    r186 = PyTuple_Pack(1, r185)
    if is_error(r186) goto L102 (error at <module>:100) else goto L64
L64:
    r187 = PyObject_SetAttr(r183, r184, r186)
    dec_ref r186
    r188 = r187 >= 0 :: signed
    if not r188 goto L102 (error at <module>:100) else goto L65 :: bool
L65:
    dank_mids._exceptions.DankMidsInternalError = r183 :: type
    r189 = dank_mids._exceptions.globals :: static
    r190 = 'DankMidsInternalError'
    r191 = CPyDict_SetItem(r189, r190, r183)
    dec_ref r183
    r192 = r191 >= 0 :: signed
    if not r192 goto L88 (error at <module>:100) else goto L66 :: bool
L66:
    r193 = builtins :: module
    r194 = 'Exception'
    r195 = CPyObject_GetAttr(r193, r194)
    if is_error(r195) goto L88 (error at <module>:116) else goto L67
L67:
    r196 = PyTuple_Pack(1, r195)
    dec_ref r195
    if is_error(r196) goto L88 (error at <module>:116) else goto L68
L68:
    r197 = 'dank_mids._exceptions'
    r198 = dank_mids._exceptions.BatchResponseSortError_template :: type
    r199 = CPyType_FromTemplate(r198, r196, r197)
    dec_ref r196
    if is_error(r199) goto L88 (error at <module>:116) else goto L69
L69:
    r200 = '__mypyc_attrs__'
    r201 = '__dict__'
    r202 = PyTuple_Pack(1, r201)
    if is_error(r202) goto L103 (error at <module>:116) else goto L70
L70:
    r203 = PyObject_SetAttr(r199, r200, r202)
    dec_ref r202
    r204 = r203 >= 0 :: signed
    if not r204 goto L103 (error at <module>:116) else goto L71 :: bool
L71:
    dank_mids._exceptions.BatchResponseSortError = r199 :: type
    r205 = dank_mids._exceptions.globals :: static
    r206 = 'BatchResponseSortError'
    r207 = CPyDict_SetItem(r205, r206, r199)
    dec_ref r199
    r208 = r207 >= 0 :: signed
    if not r208 goto L88 (error at <module>:116) else goto L72 :: bool
L72:
    r209 = dank_mids._exceptions.BadResponse :: type
    r210 = PyTuple_Pack(1, r209)
    if is_error(r210) goto L88 (error at <module>:149) else goto L73
L73:
    r211 = 'dank_mids._exceptions'
    r212 = dank_mids._exceptions.RateLimitError_template :: type
    r213 = CPyType_FromTemplate(r212, r210, r211)
    dec_ref r210
    if is_error(r213) goto L88 (error at <module>:149) else goto L74
L74:
    r214 = '__mypyc_attrs__'
    r215 = '__dict__'
    r216 = PyTuple_Pack(1, r215)
    if is_error(r216) goto L104 (error at <module>:149) else goto L75
L75:
    r217 = PyObject_SetAttr(r213, r214, r216)
    dec_ref r216
    r218 = r217 >= 0 :: signed
    if not r218 goto L104 (error at <module>:149) else goto L76 :: bool
L76:
    dank_mids._exceptions.RateLimitError = r213 :: type
    r219 = dank_mids._exceptions.globals :: static
    r220 = 'RateLimitError'
    r221 = CPyDict_SetItem(r219, r220, r213)
    dec_ref r213
    r222 = r221 >= 0 :: signed
    if not r222 goto L88 (error at <module>:149) else goto L77 :: bool
L77:
    r223 = dank_mids._exceptions.RateLimitError :: type
    r224 = PyTuple_Pack(1, r223)
    if is_error(r224) goto L88 (error at <module>:153) else goto L78
L78:
    r225 = 'dank_mids._exceptions'
    r226 = dank_mids._exceptions.ChainstackRateLimitError_template :: type
    r227 = CPyType_FromTemplate(r226, r224, r225)
    dec_ref r224
    if is_error(r227) goto L88 (error at <module>:153) else goto L79
L79:
    r228 = '__mypyc_attrs__'
    r229 = '__dict__'
    r230 = PyTuple_Pack(1, r229)
    if is_error(r230) goto L105 (error at <module>:153) else goto L80
L80:
    r231 = PyObject_SetAttr(r227, r228, r230)
    dec_ref r230
    r232 = r231 >= 0 :: signed
    if not r232 goto L105 (error at <module>:153) else goto L81 :: bool
L81:
    dank_mids._exceptions.ChainstackRateLimitError = r227 :: type
    r233 = dank_mids._exceptions.globals :: static
    r234 = 'ChainstackRateLimitError'
    r235 = CPyDict_SetItem(r233, r234, r227)
    dec_ref r227
    r236 = r235 >= 0 :: signed
    if not r236 goto L88 (error at <module>:153) else goto L82 :: bool
L82:
    r237 = dank_mids._exceptions.RateLimitError :: type
    r238 = PyTuple_Pack(1, r237)
    if is_error(r238) goto L88 (error at <module>:172) else goto L83
L83:
    r239 = 'dank_mids._exceptions'
    r240 = dank_mids._exceptions.QuiknodeRateLimitError_template :: type
    r241 = CPyType_FromTemplate(r240, r238, r239)
    dec_ref r238
    if is_error(r241) goto L88 (error at <module>:172) else goto L84
L84:
    r242 = '__mypyc_attrs__'
    r243 = '__dict__'
    r244 = PyTuple_Pack(1, r243)
    if is_error(r244) goto L106 (error at <module>:172) else goto L85
L85:
    r245 = PyObject_SetAttr(r241, r242, r244)
    dec_ref r244
    r246 = r245 >= 0 :: signed
    if not r246 goto L106 (error at <module>:172) else goto L86 :: bool
L86:
    dank_mids._exceptions.QuiknodeRateLimitError = r241 :: type
    r247 = dank_mids._exceptions.globals :: static
    r248 = 'QuiknodeRateLimitError'
    r249 = CPyDict_SetItem(r247, r248, r241)
    dec_ref r241
    r250 = r249 >= 0 :: signed
    if not r250 goto L88 (error at <module>:172) else goto L87 :: bool
L87:
    return 1
L88:
    r251 = <error> :: None
    return r251
L89:
    dec_ref r41
    goto L88
L90:
    dec_ref r57
    goto L88
L91:
    dec_ref r71
    goto L88
L92:
    dec_ref r85
    goto L88
L93:
    dec_ref r99
    goto L88
L94:
    dec_ref r113
    goto L88
L95:
    dec_ref r129
    goto L88
L96:
    dec_ref r144
    goto L88
L97:
    dec_ref r144
    dec_ref r147
    goto L88
L98:
    dec_ref r144
    dec_ref r147
    dec_ref r150
    goto L88
L99:
    dec_ref r144
    dec_ref r147
    dec_ref r150
    dec_ref r153
    goto L88
L100:
    dec_ref r144
    dec_ref r147
    dec_ref r150
    dec_ref r153
    dec_ref r156
    goto L88
L101:
    dec_ref r144
    dec_ref r147
    dec_ref r150
    dec_ref r153
    dec_ref r156
    dec_ref r159
    goto L88
L102:
    dec_ref r183
    goto L88
L103:
    dec_ref r199
    goto L88
L104:
    dec_ref r213
    goto L88
L105:
    dec_ref r227
    goto L88
L106:
    dec_ref r241
    goto L88

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20 :: object
    r21, r22, r23, r24 :: str
    r25 :: list
    r26, r27, r28, r29, r30 :: ptr
    r31 :: dict
    r32 :: str
    r33 :: i32
    r34 :: bit
    r35 :: object
    r36 :: str
    r37 :: dict
    r38, r39 :: object
    r40 :: str
    r41 :: dict
    r42 :: object
    r43 :: dict
    r44 :: str
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: str
    r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: object
    r53 :: object[1]
    r54 :: object_ptr
    r55, r56 :: object
    r57 :: str
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: object[1]
    r62 :: object_ptr
    r63 :: object
    r64 :: bool
    r65 :: object
    r66 :: str
    r67 :: dict
    r68 :: object
    r69 :: dict
    r70 :: str
    r71 :: object
    r72 :: str
    r73 :: object[1]
    r74 :: object_ptr
    r75 :: object
    r76 :: i32
    r77 :: bit
    r78 :: bool
    r79 :: object
    r80 :: str
    r81 :: dict
    r82 :: object
    r83 :: dict
    r84 :: str
    r85 :: object
    r86 :: dict
    r87 :: str
    r88 :: object
    r89 :: object[1]
    r90 :: object_ptr
    r91 :: object
    r92 :: dict
    r93 :: str
    r94 :: i32
    r95 :: bit
    r96 :: dict
    r97 :: str
    r98 :: object
    r99 :: str
    r100 :: object
    r101 :: dict
    r102 :: str
    r103 :: i32
    r104 :: bit
    r105 :: dict
    r106 :: str
    r107 :: object
    r108, r109, r110, r111 :: str
    r112 :: list
    r113, r114, r115, r116, r117 :: ptr
    r118 :: object
    r119 :: i32
    r120 :: bit
    r121, r122 :: tuple[object, object, object]
    r123, r124, r125 :: object
    r126 :: object[4]
    r127 :: object_ptr
    r128 :: object
    r129 :: i32
    r130 :: bit
    r131 :: bool
    r132 :: bit
    r133, r134, r135 :: tuple[object, object, object]
    r136 :: object
    r137 :: object[4]
    r138 :: object_ptr
    r139 :: object
    r140 :: bit
    r141 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L56 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('suppress',)
    r6 = 'contextlib'
    r7 = dank_mids.brownie_patch.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L56 (error at <module>:1) else goto L4
L4:
    contextlib = r8 :: module
    dec_ref r8
    r9 = ('AsyncEth',)
    r10 = 'web3.eth'
    r11 = dank_mids.brownie_patch.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L56 (error at <module>:3) else goto L5
L5:
    web3.eth = r12 :: module
    dec_ref r12
    r13 = ('setup_dank_w3_from_sync',)
    r14 = 'dank_mids.helpers'
    r15 = dank_mids.brownie_patch.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L56 (error at <module>:5) else goto L6
L6:
    dank_mids.helpers = r16 :: module
    dec_ref r16
    r17 = ('DankContractCall', 'DankContractMethod', 'DankContractTx', 'DankOverloadedMethod')
    r18 = 'dank_mids.brownie_patch.types'
    r19 = dank_mids.brownie_patch.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L56 (error at <module>:6) else goto L7
L7:
    dank_mids.brownie_patch.types = r20 :: module
    dec_ref r20
    r21 = 'DankContractCall'
    r22 = 'DankContractMethod'
    r23 = 'DankContractTx'
    r24 = 'DankOverloadedMethod'
    r25 = PyList_New(4)
    if is_error(r25) goto L56 (error at <module>:13) else goto L8
L8:
    r26 = get_element_ptr r25 ob_item :: PyListObject
    r27 = load_mem r26 :: ptr*
    inc_ref r21
    set_mem r27, r21 :: builtins.object*
    inc_ref r22
    r28 = r27 + 8
    set_mem r28, r22 :: builtins.object*
    inc_ref r23
    r29 = r27 + 16
    set_mem r29, r23 :: builtins.object*
    inc_ref r24
    r30 = r27 + 24
    set_mem r30, r24 :: builtins.object*
    r31 = dank_mids.brownie_patch.globals :: static
    r32 = '__all__'
    r33 = CPyDict_SetItem(r31, r32, r25)
    dec_ref r25
    r34 = r33 >= 0 :: signed
    if not r34 goto L56 (error at <module>:13) else goto L9 :: bool
L9:
    r35 = ('DankEth',)
    r36 = 'dank_mids.eth'
    r37 = dank_mids.brownie_patch.globals :: static
    r38 = CPyImport_ImportFromMany(r36, r35, r35, r37)
    if is_error(r38) goto L56 (error at <module>:15) else goto L10
L10:
    dank_mids.eth = r38 :: module
    dec_ref r38
    r39 = ('DankWeb3',)
    r40 = 'dank_mids.helpers._helpers'
    r41 = dank_mids.brownie_patch.globals :: static
    r42 = CPyImport_ImportFromMany(r40, r39, r39, r41)
    if is_error(r42) goto L56 (error at <module>:16) else goto L11
L11:
    dank_mids.helpers._helpers = r42 :: module
    dec_ref r42
    r43 = dank_mids.brownie_patch.globals :: static
    r44 = 'dank_web3'
    r45 = dank_mids.brownie_patch.globals :: static
    r46 = 'dank_eth'
    r47 = builtins :: module
    r48 = 'ImportError'
    r49 = CPyObject_GetAttr(r47, r48)
    if is_error(r49) goto L56 (error at <module>:33) else goto L12
L12:
    r50 = dank_mids.brownie_patch.globals :: static
    r51 = 'suppress'
    r52 = CPyDict_GetItem(r50, r51)
    if is_error(r52) goto L57 (error at <module>:33) else goto L13
L13:
    r53 = [r49]
    r54 = load_address r53
    r55 = PyObject_Vectorcall(r52, r54, 1, 0)
    dec_ref r52
    if is_error(r55) goto L57 (error at <module>:33) else goto L14
L14:
    dec_ref r49
    r56 = PyObject_Type(r55)
    r57 = '__exit__'
    r58 = CPyObject_GetAttr(r56, r57)
    if is_error(r58) goto L58 (error at <module>:33) else goto L15
L15:
    r59 = '__enter__'
    r60 = CPyObject_GetAttr(r56, r59)
    dec_ref r56
    if is_error(r60) goto L59 (error at <module>:33) else goto L16
L16:
    r61 = [r55]
    r62 = load_address r61
    r63 = PyObject_Vectorcall(r60, r62, 1, 0)
    dec_ref r60
    if is_error(r63) goto L59 (error at <module>:33) else goto L60
L17:
    r64 = 1
L18:
    r65 = ('network', 'web3')
    r66 = 'brownie'
    r67 = dank_mids.brownie_patch.globals :: static
    r68 = CPyImport_ImportFromMany(r66, r65, r65, r67)
    if is_error(r68) goto L35 (error at <module>:34) else goto L19
L19:
    brownie = r68 :: module
    dec_ref r68
    r69 = dank_mids.brownie_patch.globals :: static
    r70 = 'network'
    r71 = CPyDict_GetItem(r69, r70)
    if is_error(r71) goto L35 (error at <module>:36) else goto L20
L20:
    r72 = 'is_connected'
    r73 = [r71]
    r74 = load_address r73
    r75 = PyObject_VectorcallMethod(r72, r74, 9223372036854775809, 0)
    if is_error(r75) goto L61 (error at <module>:36) else goto L21
L21:
    dec_ref r71
    r76 = PyObject_IsTrue(r75)
    dec_ref r75
    r77 = r76 >= 0 :: signed
    if not r77 goto L35 (error at <module>:36) else goto L22 :: bool
L22:
    r78 = truncate r76: i32 to builtins.bool
    if r78 goto L23 else goto L43 :: bool
L23:
    r79 = ('Contract', 'patch_contract')
    r80 = 'dank_mids.brownie_patch.contract'
    r81 = dank_mids.brownie_patch.globals :: static
    r82 = CPyImport_ImportFromMany(r80, r79, r79, r81)
    if is_error(r82) goto L35 (error at <module>:37) else goto L24
L24:
    dank_mids.brownie_patch.contract = r82 :: module
    dec_ref r82
    r83 = dank_mids.brownie_patch.globals :: static
    r84 = 'web3'
    r85 = CPyDict_GetItem(r83, r84)
    if is_error(r85) goto L35 (error at <module>:39) else goto L25
L25:
    r86 = dank_mids.brownie_patch.globals :: static
    r87 = 'setup_dank_w3_from_sync'
    r88 = CPyDict_GetItem(r86, r87)
    if is_error(r88) goto L62 (error at <module>:39) else goto L26
L26:
    r89 = [r85]
    r90 = load_address r89
    r91 = PyObject_Vectorcall(r88, r90, 1, 0)
    dec_ref r88
    if is_error(r91) goto L62 (error at <module>:39) else goto L27
L27:
    dec_ref r85
    r92 = dank_mids.brownie_patch.globals :: static
    r93 = 'dank_web3'
    r94 = CPyDict_SetItem(r92, r93, r91)
    dec_ref r91
    r95 = r94 >= 0 :: signed
    if not r95 goto L35 (error at <module>:39) else goto L28 :: bool
L28:
    r96 = dank_mids.brownie_patch.globals :: static
    r97 = 'dank_web3'
    r98 = CPyDict_GetItem(r96, r97)
    if is_error(r98) goto L35 (error at <module>:40) else goto L29
L29:
    r99 = 'eth'
    r100 = CPyObject_GetAttr(r98, r99)
    dec_ref r98
    if is_error(r100) goto L35 (error at <module>:40) else goto L30
L30:
    r101 = dank_mids.brownie_patch.globals :: static
    r102 = 'dank_eth'
    r103 = CPyDict_SetItem(r101, r102, r100)
    dec_ref r100
    r104 = r103 >= 0 :: signed
    if not r104 goto L35 (error at <module>:40) else goto L31 :: bool
L31:
    r105 = dank_mids.brownie_patch.globals :: static
    r106 = '__all__'
    r107 = CPyDict_GetItem(r105, r106)
    if is_error(r107) goto L35 (error at <module>:41) else goto L32
L32:
    r108 = 'Contract'
    r109 = 'patch_contract'
    r110 = 'dank_web3'
    r111 = 'dank_eth'
    r112 = PyList_New(4)
    if is_error(r112) goto L63 (error at <module>:41) else goto L33
L33:
    r113 = get_element_ptr r112 ob_item :: PyListObject
    r114 = load_mem r113 :: ptr*
    inc_ref r108
    set_mem r114, r108 :: builtins.object*
    inc_ref r109
    r115 = r114 + 8
    set_mem r115, r109 :: builtins.object*
    inc_ref r110
    r116 = r114 + 16
    set_mem r116, r110 :: builtins.object*
    inc_ref r111
    r117 = r114 + 24
    set_mem r117, r111 :: builtins.object*
    r118 = PyNumber_InPlaceAdd(r107, r112)
    dec_ref r107
    dec_ref r112
    if is_error(r118) goto L35 (error at <module>:41) else goto L34
L34:
    r119 = CPyDict_SetItem(r105, r106, r118)
    dec_ref r118
    r120 = r119 >= 0 :: signed
    if not r120 goto L35 (error at <module>:41) else goto L43 :: bool
L35:
    r121 = CPy_CatchError()
    r64 = 0
    r122 = CPy_GetExcInfo()
    r123 = r122[0]
    r124 = r122[1]
    r125 = r122[2]
    dec_ref r122
    r126 = [r55, r123, r124, r125]
    r127 = load_address r126
    r128 = PyObject_Vectorcall(r58, r127, 4, 0)
    if is_error(r128) goto L64 (error at <module>:33) else goto L36
L36:
    dec_ref r123
    dec_ref r124
    dec_ref r125
    r129 = PyObject_IsTrue(r128)
    dec_ref r128
    r130 = r129 >= 0 :: signed
    if not r130 goto L41 (error at <module>:33) else goto L37 :: bool
L37:
    r131 = truncate r129: i32 to builtins.bool
    if r131 goto L40 else goto L38 :: bool
L38:
    CPy_Reraise()
    if not 0 goto L41 else goto L65 :: bool
L39:
    unreachable
L40:
    CPy_RestoreExcInfo(r121)
    dec_ref r121
    goto L43
L41:
    CPy_RestoreExcInfo(r121)
    dec_ref r121
    r132 = CPy_KeepPropagating()
    if not r132 goto L44 else goto L66 :: bool
L42:
    unreachable
L43:
    r133 = <error> :: tuple[object, object, object]
    r134 = r133
    goto L45
L44:
    r135 = CPy_CatchError()
    r134 = r135
L45:
    if r64 goto L46 else goto L67 :: bool
L46:
    r136 = load_address _Py_NoneStruct
    r137 = [r55, r136, r136, r136]
    r138 = load_address r137
    r139 = PyObject_Vectorcall(r58, r138, 4, 0)
    dec_ref r58
    if is_error(r139) goto L68 (error at <module>:33) else goto L69
L47:
    dec_ref r55
L48:
    if is_error(r134) goto L55 else goto L49
L49:
    CPy_Reraise()
    if not 0 goto L51 else goto L70 :: bool
L50:
    unreachable
L51:
    if is_error(r134) goto L53 else goto L52
L52:
    CPy_RestoreExcInfo(r134)
    xdec_ref r134
L53:
    r140 = CPy_KeepPropagating()
    if not r140 goto L56 else goto L54 :: bool
L54:
    unreachable
L55:
    return 1
L56:
    r141 = <error> :: None
    return r141
L57:
    dec_ref r49
    goto L56
L58:
    dec_ref r55
    dec_ref r56
    goto L56
L59:
    dec_ref r55
    dec_ref r58
    goto L56
L60:
    dec_ref r63
    goto L17
L61:
    dec_ref r71
    goto L35
L62:
    dec_ref r85
    goto L35
L63:
    dec_ref r107
    goto L35
L64:
    dec_ref r123
    dec_ref r124
    dec_ref r125
    goto L41
L65:
    dec_ref r55
    dec_ref r58
    dec_ref r121
    goto L39
L66:
    dec_ref r55
    dec_ref r58
    goto L42
L67:
    dec_ref r55
    dec_ref r58
    goto L48
L68:
    dec_ref r55
    goto L51
L69:
    dec_ref r139
    goto L47
L70:
    xdec_ref r134
    goto L50

def RawResponse.__init__(self, raw):
    self :: dank_mids.helpers._codec.RawResponse
    raw :: object
L0:
    inc_ref raw
    self._raw = raw
    return 1

def RawResponse.decode(self, partial):
    self :: dank_mids.helpers._codec.RawResponse
    partial :: bool
    r0 :: dict
    r1 :: str
    r2, r3 :: object
    r4 :: bit
    r5 :: None
    r6 :: object
    r7 :: dict
    r8 :: str
    r9 :: object
    r10 :: union[object, None]
    r11 :: dict
    r12 :: str
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: object[2]
    r18 :: object_ptr
    r19, r20, r21 :: object
L0:
    if is_error(partial) goto L1 else goto L2
L1:
    partial = 0
L2:
    r0 = dank_mids.helpers._codec.globals :: static
    r1 = 'better_decode'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L13 (error at decode:95) else goto L3
L3:
    r3 = load_address _Py_NoneStruct
    r4 = r2 == r3
    dec_ref r2
    if r4 goto L4 else goto L5 :: bool
L4:
    r5 = __import_from_types()
    if is_error(r5) goto L13 (error at decode:96) else goto L5
L5:
    r6 = self._raw
    if partial goto L6 else goto L8 :: bool
L6:
    r7 = dank_mids.helpers._codec.globals :: static
    r8 = 'PartialResponse'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L14 (error at decode:97) else goto L7
L7:
    r10 = r9
    goto L10
L8:
    r11 = dank_mids.helpers._codec.globals :: static
    r12 = 'Response'
    r13 = CPyDict_GetItem(r11, r12)
    if is_error(r13) goto L14 (error at decode:97) else goto L9
L9:
    r10 = r13
L10:
    r14 = dank_mids.helpers._codec.globals :: static
    r15 = 'better_decode'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L15 (error at decode:97) else goto L11
L11:
    r17 = [r6, r10]
    r18 = load_address r17
    r19 = ('type',)
    r20 = PyObject_Vectorcall(r16, r18, 1, r19)
    dec_ref r16
    if is_error(r20) goto L15 (error at decode:97) else goto L12
L12:
    dec_ref r6
    dec_ref r10
    return r20
L13:
    r21 = <error> :: object
    return r21
L14:
    dec_ref r6
    goto L13
L15:
    dec_ref r6
    dec_ref r10
    goto L13

def decode_raw(data):
    data, r0 :: object
    r1 :: bool
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5 :: dank_mids.helpers._codec.RawResponse
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: bool
    r9 :: bit
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: list
    r14 :: object
    r15 :: i32
    r16 :: bit
    r17 :: tuple
    r18 :: str
    r19 :: i32
    r20, r21 :: bit
    r22 :: dank_mids.helpers._codec.RawResponse
L0:
L1:
    r0 = dank_mids.helpers._codec._decode_raw :: static
    if is_error(r0) goto L2 else goto L4
L2:
    r1 = raise NameError('value for final name "_decode_raw" was not set')
    if not r1 goto L7 (error at decode_raw:113) else goto L3 :: bool
L3:
    unreachable
L4:
    r2 = [data]
    r3 = load_address r2
    r4 = PyObject_Vectorcall(r0, r3, 1, 0)
    if is_error(r4) goto L7 (error at decode_raw:113) else goto L5
L5:
    r5 = RawResponse(r4)
    dec_ref r4
    if is_error(r5) goto L7 (error at decode_raw:113) else goto L6
L6:
    return r5
L7:
    r6 = CPy_CatchError()
    r7 = dank_mids.helpers._codec.DecodeError :: static
    if is_error(r7) goto L8 else goto L10
L8:
    r8 = raise NameError('value for final name "DecodeError" was not set')
    if not r8 goto L21 (error at decode_raw:114) else goto L24 :: bool
L9:
    unreachable
L10:
    r9 = CPy_ExceptionMatches(r7)
    if r9 goto L11 else goto L19 :: bool
L11:
    r10 = CPy_GetExcValue()
    r11 = 'args'
    r12 = CPyObject_GetAttr(r10, r11)
    if is_error(r12) goto L25 (error at decode_raw:115) else goto L12
L12:
    r13 = PyList_New(0)
    if is_error(r13) goto L26 (error at decode_raw:115) else goto L13
L13:
    r14 = CPyList_Extend(r13, r12)
    dec_ref r12
    if is_error(r14) goto L27 (error at decode_raw:115) else goto L28
L14:
    r15 = PyList_Append(r13, data)
    r16 = r15 >= 0 :: signed
    if not r16 goto L27 (error at decode_raw:115) else goto L15 :: bool
L15:
    r17 = PyList_AsTuple(r13)
    dec_ref r13
    if is_error(r17) goto L25 (error at decode_raw:115) else goto L16
L16:
    r18 = 'args'
    r19 = PyObject_SetAttr(r10, r18, r17)
    dec_ref r10
    dec_ref r17
    r20 = r19 >= 0 :: signed
    if not r20 goto L21 (error at decode_raw:115) else goto L17 :: bool
L17:
    CPy_Reraise()
    if not 0 goto L21 else goto L29 :: bool
L18:
    unreachable
L19:
    CPy_Reraise()
    if not 0 goto L21 else goto L30 :: bool
L20:
    unreachable
L21:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r21 = CPy_KeepPropagating()
    if not r21 goto L23 else goto L22 :: bool
L22:
    unreachable
L23:
    r22 = <error> :: dank_mids.helpers._codec.RawResponse
    return r22
L24:
    dec_ref r6
    goto L9
L25:
    dec_ref r10
    goto L21
L26:
    dec_ref r10
    dec_ref r12
    goto L21
L27:
    dec_ref r10
    dec_ref r13
    goto L21
L28:
    dec_ref r14
    goto L14
L29:
    dec_ref r6
    goto L18
L30:
    dec_ref r6
    goto L20

def decode_jsonrpc_batch(data):
    data :: object
    r0 :: dict
    r1 :: str
    r2, r3 :: object
    r4 :: bit
    r5 :: None
    r6 :: dict
    r7 :: str
    r8 :: object
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    decoded :: union[list, object]
    r12 :: object
    r13 :: i32
    r14 :: bit
    r15 :: bool
    r16 :: list
    r17, r18 :: object
    r19 :: dank_mids.helpers._codec.RawResponse
    r20 :: i32
    r21, r22 :: bit
    r23, r24 :: union[list, object]
L0:
    r0 = dank_mids.helpers._codec.globals :: static
    r1 = '_decode_batch'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L16 (error at decode_jsonrpc_batch:129) else goto L1
L1:
    r3 = load_address _Py_NoneStruct
    r4 = r2 == r3
    dec_ref r2
    if r4 goto L2 else goto L3 :: bool
L2:
    r5 = __make_decode_batch()
    if is_error(r5) goto L16 (error at decode_jsonrpc_batch:130) else goto L3
L3:
    r6 = dank_mids.helpers._codec.globals :: static
    r7 = '_decode_batch'
    r8 = CPyDict_GetItem(r6, r7)
    if is_error(r8) goto L16 (error at decode_jsonrpc_batch:132) else goto L4
L4:
    r9 = [data]
    r10 = load_address r9
    r11 = PyObject_Vectorcall(r8, r10, 1, 0)
    dec_ref r8
    if is_error(r11) goto L16 (error at decode_jsonrpc_batch:132) else goto L5
L5:
    decoded = r11
    r12 = load_address PyList_Type
    r13 = PyObject_IsInstance(decoded, r12)
    r14 = r13 >= 0 :: signed
    if not r14 goto L17 (error at decode_jsonrpc_batch:133) else goto L6 :: bool
L6:
    r15 = truncate r13: i32 to builtins.bool
    if r15 goto L7 else goto L14 :: bool
L7:
    r16 = PyList_New(0)
    if is_error(r16) goto L17 (error at decode_jsonrpc_batch:133) else goto L8
L8:
    r17 = PyObject_GetIter(decoded)
    dec_ref decoded
    if is_error(r17) goto L18 (error at decode_jsonrpc_batch:133) else goto L9
L9:
    r18 = PyIter_Next(r17)
    if is_error(r18) goto L19 else goto L10
L10:
    r19 = RawResponse(r18)
    dec_ref r18
    if is_error(r19) goto L20 (error at decode_jsonrpc_batch:133) else goto L11
L11:
    r20 = PyList_Append(r16, r19)
    dec_ref r19
    r21 = r20 >= 0 :: signed
    if not r21 goto L20 (error at decode_jsonrpc_batch:133) else goto L9 :: bool
L12:
    r22 = CPy_NoErrOccurred()
    if not r22 goto L18 (error at decode_jsonrpc_batch:133) else goto L13 :: bool
L13:
    r23 = r16
    goto L15
L14:
    r23 = decoded
L15:
    return r23
L16:
    r24 = <error> :: union[object, list]
    return r24
L17:
    dec_ref decoded
    goto L16
L18:
    dec_ref r16
    goto L16
L19:
    dec_ref r17
    goto L12
L20:
    dec_ref r16
    dec_ref r17
    goto L16

def _encode_hook(obj):
    obj :: union[int, object, bytes]
    r0 :: object
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4 :: int
    r5 :: object
    r6 :: str
    r7, r8 :: object
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    r12 :: str
    r13 :: tuple[object, object, object]
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: bit
    r18, e :: object
    r19 :: dict
    r20 :: str
    r21 :: object
    r22 :: i32
    r23 :: bit
    r24 :: bool
    r25 :: dict
    r26 :: object
    r27 :: str
    r28 :: object[1]
    r29 :: object_ptr
    r30, r31, r32 :: object
    r33 :: tuple[object, object]
    r34, r35, r36 :: object
    r37 :: i32
    r38, r39 :: bit
    r40, r41 :: object
    r42 :: str
    r43 :: object
    r44 :: object[2]
    r45 :: object_ptr
    r46, r47 :: object
    r48 :: str
    r49 :: object
    r50 :: bit
    r51, r52 :: object
    r53 :: bool
    r54 :: i32
    r55 :: bit
    r56 :: bool
    r57 :: object
    r58 :: str
    r59 :: object[1]
    r60 :: object_ptr
    r61 :: object
    r62 :: str
    r63 :: object
    r64 :: tuple
    r65 :: object
    r66 :: list
    r67 :: object
    r68 :: i32
    r69 :: bit
    r70 :: i32
    r71 :: bit
    r72 :: tuple
    r73 :: str
    r74 :: i32
    r75 :: bit
    r76, r77 :: object
    r78 :: str
    r79 :: object
    r80 :: object[2]
    r81 :: object_ptr
    r82 :: object
    r83 :: bit
    r84 :: union[object, list, dict]
L0:
L1:
    r0 = load_address PyLong_Type
    r1 = [obj]
    r2 = load_address r1
    r3 = PyObject_Vectorcall(r0, r2, 1, 0)
    if is_error(r3) goto L7 (error at _encode_hook:151) else goto L2
L2:
    r4 = unbox(int, r3)
    dec_ref r3
    if is_error(r4) goto L7 (error at _encode_hook:151) else goto L3
L3:
    r5 = builtins :: module
    r6 = 'hex'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L53 (error at _encode_hook:151) else goto L4
L4:
    r8 = box(int, r4)
    r9 = [r8]
    r10 = load_address r9
    r11 = PyObject_Vectorcall(r7, r10, 1, 0)
    dec_ref r7
    if is_error(r11) goto L54 (error at _encode_hook:151) else goto L5
L5:
    dec_ref r8
    r12 = cast(str, r11)
    if is_error(r12) goto L7 (error at _encode_hook:151) else goto L6
L6:
    return r12
L7:
    r13 = CPy_CatchError()
    r14 = builtins :: module
    r15 = 'TypeError'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L50 (error at _encode_hook:152) else goto L8
L8:
    r17 = CPy_ExceptionMatches(r16)
    dec_ref r16
    if r17 goto L9 else goto L26 :: bool
L9:
    r18 = CPy_GetExcValue()
    e = r18
    dec_ref e
    r19 = dank_mids.helpers._codec.globals :: static
    r20 = 'Mapping'
    r21 = CPyDict_GetItem(r19, r20)
    if is_error(r21) goto L50 (error at _encode_hook:155) else goto L10
L10:
    r22 = PyObject_IsInstance(obj, r21)
    dec_ref r21
    r23 = r22 >= 0 :: signed
    if not r23 goto L50 (error at _encode_hook:155) else goto L11 :: bool
L11:
    r24 = truncate r22: i32 to builtins.bool
    if r24 goto L12 else goto L22 :: bool
L12:
    r25 = PyDict_New()
    if is_error(r25) goto L50 (error at _encode_hook:156) else goto L13
L13:
    inc_ref obj
    r26 = obj
    r27 = 'items'
    r28 = [r26]
    r29 = load_address r28
    r30 = PyObject_VectorcallMethod(r27, r29, 9223372036854775809, 0)
    if is_error(r30) goto L55 (error at _encode_hook:156) else goto L14
L14:
    dec_ref r26
L15:
    r31 = PyObject_GetIter(r30)
    dec_ref r30
    if is_error(r31) goto L56 (error at _encode_hook:156) else goto L16
L16:
    r32 = PyIter_Next(r31)
    if is_error(r32) goto L57 else goto L17
L17:
    r33 = unbox(tuple[object, object], r32)
    dec_ref r32
    if is_error(r33) goto L58 (error at _encode_hook:156) else goto L18
L18:
    r34 = r33[0]
    r35 = r33[1]
    dec_ref r33
    r36 = _rudimentary_encode_dict_value(r35)
    dec_ref r35
    if is_error(r36) goto L59 (error at _encode_hook:156) else goto L19
L19:
    r37 = CPyDict_SetItem(r25, r34, r36)
    dec_ref r34
    dec_ref r36
    r38 = r37 >= 0 :: signed
    if not r38 goto L58 (error at _encode_hook:156) else goto L16 :: bool
L20:
    r39 = CPy_NoErrOccurred()
    if not r39 goto L56 (error at _encode_hook:156) else goto L21 :: bool
L21:
    CPy_RestoreExcInfo(r13)
    dec_ref r13
    return r25
L22:
    r40 = PyObject_Type(obj)
    r41 = builtins :: module
    r42 = 'TypeError'
    r43 = CPyObject_GetAttr(r41, r42)
    if is_error(r43) goto L60 (error at _encode_hook:158) else goto L23
L23:
    r44 = [obj, r40]
    r45 = load_address r44
    r46 = PyObject_Vectorcall(r43, r45, 2, 0)
    dec_ref r43
    if is_error(r46) goto L60 (error at _encode_hook:158) else goto L24
L24:
    dec_ref r40
    CPy_Raise(r46)
    dec_ref r46
    if not 0 goto L50 (error at _encode_hook:158) else goto L61 :: bool
L25:
    unreachable
L26:
    r47 = builtins :: module
    r48 = 'ValueError'
    r49 = CPyObject_GetAttr(r47, r48)
    if is_error(r49) goto L50 (error at _encode_hook:159) else goto L27
L27:
    r50 = CPy_ExceptionMatches(r49)
    dec_ref r49
    if r50 goto L28 else goto L48 :: bool
L28:
    r51 = CPy_GetExcValue()
    e = r51
    r52 = dank_mids.helpers._codec.HexBytes :: static
    if is_error(r52) goto L62 else goto L31
L29:
    r53 = raise NameError('value for final name "HexBytes" was not set')
    if not r53 goto L50 (error at _encode_hook:162) else goto L63 :: bool
L30:
    unreachable
L31:
    r54 = PyObject_IsInstance(obj, r52)
    r55 = r54 >= 0 :: signed
    if not r55 goto L64 (error at _encode_hook:162) else goto L32 :: bool
L32:
    r56 = truncate r54: i32 to builtins.bool
    if r56 goto L65 else goto L36 :: bool
L33:
    inc_ref obj
    r57 = obj
    r58 = 'hex'
    r59 = [r57]
    r60 = load_address r59
    r61 = PyObject_VectorcallMethod(r58, r60, 9223372036854775809, 0)
    if is_error(r61) goto L66 (error at _encode_hook:163) else goto L34
L34:
    dec_ref r57
L35:
    CPy_RestoreExcInfo(r13)
    dec_ref r13
    return r61
L36:
    r62 = 'args'
    r63 = CPyObject_GetAttr(e, r62)
    if is_error(r63) goto L64 (error at _encode_hook:165) else goto L37
L37:
    r64 = cast(tuple, r63)
    if is_error(r64) goto L64 (error at _encode_hook:165) else goto L38
L38:
    r65 = PyObject_Type(obj)
    r66 = PyList_New(0)
    if is_error(r66) goto L67 (error at _encode_hook:165) else goto L39
L39:
    r67 = CPyList_Extend(r66, r64)
    dec_ref r64
    if is_error(r67) goto L68 (error at _encode_hook:165) else goto L69
L40:
    r68 = PyList_Append(r66, obj)
    r69 = r68 >= 0 :: signed
    if not r69 goto L68 (error at _encode_hook:165) else goto L41 :: bool
L41:
    r70 = PyList_Append(r66, r65)
    dec_ref r65
    r71 = r70 >= 0 :: signed
    if not r71 goto L70 (error at _encode_hook:165) else goto L42 :: bool
L42:
    r72 = PyList_AsTuple(r66)
    dec_ref r66
    if is_error(r72) goto L64 (error at _encode_hook:165) else goto L43
L43:
    r73 = 'args'
    r74 = PyObject_SetAttr(e, r73, r72)
    dec_ref e
    dec_ref r72
    r75 = r74 >= 0 :: signed
    if not r75 goto L50 (error at _encode_hook:165) else goto L44 :: bool
L44:
    r76 = PyObject_Type(obj)
    r77 = builtins :: module
    r78 = 'ValueError'
    r79 = CPyObject_GetAttr(r77, r78)
    if is_error(r79) goto L71 (error at _encode_hook:166) else goto L45
L45:
    r80 = [obj, r76]
    r81 = load_address r80
    r82 = PyObject_Vectorcall(r79, r81, 2, 0)
    dec_ref r79
    if is_error(r82) goto L71 (error at _encode_hook:166) else goto L46
L46:
    dec_ref r76
    CPy_Raise(r82)
    dec_ref r82
    if not 0 goto L50 (error at _encode_hook:166) else goto L72 :: bool
L47:
    unreachable
L48:
    CPy_Reraise()
    if not 0 goto L50 else goto L73 :: bool
L49:
    unreachable
L50:
    CPy_RestoreExcInfo(r13)
    dec_ref r13
    r83 = CPy_KeepPropagating()
    if not r83 goto L52 else goto L51 :: bool
L51:
    unreachable
L52:
    r84 = <error> :: union[object, list, dict]
    return r84
L53:
    dec_ref r4 :: int
    goto L7
L54:
    dec_ref r8
    goto L7
L55:
    dec_ref r25
    dec_ref r26
    goto L50
L56:
    dec_ref r25
    goto L50
L57:
    dec_ref r31
    goto L20
L58:
    dec_ref r25
    dec_ref r31
    goto L50
L59:
    dec_ref r25
    dec_ref r31
    dec_ref r34
    goto L50
L60:
    dec_ref r40
    goto L50
L61:
    dec_ref r13
    goto L25
L62:
    dec_ref e
    goto L29
L63:
    dec_ref r13
    goto L30
L64:
    dec_ref e
    goto L50
L65:
    dec_ref e
    goto L33
L66:
    dec_ref r57
    goto L50
L67:
    dec_ref e
    dec_ref r64
    dec_ref r65
    goto L50
L68:
    dec_ref e
    dec_ref r65
    dec_ref r66
    goto L50
L69:
    dec_ref r67
    goto L40
L70:
    dec_ref e
    dec_ref r66
    goto L50
L71:
    dec_ref r76
    goto L50
L72:
    dec_ref r13
    goto L47
L73:
    dec_ref r13
    goto L49

def _rudimentary_encode_dict_value(value):
    value :: union[int, object]
    r0 :: object
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4 :: int
    r5 :: object
    r6 :: str
    r7, r8 :: object
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    r12 :: str
    r13 :: union[str, object]
    r14 :: object
L0:
    r0 = load_address PyLong_Type
    r1 = PyObject_IsInstance(value, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L9 (error at _rudimentary_encode_dict_value:175) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L2 else goto L7 :: bool
L2:
    r4 = unbox(int, value)
    if is_error(r4) goto L9 (error at _rudimentary_encode_dict_value:175) else goto L3
L3:
    r5 = builtins :: module
    r6 = 'hex'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L10 (error at _rudimentary_encode_dict_value:175) else goto L4
L4:
    r8 = box(int, r4)
    r9 = [r8]
    r10 = load_address r9
    r11 = PyObject_Vectorcall(r7, r10, 1, 0)
    dec_ref r7
    if is_error(r11) goto L11 (error at _rudimentary_encode_dict_value:175) else goto L5
L5:
    dec_ref r8
    r12 = cast(str, r11)
    if is_error(r12) goto L9 (error at _rudimentary_encode_dict_value:175) else goto L6
L6:
    r13 = r12
    goto L8
L7:
    inc_ref value
    r13 = value
L8:
    return r13
L9:
    r14 = <error> :: object
    return r14
L10:
    dec_ref r4 :: int
    goto L9
L11:
    dec_ref r8
    goto L9

def __mypyc_lambda__0_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__0_obj.__call__(__mypyc_self__, _):
    __mypyc_self__ :: dank_mids.helpers._codec.__mypyc_lambda__0_obj
    _, r0 :: object
L0:
    r0 = load_address _Py_EllipsisObject
    inc_ref r0
    return r0

def _int_to_big_endian(value):
    value :: int
    r0 :: str
    r1 :: object
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5, r6, r7 :: int
    r8 :: bit
    r9 :: int
    r10, r11 :: str
    r12, r13 :: object
    r14 :: object[3]
    r15 :: object_ptr
    r16 :: object
    r17, r18 :: bytes
L0:
    r0 = 'bit_length'
    inc_ref value :: int
    r1 = box(int, value)
    r2 = [r1]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r0, r3, 9223372036854775809, 0)
    if is_error(r4) goto L10 (error at _int_to_big_endian:208) else goto L1
L1:
    dec_ref r1
    r5 = unbox(int, r4)
    dec_ref r4
    if is_error(r5) goto L9 (error at _int_to_big_endian:208) else goto L2
L2:
    r6 = CPyTagged_Add(r5, 14)
    dec_ref r5 :: int
    r7 = CPyTagged_Rshift(r6, 6)
    dec_ref r6 :: int
    if is_error(r7) goto L9 (error at _int_to_big_endian:-1) else goto L3
L3:
    r8 = r7 != 0
    if r8 goto L4 else goto L11 :: bool
L4:
    r9 = r7
    goto L6
L5:
    r9 = 2
L6:
    r10 = 'big'
    r11 = 'to_bytes'
    inc_ref value :: int
    r12 = box(int, value)
    r13 = box(int, r9)
    r14 = [r12, r13, r10]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r11, r15, 9223372036854775811, 0)
    if is_error(r16) goto L12 (error at _int_to_big_endian:208) else goto L7
L7:
    dec_ref r12
    dec_ref r13
    r17 = cast(bytes, r16)
    if is_error(r17) goto L9 (error at _int_to_big_endian:208) else goto L8
L8:
    return r17
L9:
    r18 = <error> :: bytes
    return r18
L10:
    dec_ref r1
    goto L9
L11:
    dec_ref r7 :: int
    goto L5
L12:
    dec_ref r12
    dec_ref r13
    goto L9

def _encode_uint_256(i):
    i :: int
    r0, r1 :: bytes
    r2 :: str
    r3 :: object
    r4 :: object[3]
    r5 :: object_ptr
    r6 :: object
    r7, r8 :: bytes
L0:
    r0 = _int_to_big_endian(i)
    if is_error(r0) goto L4 (error at _encode_uint_256:212) else goto L1
L1:
    r1 = b'\x00'
    r2 = 'rjust'
    r3 = object 32
    r4 = [r0, r3, r1]
    r5 = load_address r4
    r6 = PyObject_VectorcallMethod(r2, r5, 9223372036854775811, 0)
    if is_error(r6) goto L5 (error at _encode_uint_256:213) else goto L2
L2:
    dec_ref r0
    r7 = cast(bytes, r6)
    if is_error(r7) goto L4 (error at _encode_uint_256:213) else goto L3
L3:
    return r7
L4:
    r8 = <error> :: bytes
    return r8
L5:
    dec_ref r0
    goto L4

def __encode_new(values):
    values :: object
    r0 :: tuple[bytes, int]
    r1 :: bytes
    r2 :: int
    r3 :: bytes
    r4 :: int
    r5, r6, r7 :: bytes
L0:
    r0 = __encode_elements_new(values)
    if is_error(r0) goto L4 (error at __encode_new:217) else goto L1
L1:
    r1 = borrow r0[0]
    r2 = borrow r0[1]
    r3 = unborrow r1
    r4 = unborrow r2
    r5 = _encode_uint_256(r4)
    dec_ref r4 :: int
    if is_error(r5) goto L5 (error at __encode_new:218) else goto L2
L2:
    r6 = CPyBytes_Concat(r5, r3)
    dec_ref r3
    if is_error(r6) goto L4 (error at __encode_new:218) else goto L3
L3:
    return r6
L4:
    r7 = <error> :: bytes
    return r7
L5:
    dec_ref r3
    goto L4

def __encode_elements_new(values):
    values :: object
    r0 :: list
    r1, r2 :: object
    r3 :: union[tuple[object, object], list]
    r4 :: object
    r5 :: bool
    r6 :: object[1]
    r7 :: object_ptr
    r8 :: object
    r9 :: i32
    r10, r11 :: bit
    r12 :: ptr
    r13 :: native_int
    r14 :: short_int
    count, r15 :: int
    r16 :: list
    r17 :: object
    r18, r19 :: ptr
    offset :: int
    r20 :: object
    r21 :: list
    r22 :: short_int
    r23 :: ptr
    r24 :: native_int
    r25 :: short_int
    r26 :: bit
    r27 :: native_int
    r28, r29 :: ptr
    r30 :: native_int
    r31 :: ptr
    r32 :: object
    r33, r34 :: int
    r35 :: object
    r36 :: i32
    r37 :: bit
    r38 :: short_int
    r39 :: ptr
    r40 :: native_int
    r41 :: list
    r42 :: short_int
    r43 :: ptr
    r44 :: native_int
    r45 :: short_int
    r46 :: bit
    r47 :: native_int
    r48, r49 :: ptr
    r50 :: native_int
    r51 :: ptr
    r52 :: object
    r53, r54 :: int
    r55 :: bytes
    r56 :: bit
    r57 :: short_int
    r58 :: object
    r59 :: bytes
    r60 :: list
    r61, r62 :: object
    r63 :: tuple
    r64 :: bytes
    r65, r66 :: tuple[bytes, int]
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L32 (error at __encode_elements_new:222) else goto L1
L1:
    r1 = PyObject_GetIter(values)
    if is_error(r1) goto L33 (error at __encode_elements_new:222) else goto L2
L2:
    r2 = PyIter_Next(r1)
    if is_error(r2) goto L34 else goto L3
L3:
    r3 = cast(union[tuple[object, object], list], r2)
    if is_error(r3) goto L35 (error at __encode_elements_new:222) else goto L4
L4:
    r4 = dank_mids.helpers._codec._item_encoder :: static
    if is_error(r4) goto L36 else goto L7
L5:
    r5 = raise NameError('value for final name "_item_encoder" was not set')
    if not r5 goto L32 (error at __encode_elements_new:222) else goto L6 :: bool
L6:
    unreachable
L7:
    r6 = [r3]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r4, r7, 1, 0)
    if is_error(r8) goto L37 (error at __encode_elements_new:222) else goto L8
L8:
    dec_ref r3
    r9 = PyList_Append(r0, r8)
    dec_ref r8
    r10 = r9 >= 0 :: signed
    if not r10 goto L35 (error at __encode_elements_new:222) else goto L2 :: bool
L9:
    r11 = CPy_NoErrOccurred()
    if not r11 goto L33 (error at __encode_elements_new:222) else goto L10 :: bool
L10:
    r12 = get_element_ptr r0 ob_size :: PyVarObject
    r13 = load_mem r12 :: native_int*
    r14 = r13 << 1
    count = r14
    r15 = CPyTagged_Multiply(64, count)
    r16 = PyList_New(1)
    if is_error(r16) goto L38 (error at __encode_elements_new:225) else goto L11
L11:
    r17 = object 0
    r18 = get_element_ptr r16 ob_item :: PyListObject
    r19 = load_mem r18 :: ptr*
    inc_ref r17
    set_mem r19, r17 :: builtins.object*
    offset = 0
    r20 = CPyList_GetSlice(r0, 0, -2)
    if is_error(r20) goto L39 (error at __encode_elements_new:227) else goto L12
L12:
    r21 = cast(list, r20)
    if is_error(r21) goto L39 (error at __encode_elements_new:227) else goto L13
L13:
    r22 = 0
L14:
    r23 = get_element_ptr r21 ob_size :: PyVarObject
    r24 = load_mem r23 :: native_int*
    r25 = r24 << 1
    r26 = r22 < r25 :: signed
    if r26 goto L15 else goto L40 :: bool
L15:
    r27 = r22 >> 1
    r28 = get_element_ptr r21 ob_item :: PyListObject
    r29 = load_mem r28 :: ptr*
    r30 = r27 * 8
    r31 = r29 + r30
    r32 = load_mem r31 :: builtins.object*
    inc_ref r32
    r33 = CPyObject_Size(r32)
    dec_ref r32
    if is_error(r33) goto L41 (error at __encode_elements_new:228) else goto L16
L16:
    r34 = CPyTagged_Add(offset, r33)
    dec_ref offset :: int
    dec_ref r33 :: int
    offset = r34
    inc_ref offset :: int
    r35 = box(int, offset)
    r36 = PyList_Append(r16, r35)
    dec_ref r35
    r37 = r36 >= 0 :: signed
    if not r37 goto L41 (error at __encode_elements_new:229) else goto L17 :: bool
L17:
    r38 = r22 + 2
    r22 = r38
    goto L14
L18:
    r39 = get_element_ptr r16 ob_size :: PyVarObject
    r40 = load_mem r39 :: native_int*
    r41 = PyList_New(r40)
    if is_error(r41) goto L42 (error at __encode_elements_new:230) else goto L19
L19:
    r42 = 0
L20:
    r43 = get_element_ptr r16 ob_size :: PyVarObject
    r44 = load_mem r43 :: native_int*
    r45 = r44 << 1
    r46 = r42 < r45 :: signed
    if r46 goto L21 else goto L43 :: bool
L21:
    r47 = r42 >> 1
    r48 = get_element_ptr r16 ob_item :: PyListObject
    r49 = load_mem r48 :: ptr*
    r50 = r47 * 8
    r51 = r49 + r50
    r52 = load_mem r51 :: builtins.object*
    inc_ref r52
    r53 = unbox(int, r52)
    dec_ref r52
    if is_error(r53) goto L44 (error at __encode_elements_new:230) else goto L22
L22:
    r54 = CPyTagged_Add(r15, r53)
    dec_ref r53 :: int
    r55 = _encode_uint_256(r54)
    dec_ref r54 :: int
    if is_error(r55) goto L44 (error at __encode_elements_new:230) else goto L23
L23:
    r56 = CPyList_SetItemUnsafe(r41, r42, r55)
    if not r56 goto L44 (error at __encode_elements_new:230) else goto L24 :: bool
L24:
    r57 = r42 + 2
    r42 = r57
    goto L20
L25:
    r58 = PyObject_GetIter(r41)
    dec_ref r41
    if is_error(r58) goto L45 (error at __encode_elements_new:230) else goto L26
L26:
    r59 = b''
    r60 = PyList_New(0)
    if is_error(r60) goto L46 (error at __encode_elements_new:231) else goto L27
L27:
    r61 = CPyList_Extend(r60, r58)
    dec_ref r58
    if is_error(r61) goto L47 (error at __encode_elements_new:231) else goto L48
L28:
    r62 = CPyList_Extend(r60, r0)
    dec_ref r0
    if is_error(r62) goto L49 (error at __encode_elements_new:231) else goto L50
L29:
    r63 = PyList_AsTuple(r60)
    dec_ref r60
    if is_error(r63) goto L51 (error at __encode_elements_new:231) else goto L30
L30:
    r64 = CPyBytes_Join(r59, r63)
    dec_ref r63
    if is_error(r64) goto L51 (error at __encode_elements_new:231) else goto L31
L31:
    r65 = (r64, count)
    return r65
L32:
    r66 = <error> :: tuple[bytes, int]
    return r66
L33:
    dec_ref r0
    goto L32
L34:
    dec_ref r1
    goto L9
L35:
    dec_ref r0
    dec_ref r1
    goto L32
L36:
    dec_ref r0
    dec_ref r1
    dec_ref r3
    goto L5
L37:
    dec_ref r0
    dec_ref r1
    dec_ref r3
    goto L32
L38:
    dec_ref r0
    dec_ref count :: int
    dec_ref r15 :: int
    goto L32
L39:
    dec_ref r0
    dec_ref count :: int
    dec_ref r15 :: int
    dec_ref r16
    dec_ref offset :: int
    goto L32
L40:
    dec_ref offset :: int
    dec_ref r21
    goto L18
L41:
    dec_ref r0
    dec_ref count :: int
    dec_ref r15 :: int
    dec_ref r16
    dec_ref offset :: int
    dec_ref r21
    goto L32
L42:
    dec_ref r0
    dec_ref count :: int
    dec_ref r15 :: int
    dec_ref r16
    goto L32
L43:
    dec_ref r15 :: int
    dec_ref r16
    goto L25
L44:
    dec_ref r0
    dec_ref count :: int
    dec_ref r15 :: int
    dec_ref r16
    dec_ref r41
    goto L32
L45:
    dec_ref r0
    dec_ref count :: int
    goto L32
L46:
    dec_ref r0
    dec_ref count :: int
    dec_ref r58
    goto L32
L47:
    dec_ref r0
    dec_ref count :: int
    dec_ref r60
    goto L32
L48:
    dec_ref r61
    goto L28
L49:
    dec_ref count :: int
    dec_ref r60
    goto L32
L50:
    dec_ref r62
    goto L29
L51:
    dec_ref count :: int
    goto L32

def mcall_encode(data):
    data :: object
    r0 :: tuple[bool, object]
    r1 :: object
    r2 :: bool
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7, r8 :: bytes
L0:
    inc_ref data
    r0 = (0, data)
    r1 = dank_mids.helpers._codec._mcall_encoder :: static
    if is_error(r1) goto L7 else goto L3
L1:
    r2 = raise NameError('value for final name "_mcall_encoder" was not set')
    if not r2 goto L6 (error at mcall_encode:244) else goto L2 :: bool
L2:
    unreachable
L3:
    r3 = box(tuple[bool, object], r0)
    r4 = [r3]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r1, r5, 1, 0)
    if is_error(r6) goto L8 (error at mcall_encode:244) else goto L4
L4:
    dec_ref r3
    r7 = cast(bytes, r6)
    if is_error(r7) goto L6 (error at mcall_encode:244) else goto L5
L5:
    return r7
L6:
    r8 = <error> :: bytes
    return r8
L7:
    dec_ref r0
    goto L1
L8:
    dec_ref r3
    goto L6

def mcall_decode(data):
    data :: object
    r0, r1 :: str
    r2 :: object[2]
    r3 :: object_ptr
    r4, r5 :: object
    r6 :: bool
    r7 :: object[1]
    r8 :: object_ptr
    r9, r10 :: object
    r11 :: bool
    r12 :: object[1]
    r13 :: object_ptr
    r14 :: object
    r15 :: tuple[int, int, tuple]
    r16 :: tuple
    r17 :: tuple[object, object, object]
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: bit
    r22 :: object
    r23 :: dict
    r24 :: str
    r25, r26 :: object
    r27 :: bit
    r28 :: None
    r29 :: str
    r30 :: object
    r31 :: tuple
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: i32
    r36 :: bit
    r37 :: bool
    r38 :: str
    r39 :: object[1]
    r40 :: object_ptr
    r41 :: object
    r42 :: union[object, str]
    r43 :: list
    r44 :: object
    r45 :: i32
    r46 :: bit
    r47 :: tuple
    r48 :: str
    r49 :: i32
    r50, r51 :: bit
    r52 :: ptr
    r53 :: native_int
    r54 :: list
    r55 :: short_int
    r56 :: ptr
    r57 :: native_int
    r58 :: short_int
    r59 :: bit
    r60 :: object
    r61 :: tuple[bool, bytes]
    r62 :: bytes
    r63 :: bit
    r64 :: short_int
    r65 :: union[list, object]
L0:
L1:
    r0 = 'eth_call'
    r1 = 'decode_result'
    r2 = [data, r0]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775810, 0)
    if is_error(r4) goto L12 (error at mcall_decode:253) else goto L2
L2:
    r5 = dank_mids.helpers._codec.ContextFramesBytesIO :: static
    if is_error(r5) goto L44 else goto L5
L3:
    r6 = raise NameError('value for final name "ContextFramesBytesIO" was not set')
    if not r6 goto L12 (error at mcall_decode:253) else goto L4 :: bool
L4:
    unreachable
L5:
    r7 = [r4]
    r8 = load_address r7
    r9 = PyObject_Vectorcall(r5, r8, 1, 0)
    if is_error(r9) goto L45 (error at mcall_decode:253) else goto L6
L6:
    dec_ref r4
    r10 = dank_mids.helpers._codec._mcall_decoder :: static
    if is_error(r10) goto L46 else goto L9
L7:
    r11 = raise NameError('value for final name "_mcall_decoder" was not set')
    if not r11 goto L12 (error at mcall_decode:253) else goto L8 :: bool
L8:
    unreachable
L9:
    r12 = [r9]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r10, r13, 1, 0)
    if is_error(r14) goto L47 (error at mcall_decode:253) else goto L10
L10:
    dec_ref r9
    r15 = unbox(tuple[int, int, tuple], r14)
    dec_ref r14
    if is_error(r15) goto L12 (error at mcall_decode:253) else goto L11
L11:
    r16 = r15[2]
    dec_ref r15
    goto L35
L12:
    r17 = CPy_CatchError()
    r18 = builtins :: module
    r19 = 'Exception'
    r20 = CPyObject_GetAttr(r18, r19)
    if is_error(r20) goto L33 (error at mcall_decode:254) else goto L13
L13:
    r21 = CPy_ExceptionMatches(r20)
    dec_ref r20
    if r21 goto L14 else goto L31 :: bool
L14:
    r22 = CPy_GetExcValue()
    r23 = dank_mids.helpers._codec.globals :: static
    r24 = 'PartialResponse'
    r25 = CPyDict_GetItem(r23, r24)
    if is_error(r25) goto L48 (error at mcall_decode:255) else goto L15
L15:
    r26 = load_address _Py_NoneStruct
    r27 = r25 == r26
    dec_ref r25
    if r27 goto L16 else goto L17 :: bool
L16:
    r28 = __import_from_types()
    if is_error(r28) goto L48 (error at mcall_decode:256) else goto L17
L17:
    r29 = 'args'
    r30 = CPyObject_GetAttr(r22, r29)
    if is_error(r30) goto L48 (error at mcall_decode:258) else goto L18
L18:
    r31 = cast(tuple, r30)
    if is_error(r31) goto L48 (error at mcall_decode:258) else goto L19
L19:
    r32 = dank_mids.helpers._codec.globals :: static
    r33 = 'PartialResponse'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L49 (error at mcall_decode:258) else goto L20
L20:
    r35 = PyObject_IsInstance(data, r34)
    dec_ref r34
    r36 = r35 >= 0 :: signed
    if not r36 goto L49 (error at mcall_decode:258) else goto L21 :: bool
L21:
    r37 = truncate r35: i32 to builtins.bool
    if r37 goto L22 else goto L24 :: bool
L22:
    r38 = 'decode_result'
    r39 = [data]
    r40 = load_address r39
    r41 = PyObject_VectorcallMethod(r38, r40, 9223372036854775809, 0)
    if is_error(r41) goto L49 (error at mcall_decode:258) else goto L23
L23:
    r42 = r41
    goto L25
L24:
    inc_ref data
    r42 = data
L25:
    r43 = PyList_New(0)
    if is_error(r43) goto L50 (error at mcall_decode:258) else goto L26
L26:
    r44 = CPyList_Extend(r43, r31)
    dec_ref r31
    if is_error(r44) goto L51 (error at mcall_decode:258) else goto L52
L27:
    r45 = PyList_Append(r43, r42)
    dec_ref r42
    r46 = r45 >= 0 :: signed
    if not r46 goto L53 (error at mcall_decode:258) else goto L28 :: bool
L28:
    r47 = PyList_AsTuple(r43)
    dec_ref r43
    if is_error(r47) goto L48 (error at mcall_decode:258) else goto L29
L29:
    r48 = 'args'
    r49 = PyObject_SetAttr(r22, r48, r47)
    dec_ref r47
    r50 = r49 >= 0 :: signed
    if not r50 goto L48 (error at mcall_decode:258) else goto L30 :: bool
L30:
    CPy_RestoreExcInfo(r17)
    dec_ref r17
    return r22
L31:
    CPy_Reraise()
    if not 0 goto L33 else goto L54 :: bool
L32:
    unreachable
L33:
    CPy_RestoreExcInfo(r17)
    dec_ref r17
    r51 = CPy_KeepPropagating()
    if not r51 goto L43 else goto L34 :: bool
L34:
    unreachable
L35:
    r52 = get_element_ptr r16 ob_size :: PyVarObject
    r53 = load_mem r52 :: native_int*
    r54 = PyList_New(r53)
    if is_error(r54) goto L55 (error at mcall_decode:261) else goto L36
L36:
    r55 = 0
L37:
    r56 = get_element_ptr r16 ob_size :: PyVarObject
    r57 = load_mem r56 :: native_int*
    r58 = r57 << 1
    r59 = r55 < r58 :: signed
    if r59 goto L38 else goto L56 :: bool
L38:
    r60 = CPySequenceTuple_GetItem(r16, r55)
    if is_error(r60) goto L57 (error at mcall_decode:261) else goto L39
L39:
    r61 = unbox(tuple[bool, bytes], r60)
    dec_ref r60
    if is_error(r61) goto L57 (error at mcall_decode:261) else goto L40
L40:
    r62 = r61[1]
    dec_ref r61
    r63 = CPyList_SetItemUnsafe(r54, r55, r62)
    if not r63 goto L57 (error at mcall_decode:261) else goto L41 :: bool
L41:
    r64 = r55 + 2
    r55 = r64
    goto L37
L42:
    return r54
L43:
    r65 = <error> :: union[list, object]
    return r65
L44:
    dec_ref r4
    goto L3
L45:
    dec_ref r4
    goto L12
L46:
    dec_ref r9
    goto L7
L47:
    dec_ref r9
    goto L12
L48:
    dec_ref r22
    goto L33
L49:
    dec_ref r22
    dec_ref r31
    goto L33
L50:
    dec_ref r22
    dec_ref r31
    dec_ref r42
    goto L33
L51:
    dec_ref r22
    dec_ref r42
    dec_ref r43
    goto L33
L52:
    dec_ref r44
    goto L27
L53:
    dec_ref r22
    dec_ref r43
    goto L33
L54:
    dec_ref r17
    goto L32
L55:
    dec_ref r16
    goto L43
L56:
    dec_ref r16
    goto L42
L57:
    dec_ref r16
    dec_ref r54
    goto L43

def __import_from_types():
    r0 :: object
    r1 :: str
    r2 :: dict
    r3 :: object
    r4 :: None
L0:
    r0 = ('PartialResponse', 'Request', 'Response', 'better_decode')
    r1 = 'dank_mids.types'
    r2 = dank_mids.helpers._codec.globals :: static
    r3 = CPyImport_ImportFromMany(r1, r0, r0, r2)
    if is_error(r3) goto L2 (error at __import_from_types:267) else goto L1
L1:
    dank_mids.types = r3 :: module
    dec_ref r3
    return 1
L2:
    r4 = <error> :: None
    return r4

def __make_decode_batch():
    r0 :: object
    r1 :: str
    r2 :: dict
    r3 :: object
    r4 :: dict
    r5 :: str
    r6 :: object
    r7 :: dict
    r8 :: str
    r9 :: object
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: str
    r14, r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: object
    r19 :: tuple[object, object]
    r20, r21 :: object
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: object[1]
    r26 :: object_ptr
    r27, r28 :: object
    r29 :: str
    r30 :: object
    r31 :: dict
    r32 :: str
    r33 :: i32
    r34 :: bit
    r35 :: None
L0:
    r0 = ('PartialResponse',)
    r1 = 'dank_mids.types'
    r2 = dank_mids.helpers._codec.globals :: static
    r3 = CPyImport_ImportFromMany(r1, r0, r0, r2)
    if is_error(r3) goto L13 (error at __make_decode_batch:271) else goto L1
L1:
    dank_mids.types = r3 :: module
    dec_ref r3
    r4 = dank_mids.helpers._codec.globals :: static
    r5 = 'Union'
    r6 = CPyDict_GetItem(r4, r5)
    if is_error(r6) goto L13 (error at __make_decode_batch:274) else goto L2
L2:
    r7 = dank_mids.helpers._codec.globals :: static
    r8 = 'List'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L14 (error at __make_decode_batch:274) else goto L3
L3:
    r10 = dank_mids.helpers._codec.globals :: static
    r11 = 'msgspec'
    r12 = CPyDict_GetItem(r10, r11)
    if is_error(r12) goto L15 (error at __make_decode_batch:274) else goto L4
L4:
    r13 = 'Raw'
    r14 = CPyObject_GetAttr(r12, r13)
    dec_ref r12
    if is_error(r14) goto L15 (error at __make_decode_batch:274) else goto L5
L5:
    r15 = PyObject_GetItem(r9, r14)
    dec_ref r9
    dec_ref r14
    if is_error(r15) goto L14 (error at __make_decode_batch:274) else goto L6
L6:
    r16 = dank_mids.helpers._codec.globals :: static
    r17 = 'PartialResponse'
    r18 = CPyDict_GetItem(r16, r17)
    if is_error(r18) goto L16 (error at __make_decode_batch:274) else goto L7
L7:
    r19 = (r15, r18)
    r20 = box(tuple[object, object], r19)
    r21 = PyObject_GetItem(r6, r20)
    dec_ref r6
    dec_ref r20
    if is_error(r21) goto L13 (error at __make_decode_batch:274) else goto L8
L8:
    r22 = dank_mids.helpers._codec.globals :: static
    r23 = 'Decoder'
    r24 = CPyDict_GetItem(r22, r23)
    if is_error(r24) goto L17 (error at __make_decode_batch:274) else goto L9
L9:
    r25 = [r21]
    r26 = load_address r25
    r27 = ('type',)
    r28 = PyObject_Vectorcall(r24, r26, 0, r27)
    dec_ref r24
    if is_error(r28) goto L17 (error at __make_decode_batch:274) else goto L10
L10:
    dec_ref r21
    r29 = 'decode'
    r30 = CPyObject_GetAttr(r28, r29)
    dec_ref r28
    if is_error(r30) goto L13 (error at __make_decode_batch:274) else goto L11
L11:
    r31 = dank_mids.helpers._codec.globals :: static
    r32 = '_decode_batch'
    r33 = CPyDict_SetItem(r31, r32, r30)
    dec_ref r30
    r34 = r33 >= 0 :: signed
    if not r34 goto L13 (error at __make_decode_batch:274) else goto L12 :: bool
L12:
    return 1
L13:
    r35 = <error> :: None
    return r35
L14:
    dec_ref r6
    goto L13
L15:
    dec_ref r6
    dec_ref r9
    goto L13
L16:
    dec_ref r6
    dec_ref r15
    goto L13
L17:
    dec_ref r21
    goto L13

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9, r10 :: object_ptr
    r11 :: object_ptr[2]
    r12 :: c_ptr
    r13 :: native_int[2]
    r14 :: c_ptr
    r15 :: object
    r16 :: dict
    r17, r18 :: str
    r19 :: bit
    r20 :: object
    r21 :: str
    r22 :: dict
    r23, r24 :: object
    r25 :: str
    r26 :: dict
    r27, r28 :: object
    r29 :: str
    r30 :: dict
    r31, r32 :: object
    r33 :: str
    r34 :: dict
    r35, r36 :: object
    r37 :: str
    r38 :: dict
    r39 :: object
    r40 :: dict
    r41 :: str
    r42 :: object
    r43 :: i32
    r44 :: bit
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: i32
    r49 :: bit
    r50 :: dict
    r51 :: str
    r52 :: object
    r53 :: i32
    r54 :: bit
    r55 :: dict
    r56 :: str
    r57 :: object
    r58 :: i32
    r59 :: bit
    r60 :: str
    r61 :: dict
    r62 :: str
    r63 :: object
    r64 :: object[1]
    r65 :: object_ptr
    r66 :: object
    r67 :: dict
    r68 :: str
    r69 :: i32
    r70 :: bit
    r71 :: dict
    r72 :: str
    r73 :: object
    r74 :: dict
    r75 :: str
    r76 :: object
    r77 :: dict
    r78 :: str
    r79 :: object
    r80 :: tuple[object, object]
    r81, r82 :: object
    r83 :: dict
    r84 :: str
    r85 :: i32
    r86 :: bit
    r87 :: dict
    r88 :: str
    r89, r90 :: object
    r91 :: dict
    r92 :: str
    r93 :: object
    r94 :: dict
    r95 :: str
    r96 :: object
    r97 :: str
    r98, r99 :: object
    r100 :: tuple[object, object, object, object]
    r101, r102 :: object
    r103 :: dict
    r104 :: str
    r105 :: i32
    r106 :: bit
    r107 :: dict
    r108 :: str
    r109 :: object
    r110 :: dict
    r111 :: str
    r112 :: object
    r113 :: dict
    r114 :: str
    r115 :: object
    r116 :: dict
    r117 :: str
    r118, r119 :: object
    r120 :: dict
    r121 :: str
    r122, r123 :: object
    r124 :: dict
    r125 :: str
    r126 :: object
    r127 :: tuple[object, object]
    r128, r129 :: object
    r130 :: tuple[object, object, object]
    r131, r132 :: object
    r133 :: dict
    r134 :: str
    r135 :: i32
    r136 :: bit
    r137 :: dict
    r138 :: str
    r139 :: object
    r140 :: dict
    r141 :: str
    r142 :: object
    r143 :: dict
    r144 :: str
    r145 :: object
    r146 :: dict
    r147 :: str
    r148 :: object
    r149 :: str
    r150 :: object
    r151 :: tuple[object, object]
    r152, r153 :: object
    r154 :: dict
    r155 :: str
    r156 :: object
    r157 :: dict
    r158 :: str
    r159 :: object
    r160 :: dict
    r161 :: str
    r162 :: object
    r163 :: dict
    r164 :: str
    r165 :: object
    r166 :: str
    r167 :: object
    r168 :: tuple[object, object]
    r169, r170, r171 :: object
    r172 :: tuple[object, object]
    r173, r174 :: object
    r175 :: dict
    r176 :: str
    r177 :: i32
    r178 :: bit
    r179 :: dict
    r180 :: str
    r181 :: object
    r182 :: dict
    r183 :: str
    r184, r185 :: object
    r186 :: dict
    r187 :: str
    r188 :: object
    r189 :: dict
    r190 :: str
    r191, r192 :: object
    r193 :: tuple[object, object]
    r194, r195 :: object
    r196 :: list
    r197, r198 :: ptr
    r199 :: object
    r200 :: tuple[list, object]
    r201, r202 :: object
    r203 :: dict
    r204 :: str
    r205 :: i32
    r206 :: bit
    r207 :: dict
    r208 :: str
    r209, r210, r211 :: object
    r212 :: dict
    r213 :: str
    r214 :: object
    r215 :: dict
    r216 :: str
    r217 :: object
    r218 :: str
    r219 :: object
    r220 :: tuple[str, object]
    r221, r222, r223 :: object
    r224 :: tuple[object, object]
    r225, r226 :: object
    r227 :: tuple[object, object, object]
    r228, r229 :: object
    r230 :: dict
    r231 :: str
    r232 :: i32
    r233 :: bit
    r234 :: dict
    r235 :: str
    r236, r237 :: object
    r238 :: dict
    r239 :: str
    r240 :: object
    r241 :: tuple[object, object]
    r242, r243 :: object
    r244 :: dict
    r245 :: str
    r246 :: i32
    r247 :: bit
    r248 :: dict
    r249 :: str
    r250 :: object
    r251 :: str
    r252 :: object
    r253 :: dict
    r254 :: str
    r255 :: i32
    r256 :: bit
    r257 :: dict
    r258 :: str
    r259 :: object
    r260 :: dict
    r261 :: str
    r262 :: object
    r263 :: str
    r264 :: object
    r265 :: str
    r266 :: tuple[object, str]
    r267, r268 :: object
    r269 :: dict
    r270 :: str
    r271 :: i32
    r272 :: bit
    r273 :: dict
    r274 :: str
    r275 :: object
    r276 :: dict
    r277 :: str
    r278, r279, r280 :: object
    r281 :: tuple[object, object]
    r282, r283 :: object
    r284 :: list
    r285, r286 :: ptr
    r287 :: dict
    r288 :: str
    r289 :: object
    r290 :: dict
    r291 :: str
    r292 :: object
    r293 :: dict
    r294 :: str
    r295 :: object
    r296 :: str
    r297, r298 :: object
    r299 :: str
    r300 :: tuple[object, str]
    r301, r302 :: object
    r303 :: tuple[list, object]
    r304, r305 :: object
    r306 :: dict
    r307 :: str
    r308 :: i32
    r309 :: bit
    r310 :: dict
    r311 :: str
    r312 :: object
    r313 :: str
    r314 :: object
    r315 :: dict
    r316 :: str
    r317 :: i32
    r318 :: bit
    r319 :: dict
    r320 :: str
    r321 :: object
    r322 :: str
    r323 :: object
    r324 :: dict
    r325 :: str
    r326 :: i32
    r327 :: bit
    r328 :: dict
    r329 :: str
    r330 :: object
    r331 :: str
    r332 :: object
    r333 :: dict
    r334 :: str
    r335 :: i32
    r336 :: bit
    r337 :: dict
    r338 :: str
    r339 :: object
    r340 :: str
    r341 :: object
    r342 :: dict
    r343 :: str
    r344 :: i32
    r345 :: bit
    r346 :: object
    r347 :: dict
    r348 :: str
    r349 :: object
    r350 :: object[1]
    r351 :: object_ptr
    r352, r353 :: object
    r354 :: str
    r355 :: object
    r356 :: dict
    r357 :: str
    r358 :: i32
    r359 :: bit
    r360 :: object
    r361 :: bool
    r362 :: dict
    r363 :: str
    r364 :: object
    r365 :: object[1]
    r366 :: object_ptr
    r367, r368 :: object
    r369 :: str
    r370 :: object
    r371 :: dict
    r372 :: str
    r373 :: i32
    r374 :: bit
    r375 :: dict
    r376 :: str
    r377 :: object
    r378 :: i32
    r379 :: bit
    r380 :: object
    r381 :: str
    r382, r383 :: object
    r384 :: bool
    r385, r386 :: str
    r387 :: tuple
    r388 :: i32
    r389 :: bit
    r390 :: dict
    r391 :: str
    r392 :: i32
    r393 :: bit
    r394 :: dict
    r395 :: str
    r396 :: object
    r397 :: dict
    r398 :: str
    r399 :: object
    r400 :: object[1]
    r401 :: object_ptr
    r402, r403 :: object
    r404 :: str
    r405 :: object
    r406 :: dict
    r407 :: str
    r408 :: i32
    r409 :: bit
    r410 :: dict
    r411 :: str
    r412 :: object
    r413 :: str
    r414 :: object
    r415, r416 :: str
    r417 :: object[2]
    r418 :: object_ptr
    r419 :: object
    r420 :: dict
    r421 :: str
    r422 :: i32
    r423 :: bit
    r424 :: object
    r425 :: bool
    r426 :: str
    r427, r428, r429 :: object
    r430 :: dict
    r431 :: str
    r432 :: i32
    r433 :: bit
    r434 :: object
    r435 :: bool
    r436 :: str
    r437 :: object
    r438 :: dict
    r439 :: str
    r440 :: i32
    r441 :: bit
    r442 :: dank_mids.helpers._codec.__mypyc_lambda__0_obj
    r443 :: object
    r444 :: bool
    r445 :: str
    r446 :: i32
    r447 :: bit
    r448 :: object
    r449 :: bool
    r450 :: str
    r451 :: i32
    r452 :: bit
    r453 :: object
    r454 :: bool
    r455 :: str
    r456 :: i32
    r457 :: bit
    r458 :: dict
    r459 :: str
    r460, r461 :: object
    r462 :: bool
    r463 :: str
    r464 :: i32
    r465 :: bit
    r466 :: dict
    r467 :: str
    r468, r469 :: object
    r470 :: bool
    r471 :: str
    r472 :: i32
    r473 :: bit
    r474 :: dict
    r475 :: str
    r476 :: object
    r477 :: str
    r478 :: object
    r479, r480 :: str
    r481 :: object[2]
    r482 :: object_ptr
    r483 :: object
    r484 :: str
    r485 :: object
    r486 :: dict
    r487 :: str
    r488 :: i32
    r489 :: bit
    r490 :: object
    r491 :: dict
    r492 :: str
    r493 :: i32
    r494 :: bit
    r495 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L173 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Any', 'AnyStr', 'Callable', 'Dict', 'Final', 'Iterable', 'List', 'Literal', 'Mapping', 'Optional', 'Union', 'Tuple', 'Type', 'TypeVar', 'Union', 'final', 'overload')
    r6 = 'typing'
    r7 = dank_mids.helpers._codec.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L173 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address hexbytes :: module
    r10 = load_address msgspec :: module
    r11 = [r9, r10]
    r12 = load_address r11
    r13 = [22, 23]
    r14 = load_address r13
    r15 = (('hexbytes', 'hexbytes', 'hexbytes'), ('msgspec', 'msgspec', 'msgspec'))
    r16 = dank_mids.helpers._codec.globals :: static
    r17 = 'dank_mids\\helpers\\_codec.py'
    r18 = '<module>'
    r19 = CPyImport_ImportMany(r15, r12, r16, r17, r18, r14)
    if not r19 goto L173 else goto L5 :: bool
L5:
    r20 = ('decoding',)
    r21 = 'eth_abi'
    r22 = dank_mids.helpers._codec.globals :: static
    r23 = CPyImport_ImportFromMany(r21, r20, r20, r22)
    if is_error(r23) goto L173 (error at <module>:24) else goto L6
L6:
    eth_abi = r23 :: module
    dec_ref r23
    r24 = ('default_codec',)
    r25 = 'eth_abi.abi'
    r26 = dank_mids.helpers._codec.globals :: static
    r27 = CPyImport_ImportFromMany(r25, r24, r24, r26)
    if is_error(r27) goto L173 (error at <module>:25) else goto L7
L7:
    eth_abi.abi = r27 :: module
    dec_ref r27
    r28 = ('DynamicArrayEncoder', 'TupleEncoder')
    r29 = 'eth_abi.encoding'
    r30 = dank_mids.helpers._codec.globals :: static
    r31 = CPyImport_ImportFromMany(r29, r28, r28, r30)
    if is_error(r31) goto L173 (error at <module>:26) else goto L8
L8:
    eth_abi.encoding = r31 :: module
    dec_ref r31
    r32 = ('ChecksumAddress', 'HexStr')
    r33 = 'eth_typing'
    r34 = dank_mids.helpers._codec.globals :: static
    r35 = CPyImport_ImportFromMany(r33, r32, r32, r34)
    if is_error(r35) goto L173 (error at <module>:27) else goto L9
L9:
    eth_typing = r35 :: module
    dec_ref r35
    r36 = ('Decoder', 'Encoder')
    r37 = 'msgspec.json'
    r38 = dank_mids.helpers._codec.globals :: static
    r39 = CPyImport_ImportFromMany(r37, r36, r36, r38)
    if is_error(r39) goto L173 (error at <module>:28) else goto L10
L10:
    msgspec.json = r39 :: module
    dec_ref r39
    if 0 goto L11 else goto L11 :: bool
L11:
    r40 = dank_mids.helpers._codec.globals :: static
    r41 = 'PartialResponse'
    r42 = box(None, 1)
    r43 = CPyDict_SetItem(r40, r41, r42)
    r44 = r43 >= 0 :: signed
    if not r44 goto L173 (error at <module>:35) else goto L12 :: bool
L12:
    r45 = dank_mids.helpers._codec.globals :: static
    r46 = 'Request'
    r47 = box(None, 1)
    r48 = CPyDict_SetItem(r45, r46, r47)
    r49 = r48 >= 0 :: signed
    if not r49 goto L173 (error at <module>:36) else goto L13 :: bool
L13:
    r50 = dank_mids.helpers._codec.globals :: static
    r51 = 'Response'
    r52 = box(None, 1)
    r53 = CPyDict_SetItem(r50, r51, r52)
    r54 = r53 >= 0 :: signed
    if not r54 goto L173 (error at <module>:37) else goto L14 :: bool
L14:
    r55 = dank_mids.helpers._codec.globals :: static
    r56 = 'better_decode'
    r57 = box(None, 1)
    r58 = CPyDict_SetItem(r55, r56, r57)
    r59 = r58 >= 0 :: signed
    if not r59 goto L173 (error at <module>:38) else goto L15 :: bool
L15:
    r60 = '__T'
    r61 = dank_mids.helpers._codec.globals :: static
    r62 = 'TypeVar'
    r63 = CPyDict_GetItem(r61, r62)
    if is_error(r63) goto L173 (error at <module>:41) else goto L16
L16:
    r64 = [r60]
    r65 = load_address r64
    r66 = PyObject_Vectorcall(r63, r65, 1, 0)
    dec_ref r63
    if is_error(r66) goto L173 (error at <module>:41) else goto L17
L17:
    r67 = dank_mids.helpers._codec.globals :: static
    r68 = '__T'
    r69 = CPyDict_SetItem(r67, r68, r66)
    dec_ref r66
    r70 = r69 >= 0 :: signed
    if not r70 goto L173 (error at <module>:41) else goto L18 :: bool
L18:
    r71 = dank_mids.helpers._codec.globals :: static
    r72 = 'Union'
    r73 = CPyDict_GetItem(r71, r72)
    if is_error(r73) goto L173 (error at <module>:44) else goto L19
L19:
    r74 = dank_mids.helpers._codec.globals :: static
    r75 = 'ChecksumAddress'
    r76 = CPyDict_GetItem(r74, r75)
    if is_error(r76) goto L174 (error at <module>:44) else goto L20
L20:
    r77 = dank_mids.helpers._codec.globals :: static
    r78 = 'HexStr'
    r79 = CPyDict_GetItem(r77, r78)
    if is_error(r79) goto L175 (error at <module>:44) else goto L21
L21:
    r80 = (r76, r79)
    r81 = box(tuple[object, object], r80)
    r82 = PyObject_GetItem(r73, r81)
    dec_ref r73
    dec_ref r81
    if is_error(r82) goto L173 (error at <module>:44) else goto L22
L22:
    r83 = dank_mids.helpers._codec.globals :: static
    r84 = 'StrEncodable'
    r85 = CPyDict_SetItem(r83, r84, r82)
    dec_ref r82
    r86 = r85 >= 0 :: signed
    if not r86 goto L173 (error at <module>:44) else goto L23 :: bool
L23:
    r87 = dank_mids.helpers._codec.globals :: static
    r88 = 'Union'
    r89 = CPyDict_GetItem(r87, r88)
    if is_error(r89) goto L173 (error at <module>:45) else goto L24
L24:
    r90 = load_address PyLong_Type
    r91 = dank_mids.helpers._codec.globals :: static
    r92 = 'StrEncodable'
    r93 = CPyDict_GetItem(r91, r92)
    if is_error(r93) goto L176 (error at <module>:45) else goto L25
L25:
    r94 = dank_mids.helpers._codec.globals :: static
    r95 = 'hexbytes'
    r96 = CPyDict_GetItem(r94, r95)
    if is_error(r96) goto L177 (error at <module>:45) else goto L26
L26:
    r97 = 'HexBytes'
    r98 = CPyObject_GetAttr(r96, r97)
    dec_ref r96
    if is_error(r98) goto L177 (error at <module>:45) else goto L27
L27:
    r99 = load_address PyBytes_Type
    inc_ref r90
    inc_ref r99
    r100 = (r90, r93, r98, r99)
    r101 = box(tuple[object, object, object, object], r100)
    r102 = PyObject_GetItem(r89, r101)
    dec_ref r89
    dec_ref r101
    if is_error(r102) goto L173 (error at <module>:45) else goto L28
L28:
    r103 = dank_mids.helpers._codec.globals :: static
    r104 = 'Encodable'
    r105 = CPyDict_SetItem(r103, r104, r102)
    dec_ref r102
    r106 = r105 >= 0 :: signed
    if not r106 goto L173 (error at <module>:45) else goto L29 :: bool
L29:
    r107 = dank_mids.helpers._codec.globals :: static
    r108 = 'Union'
    r109 = CPyDict_GetItem(r107, r108)
    if is_error(r109) goto L173 (error at <module>:47) else goto L30
L30:
    r110 = dank_mids.helpers._codec.globals :: static
    r111 = 'HexStr'
    r112 = CPyDict_GetItem(r110, r111)
    if is_error(r112) goto L178 (error at <module>:47) else goto L31
L31:
    r113 = dank_mids.helpers._codec.globals :: static
    r114 = 'List'
    r115 = CPyDict_GetItem(r113, r114)
    if is_error(r115) goto L179 (error at <module>:47) else goto L32
L32:
    r116 = dank_mids.helpers._codec.globals :: static
    r117 = 'HexStr'
    r118 = CPyDict_GetItem(r116, r117)
    if is_error(r118) goto L180 (error at <module>:47) else goto L33
L33:
    r119 = PyObject_GetItem(r115, r118)
    dec_ref r115
    dec_ref r118
    if is_error(r119) goto L179 (error at <module>:47) else goto L34
L34:
    r120 = dank_mids.helpers._codec.globals :: static
    r121 = 'Dict'
    r122 = CPyDict_GetItem(r120, r121)
    if is_error(r122) goto L181 (error at <module>:47) else goto L35
L35:
    r123 = load_address PyUnicode_Type
    r124 = dank_mids.helpers._codec.globals :: static
    r125 = 'HexStr'
    r126 = CPyDict_GetItem(r124, r125)
    if is_error(r126) goto L182 (error at <module>:47) else goto L36
L36:
    inc_ref r123
    r127 = (r123, r126)
    r128 = box(tuple[object, object], r127)
    r129 = PyObject_GetItem(r122, r128)
    dec_ref r122
    dec_ref r128
    if is_error(r129) goto L181 (error at <module>:47) else goto L37
L37:
    r130 = (r112, r119, r129)
    r131 = box(tuple[object, object, object], r130)
    r132 = PyObject_GetItem(r109, r131)
    dec_ref r109
    dec_ref r131
    if is_error(r132) goto L173 (error at <module>:47) else goto L38
L38:
    r133 = dank_mids.helpers._codec.globals :: static
    r134 = 'RpcThing'
    r135 = CPyDict_SetItem(r133, r134, r132)
    dec_ref r132
    r136 = r135 >= 0 :: signed
    if not r136 goto L173 (error at <module>:47) else goto L39 :: bool
L39:
    r137 = dank_mids.helpers._codec.globals :: static
    r138 = 'Union'
    r139 = CPyDict_GetItem(r137, r138)
    if is_error(r139) goto L173 (error at <module>:50) else goto L40
L40:
    r140 = dank_mids.helpers._codec.globals :: static
    r141 = 'Tuple'
    r142 = CPyDict_GetItem(r140, r141)
    if is_error(r142) goto L183 (error at <module>:51) else goto L41
L41:
    r143 = dank_mids.helpers._codec.globals :: static
    r144 = 'ChecksumAddress'
    r145 = CPyDict_GetItem(r143, r144)
    if is_error(r145) goto L184 (error at <module>:51) else goto L42
L42:
    r146 = dank_mids.helpers._codec.globals :: static
    r147 = 'hexbytes'
    r148 = CPyDict_GetItem(r146, r147)
    if is_error(r148) goto L185 (error at <module>:51) else goto L43
L43:
    r149 = 'HexBytes'
    r150 = CPyObject_GetAttr(r148, r149)
    dec_ref r148
    if is_error(r150) goto L185 (error at <module>:51) else goto L44
L44:
    r151 = (r145, r150)
    r152 = box(tuple[object, object], r151)
    r153 = PyObject_GetItem(r142, r152)
    dec_ref r142
    dec_ref r152
    if is_error(r153) goto L183 (error at <module>:51) else goto L45
L45:
    r154 = dank_mids.helpers._codec.globals :: static
    r155 = 'List'
    r156 = CPyDict_GetItem(r154, r155)
    if is_error(r156) goto L186 (error at <module>:52) else goto L46
L46:
    r157 = dank_mids.helpers._codec.globals :: static
    r158 = 'Union'
    r159 = CPyDict_GetItem(r157, r158)
    if is_error(r159) goto L187 (error at <module>:52) else goto L47
L47:
    r160 = dank_mids.helpers._codec.globals :: static
    r161 = 'ChecksumAddress'
    r162 = CPyDict_GetItem(r160, r161)
    if is_error(r162) goto L188 (error at <module>:52) else goto L48
L48:
    r163 = dank_mids.helpers._codec.globals :: static
    r164 = 'hexbytes'
    r165 = CPyDict_GetItem(r163, r164)
    if is_error(r165) goto L189 (error at <module>:52) else goto L49
L49:
    r166 = 'HexBytes'
    r167 = CPyObject_GetAttr(r165, r166)
    dec_ref r165
    if is_error(r167) goto L189 (error at <module>:52) else goto L50
L50:
    r168 = (r162, r167)
    r169 = box(tuple[object, object], r168)
    r170 = PyObject_GetItem(r159, r169)
    dec_ref r159
    dec_ref r169
    if is_error(r170) goto L187 (error at <module>:52) else goto L51
L51:
    r171 = PyObject_GetItem(r156, r170)
    dec_ref r156
    dec_ref r170
    if is_error(r171) goto L186 (error at <module>:52) else goto L52
L52:
    r172 = (r153, r171)
    r173 = box(tuple[object, object], r172)
    r174 = PyObject_GetItem(r139, r173)
    dec_ref r139
    dec_ref r173
    if is_error(r174) goto L173 (error at <module>:50) else goto L53
L53:
    r175 = dank_mids.helpers._codec.globals :: static
    r176 = 'MulticallChunk'
    r177 = CPyDict_SetItem(r175, r176, r174)
    dec_ref r174
    r178 = r177 >= 0 :: signed
    if not r178 goto L173 (error at <module>:50) else goto L54 :: bool
L54:
    r179 = dank_mids.helpers._codec.globals :: static
    r180 = 'Callable'
    r181 = CPyDict_GetItem(r179, r180)
    if is_error(r181) goto L173 (error at <module>:54) else goto L55
L55:
    r182 = dank_mids.helpers._codec.globals :: static
    r183 = 'Tuple'
    r184 = CPyDict_GetItem(r182, r183)
    if is_error(r184) goto L190 (error at <module>:54) else goto L56
L56:
    r185 = load_address PyBool_Type
    r186 = dank_mids.helpers._codec.globals :: static
    r187 = 'Iterable'
    r188 = CPyDict_GetItem(r186, r187)
    if is_error(r188) goto L191 (error at <module>:54) else goto L57
L57:
    r189 = dank_mids.helpers._codec.globals :: static
    r190 = 'MulticallChunk'
    r191 = CPyDict_GetItem(r189, r190)
    if is_error(r191) goto L192 (error at <module>:54) else goto L58
L58:
    r192 = PyObject_GetItem(r188, r191)
    dec_ref r188
    dec_ref r191
    if is_error(r192) goto L191 (error at <module>:54) else goto L59
L59:
    inc_ref r185
    r193 = (r185, r192)
    r194 = box(tuple[object, object], r193)
    r195 = PyObject_GetItem(r184, r194)
    dec_ref r184
    dec_ref r194
    if is_error(r195) goto L190 (error at <module>:54) else goto L60
L60:
    r196 = PyList_New(1)
    if is_error(r196) goto L193 (error at <module>:54) else goto L61
L61:
    r197 = get_element_ptr r196 ob_item :: PyListObject
    r198 = load_mem r197 :: ptr*
    set_mem r198, r195 :: builtins.object*
    r199 = load_address PyBytes_Type
    inc_ref r199
    r200 = (r196, r199)
    r201 = box(tuple[list, object], r200)
    r202 = PyObject_GetItem(r181, r201)
    dec_ref r181
    dec_ref r201
    if is_error(r202) goto L173 (error at <module>:54) else goto L62
L62:
    r203 = dank_mids.helpers._codec.globals :: static
    r204 = 'MulticallEncoder'
    r205 = CPyDict_SetItem(r203, r204, r202)
    dec_ref r202
    r206 = r205 >= 0 :: signed
    if not r206 goto L173 (error at <module>:54) else goto L63 :: bool
L63:
    r207 = dank_mids.helpers._codec.globals :: static
    r208 = 'Tuple'
    r209 = CPyDict_GetItem(r207, r208)
    if is_error(r209) goto L173 (error at <module>:56) else goto L64
L64:
    r210 = load_address PyLong_Type
    r211 = load_address PyLong_Type
    r212 = dank_mids.helpers._codec.globals :: static
    r213 = 'Tuple'
    r214 = CPyDict_GetItem(r212, r213)
    if is_error(r214) goto L194 (error at <module>:56) else goto L65
L65:
    r215 = dank_mids.helpers._codec.globals :: static
    r216 = 'Tuple'
    r217 = CPyDict_GetItem(r215, r216)
    if is_error(r217) goto L195 (error at <module>:56) else goto L66
L66:
    r218 = 'Success'
    r219 = load_address PyBytes_Type
    inc_ref r218
    inc_ref r219
    r220 = (r218, r219)
    r221 = box(tuple[str, object], r220)
    r222 = PyObject_GetItem(r217, r221)
    dec_ref r217
    dec_ref r221
    if is_error(r222) goto L195 (error at <module>:56) else goto L67
L67:
    r223 = load_address _Py_EllipsisObject
    inc_ref r223
    r224 = (r222, r223)
    r225 = box(tuple[object, object], r224)
    r226 = PyObject_GetItem(r214, r225)
    dec_ref r214
    dec_ref r225
    if is_error(r226) goto L194 (error at <module>:56) else goto L68
L68:
    inc_ref r210
    inc_ref r211
    r227 = (r210, r211, r226)
    r228 = box(tuple[object, object, object], r227)
    r229 = PyObject_GetItem(r209, r228)
    dec_ref r209
    dec_ref r228
    if is_error(r229) goto L173 (error at <module>:56) else goto L69
L69:
    r230 = dank_mids.helpers._codec.globals :: static
    r231 = 'DecodedMulticall'
    r232 = CPyDict_SetItem(r230, r231, r229)
    dec_ref r229
    r233 = r232 >= 0 :: signed
    if not r233 goto L173 (error at <module>:56) else goto L70 :: bool
L70:
    r234 = dank_mids.helpers._codec.globals :: static
    r235 = 'Callable'
    r236 = CPyDict_GetItem(r234, r235)
    if is_error(r236) goto L173 (error at <module>:57) else goto L71
L71:
    r237 = load_address _Py_EllipsisObject
    r238 = dank_mids.helpers._codec.globals :: static
    r239 = 'DecodedMulticall'
    r240 = CPyDict_GetItem(r238, r239)
    if is_error(r240) goto L196 (error at <module>:57) else goto L72
L72:
    inc_ref r237
    r241 = (r237, r240)
    r242 = box(tuple[object, object], r241)
    r243 = PyObject_GetItem(r236, r242)
    dec_ref r236
    dec_ref r242
    if is_error(r243) goto L173 (error at <module>:57) else goto L73
L73:
    r244 = dank_mids.helpers._codec.globals :: static
    r245 = 'MulticallDecoder'
    r246 = CPyDict_SetItem(r244, r245, r243)
    dec_ref r243
    r247 = r246 >= 0 :: signed
    if not r247 goto L173 (error at <module>:57) else goto L74 :: bool
L74:
    r248 = dank_mids.helpers._codec.globals :: static
    r249 = 'List'
    r250 = CPyDict_GetItem(r248, r249)
    if is_error(r250) goto L173 (error at <module>:60) else goto L75
L75:
    r251 = 'types.Request'
    r252 = PyObject_GetItem(r250, r251)
    dec_ref r250
    if is_error(r252) goto L173 (error at <module>:60) else goto L76
L76:
    r253 = dank_mids.helpers._codec.globals :: static
    r254 = 'JSONRPCBatchRequest'
    r255 = CPyDict_SetItem(r253, r254, r252)
    dec_ref r252
    r256 = r255 >= 0 :: signed
    if not r256 goto L173 (error at <module>:60) else goto L77 :: bool
L77:
    r257 = dank_mids.helpers._codec.globals :: static
    r258 = 'Union'
    r259 = CPyDict_GetItem(r257, r258)
    if is_error(r259) goto L173 (error at <module>:62) else goto L78
L78:
    r260 = dank_mids.helpers._codec.globals :: static
    r261 = 'List'
    r262 = CPyDict_GetItem(r260, r261)
    if is_error(r262) goto L197 (error at <module>:62) else goto L79
L79:
    r263 = 'RawResponse'
    r264 = PyObject_GetItem(r262, r263)
    dec_ref r262
    if is_error(r264) goto L197 (error at <module>:62) else goto L80
L80:
    r265 = 'types.PartialResponse'
    inc_ref r265
    r266 = (r264, r265)
    r267 = box(tuple[object, str], r266)
    r268 = PyObject_GetItem(r259, r267)
    dec_ref r259
    dec_ref r267
    if is_error(r268) goto L173 (error at <module>:62) else goto L81
L81:
    r269 = dank_mids.helpers._codec.globals :: static
    r270 = 'JSONRPCBatchResponse'
    r271 = CPyDict_SetItem(r269, r270, r268)
    dec_ref r268
    r272 = r271 >= 0 :: signed
    if not r272 goto L173 (error at <module>:62) else goto L82 :: bool
L82:
    r273 = dank_mids.helpers._codec.globals :: static
    r274 = 'Callable'
    r275 = CPyDict_GetItem(r273, r274)
    if is_error(r275) goto L173 (error at <module>:63) else goto L83
L83:
    r276 = dank_mids.helpers._codec.globals :: static
    r277 = 'Union'
    r278 = CPyDict_GetItem(r276, r277)
    if is_error(r278) goto L198 (error at <module>:63) else goto L84
L84:
    r279 = load_address PyUnicode_Type
    r280 = load_address PyBytes_Type
    inc_ref r279
    inc_ref r280
    r281 = (r279, r280)
    r282 = box(tuple[object, object], r281)
    r283 = PyObject_GetItem(r278, r282)
    dec_ref r278
    dec_ref r282
    if is_error(r283) goto L198 (error at <module>:63) else goto L85
L85:
    r284 = PyList_New(1)
    if is_error(r284) goto L199 (error at <module>:63) else goto L86
L86:
    r285 = get_element_ptr r284 ob_item :: PyListObject
    r286 = load_mem r285 :: ptr*
    set_mem r286, r283 :: builtins.object*
    r287 = dank_mids.helpers._codec.globals :: static
    r288 = 'Union'
    r289 = CPyDict_GetItem(r287, r288)
    if is_error(r289) goto L200 (error at <module>:63) else goto L87
L87:
    r290 = dank_mids.helpers._codec.globals :: static
    r291 = 'List'
    r292 = CPyDict_GetItem(r290, r291)
    if is_error(r292) goto L201 (error at <module>:63) else goto L88
L88:
    r293 = dank_mids.helpers._codec.globals :: static
    r294 = 'msgspec'
    r295 = CPyDict_GetItem(r293, r294)
    if is_error(r295) goto L202 (error at <module>:63) else goto L89
L89:
    r296 = 'Raw'
    r297 = CPyObject_GetAttr(r295, r296)
    dec_ref r295
    if is_error(r297) goto L202 (error at <module>:63) else goto L90
L90:
    r298 = PyObject_GetItem(r292, r297)
    dec_ref r292
    dec_ref r297
    if is_error(r298) goto L201 (error at <module>:63) else goto L91
L91:
    r299 = 'types.PartialResponse'
    inc_ref r299
    r300 = (r298, r299)
    r301 = box(tuple[object, str], r300)
    r302 = PyObject_GetItem(r289, r301)
    dec_ref r289
    dec_ref r301
    if is_error(r302) goto L200 (error at <module>:63) else goto L92
L92:
    r303 = (r284, r302)
    r304 = box(tuple[list, object], r303)
    r305 = PyObject_GetItem(r275, r304)
    dec_ref r275
    dec_ref r304
    if is_error(r305) goto L173 (error at <module>:63) else goto L93
L93:
    r306 = dank_mids.helpers._codec.globals :: static
    r307 = 'BatchDecoder'
    r308 = CPyDict_SetItem(r306, r307, r305)
    dec_ref r305
    r309 = r308 >= 0 :: signed
    if not r309 goto L173 (error at <module>:63) else goto L94 :: bool
L94:
    r310 = dank_mids.helpers._codec.globals :: static
    r311 = 'hexbytes'
    r312 = CPyDict_GetItem(r310, r311)
    if is_error(r312) goto L173 (error at <module>:66) else goto L95
L95:
    r313 = 'HexBytes'
    r314 = CPyObject_GetAttr(r312, r313)
    dec_ref r312
    if is_error(r314) goto L173 (error at <module>:66) else goto L96
L96:
    dank_mids.helpers._codec.HexBytes = r314 :: static
    r315 = dank_mids.helpers._codec.globals :: static
    r316 = 'HexBytes'
    r317 = CPyDict_SetItem(r315, r316, r314)
    dec_ref r314
    r318 = r317 >= 0 :: signed
    if not r318 goto L173 (error at <module>:66) else goto L97 :: bool
L97:
    r319 = dank_mids.helpers._codec.globals :: static
    r320 = 'msgspec'
    r321 = CPyDict_GetItem(r319, r320)
    if is_error(r321) goto L173 (error at <module>:67) else goto L98
L98:
    r322 = 'Raw'
    r323 = CPyObject_GetAttr(r321, r322)
    dec_ref r321
    if is_error(r323) goto L173 (error at <module>:67) else goto L99
L99:
    dank_mids.helpers._codec.Raw = r323 :: static
    r324 = dank_mids.helpers._codec.globals :: static
    r325 = 'Raw'
    r326 = CPyDict_SetItem(r324, r325, r323)
    dec_ref r323
    r327 = r326 >= 0 :: signed
    if not r327 goto L173 (error at <module>:67) else goto L100 :: bool
L100:
    r328 = dank_mids.helpers._codec.globals :: static
    r329 = 'decoding'
    r330 = CPyDict_GetItem(r328, r329)
    if is_error(r330) goto L173 (error at <module>:68) else goto L101
L101:
    r331 = 'ContextFramesBytesIO'
    r332 = CPyObject_GetAttr(r330, r331)
    dec_ref r330
    if is_error(r332) goto L173 (error at <module>:68) else goto L102
L102:
    dank_mids.helpers._codec.ContextFramesBytesIO = r332 :: static
    r333 = dank_mids.helpers._codec.globals :: static
    r334 = 'ContextFramesBytesIO'
    r335 = CPyDict_SetItem(r333, r334, r332)
    dec_ref r332
    r336 = r335 >= 0 :: signed
    if not r336 goto L173 (error at <module>:68) else goto L103 :: bool
L103:
    r337 = dank_mids.helpers._codec.globals :: static
    r338 = 'msgspec'
    r339 = CPyDict_GetItem(r337, r338)
    if is_error(r339) goto L173 (error at <module>:69) else goto L104
L104:
    r340 = 'DecodeError'
    r341 = CPyObject_GetAttr(r339, r340)
    dec_ref r339
    if is_error(r341) goto L173 (error at <module>:69) else goto L105
L105:
    dank_mids.helpers._codec.DecodeError = r341 :: static
    r342 = dank_mids.helpers._codec.globals :: static
    r343 = 'DecodeError'
    r344 = CPyDict_SetItem(r342, r343, r341)
    dec_ref r341
    r345 = r344 >= 0 :: signed
    if not r345 goto L173 (error at <module>:69) else goto L106 :: bool
L106:
    r346 = load_address PyUnicode_Type
    r347 = dank_mids.helpers._codec.globals :: static
    r348 = 'Decoder'
    r349 = CPyDict_GetItem(r347, r348)
    if is_error(r349) goto L173 (error at <module>:71) else goto L107
L107:
    r350 = [r346]
    r351 = load_address r350
    r352 = ('type',)
    r353 = PyObject_Vectorcall(r349, r351, 0, r352)
    dec_ref r349
    if is_error(r353) goto L173 (error at <module>:71) else goto L108
L108:
    r354 = 'decode'
    r355 = CPyObject_GetAttr(r353, r354)
    dec_ref r353
    if is_error(r355) goto L173 (error at <module>:71) else goto L109
L109:
    dank_mids.helpers._codec.decode_string = r355 :: static
    r356 = dank_mids.helpers._codec.globals :: static
    r357 = 'decode_string'
    r358 = CPyDict_SetItem(r356, r357, r355)
    dec_ref r355
    r359 = r358 >= 0 :: signed
    if not r359 goto L173 (error at <module>:71) else goto L110 :: bool
L110:
    r360 = dank_mids.helpers._codec.Raw :: static
    if is_error(r360) goto L111 else goto L113
L111:
    r361 = raise NameError('value for final name "Raw" was not set')
    if not r361 goto L173 (error at <module>:72) else goto L112 :: bool
L112:
    unreachable
L113:
    r362 = dank_mids.helpers._codec.globals :: static
    r363 = 'Decoder'
    r364 = CPyDict_GetItem(r362, r363)
    if is_error(r364) goto L173 (error at <module>:72) else goto L114
L114:
    r365 = [r360]
    r366 = load_address r365
    r367 = ('type',)
    r368 = PyObject_Vectorcall(r364, r366, 0, r367)
    dec_ref r364
    if is_error(r368) goto L173 (error at <module>:72) else goto L115
L115:
    r369 = 'decode'
    r370 = CPyObject_GetAttr(r368, r369)
    dec_ref r368
    if is_error(r370) goto L173 (error at <module>:72) else goto L116
L116:
    dank_mids.helpers._codec._decode_raw = r370 :: static
    r371 = dank_mids.helpers._codec.globals :: static
    r372 = '_decode_raw'
    r373 = CPyDict_SetItem(r371, r372, r370)
    dec_ref r370
    r374 = r373 >= 0 :: signed
    if not r374 goto L173 (error at <module>:72) else goto L117 :: bool
L117:
    r375 = dank_mids.helpers._codec.globals :: static
    r376 = '_decode_batch'
    r377 = box(None, 1)
    r378 = CPyDict_SetItem(r375, r376, r377)
    r379 = r378 >= 0 :: signed
    if not r379 goto L173 (error at <module>:74) else goto L118 :: bool
L118:
    r380 = <error> :: object
    r381 = 'dank_mids.helpers._codec'
    r382 = dank_mids.helpers._codec.RawResponse_template :: type
    r383 = CPyType_FromTemplate(r382, r380, r381)
    if is_error(r383) goto L173 (error at <module>:78) else goto L119
L119:
    r384 = RawResponse_trait_vtable_setup()
    if is_error(r384) goto L203 (error at <module>:-1) else goto L120
L120:
    r385 = '__mypyc_attrs__'
    r386 = '_raw'
    r387 = PyTuple_Pack(1, r386)
    if is_error(r387) goto L203 (error at <module>:78) else goto L121
L121:
    r388 = PyObject_SetAttr(r383, r385, r387)
    dec_ref r387
    r389 = r388 >= 0 :: signed
    if not r389 goto L203 (error at <module>:78) else goto L122 :: bool
L122:
    dank_mids.helpers._codec.RawResponse = r383 :: type
    r390 = dank_mids.helpers._codec.globals :: static
    r391 = 'RawResponse'
    r392 = CPyDict_SetItem(r390, r391, r383)
    dec_ref r383
    r393 = r392 >= 0 :: signed
    if not r393 goto L173 (error at <module>:78) else goto L123 :: bool
L123:
    r394 = dank_mids.helpers._codec.globals :: static
    r395 = '_encode_hook'
    r396 = CPyDict_GetItem(r394, r395)
    if is_error(r396) goto L173 (error at <module>:178) else goto L124
L124:
    r397 = dank_mids.helpers._codec.globals :: static
    r398 = 'Encoder'
    r399 = CPyDict_GetItem(r397, r398)
    if is_error(r399) goto L204 (error at <module>:178) else goto L125
L125:
    r400 = [r396]
    r401 = load_address r400
    r402 = ('enc_hook',)
    r403 = PyObject_Vectorcall(r399, r401, 0, r402)
    dec_ref r399
    if is_error(r403) goto L204 (error at <module>:178) else goto L126
L126:
    dec_ref r396
    r404 = 'encode'
    r405 = CPyObject_GetAttr(r403, r404)
    dec_ref r403
    if is_error(r405) goto L173 (error at <module>:178) else goto L127
L127:
    dank_mids.helpers._codec.encode = r405 :: static
    r406 = dank_mids.helpers._codec.globals :: static
    r407 = 'encode'
    r408 = CPyDict_SetItem(r406, r407, r405)
    dec_ref r405
    r409 = r408 >= 0 :: signed
    if not r409 goto L173 (error at <module>:178) else goto L128 :: bool
L128:
    r410 = dank_mids.helpers._codec.globals :: static
    r411 = 'default_codec'
    r412 = CPyDict_GetItem(r410, r411)
    if is_error(r412) goto L173 (error at <module>:197) else goto L129
L129:
    r413 = '_registry'
    r414 = CPyObject_GetAttr(r412, r413)
    dec_ref r412
    if is_error(r414) goto L173 (error at <module>:197) else goto L130
L130:
    r415 = '(bool,(address,bytes)[])'
    r416 = 'get_encoder'
    r417 = [r414, r415]
    r418 = load_address r417
    r419 = PyObject_VectorcallMethod(r416, r418, 9223372036854775810, 0)
    if is_error(r419) goto L205 (error at <module>:197) else goto L131
L131:
    dec_ref r414
    dank_mids.helpers._codec._mcall_encoder = r419 :: static
    r420 = dank_mids.helpers._codec.globals :: static
    r421 = '_mcall_encoder'
    r422 = CPyDict_SetItem(r420, r421, r419)
    dec_ref r419
    r423 = r422 >= 0 :: signed
    if not r423 goto L173 (error at <module>:197) else goto L132 :: bool
L132:
    r424 = dank_mids.helpers._codec._mcall_encoder :: static
    if is_error(r424) goto L133 else goto L135
L133:
    r425 = raise NameError('value for final name "_mcall_encoder" was not set')
    if not r425 goto L173 (error at <module>:200) else goto L134 :: bool
L134:
    unreachable
L135:
    r426 = 'encoders'
    r427 = CPyObject_GetAttr(r424, r426)
    if is_error(r427) goto L173 (error at <module>:200) else goto L136
L136:
    r428 = object -1
    r429 = PyObject_GetItem(r427, r428)
    dec_ref r427
    if is_error(r429) goto L173 (error at <module>:200) else goto L137
L137:
    dank_mids.helpers._codec._array_encoder = r429 :: static
    r430 = dank_mids.helpers._codec.globals :: static
    r431 = '_array_encoder'
    r432 = CPyDict_SetItem(r430, r431, r429)
    dec_ref r429
    r433 = r432 >= 0 :: signed
    if not r433 goto L173 (error at <module>:200) else goto L138 :: bool
L138:
    r434 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r434) goto L139 else goto L141
L139:
    r435 = raise NameError('value for final name "_array_encoder" was not set')
    if not r435 goto L173 (error at <module>:201) else goto L140 :: bool
L140:
    unreachable
L141:
    r436 = 'item_encoder'
    r437 = CPyObject_GetAttr(r434, r436)
    if is_error(r437) goto L173 (error at <module>:201) else goto L142
L142:
    dank_mids.helpers._codec._item_encoder = r437 :: static
    r438 = dank_mids.helpers._codec.globals :: static
    r439 = '_item_encoder'
    r440 = CPyDict_SetItem(r438, r439, r437)
    dec_ref r437
    r441 = r440 >= 0 :: signed
    if not r441 goto L173 (error at <module>:201) else goto L143 :: bool
L143:
    r442 = __mypyc_lambda__0_obj()
    if is_error(r442) goto L173 (error at <module>:204) else goto L144
L144:
    r443 = dank_mids.helpers._codec._mcall_encoder :: static
    if is_error(r443) goto L206 else goto L147
L145:
    r444 = raise NameError('value for final name "_mcall_encoder" was not set')
    if not r444 goto L173 (error at <module>:204) else goto L146 :: bool
L146:
    unreachable
L147:
    r445 = 'validate_value'
    r446 = PyObject_SetAttr(r443, r445, r442)
    r447 = r446 >= 0 :: signed
    if not r447 goto L207 (error at <module>:204) else goto L148 :: bool
L148:
    r448 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r448) goto L208 else goto L151
L149:
    r449 = raise NameError('value for final name "_array_encoder" was not set')
    if not r449 goto L173 (error at <module>:204) else goto L150 :: bool
L150:
    unreachable
L151:
    r450 = 'validate_value'
    r451 = PyObject_SetAttr(r448, r450, r442)
    r452 = r451 >= 0 :: signed
    if not r452 goto L207 (error at <module>:204) else goto L152 :: bool
L152:
    r453 = dank_mids.helpers._codec._item_encoder :: static
    if is_error(r453) goto L209 else goto L155
L153:
    r454 = raise NameError('value for final name "_item_encoder" was not set')
    if not r454 goto L173 (error at <module>:204) else goto L154 :: bool
L154:
    unreachable
L155:
    r455 = 'validate_value'
    r456 = PyObject_SetAttr(r453, r455, r442)
    dec_ref r442
    r457 = r456 >= 0 :: signed
    if not r457 goto L173 (error at <module>:204) else goto L156 :: bool
L156:
    r458 = dank_mids.helpers._codec.globals :: static
    r459 = '__encode_new'
    r460 = CPyDict_GetItem(r458, r459)
    if is_error(r460) goto L173 (error at <module>:234) else goto L157
L157:
    r461 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r461) goto L210 else goto L160
L158:
    r462 = raise NameError('value for final name "_array_encoder" was not set')
    if not r462 goto L173 (error at <module>:234) else goto L159 :: bool
L159:
    unreachable
L160:
    r463 = 'encode'
    r464 = PyObject_SetAttr(r461, r463, r460)
    dec_ref r460
    r465 = r464 >= 0 :: signed
    if not r465 goto L173 (error at <module>:234) else goto L161 :: bool
L161:
    r466 = dank_mids.helpers._codec.globals :: static
    r467 = '__encode_elements_new'
    r468 = CPyDict_GetItem(r466, r467)
    if is_error(r468) goto L173 (error at <module>:235) else goto L162
L162:
    r469 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r469) goto L211 else goto L165
L163:
    r470 = raise NameError('value for final name "_array_encoder" was not set')
    if not r470 goto L173 (error at <module>:235) else goto L164 :: bool
L164:
    unreachable
L165:
    r471 = 'encode_elements'
    r472 = PyObject_SetAttr(r469, r471, r468)
    dec_ref r468
    r473 = r472 >= 0 :: signed
    if not r473 goto L173 (error at <module>:235) else goto L166 :: bool
L166:
    r474 = dank_mids.helpers._codec.globals :: static
    r475 = 'default_codec'
    r476 = CPyDict_GetItem(r474, r475)
    if is_error(r476) goto L173 (error at <module>:238) else goto L167
L167:
    r477 = '_registry'
    r478 = CPyObject_GetAttr(r476, r477)
    dec_ref r476
    if is_error(r478) goto L173 (error at <module>:238) else goto L168
L168:
    r479 = '(uint256,uint256,(bool,bytes)[])'
    r480 = 'get_decoder'
    r481 = [r478, r479]
    r482 = load_address r481
    r483 = PyObject_VectorcallMethod(r480, r482, 9223372036854775810, 0)
    if is_error(r483) goto L212 (error at <module>:238) else goto L169
L169:
    dec_ref r478
    r484 = 'decode'
    r485 = CPyObject_GetAttr(r483, r484)
    dec_ref r483
    if is_error(r485) goto L173 (error at <module>:238) else goto L170
L170:
    dank_mids.helpers._codec._mcall_decoder = r485 :: static
    r486 = dank_mids.helpers._codec.globals :: static
    r487 = '_mcall_decoder'
    r488 = CPyDict_SetItem(r486, r487, r485)
    dec_ref r485
    r489 = r488 >= 0 :: signed
    if not r489 goto L173 (error at <module>:238) else goto L171 :: bool
L171:
    r490 = load_address PyBool_Type
    r491 = dank_mids.helpers._codec.globals :: static
    r492 = 'Success'
    r493 = CPyDict_SetItem(r491, r492, r490)
    r494 = r493 >= 0 :: signed
    if not r494 goto L173 (error at <module>:248) else goto L172 :: bool
L172:
    return 1
L173:
    r495 = <error> :: None
    return r495
L174:
    dec_ref r73
    goto L173
L175:
    dec_ref r73
    dec_ref r76
    goto L173
L176:
    dec_ref r89
    goto L173
L177:
    dec_ref r89
    dec_ref r93
    goto L173
L178:
    dec_ref r109
    goto L173
L179:
    dec_ref r109
    dec_ref r112
    goto L173
L180:
    dec_ref r109
    dec_ref r112
    dec_ref r115
    goto L173
L181:
    dec_ref r109
    dec_ref r112
    dec_ref r119
    goto L173
L182:
    dec_ref r109
    dec_ref r112
    dec_ref r119
    dec_ref r122
    goto L173
L183:
    dec_ref r139
    goto L173
L184:
    dec_ref r139
    dec_ref r142
    goto L173
L185:
    dec_ref r139
    dec_ref r142
    dec_ref r145
    goto L173
L186:
    dec_ref r139
    dec_ref r153
    goto L173
L187:
    dec_ref r139
    dec_ref r153
    dec_ref r156
    goto L173
L188:
    dec_ref r139
    dec_ref r153
    dec_ref r156
    dec_ref r159
    goto L173
L189:
    dec_ref r139
    dec_ref r153
    dec_ref r156
    dec_ref r159
    dec_ref r162
    goto L173
L190:
    dec_ref r181
    goto L173
L191:
    dec_ref r181
    dec_ref r184
    goto L173
L192:
    dec_ref r181
    dec_ref r184
    dec_ref r188
    goto L173
L193:
    dec_ref r181
    dec_ref r195
    goto L173
L194:
    dec_ref r209
    goto L173
L195:
    dec_ref r209
    dec_ref r214
    goto L173
L196:
    dec_ref r236
    goto L173
L197:
    dec_ref r259
    goto L173
L198:
    dec_ref r275
    goto L173
L199:
    dec_ref r275
    dec_ref r283
    goto L173
L200:
    dec_ref r275
    dec_ref r284
    goto L173
L201:
    dec_ref r275
    dec_ref r284
    dec_ref r289
    goto L173
L202:
    dec_ref r275
    dec_ref r284
    dec_ref r289
    dec_ref r292
    goto L173
L203:
    dec_ref r383
    goto L173
L204:
    dec_ref r396
    goto L173
L205:
    dec_ref r414
    goto L173
L206:
    dec_ref r442
    goto L145
L207:
    dec_ref r442
    goto L173
L208:
    dec_ref r442
    goto L149
L209:
    dec_ref r442
    goto L153
L210:
    dec_ref r460
    goto L158
L211:
    dec_ref r468
    goto L163
L212:
    dec_ref r478
    goto L173

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13, r14 :: object_ptr
    r15 :: object_ptr[2]
    r16 :: c_ptr
    r17 :: native_int[2]
    r18 :: c_ptr
    r19 :: object
    r20 :: dict
    r21, r22 :: str
    r23 :: bit
    r24 :: object
    r25 :: str
    r26 :: dict
    r27, r28 :: object
    r29 :: str
    r30 :: dict
    r31, r32 :: object
    r33 :: str
    r34 :: dict
    r35, r36 :: object
    r37 :: str
    r38 :: dict
    r39, r40 :: object
    r41 :: str
    r42 :: dict
    r43 :: object
    r44 :: str
    r45 :: object
    r46 :: bool
    r47 :: object[1]
    r48 :: object_ptr
    r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: dict
    r55 :: str
    r56 :: object
    r57 :: str
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: i32
    r62 :: bit
    r63 :: bool
    r64 :: object
    r65 :: bool
    r66 :: str
    r67 :: object[1]
    r68 :: object_ptr
    r69 :: object
    r70 :: bool
    r71 :: object
    r72 :: bool
    r73 :: dict
    r74 :: str
    r75, r76 :: object
    r77 :: str
    r78 :: object[2]
    r79 :: object_ptr
    r80, r81 :: object
    r82 :: bool
    r83 :: int
    r84 :: bool
    r85 :: str
    r86 :: object
    r87 :: object[2]
    r88 :: object_ptr
    r89 :: object
    r90 :: bool
    r91 :: object
    r92 :: bool
    r93 :: int
    r94 :: bool
    r95 :: str
    r96 :: object
    r97 :: object[2]
    r98 :: object_ptr
    r99, r100 :: object
    r101 :: bool
    r102, r103 :: str
    r104 :: object[2]
    r105 :: object_ptr
    r106 :: object
    r107 :: str
    r108 :: dict
    r109 :: str
    r110 :: object
    r111 :: str
    r112 :: object
    r113 :: bool
    r114 :: object
    r115 :: object[4]
    r116 :: object_ptr
    r117, r118 :: object
    r119 :: dict
    r120 :: str
    r121 :: i32
    r122 :: bit
    r123 :: str
    r124, r125 :: object
    r126 :: bool
    r127 :: object
    r128 :: object[3]
    r129 :: object_ptr
    r130, r131 :: object
    r132 :: dict
    r133 :: str
    r134 :: i32
    r135 :: bit
    r136 :: str
    r137, r138 :: object
    r139 :: bool
    r140 :: object
    r141 :: object[3]
    r142 :: object_ptr
    r143, r144 :: object
    r145 :: dict
    r146 :: str
    r147 :: i32
    r148 :: bit
    r149 :: str
    r150, r151 :: object
    r152 :: bool
    r153 :: object
    r154 :: object[3]
    r155 :: object_ptr
    r156, r157 :: object
    r158 :: dict
    r159 :: str
    r160 :: i32
    r161 :: bit
    r162 :: str
    r163, r164 :: object
    r165 :: bool
    r166 :: object
    r167 :: object[3]
    r168 :: object_ptr
    r169, r170 :: object
    r171 :: dict
    r172 :: str
    r173 :: i32
    r174 :: bit
    r175 :: object
    r176 :: bool
    r177 :: str
    r178 :: object
    r179 :: str
    r180, r181 :: object
    r182 :: object[5]
    r183 :: object_ptr
    r184, r185 :: object
    r186 :: dict
    r187 :: str
    r188 :: i32
    r189 :: bit
    r190 :: str
    r191, r192 :: object
    r193 :: bool
    r194 :: i32
    r195 :: bit
    r196 :: bool
    r197 :: object
    r198 :: bool
    r199, r200 :: object
    r201 :: object[4]
    r202 :: object_ptr
    r203, r204 :: object
    r205 :: dict
    r206 :: str
    r207 :: i32
    r208 :: bit
    r209 :: object
    r210 :: bool
    r211 :: str
    r212 :: object
    r213 :: str
    r214, r215 :: object
    r216 :: object[5]
    r217 :: object_ptr
    r218, r219 :: object
    r220 :: dict
    r221 :: str
    r222 :: i32
    r223 :: bit
    r224 :: str
    r225, r226 :: object
    r227 :: bool
    r228 :: i32
    r229 :: bit
    r230 :: bool
    r231 :: object
    r232 :: bool
    r233 :: object
    r234 :: object[3]
    r235 :: object_ptr
    r236, r237 :: object
    r238 :: dict
    r239 :: str
    r240 :: i32
    r241 :: bit
    r242 :: str
    r243, r244 :: object
    r245 :: bool
    r246 :: object
    r247 :: object[3]
    r248 :: object_ptr
    r249, r250 :: object
    r251 :: dict
    r252 :: str
    r253 :: i32
    r254 :: bit
    r255 :: object
    r256 :: bool
    r257 :: str
    r258 :: object
    r259 :: str
    r260, r261 :: object
    r262 :: object[5]
    r263 :: object_ptr
    r264, r265 :: object
    r266 :: dict
    r267 :: str
    r268 :: i32
    r269 :: bit
    r270 :: str
    r271 :: dict
    r272 :: str
    r273, r274 :: object
    r275 :: bool
    r276 :: object
    r277 :: bool
    r278 :: str
    r279 :: object
    r280 :: i32
    r281 :: bit
    r282 :: bool
    r283 :: object
    r284 :: bool
    r285 :: object
    r286 :: object[4]
    r287 :: object_ptr
    r288, r289 :: object
    r290 :: dict
    r291 :: str
    r292 :: i32
    r293 :: bit
    r294 :: str
    r295 :: dict
    r296 :: str
    r297, r298 :: object
    r299 :: bool
    r300 :: str
    r301, r302, r303, r304 :: object
    r305 :: bool
    r306 :: str
    r307 :: object
    r308 :: i32
    r309 :: bit
    r310 :: bool
    r311 :: object
    r312 :: bool
    r313 :: object
    r314 :: object[4]
    r315 :: object_ptr
    r316, r317 :: object
    r318 :: dict
    r319 :: str
    r320 :: i32
    r321 :: bit
    r322 :: str
    r323 :: dict
    r324 :: str
    r325, r326 :: object
    r327 :: bool
    r328 :: str
    r329 :: object
    r330 :: i32
    r331 :: bit
    r332 :: bool
    r333 :: int
    r334 :: object
    r335 :: bool
    r336 :: str
    r337 :: object
    r338 :: i32
    r339 :: bit
    r340 :: bool
    r341 :: object
    r342 :: bool
    r343, r344 :: object
    r345 :: object[4]
    r346 :: object_ptr
    r347, r348 :: object
    r349 :: dict
    r350 :: str
    r351 :: i32
    r352 :: bit
    r353 :: str
    r354 :: dict
    r355 :: str
    r356, r357 :: object
    r358 :: bool
    r359 :: str
    r360 :: object
    r361 :: i32
    r362 :: bit
    r363 :: bool
    r364 :: int
    r365 :: object
    r366 :: bool
    r367 :: str
    r368 :: object
    r369 :: i32
    r370 :: bit
    r371 :: bool
    r372 :: object
    r373 :: bool
    r374, r375 :: object
    r376 :: object[4]
    r377 :: object_ptr
    r378, r379 :: object
    r380 :: dict
    r381 :: str
    r382 :: i32
    r383 :: bit
    r384 :: str
    r385 :: dict
    r386 :: str
    r387, r388 :: object
    r389 :: bool
    r390 :: str
    r391 :: object
    r392 :: i32
    r393 :: bit
    r394 :: bool
    r395 :: int
    r396 :: object
    r397 :: bool
    r398 :: str
    r399 :: object
    r400 :: i32
    r401 :: bit
    r402 :: bool
    r403 :: object
    r404 :: bool
    r405, r406 :: object
    r407 :: object[4]
    r408 :: object_ptr
    r409, r410 :: object
    r411 :: dict
    r412 :: str
    r413 :: i32
    r414 :: bit
    r415 :: str
    r416, r417 :: object
    r418 :: bool
    r419 :: str
    r420 :: object
    r421 :: i32
    r422 :: bit
    r423 :: bool
    r424 :: int
    r425 :: object
    r426 :: bool
    r427 :: str
    r428 :: object
    r429 :: i32
    r430 :: bit
    r431 :: bool
    r432 :: object
    r433 :: bool
    r434, r435 :: object
    r436 :: object[4]
    r437 :: object_ptr
    r438, r439 :: object
    r440 :: dict
    r441 :: str
    r442 :: i32
    r443 :: bit
    r444 :: str
    r445, r446 :: object
    r447 :: bool
    r448, r449 :: object
    r450 :: object[4]
    r451 :: object_ptr
    r452, r453 :: object
    r454 :: dict
    r455 :: str
    r456 :: i32
    r457 :: bit
    r458 :: str
    r459, r460 :: object
    r461 :: bool
    r462, r463 :: object
    r464 :: object[4]
    r465 :: object_ptr
    r466, r467 :: object
    r468 :: dict
    r469 :: str
    r470 :: i32
    r471 :: bit
    r472 :: str
    r473, r474 :: object
    r475 :: bool
    r476, r477 :: object
    r478 :: object[4]
    r479 :: object_ptr
    r480, r481 :: object
    r482 :: dict
    r483 :: str
    r484 :: i32
    r485 :: bit
    r486 :: str
    r487, r488 :: object
    r489 :: bool
    r490 :: object
    r491 :: bool
    r492 :: i32
    r493 :: bit
    r494 :: bool
    r495 :: object
    r496 :: bool
    r497 :: object
    r498 :: object[4]
    r499 :: object_ptr
    r500, r501 :: object
    r502 :: dict
    r503 :: str
    r504 :: i32
    r505 :: bit
    r506 :: str
    r507, r508 :: object
    r509 :: bool
    r510 :: object
    r511 :: object[3]
    r512 :: object_ptr
    r513, r514 :: object
    r515 :: dict
    r516 :: str
    r517 :: i32
    r518 :: bit
    r519, r520 :: str
    r521 :: dict
    r522 :: str
    r523, r524 :: object
    r525 :: bool
    r526 :: str
    r527, r528 :: object
    r529 :: bool
    r530 :: object
    r531 :: object[4]
    r532 :: object_ptr
    r533, r534 :: object
    r535, r536 :: str
    r537 :: dict
    r538 :: str
    r539 :: object
    r540 :: str
    r541, r542 :: object
    r543 :: bool
    r544, r545 :: object
    r546 :: object[4]
    r547 :: object_ptr
    r548, r549 :: object
    r550, r551 :: str
    r552 :: dict
    r553 :: str
    r554 :: object
    r555 :: str
    r556, r557 :: object
    r558 :: bool
    r559, r560 :: object
    r561 :: object[4]
    r562 :: object_ptr
    r563, r564 :: object
    r565, r566 :: dict
    r567 :: str
    r568 :: i32
    r569 :: bit
    r570 :: dict
    r571 :: str
    r572 :: object
    r573 :: str
    r574 :: object
    r575 :: str
    r576 :: object
    r577 :: i32
    r578 :: bit
    r579 :: bool
    r580 :: object
    r581 :: bool
    r582, r583 :: str
    r584 :: object[2]
    r585 :: object_ptr
    r586, r587 :: object
    r588 :: bool
    r589, r590 :: str
    r591 :: object[2]
    r592 :: object_ptr
    r593, r594 :: object
    r595 :: bool
    r596 :: str
    r597 :: object
    r598 :: i32
    r599 :: bit
    r600 :: bool
    r601 :: object
    r602 :: bool
    r603, r604 :: str
    r605 :: object[2]
    r606 :: object_ptr
    r607, r608 :: object
    r609 :: bool
    r610 :: str
    r611 :: object
    r612 :: i32
    r613 :: bit
    r614 :: bool
    r615 :: dict
    r616 :: str
    r617 :: object
    r618 :: dict
    r619 :: str
    r620 :: object
    r621 :: dict
    r622 :: str
    r623 :: object
    r624 :: set
    r625 :: i32
    r626 :: bit
    r627 :: i32
    r628 :: bit
    r629 :: i32
    r630 :: bit
    r631, r632 :: object
    r633 :: dict
    r634 :: str
    r635 :: i32
    r636 :: bit
    r637 :: dict
    r638 :: str
    r639 :: object
    r640 :: str
    r641 :: object
    r642 :: i32
    r643 :: bit
    r644 :: bool
    r645 :: str
    r646 :: dict
    r647 :: str
    r648 :: object
    r649 :: str
    r650 :: object
    r651, r652, r653 :: str
    r654 :: object
    r655 :: str
    r656 :: object
    r657 :: object[1]
    r658 :: object_ptr
    r659 :: object
    r660 :: bit
    r661 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L332 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('StreamHandler',)
    r6 = 'logging'
    r7 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L332 (error at <module>:2) else goto L4
L4:
    logging = r8 :: module
    dec_ref r8
    r9 = ('Dict', 'Final')
    r10 = 'typing'
    r11 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L332 (error at <module>:3) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = load_address a_sync :: module
    r14 = load_address typed_envs :: module
    r15 = [r13, r14]
    r16 = load_address r15
    r17 = [5, 6]
    r18 = load_address r17
    r19 = (('a_sync', 'a_sync', 'a_sync'), ('typed_envs', 'typed_envs', 'typed_envs'))
    r20 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r21 = 'dank_mids\\ENVIRONMENT_VARIABLES.py'
    r22 = '<module>'
    r23 = CPyImport_ImportMany(r19, r16, r20, r21, r22, r18)
    if not r23 goto L332 else goto L6 :: bool
L6:
    r24 = ('AsyncProcessPoolExecutor',)
    r25 = 'a_sync'
    r26 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r27 = CPyImport_ImportFromMany(r25, r24, r24, r26)
    if is_error(r27) goto L332 (error at <module>:7) else goto L7
L7:
    a_sync = r27 :: module
    dec_ref r27
    r28 = ('_envs',)
    r29 = 'dank_mids'
    r30 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r31 = CPyImport_ImportFromMany(r29, r28, r28, r30)
    if is_error(r31) goto L332 (error at <module>:9) else goto L8
L8:
    dank_mids = r31 :: module
    dec_ref r31
    r32 = ('INFO', 'getLogger')
    r33 = 'dank_mids._logging'
    r34 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r35 = CPyImport_ImportFromMany(r33, r32, r32, r34)
    if is_error(r35) goto L332 (error at <module>:10) else goto L9
L9:
    dank_mids._logging = r35 :: module
    dec_ref r35
    r36 = ('OperationMode',)
    r37 = 'dank_mids._mode'
    r38 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r39 = CPyImport_ImportFromMany(r37, r36, r36, r38)
    if is_error(r39) goto L332 (error at <module>:11) else goto L10
L10:
    dank_mids._mode = r39 :: module
    dec_ref r39
    r40 = ('BlockSemaphore',)
    r41 = 'dank_mids.semaphores'
    r42 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r43 = CPyImport_ImportFromMany(r41, r40, r40, r42)
    if is_error(r43) goto L332 (error at <module>:12) else goto L11
L11:
    dank_mids.semaphores = r43 :: module
    dec_ref r43
    r44 = 'dank_mids.envs'
    r45 = dank_mids._logging.getLogger :: static
    if is_error(r45) goto L12 else goto L14
L12:
    r46 = raise NameError('value for final name "getLogger" was not set')
    if not r46 goto L332 (error at <module>:15) else goto L13 :: bool
L13:
    unreachable
L14:
    r47 = [r44]
    r48 = load_address r47
    r49 = PyObject_Vectorcall(r45, r48, 1, 0)
    if is_error(r49) goto L332 (error at <module>:15) else goto L15
L15:
    dank_mids.ENVIRONMENT_VARIABLES.logger = r49 :: static
    r50 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r51 = 'logger'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L332 (error at <module>:15) else goto L16 :: bool
L16:
    r54 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r55 = 'typed_envs'
    r56 = CPyDict_GetItem(r54, r55)
    if is_error(r56) goto L332 (error at <module>:17) else goto L17
L17:
    r57 = 'logger'
    r58 = CPyObject_GetAttr(r56, r57)
    dec_ref r56
    if is_error(r58) goto L332 (error at <module>:17) else goto L18
L18:
    r59 = 'disabled'
    r60 = CPyObject_GetAttr(r58, r59)
    dec_ref r58
    if is_error(r60) goto L332 (error at <module>:17) else goto L19
L19:
    r61 = PyObject_IsTrue(r60)
    dec_ref r60
    r62 = r61 >= 0 :: signed
    if not r62 goto L332 (error at <module>:17) else goto L20 :: bool
L20:
    r63 = truncate r61: i32 to builtins.bool
    if r63 goto L55 else goto L21 :: bool
L21:
    r64 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r64) goto L22 else goto L24
L22:
    r65 = raise NameError('value for final name "logger" was not set')
    if not r65 goto L332 (error at <module>:18) else goto L23 :: bool
L23:
    unreachable
L24:
    r66 = 'hasHandlers'
    r67 = [r64]
    r68 = load_address r67
    r69 = PyObject_VectorcallMethod(r66, r68, 9223372036854775809, 0)
    if is_error(r69) goto L332 (error at <module>:18) else goto L25
L25:
    r70 = unbox(bool, r69)
    dec_ref r69
    if is_error(r70) goto L332 (error at <module>:18) else goto L26
L26:
    if r70 goto L34 else goto L27 :: bool
L27:
    r71 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r71) goto L28 else goto L30
L28:
    r72 = raise NameError('value for final name "logger" was not set')
    if not r72 goto L332 (error at <module>:19) else goto L29 :: bool
L29:
    unreachable
L30:
    r73 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r74 = 'StreamHandler'
    r75 = CPyDict_GetItem(r73, r74)
    if is_error(r75) goto L332 (error at <module>:19) else goto L31
L31:
    r76 = PyObject_Vectorcall(r75, 0, 0, 0)
    dec_ref r75
    if is_error(r76) goto L332 (error at <module>:19) else goto L32
L32:
    r77 = 'addHandler'
    r78 = [r71, r76]
    r79 = load_address r78
    r80 = PyObject_VectorcallMethod(r77, r79, 9223372036854775810, 0)
    if is_error(r80) goto L333 (error at <module>:19) else goto L334
L33:
    dec_ref r76
L34:
    r81 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r81) goto L35 else goto L37
L35:
    r82 = raise NameError('value for final name "logger" was not set')
    if not r82 goto L332 (error at <module>:20) else goto L36 :: bool
L36:
    unreachable
L37:
    r83 = dank_mids._logging.INFO :: static
    if is_error(r83) goto L38 else goto L40
L38:
    r84 = raise NameError('value for final name "INFO" was not set')
    if not r84 goto L332 (error at <module>:20) else goto L39 :: bool
L39:
    unreachable
L40:
    r85 = 'isEnabledFor'
    inc_ref r83 :: int
    r86 = box(int, r83)
    r87 = [r81, r86]
    r88 = load_address r87
    r89 = PyObject_VectorcallMethod(r85, r88, 9223372036854775810, 0)
    if is_error(r89) goto L335 (error at <module>:20) else goto L41
L41:
    dec_ref r86
    r90 = unbox(bool, r89)
    dec_ref r89
    if is_error(r90) goto L332 (error at <module>:20) else goto L42
L42:
    if r90 goto L51 else goto L43 :: bool
L43:
    r91 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r91) goto L44 else goto L46
L44:
    r92 = raise NameError('value for final name "logger" was not set')
    if not r92 goto L332 (error at <module>:21) else goto L45 :: bool
L45:
    unreachable
L46:
    r93 = dank_mids._logging.INFO :: static
    if is_error(r93) goto L47 else goto L49
L47:
    r94 = raise NameError('value for final name "INFO" was not set')
    if not r94 goto L332 (error at <module>:21) else goto L48 :: bool
L48:
    unreachable
L49:
    r95 = 'setLevel'
    inc_ref r93 :: int
    r96 = box(int, r93)
    r97 = [r91, r96]
    r98 = load_address r97
    r99 = PyObject_VectorcallMethod(r95, r98, 9223372036854775810, 0)
    if is_error(r99) goto L336 (error at <module>:21) else goto L337
L50:
    dec_ref r96
L51:
    r100 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r100) goto L52 else goto L54
L52:
    r101 = raise NameError('value for final name "logger" was not set')
    if not r101 goto L332 (error at <module>:22) else goto L53 :: bool
L53:
    unreachable
L54:
    r102 = 'For your information, you can tweak your configuration for optimal performance using any of the envs below:'
    r103 = 'info'
    r104 = [r100, r102]
    r105 = load_address r104
    r106 = PyObject_VectorcallMethod(r103, r105, 9223372036854775810, 0)
    if is_error(r106) goto L332 (error at <module>:22) else goto L338
L55:
    r107 = 'OPERATION_MODE'
    r108 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r109 = 'OperationMode'
    r110 = CPyDict_GetItem(r108, r109)
    if is_error(r110) goto L332 (error at <module>:35) else goto L56
L56:
    r111 = 'infura'
    r112 = dank_mids._envs.create_env :: static
    if is_error(r112) goto L339 else goto L59
L57:
    r113 = raise NameError('value for final name "create_env" was not set')
    if not r113 goto L332 (error at <module>:34) else goto L58 :: bool
L58:
    unreachable
L59:
    r114 = box(bool, 0)
    r115 = [r107, r110, r111, r114]
    r116 = load_address r115
    r117 = ('default', 'verbose')
    r118 = PyObject_Vectorcall(r112, r116, 2, r117)
    if is_error(r118) goto L340 (error at <module>:34) else goto L60
L60:
    dec_ref r110
    dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE = r118 :: static
    r119 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r120 = 'OPERATION_MODE'
    r121 = CPyDict_SetItem(r119, r120, r118)
    dec_ref r118
    r122 = r121 >= 0 :: signed
    if not r122 goto L332 (error at <module>:34) else goto L61 :: bool
L61:
    r123 = 'MAX_MULTICALL_SIZE'
    r124 = load_address PyLong_Type
    r125 = dank_mids._envs.create_env :: static
    if is_error(r125) goto L62 else goto L64
L62:
    r126 = raise NameError('value for final name "create_env" was not set')
    if not r126 goto L332 (error at <module>:39) else goto L63 :: bool
L63:
    unreachable
L64:
    r127 = object 10000
    r128 = [r123, r124, r127]
    r129 = load_address r128
    r130 = ('default',)
    r131 = PyObject_Vectorcall(r125, r129, 2, r130)
    if is_error(r131) goto L332 (error at <module>:39) else goto L65
L65:
    dank_mids.ENVIRONMENT_VARIABLES.MAX_MULTICALL_SIZE = r131 :: static
    r132 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r133 = 'MAX_MULTICALL_SIZE'
    r134 = CPyDict_SetItem(r132, r133, r131)
    dec_ref r131
    r135 = r134 >= 0 :: signed
    if not r135 goto L332 (error at <module>:39) else goto L66 :: bool
L66:
    r136 = 'MAX_JSONRPC_BATCH_SIZE'
    r137 = load_address PyLong_Type
    r138 = dank_mids._envs.create_env :: static
    if is_error(r138) goto L67 else goto L69
L67:
    r139 = raise NameError('value for final name "create_env" was not set')
    if not r139 goto L332 (error at <module>:41) else goto L68 :: bool
L68:
    unreachable
L69:
    r140 = object 500
    r141 = [r136, r137, r140]
    r142 = load_address r141
    r143 = ('default',)
    r144 = PyObject_Vectorcall(r138, r142, 2, r143)
    if is_error(r144) goto L332 (error at <module>:41) else goto L70
L70:
    dank_mids.ENVIRONMENT_VARIABLES.MAX_JSONRPC_BATCH_SIZE = r144 :: static
    r145 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r146 = 'MAX_JSONRPC_BATCH_SIZE'
    r147 = CPyDict_SetItem(r145, r146, r144)
    dec_ref r144
    r148 = r147 >= 0 :: signed
    if not r148 goto L332 (error at <module>:41) else goto L71 :: bool
L71:
    r149 = 'REQUESTS_PER_SECOND'
    r150 = load_address PyLong_Type
    r151 = dank_mids._envs.create_env :: static
    if is_error(r151) goto L72 else goto L74
L72:
    r152 = raise NameError('value for final name "create_env" was not set')
    if not r152 goto L332 (error at <module>:43) else goto L73 :: bool
L73:
    unreachable
L74:
    r153 = object 50
    r154 = [r149, r150, r153]
    r155 = load_address r154
    r156 = ('default',)
    r157 = PyObject_Vectorcall(r151, r155, 2, r156)
    if is_error(r157) goto L332 (error at <module>:43) else goto L75
L75:
    dank_mids.ENVIRONMENT_VARIABLES.REQUESTS_PER_SECOND = r157 :: static
    r158 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r159 = 'REQUESTS_PER_SECOND'
    r160 = CPyDict_SetItem(r158, r159, r157)
    dec_ref r157
    r161 = r160 >= 0 :: signed
    if not r161 goto L332 (error at <module>:43) else goto L76 :: bool
L76:
    r162 = 'MIN_REQUESTS_PER_SECOND'
    r163 = load_address PyLong_Type
    r164 = dank_mids._envs.create_env :: static
    if is_error(r164) goto L77 else goto L79
L77:
    r165 = raise NameError('value for final name "create_env" was not set')
    if not r165 goto L332 (error at <module>:45) else goto L78 :: bool
L78:
    unreachable
L79:
    r166 = object 10
    r167 = [r162, r163, r166]
    r168 = load_address r167
    r169 = ('default',)
    r170 = PyObject_Vectorcall(r164, r168, 2, r169)
    if is_error(r170) goto L332 (error at <module>:45) else goto L80
L80:
    dank_mids.ENVIRONMENT_VARIABLES.MIN_REQUESTS_PER_SECOND = r170 :: static
    r171 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r172 = 'MIN_REQUESTS_PER_SECOND'
    r173 = CPyDict_SetItem(r171, r172, r170)
    dec_ref r170
    r174 = r173 >= 0 :: signed
    if not r174 goto L332 (error at <module>:45) else goto L81 :: bool
L81:
    r175 = dank_mids._envs._deprecated_format :: static
    if is_error(r175) goto L82 else goto L84
L82:
    r176 = raise NameError('value for final name "_deprecated_format" was not set')
    if not r176 goto L332 (error at <module>:48) else goto L83 :: bool
L83:
    unreachable
L84:
    r177 = 'DEMO_MODE'
    r178 = load_address PyBool_Type
    r179 = 'create_env'
    r180 = box(bool, 0)
    r181 = box(bool, 0)
    r182 = [r175, r177, r178, r180, r181]
    r183 = load_address r182
    r184 = ('default', 'verbose')
    r185 = PyObject_VectorcallMethod(r179, r183, 9223372036854775811, r184)
    if is_error(r185) goto L332 (error at <module>:48) else goto L85
L85:
    dank_mids.ENVIRONMENT_VARIABLES.demo_mode = r185 :: static
    r186 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r187 = 'demo_mode'
    r188 = CPyDict_SetItem(r186, r187, r185)
    dec_ref r185
    r189 = r188 >= 0 :: signed
    if not r189 goto L332 (error at <module>:48) else goto L86 :: bool
L86:
    r190 = 'DEMO_MODE'
    r191 = load_address PyBool_Type
    r192 = dank_mids.ENVIRONMENT_VARIABLES.demo_mode :: static
    if is_error(r192) goto L87 else goto L89
L87:
    r193 = raise NameError('value for final name "demo_mode" was not set')
    if not r193 goto L332 (error at <module>:51) else goto L88 :: bool
L88:
    unreachable
L89:
    r194 = PyObject_IsTrue(r192)
    r195 = r194 >= 0 :: signed
    if not r195 goto L332 (error at <module>:51) else goto L90 :: bool
L90:
    r196 = truncate r194: i32 to builtins.bool
    r197 = dank_mids._envs.create_env :: static
    if is_error(r197) goto L91 else goto L93
L91:
    r198 = raise NameError('value for final name "create_env" was not set')
    if not r198 goto L332 (error at <module>:51) else goto L92 :: bool
L92:
    unreachable
L93:
    r199 = box(bool, r196)
    r200 = box(bool, 0)
    r201 = [r190, r191, r199, r200]
    r202 = load_address r201
    r203 = ('default', 'verbose')
    r204 = PyObject_Vectorcall(r197, r202, 2, r203)
    if is_error(r204) goto L332 (error at <module>:51) else goto L94
L94:
    dank_mids.ENVIRONMENT_VARIABLES.DEMO_MODE = r204 :: static
    r205 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r206 = 'DEMO_MODE'
    r207 = CPyDict_SetItem(r205, r206, r204)
    dec_ref r204
    r208 = r207 >= 0 :: signed
    if not r208 goto L332 (error at <module>:51) else goto L95 :: bool
L95:
    r209 = dank_mids._envs._deprecated_format :: static
    if is_error(r209) goto L96 else goto L98
L96:
    r210 = raise NameError('value for final name "_deprecated_format" was not set')
    if not r210 goto L332 (error at <module>:54) else goto L97 :: bool
L97:
    unreachable
L98:
    r211 = 'GANACHE_FORK'
    r212 = load_address PyBool_Type
    r213 = 'create_env'
    r214 = box(bool, 0)
    r215 = box(bool, 0)
    r216 = [r209, r211, r212, r214, r215]
    r217 = load_address r216
    r218 = ('default', 'verbose')
    r219 = PyObject_VectorcallMethod(r213, r217, 9223372036854775811, r218)
    if is_error(r219) goto L332 (error at <module>:54) else goto L99
L99:
    dank_mids.ENVIRONMENT_VARIABLES.ganache_fork = r219 :: static
    r220 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r221 = 'ganache_fork'
    r222 = CPyDict_SetItem(r220, r221, r219)
    dec_ref r219
    r223 = r222 >= 0 :: signed
    if not r223 goto L332 (error at <module>:54) else goto L100 :: bool
L100:
    r224 = 'GANACHE_FORK'
    r225 = load_address PyBool_Type
    r226 = dank_mids.ENVIRONMENT_VARIABLES.ganache_fork :: static
    if is_error(r226) goto L101 else goto L103
L101:
    r227 = raise NameError('value for final name "ganache_fork" was not set')
    if not r227 goto L332 (error at <module>:57) else goto L102 :: bool
L102:
    unreachable
L103:
    r228 = PyObject_IsTrue(r226)
    r229 = r228 >= 0 :: signed
    if not r229 goto L332 (error at <module>:57) else goto L104 :: bool
L104:
    r230 = truncate r228: i32 to builtins.bool
    r231 = dank_mids._envs.create_env :: static
    if is_error(r231) goto L105 else goto L107
L105:
    r232 = raise NameError('value for final name "create_env" was not set')
    if not r232 goto L332 (error at <module>:57) else goto L106 :: bool
L106:
    unreachable
L107:
    r233 = box(bool, r230)
    r234 = [r224, r225, r233]
    r235 = load_address r234
    r236 = ('default',)
    r237 = PyObject_Vectorcall(r231, r235, 2, r236)
    if is_error(r237) goto L332 (error at <module>:57) else goto L108
L108:
    dank_mids.ENVIRONMENT_VARIABLES.GANACHE_FORK = r237 :: static
    r238 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r239 = 'GANACHE_FORK'
    r240 = CPyDict_SetItem(r238, r239, r237)
    dec_ref r237
    r241 = r240 >= 0 :: signed
    if not r241 goto L332 (error at <module>:57) else goto L109 :: bool
L109:
    r242 = 'AIOHTTP_TIMEOUT'
    r243 = load_address PyLong_Type
    r244 = dank_mids._envs.create_env :: static
    if is_error(r244) goto L110 else goto L112
L110:
    r245 = raise NameError('value for final name "create_env" was not set')
    if not r245 goto L332 (error at <module>:61) else goto L111 :: bool
L111:
    unreachable
L112:
    r246 = object 1200
    r247 = [r242, r243, r246]
    r248 = load_address r247
    r249 = ('default',)
    r250 = PyObject_Vectorcall(r244, r248, 2, r249)
    if is_error(r250) goto L332 (error at <module>:61) else goto L113
L113:
    dank_mids.ENVIRONMENT_VARIABLES.AIOHTTP_TIMEOUT = r250 :: static
    r251 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r252 = 'AIOHTTP_TIMEOUT'
    r253 = CPyDict_SetItem(r251, r252, r250)
    dec_ref r250
    r254 = r253 >= 0 :: signed
    if not r254 goto L332 (error at <module>:61) else goto L114 :: bool
L114:
    r255 = dank_mids._envs._deprecated_format :: static
    if is_error(r255) goto L115 else goto L117
L115:
    r256 = raise NameError('value for final name "_deprecated_format" was not set')
    if not r256 goto L332 (error at <module>:67) else goto L116 :: bool
L116:
    unreachable
L117:
    r257 = 'BROWNIE_CALL_SEMAPHORE'
    r258 = load_address PyLong_Type
    r259 = 'create_env'
    r260 = object 100000
    r261 = box(bool, 0)
    r262 = [r255, r257, r258, r260, r261]
    r263 = load_address r262
    r264 = ('default', 'verbose')
    r265 = PyObject_VectorcallMethod(r259, r263, 9223372036854775811, r264)
    if is_error(r265) goto L332 (error at <module>:67) else goto L118
L118:
    dank_mids.ENVIRONMENT_VARIABLES.brownie_semaphore = r265 :: static
    r266 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r267 = 'brownie_semaphore'
    r268 = CPyDict_SetItem(r266, r267, r265)
    dec_ref r265
    r269 = r268 >= 0 :: signed
    if not r269 goto L332 (error at <module>:67) else goto L119 :: bool
L119:
    r270 = 'BROWNIE_CALL_SEMAPHORE'
    r271 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r272 = 'BlockSemaphore'
    r273 = CPyDict_GetItem(r271, r272)
    if is_error(r273) goto L332 (error at <module>:72) else goto L120
L120:
    r274 = dank_mids.ENVIRONMENT_VARIABLES.brownie_semaphore :: static
    if is_error(r274) goto L341 else goto L123
L121:
    r275 = raise NameError('value for final name "brownie_semaphore" was not set')
    if not r275 goto L332 (error at <module>:73) else goto L122 :: bool
L122:
    unreachable
L123:
    r276 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r276) goto L342 else goto L126
L124:
    r277 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r277 goto L332 (error at <module>:74) else goto L125 :: bool
L125:
    unreachable
L126:
    r278 = 'infura'
    r279 = CPyObject_GetAttr(r276, r278)
    if is_error(r279) goto L343 (error at <module>:74) else goto L127
L127:
    r280 = PyObject_Not(r279)
    dec_ref r279
    r281 = r280 >= 0 :: signed
    if not r281 goto L343 (error at <module>:74) else goto L128 :: bool
L128:
    r282 = truncate r280: i32 to builtins.bool
    r283 = dank_mids._envs.create_env :: static
    if is_error(r283) goto L344 else goto L131
L129:
    r284 = raise NameError('value for final name "create_env" was not set')
    if not r284 goto L332 (error at <module>:70) else goto L130 :: bool
L130:
    unreachable
L131:
    r285 = box(bool, r282)
    r286 = [r270, r273, r274, r285]
    r287 = load_address r286
    r288 = ('default', 'verbose')
    r289 = PyObject_Vectorcall(r283, r287, 2, r288)
    if is_error(r289) goto L343 (error at <module>:70) else goto L132
L132:
    dec_ref r273
    dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE = r289 :: static
    r290 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r291 = 'BROWNIE_CALL_SEMAPHORE'
    r292 = CPyDict_SetItem(r290, r291, r289)
    dec_ref r289
    r293 = r292 >= 0 :: signed
    if not r293 goto L332 (error at <module>:70) else goto L133 :: bool
L133:
    r294 = 'BROWNIE_ENCODER_SEMAPHORE'
    r295 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r296 = 'BlockSemaphore'
    r297 = CPyDict_GetItem(r295, r296)
    if is_error(r297) goto L332 (error at <module>:85) else goto L134
L134:
    r298 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE :: static
    if is_error(r298) goto L345 else goto L137
L135:
    r299 = raise NameError('value for final name "BROWNIE_CALL_SEMAPHORE" was not set')
    if not r299 goto L332 (error at <module>:86) else goto L136 :: bool
L136:
    unreachable
L137:
    r300 = '_default_value'
    r301 = CPyObject_GetAttr(r298, r300)
    if is_error(r301) goto L346 (error at <module>:86) else goto L138
L138:
    r302 = object 2
    r303 = PyNumber_Multiply(r301, r302)
    dec_ref r301
    if is_error(r303) goto L346 (error at <module>:86) else goto L139
L139:
    r304 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r304) goto L347 else goto L142
L140:
    r305 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r305 goto L332 (error at <module>:87) else goto L141 :: bool
L141:
    unreachable
L142:
    r306 = 'infura'
    r307 = CPyObject_GetAttr(r304, r306)
    if is_error(r307) goto L348 (error at <module>:87) else goto L143
L143:
    r308 = PyObject_Not(r307)
    dec_ref r307
    r309 = r308 >= 0 :: signed
    if not r309 goto L348 (error at <module>:87) else goto L144 :: bool
L144:
    r310 = truncate r308: i32 to builtins.bool
    r311 = dank_mids._envs.create_env :: static
    if is_error(r311) goto L349 else goto L147
L145:
    r312 = raise NameError('value for final name "create_env" was not set')
    if not r312 goto L332 (error at <module>:83) else goto L146 :: bool
L146:
    unreachable
L147:
    r313 = box(bool, r310)
    r314 = [r294, r297, r303, r313]
    r315 = load_address r314
    r316 = ('default', 'verbose')
    r317 = PyObject_Vectorcall(r311, r315, 2, r316)
    if is_error(r317) goto L348 (error at <module>:83) else goto L148
L148:
    dec_ref r297
    dec_ref r303
    dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_ENCODER_SEMAPHORE = r317 :: static
    r318 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r319 = 'BROWNIE_ENCODER_SEMAPHORE'
    r320 = CPyDict_SetItem(r318, r319, r317)
    dec_ref r317
    r321 = r320 >= 0 :: signed
    if not r321 goto L332 (error at <module>:83) else goto L149 :: bool
L149:
    r322 = 'BROWNIE_ENCODER_PROCESSES'
    r323 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r324 = 'AsyncProcessPoolExecutor'
    r325 = CPyDict_GetItem(r323, r324)
    if is_error(r325) goto L332 (error at <module>:101) else goto L150
L150:
    r326 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r326) goto L350 else goto L153
L151:
    r327 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r327 goto L332 (error at <module>:102) else goto L152 :: bool
L152:
    unreachable
L153:
    r328 = 'infura'
    r329 = CPyObject_GetAttr(r326, r328)
    if is_error(r329) goto L351 (error at <module>:102) else goto L154
L154:
    r330 = PyObject_IsTrue(r329)
    dec_ref r329
    r331 = r330 >= 0 :: signed
    if not r331 goto L351 (error at <module>:102) else goto L155 :: bool
L155:
    r332 = truncate r330: i32 to builtins.bool
    if r332 goto L156 else goto L157 :: bool
L156:
    r333 = 0
    goto L158
L157:
    r333 = 2
L158:
    r334 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r334) goto L352 else goto L161
L159:
    r335 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r335 goto L332 (error at <module>:103) else goto L160 :: bool
L160:
    unreachable
L161:
    r336 = 'infura'
    r337 = CPyObject_GetAttr(r334, r336)
    if is_error(r337) goto L353 (error at <module>:103) else goto L162
L162:
    r338 = PyObject_Not(r337)
    dec_ref r337
    r339 = r338 >= 0 :: signed
    if not r339 goto L353 (error at <module>:103) else goto L163 :: bool
L163:
    r340 = truncate r338: i32 to builtins.bool
    r341 = dank_mids._envs.create_env :: static
    if is_error(r341) goto L354 else goto L166
L164:
    r342 = raise NameError('value for final name "create_env" was not set')
    if not r342 goto L332 (error at <module>:99) else goto L165 :: bool
L165:
    unreachable
L166:
    r343 = box(int, r333)
    r344 = box(bool, r340)
    r345 = [r322, r325, r343, r344]
    r346 = load_address r345
    r347 = ('default', 'verbose')
    r348 = PyObject_Vectorcall(r341, r346, 2, r347)
    if is_error(r348) goto L355 (error at <module>:99) else goto L167
L167:
    dec_ref r325
    dec_ref r343
    r349 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r350 = 'BROWNIE_ENCODER_PROCESSES'
    r351 = CPyDict_SetItem(r349, r350, r348)
    dec_ref r348
    r352 = r351 >= 0 :: signed
    if not r352 goto L332 (error at <module>:99) else goto L168 :: bool
L168:
    r353 = 'BROWNIE_DECODER_PROCESSES'
    r354 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r355 = 'AsyncProcessPoolExecutor'
    r356 = CPyDict_GetItem(r354, r355)
    if is_error(r356) goto L332 (error at <module>:114) else goto L169
L169:
    r357 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r357) goto L356 else goto L172
L170:
    r358 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r358 goto L332 (error at <module>:115) else goto L171 :: bool
L171:
    unreachable
L172:
    r359 = 'infura'
    r360 = CPyObject_GetAttr(r357, r359)
    if is_error(r360) goto L357 (error at <module>:115) else goto L173
L173:
    r361 = PyObject_IsTrue(r360)
    dec_ref r360
    r362 = r361 >= 0 :: signed
    if not r362 goto L357 (error at <module>:115) else goto L174 :: bool
L174:
    r363 = truncate r361: i32 to builtins.bool
    if r363 goto L175 else goto L176 :: bool
L175:
    r364 = 0
    goto L177
L176:
    r364 = 2
L177:
    r365 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r365) goto L358 else goto L180
L178:
    r366 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r366 goto L332 (error at <module>:116) else goto L179 :: bool
L179:
    unreachable
L180:
    r367 = 'infura'
    r368 = CPyObject_GetAttr(r365, r367)
    if is_error(r368) goto L359 (error at <module>:116) else goto L181
L181:
    r369 = PyObject_Not(r368)
    dec_ref r368
    r370 = r369 >= 0 :: signed
    if not r370 goto L359 (error at <module>:116) else goto L182 :: bool
L182:
    r371 = truncate r369: i32 to builtins.bool
    r372 = dank_mids._envs.create_env :: static
    if is_error(r372) goto L360 else goto L185
L183:
    r373 = raise NameError('value for final name "create_env" was not set')
    if not r373 goto L332 (error at <module>:112) else goto L184 :: bool
L184:
    unreachable
L185:
    r374 = box(int, r364)
    r375 = box(bool, r371)
    r376 = [r353, r356, r374, r375]
    r377 = load_address r376
    r378 = ('default', 'verbose')
    r379 = PyObject_Vectorcall(r372, r377, 2, r378)
    if is_error(r379) goto L361 (error at <module>:112) else goto L186
L186:
    dec_ref r356
    dec_ref r374
    r380 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r381 = 'BROWNIE_DECODER_PROCESSES'
    r382 = CPyDict_SetItem(r380, r381, r379)
    dec_ref r379
    r383 = r382 >= 0 :: signed
    if not r383 goto L332 (error at <module>:112) else goto L187 :: bool
L187:
    r384 = 'MULTICALL_DECODER_PROCESSES'
    r385 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r386 = 'AsyncProcessPoolExecutor'
    r387 = CPyDict_GetItem(r385, r386)
    if is_error(r387) goto L332 (error at <module>:127) else goto L188
L188:
    r388 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r388) goto L362 else goto L191
L189:
    r389 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r389 goto L332 (error at <module>:128) else goto L190 :: bool
L190:
    unreachable
L191:
    r390 = 'infura'
    r391 = CPyObject_GetAttr(r388, r390)
    if is_error(r391) goto L363 (error at <module>:128) else goto L192
L192:
    r392 = PyObject_IsTrue(r391)
    dec_ref r391
    r393 = r392 >= 0 :: signed
    if not r393 goto L363 (error at <module>:128) else goto L193 :: bool
L193:
    r394 = truncate r392: i32 to builtins.bool
    if r394 goto L194 else goto L195 :: bool
L194:
    r395 = 0
    goto L196
L195:
    r395 = 2
L196:
    r396 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r396) goto L364 else goto L199
L197:
    r397 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r397 goto L332 (error at <module>:129) else goto L198 :: bool
L198:
    unreachable
L199:
    r398 = 'infura'
    r399 = CPyObject_GetAttr(r396, r398)
    if is_error(r399) goto L365 (error at <module>:129) else goto L200
L200:
    r400 = PyObject_Not(r399)
    dec_ref r399
    r401 = r400 >= 0 :: signed
    if not r401 goto L365 (error at <module>:129) else goto L201 :: bool
L201:
    r402 = truncate r400: i32 to builtins.bool
    r403 = dank_mids._envs.create_env :: static
    if is_error(r403) goto L366 else goto L204
L202:
    r404 = raise NameError('value for final name "create_env" was not set')
    if not r404 goto L332 (error at <module>:125) else goto L203 :: bool
L203:
    unreachable
L204:
    r405 = box(int, r395)
    r406 = box(bool, r402)
    r407 = [r384, r387, r405, r406]
    r408 = load_address r407
    r409 = ('default', 'verbose')
    r410 = PyObject_Vectorcall(r403, r408, 2, r409)
    if is_error(r410) goto L367 (error at <module>:125) else goto L205
L205:
    dec_ref r387
    dec_ref r405
    r411 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r412 = 'MULTICALL_DECODER_PROCESSES'
    r413 = CPyDict_SetItem(r411, r412, r410)
    dec_ref r410
    r414 = r413 >= 0 :: signed
    if not r414 goto L332 (error at <module>:125) else goto L206 :: bool
L206:
    r415 = 'COLLECTION_FACTOR'
    r416 = load_address PyLong_Type
    r417 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r417) goto L207 else goto L209
L207:
    r418 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r418 goto L332 (error at <module>:141) else goto L208 :: bool
L208:
    unreachable
L209:
    r419 = 'infura'
    r420 = CPyObject_GetAttr(r417, r419)
    if is_error(r420) goto L332 (error at <module>:141) else goto L210
L210:
    r421 = PyObject_IsTrue(r420)
    dec_ref r420
    r422 = r421 >= 0 :: signed
    if not r422 goto L332 (error at <module>:141) else goto L211 :: bool
L211:
    r423 = truncate r421: i32 to builtins.bool
    if r423 goto L212 else goto L213 :: bool
L212:
    r424 = 20
    goto L214
L213:
    r424 = 2
L214:
    r425 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r425) goto L368 else goto L217
L215:
    r426 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r426 goto L332 (error at <module>:142) else goto L216 :: bool
L216:
    unreachable
L217:
    r427 = 'infura'
    r428 = CPyObject_GetAttr(r425, r427)
    if is_error(r428) goto L369 (error at <module>:142) else goto L218
L218:
    r429 = PyObject_Not(r428)
    dec_ref r428
    r430 = r429 >= 0 :: signed
    if not r430 goto L369 (error at <module>:142) else goto L219 :: bool
L219:
    r431 = truncate r429: i32 to builtins.bool
    r432 = dank_mids._envs.create_env :: static
    if is_error(r432) goto L370 else goto L222
L220:
    r433 = raise NameError('value for final name "create_env" was not set')
    if not r433 goto L332 (error at <module>:138) else goto L221 :: bool
L221:
    unreachable
L222:
    r434 = box(int, r424)
    r435 = box(bool, r431)
    r436 = [r415, r416, r434, r435]
    r437 = load_address r436
    r438 = ('default', 'verbose')
    r439 = PyObject_Vectorcall(r432, r437, 2, r438)
    if is_error(r439) goto L371 (error at <module>:138) else goto L223
L223:
    dec_ref r434
    dank_mids.ENVIRONMENT_VARIABLES.COLLECTION_FACTOR = r439 :: static
    r440 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r441 = 'COLLECTION_FACTOR'
    r442 = CPyDict_SetItem(r440, r441, r439)
    dec_ref r439
    r443 = r442 >= 0 :: signed
    if not r443 goto L332 (error at <module>:138) else goto L224 :: bool
L224:
    r444 = 'USE_FULL_REQUEST'
    r445 = load_address PyBool_Type
    r446 = dank_mids._envs.create_env :: static
    if is_error(r446) goto L225 else goto L227
L225:
    r447 = raise NameError('value for final name "create_env" was not set')
    if not r447 goto L332 (error at <module>:148) else goto L226 :: bool
L226:
    unreachable
L227:
    r448 = box(bool, 0)
    r449 = box(bool, 0)
    r450 = [r444, r445, r448, r449]
    r451 = load_address r450
    r452 = ('default', 'verbose')
    r453 = PyObject_Vectorcall(r446, r451, 2, r452)
    if is_error(r453) goto L332 (error at <module>:148) else goto L228
L228:
    dank_mids.ENVIRONMENT_VARIABLES.USE_FULL_REQUEST = r453 :: static
    r454 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r455 = 'USE_FULL_REQUEST'
    r456 = CPyDict_SetItem(r454, r455, r453)
    dec_ref r453
    r457 = r456 >= 0 :: signed
    if not r457 goto L332 (error at <module>:148) else goto L229 :: bool
L229:
    r458 = 'DEBUG'
    r459 = load_address PyBool_Type
    r460 = dank_mids._envs.create_env :: static
    if is_error(r460) goto L230 else goto L232
L230:
    r461 = raise NameError('value for final name "create_env" was not set')
    if not r461 goto L332 (error at <module>:151) else goto L231 :: bool
L231:
    unreachable
L232:
    r462 = box(bool, 0)
    r463 = box(bool, 0)
    r464 = [r458, r459, r462, r463]
    r465 = load_address r464
    r466 = ('default', 'verbose')
    r467 = PyObject_Vectorcall(r460, r465, 2, r466)
    if is_error(r467) goto L332 (error at <module>:151) else goto L233
L233:
    dank_mids.ENVIRONMENT_VARIABLES.DEBUG = r467 :: static
    r468 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r469 = 'DEBUG'
    r470 = CPyDict_SetItem(r468, r469, r467)
    dec_ref r467
    r471 = r470 >= 0 :: signed
    if not r471 goto L332 (error at <module>:151) else goto L234 :: bool
L234:
    r472 = 'EXPORT_STATS'
    r473 = load_address PyBool_Type
    r474 = dank_mids._envs.create_env :: static
    if is_error(r474) goto L235 else goto L237
L235:
    r475 = raise NameError('value for final name "create_env" was not set')
    if not r475 goto L332 (error at <module>:154) else goto L236 :: bool
L236:
    unreachable
L237:
    r476 = box(bool, 0)
    r477 = box(bool, 0)
    r478 = [r472, r473, r476, r477]
    r479 = load_address r478
    r480 = ('default', 'verbose')
    r481 = PyObject_Vectorcall(r474, r479, 2, r480)
    if is_error(r481) goto L332 (error at <module>:154) else goto L238
L238:
    dank_mids.ENVIRONMENT_VARIABLES.EXPORT_STATS = r481 :: static
    r482 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r483 = 'EXPORT_STATS'
    r484 = CPyDict_SetItem(r482, r483, r481)
    dec_ref r481
    r485 = r484 >= 0 :: signed
    if not r485 goto L332 (error at <module>:154) else goto L239 :: bool
L239:
    r486 = 'COLLECT_STATS'
    r487 = load_address PyBool_Type
    r488 = dank_mids.ENVIRONMENT_VARIABLES.EXPORT_STATS :: static
    if is_error(r488) goto L240 else goto L242
L240:
    r489 = raise NameError('value for final name "EXPORT_STATS" was not set')
    if not r489 goto L332 (error at <module>:157) else goto L241 :: bool
L241:
    unreachable
L242:
    r490 = dank_mids.ENVIRONMENT_VARIABLES.EXPORT_STATS :: static
    if is_error(r490) goto L243 else goto L245
L243:
    r491 = raise NameError('value for final name "EXPORT_STATS" was not set')
    if not r491 goto L332 (error at <module>:157) else goto L244 :: bool
L244:
    unreachable
L245:
    r492 = PyObject_Not(r490)
    r493 = r492 >= 0 :: signed
    if not r493 goto L332 (error at <module>:157) else goto L246 :: bool
L246:
    r494 = truncate r492: i32 to builtins.bool
    r495 = dank_mids._envs.create_env :: static
    if is_error(r495) goto L247 else goto L249
L247:
    r496 = raise NameError('value for final name "create_env" was not set')
    if not r496 goto L332 (error at <module>:156) else goto L248 :: bool
L248:
    unreachable
L249:
    r497 = box(bool, r494)
    r498 = [r486, r487, r488, r497]
    r499 = load_address r498
    r500 = ('default', 'verbose')
    r501 = PyObject_Vectorcall(r495, r499, 2, r500)
    if is_error(r501) goto L332 (error at <module>:156) else goto L250
L250:
    dank_mids.ENVIRONMENT_VARIABLES.COLLECT_STATS = r501 :: static
    r502 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r503 = 'COLLECT_STATS'
    r504 = CPyDict_SetItem(r502, r503, r501)
    dec_ref r501
    r505 = r504 >= 0 :: signed
    if not r505 goto L332 (error at <module>:156) else goto L251 :: bool
L251:
    r506 = 'STUCK_CALL_TIMEOUT'
    r507 = load_address PyLong_Type
    r508 = dank_mids._envs.create_env :: static
    if is_error(r508) goto L252 else goto L254
L252:
    r509 = raise NameError('value for final name "create_env" was not set')
    if not r509 goto L332 (error at <module>:161) else goto L253 :: bool
L253:
    unreachable
L254:
    r510 = object 120
    r511 = [r506, r507, r510]
    r512 = load_address r511
    r513 = ('default',)
    r514 = PyObject_Vectorcall(r508, r512, 2, r513)
    if is_error(r514) goto L332 (error at <module>:161) else goto L255
L255:
    dank_mids.ENVIRONMENT_VARIABLES.STUCK_CALL_TIMEOUT = r514 :: static
    r515 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r516 = 'STUCK_CALL_TIMEOUT'
    r517 = CPyDict_SetItem(r515, r516, r514)
    dec_ref r514
    r518 = r517 >= 0 :: signed
    if not r518 goto L332 (error at <module>:161) else goto L256 :: bool
L256:
    r519 = 'eth_call'
    r520 = 'ETH_CALL_SEMAPHORE'
    r521 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r522 = 'BlockSemaphore'
    r523 = CPyDict_GetItem(r521, r522)
    if is_error(r523) goto L332 (error at <module>:167) else goto L257
L257:
    r524 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE :: static
    if is_error(r524) goto L372 else goto L260
L258:
    r525 = raise NameError('value for final name "BROWNIE_CALL_SEMAPHORE" was not set')
    if not r525 goto L332 (error at <module>:168) else goto L259 :: bool
L259:
    unreachable
L260:
    r526 = '_value'
    r527 = CPyObject_GetAttr(r524, r526)
    if is_error(r527) goto L373 (error at <module>:168) else goto L261
L261:
    r528 = dank_mids._envs.create_env :: static
    if is_error(r528) goto L374 else goto L264
L262:
    r529 = raise NameError('value for final name "create_env" was not set')
    if not r529 goto L332 (error at <module>:165) else goto L263 :: bool
L263:
    unreachable
L264:
    r530 = box(bool, 0)
    r531 = [r520, r523, r527, r530]
    r532 = load_address r531
    r533 = ('default', 'verbose')
    r534 = PyObject_Vectorcall(r528, r532, 2, r533)
    if is_error(r534) goto L375 (error at <module>:165) else goto L265
L265:
    dec_ref r523
    dec_ref r527
    r535 = 'eth_getBlock'
    r536 = 'ETH_GETBLOCK_SEMAPHORE'
    r537 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r538 = 'a_sync'
    r539 = CPyDict_GetItem(r537, r538)
    if is_error(r539) goto L376 (error at <module>:173) else goto L266
L266:
    r540 = 'Semaphore'
    r541 = CPyObject_GetAttr(r539, r540)
    dec_ref r539
    if is_error(r541) goto L376 (error at <module>:173) else goto L267
L267:
    r542 = dank_mids._envs.create_env :: static
    if is_error(r542) goto L377 else goto L270
L268:
    r543 = raise NameError('value for final name "create_env" was not set')
    if not r543 goto L332 (error at <module>:171) else goto L269 :: bool
L269:
    unreachable
L270:
    r544 = object 1000
    r545 = box(bool, 0)
    r546 = [r536, r541, r544, r545]
    r547 = load_address r546
    r548 = ('default', 'verbose')
    r549 = PyObject_Vectorcall(r542, r547, 2, r548)
    if is_error(r549) goto L378 (error at <module>:171) else goto L271
L271:
    dec_ref r541
    r550 = 'eth_getCode'
    r551 = 'ETH_GETCODE_SEMAPHORE'
    r552 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r553 = 'a_sync'
    r554 = CPyDict_GetItem(r552, r553)
    if is_error(r554) goto L379 (error at <module>:179) else goto L272
L272:
    r555 = 'Semaphore'
    r556 = CPyObject_GetAttr(r554, r555)
    dec_ref r554
    if is_error(r556) goto L379 (error at <module>:179) else goto L273
L273:
    r557 = dank_mids._envs.create_env :: static
    if is_error(r557) goto L380 else goto L276
L274:
    r558 = raise NameError('value for final name "create_env" was not set')
    if not r558 goto L332 (error at <module>:177) else goto L275 :: bool
L275:
    unreachable
L276:
    r559 = object 5000
    r560 = box(bool, 0)
    r561 = [r551, r556, r559, r560]
    r562 = load_address r561
    r563 = ('default', 'verbose')
    r564 = PyObject_Vectorcall(r557, r562, 2, r563)
    if is_error(r564) goto L381 (error at <module>:177) else goto L277
L277:
    dec_ref r556
    r565 = CPyDict_Build(3, r519, r534, r535, r549, r550, r564)
    dec_ref r534
    dec_ref r549
    dec_ref r564
    if is_error(r565) goto L332 (error at <module>:164) else goto L278
L278:
    dank_mids.ENVIRONMENT_VARIABLES.method_semaphores = r565 :: static
    r566 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r567 = 'method_semaphores'
    r568 = CPyDict_SetItem(r566, r567, r565)
    dec_ref r565
    r569 = r568 >= 0 :: signed
    if not r569 goto L332 (error at <module>:164) else goto L279 :: bool
L279:
    r570 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r571 = 'typed_envs'
    r572 = CPyDict_GetItem(r570, r571)
    if is_error(r572) goto L332 (error at <module>:185) else goto L280
L280:
    r573 = 'logger'
    r574 = CPyObject_GetAttr(r572, r573)
    dec_ref r572
    if is_error(r574) goto L332 (error at <module>:185) else goto L281
L281:
    r575 = 'disabled'
    r576 = CPyObject_GetAttr(r574, r575)
    dec_ref r574
    if is_error(r576) goto L332 (error at <module>:185) else goto L282
L282:
    r577 = PyObject_IsTrue(r576)
    dec_ref r576
    r578 = r577 >= 0 :: signed
    if not r578 goto L332 (error at <module>:185) else goto L283 :: bool
L283:
    r579 = truncate r577: i32 to builtins.bool
    if r579 goto L292 else goto L284 :: bool
L284:
    r580 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r580) goto L285 else goto L287
L285:
    r581 = raise NameError('value for final name "logger" was not set')
    if not r581 goto L332 (error at <module>:186) else goto L286 :: bool
L286:
    unreachable
L287:
    r582 = 'More details can be found in dank_mids/ENVIRONMENT_VARIABLES.py'
    r583 = 'info'
    r584 = [r580, r582]
    r585 = load_address r584
    r586 = PyObject_VectorcallMethod(r583, r585, 9223372036854775810, 0)
    if is_error(r586) goto L332 (error at <module>:186) else goto L382
L288:
    r587 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r587) goto L289 else goto L291
L289:
    r588 = raise NameError('value for final name "logger" was not set')
    if not r588 goto L332 (error at <module>:187) else goto L290 :: bool
L290:
    unreachable
L291:
    r589 = 'NOTE: You can disable these logs by setting the `TYPEDENVS_SHUTUP` env var to any value.'
    r590 = 'info'
    r591 = [r587, r589]
    r592 = load_address r591
    r593 = PyObject_VectorcallMethod(r590, r592, 9223372036854775810, 0)
    if is_error(r593) goto L332 (error at <module>:187) else goto L383
L292:
    r594 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r594) goto L293 else goto L295
L293:
    r595 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r595 goto L332 (error at <module>:195) else goto L294 :: bool
L294:
    unreachable
L295:
    r596 = 'infura'
    r597 = CPyObject_GetAttr(r594, r596)
    if is_error(r597) goto L332 (error at <module>:195) else goto L296
L296:
    r598 = PyObject_IsTrue(r597)
    dec_ref r597
    r599 = r598 >= 0 :: signed
    if not r599 goto L332 (error at <module>:195) else goto L297 :: bool
L297:
    r600 = truncate r598: i32 to builtins.bool
    if r600 goto L302 else goto L298 :: bool
L298:
    r601 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r601) goto L299 else goto L301
L299:
    r602 = raise NameError('value for final name "logger" was not set')
    if not r602 goto L332 (error at <module>:196) else goto L300 :: bool
L300:
    unreachable
L301:
    r603 = "Unless you know what you're doing, dank mids should be run in infura mode for now"
    r604 = 'warning'
    r605 = [r601, r603]
    r606 = load_address r605
    r607 = PyObject_VectorcallMethod(r604, r606, 9223372036854775810, 0)
    if is_error(r607) goto L332 (error at <module>:196) else goto L384
L302:
    r608 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r608) goto L303 else goto L305
L303:
    r609 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r609 goto L332 (error at <module>:200) else goto L304 :: bool
L304:
    unreachable
L305:
    r610 = 'infura'
    r611 = CPyObject_GetAttr(r608, r610)
    if is_error(r611) goto L332 (error at <module>:200) else goto L306
L306:
    r612 = PyObject_IsTrue(r611)
    dec_ref r611
    r613 = r612 >= 0 :: signed
    if not r613 goto L332 (error at <module>:200) else goto L307 :: bool
L307:
    r614 = truncate r612: i32 to builtins.bool
    if r614 goto L308 else goto L331 :: bool
L308:
    r615 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r616 = 'MULTICALL_DECODER_PROCESSES'
    r617 = CPyDict_GetItem(r615, r616)
    if is_error(r617) goto L332 (error at <module>:202) else goto L309
L309:
    r618 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r619 = 'BROWNIE_DECODER_PROCESSES'
    r620 = CPyDict_GetItem(r618, r619)
    if is_error(r620) goto L385 (error at <module>:203) else goto L310
L310:
    r621 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r622 = 'BROWNIE_ENCODER_PROCESSES'
    r623 = CPyDict_GetItem(r621, r622)
    if is_error(r623) goto L386 (error at <module>:204) else goto L311
L311:
    r624 = PySet_New(0)
    if is_error(r624) goto L387 (error at <module>:201) else goto L312
L312:
    r625 = PySet_Add(r624, r617)
    dec_ref r617
    r626 = r625 >= 0 :: signed
    if not r626 goto L388 (error at <module>:201) else goto L313 :: bool
L313:
    r627 = PySet_Add(r624, r620)
    dec_ref r620
    r628 = r627 >= 0 :: signed
    if not r628 goto L389 (error at <module>:201) else goto L314 :: bool
L314:
    r629 = PySet_Add(r624, r623)
    dec_ref r623
    r630 = r629 >= 0 :: signed
    if not r630 goto L390 (error at <module>:201) else goto L315 :: bool
L315:
    r631 = PyObject_GetIter(r624)
    dec_ref r624
    if is_error(r631) goto L332 (error at <module>:201) else goto L316
L316:
    r632 = PyIter_Next(r631)
    if is_error(r632) goto L391 else goto L317
L317:
    r633 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r634 = 'process_pool'
    r635 = CPyDict_SetItem(r633, r634, r632)
    dec_ref r632
    r636 = r635 >= 0 :: signed
    if not r636 goto L392 (error at <module>:201) else goto L318 :: bool
L318:
    r637 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r638 = 'process_pool'
    r639 = CPyDict_GetItem(r637, r638)
    if is_error(r639) goto L392 (error at <module>:206) else goto L319
L319:
    r640 = '_max_workers'
    r641 = CPyObject_GetAttr(r639, r640)
    dec_ref r639
    if is_error(r641) goto L392 (error at <module>:206) else goto L320
L320:
    r642 = PyObject_IsTrue(r641)
    dec_ref r641
    r643 = r642 >= 0 :: signed
    if not r643 goto L392 (error at <module>:206) else goto L321 :: bool
L321:
    r644 = truncate r642: i32 to builtins.bool
    if r644 goto L393 else goto L316 :: bool
L322:
    r645 = 'You cannot set env var '
    r646 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r647 = 'process_pool'
    r648 = CPyDict_GetItem(r646, r647)
    if is_error(r648) goto L332 (error at <module>:208) else goto L323
L323:
    r649 = 'name'
    r650 = CPyObject_GetAttr(r648, r649)
    dec_ref r648
    if is_error(r650) goto L332 (error at <module>:208) else goto L324
L324:
    r651 = PyObject_Str(r650)
    dec_ref r650
    if is_error(r651) goto L332 (error at <module>:208) else goto L325
L325:
    r652 = ' while running dank in infura mode.'
    r653 = CPyStr_Build(3, r645, r651, r652)
    dec_ref r651
    if is_error(r653) goto L332 (error at <module>:208) else goto L326
L326:
    r654 = builtins :: module
    r655 = 'ValueError'
    r656 = CPyObject_GetAttr(r654, r655)
    if is_error(r656) goto L394 (error at <module>:207) else goto L327
L327:
    r657 = [r653]
    r658 = load_address r657
    r659 = PyObject_Vectorcall(r656, r658, 1, 0)
    dec_ref r656
    if is_error(r659) goto L394 (error at <module>:207) else goto L328
L328:
    dec_ref r653
    CPy_Raise(r659)
    dec_ref r659
    if not 0 goto L332 (error at <module>:207) else goto L329 :: bool
L329:
    unreachable
L330:
    r660 = CPy_NoErrOccurred()
    if not r660 goto L332 (error at <module>:201) else goto L331 :: bool
L331:
    return 1
L332:
    r661 = <error> :: None
    return r661
L333:
    dec_ref r76
    goto L332
L334:
    dec_ref r80
    goto L33
L335:
    dec_ref r86
    goto L332
L336:
    dec_ref r96
    goto L332
L337:
    dec_ref r99
    goto L50
L338:
    dec_ref r106
    goto L55
L339:
    dec_ref r110
    goto L57
L340:
    dec_ref r110
    goto L332
L341:
    dec_ref r273
    goto L121
L342:
    dec_ref r273
    goto L124
L343:
    dec_ref r273
    goto L332
L344:
    dec_ref r273
    goto L129
L345:
    dec_ref r297
    goto L135
L346:
    dec_ref r297
    goto L332
L347:
    dec_ref r297
    dec_ref r303
    goto L140
L348:
    dec_ref r297
    dec_ref r303
    goto L332
L349:
    dec_ref r297
    dec_ref r303
    goto L145
L350:
    dec_ref r325
    goto L151
L351:
    dec_ref r325
    goto L332
L352:
    dec_ref r325
    dec_ref r333 :: int
    goto L159
L353:
    dec_ref r325
    dec_ref r333 :: int
    goto L332
L354:
    dec_ref r325
    dec_ref r333 :: int
    goto L164
L355:
    dec_ref r325
    dec_ref r343
    goto L332
L356:
    dec_ref r356
    goto L170
L357:
    dec_ref r356
    goto L332
L358:
    dec_ref r356
    dec_ref r364 :: int
    goto L178
L359:
    dec_ref r356
    dec_ref r364 :: int
    goto L332
L360:
    dec_ref r356
    dec_ref r364 :: int
    goto L183
L361:
    dec_ref r356
    dec_ref r374
    goto L332
L362:
    dec_ref r387
    goto L189
L363:
    dec_ref r387
    goto L332
L364:
    dec_ref r387
    dec_ref r395 :: int
    goto L197
L365:
    dec_ref r387
    dec_ref r395 :: int
    goto L332
L366:
    dec_ref r387
    dec_ref r395 :: int
    goto L202
L367:
    dec_ref r387
    dec_ref r405
    goto L332
L368:
    dec_ref r424 :: int
    goto L215
L369:
    dec_ref r424 :: int
    goto L332
L370:
    dec_ref r424 :: int
    goto L220
L371:
    dec_ref r434
    goto L332
L372:
    dec_ref r523
    goto L258
L373:
    dec_ref r523
    goto L332
L374:
    dec_ref r523
    dec_ref r527
    goto L262
L375:
    dec_ref r523
    dec_ref r527
    goto L332
L376:
    dec_ref r534
    goto L332
L377:
    dec_ref r534
    dec_ref r541
    goto L268
L378:
    dec_ref r534
    dec_ref r541
    goto L332
L379:
    dec_ref r534
    dec_ref r549
    goto L332
L380:
    dec_ref r534
    dec_ref r549
    dec_ref r556
    goto L274
L381:
    dec_ref r534
    dec_ref r549
    dec_ref r556
    goto L332
L382:
    dec_ref r586
    goto L288
L383:
    dec_ref r593
    goto L292
L384:
    dec_ref r607
    goto L302
L385:
    dec_ref r617
    goto L332
L386:
    dec_ref r617
    dec_ref r620
    goto L332
L387:
    dec_ref r617
    dec_ref r620
    dec_ref r623
    goto L332
L388:
    dec_ref r620
    dec_ref r623
    dec_ref r624
    goto L332
L389:
    dec_ref r623
    dec_ref r624
    goto L332
L390:
    dec_ref r624
    goto L332
L391:
    dec_ref r631
    goto L330
L392:
    dec_ref r631
    goto L332
L393:
    dec_ref r631
    goto L322
L394:
    dec_ref r653
    goto L332

def coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    type, value, traceback, arg, r0, r1 :: object
    r2 :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_env
    r3 :: int
    r4 :: object
    r5 :: bit
    r6 :: dank_mids.brownie_patch.types.DankOverloadedMethod
    r7 :: tuple
    r8 :: str
    r9 :: object[2]
    r10 :: object_ptr
    r11 :: object
    r12 :: union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx]
    r13 :: bool
    r14 :: union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx]
    r15 :: tuple
    r16, r17 :: union[int, None]
    r18 :: union[dict, None]
    r19 :: str
    r20 :: object
    r21 :: list
    r22 :: object
    r23, r24, r25 :: str
    r26 :: tuple
    r27 :: dict
    r28, r29 :: object
    r30 :: bool
    r31, r32, r33, r34, r35 :: object
    r36 :: bool
    r37 :: object
    r38 :: bit
    r39 :: tuple[object, object, object]
    r40 :: bool
    r41 :: object_ptr
    r42 :: object
    r43 :: bool
    r44, r45, r46 :: tuple[object, object, object]
    r47 :: bit
    r48, r49, r50 :: object
    r51 :: bool
    r52, r53 :: bit
    r54 :: bool
    r55 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_env__
    if is_error(r2) goto L58 (error at coroutine:57) else goto L1
L1:
    r3 = r2.__mypyc_next_label__
    if is_error(r3) goto L59 (error at coroutine:57) else goto L53
L2:
    r4 = load_address _Py_NoneStruct
    r5 = type != r4
    if r5 goto L60 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L57 (error at coroutine:57) else goto L4 :: bool
L4:
    unreachable
L5:
    r6 = r2.self
    if is_error(r6) goto L59 (error at coroutine:75) else goto L6
L6:
    r7 = r2.args
    if is_error(r7) goto L61 (error at coroutine:75) else goto L7
L7:
    r8 = '_get_fn_from_args'
    r9 = [r6, r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775810, 0)
    if is_error(r11) goto L62 (error at coroutine:75) else goto L8
L8:
    dec_ref r6
    dec_ref r7
    r12 = cast(union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx], r11)
    if is_error(r12) goto L59 (error at coroutine:75) else goto L9
L9:
    r2.call = r12; r13 = is_error
    if not r13 goto L59 (error at coroutine:75) else goto L10 :: bool
L10:
    r14 = r2.call
    if is_error(r14) goto L59 (error at coroutine:76) else goto L11
L11:
    r15 = r2.args
    if is_error(r15) goto L63 (error at coroutine:77) else goto L12
L12:
    r16 = r2.block_identifier
    if is_error(r16) goto L64 (error at coroutine:77) else goto L13
L13:
    r17 = r2.decimals
    if is_error(r17) goto L65 (error at coroutine:77) else goto L14
L14:
    r18 = r2.override
    if is_error(r18) goto L66 (error at coroutine:77) else goto L15
L15:
    r19 = 'coroutine'
    r20 = CPyObject_GetAttr(r14, r19)
    dec_ref r14
    if is_error(r20) goto L67 (error at coroutine:76) else goto L16
L16:
    r21 = PyList_New(0)
    if is_error(r21) goto L68 (error at coroutine:76) else goto L17
L17:
    r22 = CPyList_Extend(r21, r15)
    dec_ref r15
    if is_error(r22) goto L69 (error at coroutine:76) else goto L70
L18:
    r23 = 'block_identifier'
    r24 = 'decimals'
    r25 = 'override'
    r26 = PyList_AsTuple(r21)
    dec_ref r21
    if is_error(r26) goto L71 (error at coroutine:76) else goto L19
L19:
    r27 = CPyDict_Build(3, r23, r16, r24, r17, r25, r18)
    dec_ref r16
    dec_ref r17
    dec_ref r18
    if is_error(r27) goto L72 (error at coroutine:76) else goto L20
L20:
    r28 = PyObject_Call(r20, r26, r27)
    dec_ref r20
    dec_ref r26
    dec_ref r27
    if is_error(r28) goto L59 (error at coroutine:76) else goto L21
L21:
    r29 = CPy_GetCoro(r28)
    dec_ref r28
    if is_error(r29) goto L59 (error at coroutine:76) else goto L22
L22:
    r2.__mypyc_temp__0 = r29; r30 = is_error
    if not r30 goto L59 (error at coroutine:-1) else goto L23 :: bool
L23:
    r31 = r2.__mypyc_temp__0
    if is_error(r31) goto L59 (error at coroutine:-1) else goto L24
L24:
    r32 = CPyIter_Next(r31)
    dec_ref r31
    if is_error(r32) goto L73 else goto L27
L25:
    r33 = CPy_FetchStopIterationValue()
    if is_error(r33) goto L74 (error at coroutine:76) else goto L26
L26:
    r34 = r33
    goto L50
L27:
    r35 = r32
L28:
    r2.__mypyc_next_label__ = 2; r36 = is_error
    if not r36 goto L75 (error at coroutine:76) else goto L76 :: bool
L29:
    return r35
L30:
    r37 = load_address _Py_NoneStruct
    r38 = type != r37
    if r38 goto L31 else goto L33 :: bool
L31:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L34 (error at coroutine:76) else goto L77 :: bool
L32:
    unreachable
L33:
    inc_ref arg
    goto L45
L34:
    r39 = CPy_CatchError()
    r2.__mypyc_temp__1 = r39; r40 = is_error
    if not r40 goto L78 (error at coroutine:-1) else goto L35 :: bool
L35:
    r41 = load_address r1
    r42 = r2.__mypyc_temp__0
    if is_error(r42) goto L78 (error at coroutine:-1) else goto L36
L36:
    r43 = CPy_YieldFromErrorHandle(r42, r41)
    dec_ref r42
    if is_error(r43) goto L78 (error at coroutine:76) else goto L37
L37:
    if r43 goto L40 else goto L38 :: bool
L38:
    inc_ref r1
    r35 = r1
    r44 = r2.__mypyc_temp__1
    if is_error(r44) goto L79 (error at coroutine:-1) else goto L39
L39:
    CPy_RestoreExcInfo(r44)
    dec_ref r44
    goto L28
L40:
    r34 = r1
    r45 = r2.__mypyc_temp__1
    if is_error(r45) goto L80 (error at coroutine:-1) else goto L41
L41:
    CPy_RestoreExcInfo(r45)
    dec_ref r45
    goto L50
L42:
    r46 = r2.__mypyc_temp__1
    dec_ref r2
    if is_error(r46) goto L57 (error at coroutine:-1) else goto L43
L43:
    CPy_RestoreExcInfo(r46)
    dec_ref r46
    r47 = CPy_KeepPropagating()
    if not r47 goto L57 else goto L44 :: bool
L44:
    unreachable
L45:
    r48 = r2.__mypyc_temp__0
    if is_error(r48) goto L81 (error at coroutine:-1) else goto L46
L46:
    r49 = CPyIter_Send(r48, arg)
    dec_ref r48
    dec_ref arg
    if is_error(r49) goto L82 else goto L47
L47:
    r35 = r49
    goto L28
L48:
    r50 = CPy_FetchStopIterationValue()
    if is_error(r50) goto L74 (error at coroutine:76) else goto L49
L49:
    r34 = r50
L50:
    r2.__mypyc_next_label__ = -2; r51 = is_error
    dec_ref r2
    if not r51 goto L83 (error at coroutine:76) else goto L51 :: bool
L51:
    CPyGen_SetStopIterationValue(r34)
    dec_ref r34
    if not 0 goto L57 else goto L52 :: bool
L52:
    unreachable
L53:
    r52 = r3 == 0
    if r52 goto L84 else goto L54 :: bool
L54:
    r53 = r3 == 2
    dec_ref r3 :: int
    if r53 goto L30 else goto L85 :: bool
L55:
    r54 = raise StopIteration
    if not r54 goto L57 (error at coroutine:57) else goto L56 :: bool
L56:
    unreachable
L57:
    r55 = <error> :: object
    return r55
L58:
    xdec_ref r1
    goto L57
L59:
    xdec_ref r1
    dec_ref r2
    goto L57
L60:
    xdec_ref r1
    dec_ref r2
    goto L3
L61:
    xdec_ref r1
    dec_ref r2
    dec_ref r6
    goto L57
L62:
    xdec_ref r1
    dec_ref r2
    dec_ref r6
    dec_ref r7
    goto L57
L63:
    xdec_ref r1
    dec_ref r2
    dec_ref r14
    goto L57
L64:
    xdec_ref r1
    dec_ref r2
    dec_ref r14
    dec_ref r15
    goto L57
L65:
    xdec_ref r1
    dec_ref r2
    dec_ref r14
    dec_ref r15
    dec_ref r16
    goto L57
L66:
    xdec_ref r1
    dec_ref r2
    dec_ref r14
    dec_ref r15
    dec_ref r16
    dec_ref r17
    goto L57
L67:
    xdec_ref r1
    dec_ref r2
    dec_ref r15
    dec_ref r16
    dec_ref r17
    dec_ref r18
    goto L57
L68:
    xdec_ref r1
    dec_ref r2
    dec_ref r15
    dec_ref r16
    dec_ref r17
    dec_ref r18
    dec_ref r20
    goto L57
L69:
    xdec_ref r1
    dec_ref r2
    dec_ref r16
    dec_ref r17
    dec_ref r18
    dec_ref r20
    dec_ref r21
    goto L57
L70:
    dec_ref r22
    goto L18
L71:
    xdec_ref r1
    dec_ref r2
    dec_ref r16
    dec_ref r17
    dec_ref r18
    dec_ref r20
    goto L57
L72:
    xdec_ref r1
    dec_ref r2
    dec_ref r20
    dec_ref r26
    goto L57
L73:
    xdec_ref r1
    goto L25
L74:
    dec_ref r2
    goto L57
L75:
    dec_ref r35
    goto L34
L76:
    xdec_ref r1
    dec_ref r2
    goto L29
L77:
    xdec_ref r1
    dec_ref r2
    goto L32
L78:
    xdec_ref r1
    goto L42
L79:
    xdec_ref r1
    dec_ref r35
    goto L42
L80:
    dec_ref r34
    goto L42
L81:
    xdec_ref r1
    dec_ref r2
    dec_ref arg
    goto L57
L82:
    xdec_ref r1
    goto L48
L83:
    dec_ref r34
    goto L57
L84:
    dec_ref r3 :: int
    goto L2
L85:
    xdec_ref r1
    dec_ref r2
    goto L55

def coroutine_DankOverloadedMethod_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine_DankOverloadedMethod_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine_DankOverloadedMethod_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine_DankOverloadedMethod_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutine_DankOverloadedMethod_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def coroutine_DankOverloadedMethod_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def DankOverloadedMethod.coroutine(self, args, block_identifier, decimals, override):
    self :: dank_mids.brownie_patch.types.DankOverloadedMethod
    args :: tuple
    block_identifier, decimals :: union[int, None]
    override :: union[dict, None]
    r0, r1, r2 :: object
    r3 :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_env
    r4, r5, r6, r7, r8 :: bool
    r9 :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    r10, r11 :: bool
    r12 :: object
L0:
    if is_error(block_identifier) goto L1 else goto L17
L1:
    r0 = box(None, 1)
    inc_ref r0
    block_identifier = r0
L2:
    if is_error(decimals) goto L3 else goto L18
L3:
    r1 = box(None, 1)
    inc_ref r1
    decimals = r1
L4:
    if is_error(override) goto L5 else goto L19
L5:
    r2 = box(None, 1)
    inc_ref r2
    override = r2
L6:
    r3 = coroutine_DankOverloadedMethod_env()
    if is_error(r3) goto L20 (error at coroutine:57) else goto L7
L7:
    inc_ref self
    r3.self = self; r4 = is_error
    if not r4 goto L21 (error at coroutine:57) else goto L8 :: bool
L8:
    inc_ref args
    r3.args = args; r5 = is_error
    if not r5 goto L21 (error at coroutine:57) else goto L9 :: bool
L9:
    r3.block_identifier = block_identifier; r6 = is_error
    if not r6 goto L22 (error at coroutine:57) else goto L10 :: bool
L10:
    r3.decimals = decimals; r7 = is_error
    if not r7 goto L23 (error at coroutine:57) else goto L11 :: bool
L11:
    r3.override = override; r8 = is_error
    if not r8 goto L24 (error at coroutine:57) else goto L12 :: bool
L12:
    r9 = coroutine_DankOverloadedMethod_gen()
    if is_error(r9) goto L24 (error at coroutine:57) else goto L13
L13:
    inc_ref r3
    r9.__mypyc_env__ = r3; r10 = is_error
    if not r10 goto L25 (error at coroutine:57) else goto L14 :: bool
L14:
    r3.__mypyc_next_label__ = 0; r11 = is_error
    dec_ref r3
    if not r11 goto L26 (error at coroutine:57) else goto L15 :: bool
L15:
    return r9
L16:
    r12 = <error> :: object
    return r12
L17:
    inc_ref block_identifier
    goto L2
L18:
    inc_ref decimals
    goto L4
L19:
    inc_ref override
    goto L6
L20:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    goto L16
L21:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r3
    goto L16
L22:
    dec_ref decimals
    dec_ref override
    dec_ref r3
    goto L16
L23:
    dec_ref override
    dec_ref r3
    goto L16
L24:
    dec_ref r3
    goto L16
L25:
    dec_ref r3
    dec_ref r9
    goto L16
L26:
    dec_ref r9
    goto L16

def DankOverloadedMethod._add_fn(self, abi, natspec):
    self :: dank_mids.brownie_patch.types.DankOverloadedMethod
    abi, natspec :: dict
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx]
    r8 :: list
    r9 :: str
    r10, r11, r12 :: object
    r13 :: str
    r14 :: object
    r15, r16, r17 :: str
    r18 :: object[3]
    r19 :: object_ptr
    r20 :: object
    r21 :: i32
    r22, r23 :: bit
    r24 :: tuple
    r25 :: dict
    r26 :: i32
    r27 :: bit
    r28 :: str
    r29 :: object
    r30 :: str
    r31 :: object[2]
    r32 :: object_ptr
    r33 :: object
    r34 :: None
L0:
    r0 = '_address'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L19 (error at _add_fn:91) else goto L1
L1:
    r2 = '_name'
    r3 = CPyObject_GetAttr(self, r2)
    if is_error(r3) goto L20 (error at _add_fn:91) else goto L2
L2:
    r4 = '_owner'
    r5 = CPyObject_GetAttr(self, r4)
    if is_error(r5) goto L21 (error at _add_fn:91) else goto L3
L3:
    r6 = cast(str, r3)
    if is_error(r6) goto L22 (error at _add_fn:91) else goto L4
L4:
    r7 = _get_method_object(r1, abi, r6, r5, natspec)
    dec_ref r1
    dec_ref r6
    dec_ref r5
    if is_error(r7) goto L19 (error at _add_fn:91) else goto L5
L5:
    r8 = PyList_New(0)
    if is_error(r8) goto L23 (error at _add_fn:92) else goto L6
L6:
    r9 = 'inputs'
    r10 = CPyDict_GetItem(abi, r9)
    if is_error(r10) goto L24 (error at _add_fn:92) else goto L7
L7:
    r11 = PyObject_GetIter(r10)
    dec_ref r10
    if is_error(r11) goto L24 (error at _add_fn:92) else goto L8
L8:
    r12 = PyIter_Next(r11)
    if is_error(r12) goto L25 else goto L9
L9:
    r13 = 'type'
    r14 = PyObject_GetItem(r12, r13)
    dec_ref r12
    if is_error(r14) goto L26 (error at _add_fn:92) else goto L10
L10:
    r15 = '256'
    r16 = ''
    r17 = 'replace'
    r18 = [r14, r15, r16]
    r19 = load_address r18
    r20 = PyObject_VectorcallMethod(r17, r19, 9223372036854775811, 0)
    if is_error(r20) goto L27 (error at _add_fn:92) else goto L11
L11:
    dec_ref r14
    r21 = PyList_Append(r8, r20)
    dec_ref r20
    r22 = r21 >= 0 :: signed
    if not r22 goto L26 (error at _add_fn:92) else goto L8 :: bool
L12:
    r23 = CPy_NoErrOccurred()
    if not r23 goto L24 (error at _add_fn:92) else goto L13 :: bool
L13:
    r24 = PyList_AsTuple(r8)
    dec_ref r8
    if is_error(r24) goto L23 (error at _add_fn:92) else goto L14
L14:
    r25 = self.methods
    if is_error(r25) goto L28 (error at _add_fn:93) else goto L15
L15:
    r26 = CPyDict_SetItem(r25, r24, r7)
    dec_ref r25
    dec_ref r24
    dec_ref r7
    r27 = r26 >= 0 :: signed
    if not r27 goto L19 (error at _add_fn:93) else goto L16 :: bool
L16:
    r28 = 'natspec'
    r29 = CPyObject_GetAttr(self, r28)
    if is_error(r29) goto L19 (error at _add_fn:94) else goto L17
L17:
    r30 = 'update'
    r31 = [r29, natspec]
    r32 = load_address r31
    r33 = PyObject_VectorcallMethod(r30, r32, 9223372036854775810, 0)
    if is_error(r33) goto L29 (error at _add_fn:94) else goto L30
L18:
    dec_ref r29
    return 1
L19:
    r34 = <error> :: None
    return r34
L20:
    dec_ref r1
    goto L19
L21:
    dec_ref r1
    dec_ref r3
    goto L19
L22:
    dec_ref r1
    dec_ref r5
    goto L19
L23:
    dec_ref r7
    goto L19
L24:
    dec_ref r7
    dec_ref r8
    goto L19
L25:
    dec_ref r11
    goto L12
L26:
    dec_ref r7
    dec_ref r8
    dec_ref r11
    goto L19
L27:
    dec_ref r7
    dec_ref r8
    dec_ref r11
    dec_ref r14
    goto L19
L28:
    dec_ref r7
    dec_ref r24
    goto L19
L29:
    dec_ref r29
    goto L19
L30:
    dec_ref r33
    goto L18

def _get_method_object(address, abi, name, owner, natspec):
    address :: object
    abi :: dict
    name :: str
    owner :: union[object, None]
    natspec :: dict
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4 :: str
    r5, constant :: object
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10, r11 :: bool
    r12 :: str
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: bool
    r17 :: object
    r18 :: i32
    r19 :: bit
    r20 :: bool
    r21 :: tuple
    r22 :: dict
    r23 :: dank_mids.brownie_patch.types.DankContractCall
    r24 :: tuple
    r25 :: dict
    r26 :: dank_mids.brownie_patch.types.DankContractTx
    r27 :: union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx]
L0:
    r0 = 'constant'
    r1 = PyDict_Contains(abi, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L24 (error at _get_method_object:131) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L2 else goto L4 :: bool
L2:
    r4 = 'constant'
    r5 = CPyDict_GetItem(abi, r4)
    if is_error(r5) goto L24 (error at _get_method_object:132) else goto L3
L3:
    constant = r5
    goto L14
L4:
    r6 = 'stateMutability'
    r7 = CPyDict_GetItem(abi, r6)
    if is_error(r7) goto L24 (error at _get_method_object:134) else goto L5
L5:
    r8 = 'view'
    r9 = PyObject_RichCompare(r7, r8, 2)
    dec_ref r7
    if is_error(r9) goto L24 (error at _get_method_object:-1) else goto L6
L6:
    r10 = unbox(bool, r9)
    dec_ref r9
    if is_error(r10) goto L24 (error at _get_method_object:-1) else goto L7
L7:
    if r10 goto L8 else goto L9 :: bool
L8:
    r11 = r10
    goto L13
L9:
    r12 = 'stateMutability'
    r13 = CPyDict_GetItem(abi, r12)
    if is_error(r13) goto L24 (error at _get_method_object:134) else goto L10
L10:
    r14 = 'pure'
    r15 = PyObject_RichCompare(r13, r14, 2)
    dec_ref r13
    if is_error(r15) goto L24 (error at _get_method_object:-1) else goto L11
L11:
    r16 = unbox(bool, r15)
    dec_ref r15
    if is_error(r16) goto L24 (error at _get_method_object:-1) else goto L12
L12:
    r11 = r16
L13:
    r17 = box(bool, r11)
    inc_ref r17
    constant = r17
L14:
    r18 = PyObject_IsTrue(constant)
    dec_ref constant
    r19 = r18 >= 0 :: signed
    if not r19 goto L24 (error at _get_method_object:132) else goto L15 :: bool
L15:
    r20 = truncate r18: i32 to builtins.bool
    if r20 goto L16 else goto L20 :: bool
L16:
    r21 = PyTuple_Pack(5, address, abi, name, owner, natspec)
    if is_error(r21) goto L24 (error at _get_method_object:137) else goto L17
L17:
    r22 = PyDict_New()
    if is_error(r22) goto L25 (error at _get_method_object:137) else goto L18
L18:
    r23 = DankContractCall(r21, r22)
    dec_ref r21
    dec_ref r22
    if is_error(r23) goto L24 (error at _get_method_object:137) else goto L19
L19:
    return r23
L20:
    r24 = PyTuple_Pack(5, address, abi, name, owner, natspec)
    if is_error(r24) goto L24 (error at _get_method_object:138) else goto L21
L21:
    r25 = PyDict_New()
    if is_error(r25) goto L26 (error at _get_method_object:138) else goto L22
L22:
    r26 = DankContractTx(r24, r25)
    dec_ref r24
    dec_ref r25
    if is_error(r26) goto L24 (error at _get_method_object:138) else goto L23
L23:
    return r26
L24:
    r27 = <error> :: union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx]
    return r27
L25:
    dec_ref r21
    goto L24
L26:
    dec_ref r24
    goto L24

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24 :: object
    r25 :: str
    r26 :: dict
    r27 :: str
    r28 :: object
    r29 :: object[1]
    r30 :: object_ptr
    r31 :: object
    r32 :: dict
    r33 :: str
    r34 :: i32
    r35 :: bit
    r36 :: dict
    r37 :: str
    r38 :: object
    r39 :: dict
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: object
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: tuple[object, object, object]
    r49, r50 :: object
    r51 :: dict
    r52 :: str
    r53 :: i32
    r54 :: bit
    r55 :: dict
    r56 :: str
    r57 :: object
    r58 :: dict
    r59 :: str
    r60 :: object
    r61 :: tuple
    r62 :: str
    r63, r64 :: object
    r65 :: bool
    r66, r67 :: str
    r68 :: tuple
    r69 :: i32
    r70 :: bit
    r71 :: dict
    r72 :: str
    r73 :: i32
    r74 :: bit
    r75 :: dict
    r76 :: str
    r77 :: object
    r78 :: dict
    r79 :: str
    r80 :: object
    r81 :: tuple
    r82 :: str
    r83, r84 :: object
    r85 :: bool
    r86, r87 :: str
    r88 :: tuple
    r89 :: i32
    r90 :: bit
    r91 :: dict
    r92 :: str
    r93 :: i32
    r94 :: bit
    r95 :: dict
    r96 :: str
    r97, r98, r99 :: object
    r100 :: tuple[object, object]
    r101, r102 :: object
    r103 :: dict
    r104 :: str
    r105 :: i32
    r106 :: bit
    r107 :: dict
    r108 :: str
    r109 :: object
    r110 :: dict
    r111 :: str
    r112 :: object
    r113 :: dict
    r114 :: str
    r115, r116 :: object
    r117 :: tuple
    r118 :: str
    r119, r120 :: object
    r121 :: bool
    r122, r123, r124 :: str
    r125 :: tuple
    r126 :: i32
    r127 :: bit
    r128 :: dict
    r129 :: str
    r130 :: i32
    r131 :: bit
    r132 :: dict
    r133 :: str
    r134, r135, r136, r137 :: object
    r138 :: tuple[object, object, object]
    r139, r140 :: object
    r141 :: dict
    r142 :: str
    r143 :: i32
    r144 :: bit
    r145 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L50 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Dict', 'Optional', 'Tuple', 'TypeVar', 'Union', 'final')
    r6 = 'typing'
    r7 = dank_mids.brownie_patch.types.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L50 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ContractCall', 'ContractTx', 'OverloadedMethod')
    r10 = 'brownie.network.contract'
    r11 = dank_mids.brownie_patch.types.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L50 (error at <module>:3) else goto L5
L5:
    brownie.network.contract = r12 :: module
    dec_ref r12
    r13 = ('AccountsType',)
    r14 = 'brownie.typing'
    r15 = dank_mids.brownie_patch.types.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L50 (error at <module>:4) else goto L6
L6:
    brownie.typing = r16 :: module
    dec_ref r16
    r17 = ('ChecksumAddress',)
    r18 = 'eth_typing'
    r19 = dank_mids.brownie_patch.types.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L50 (error at <module>:5) else goto L7
L7:
    eth_typing = r20 :: module
    dec_ref r20
    r21 = ('_DankMethod', '_DankMethodMixin', '_EVMType')
    r22 = 'dank_mids.brownie_patch._method'
    r23 = dank_mids.brownie_patch.types.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L50 (error at <module>:7) else goto L8
L8:
    dank_mids.brownie_patch._method = r24 :: module
    dec_ref r24
    r25 = '_T'
    r26 = dank_mids.brownie_patch.types.globals :: static
    r27 = 'TypeVar'
    r28 = CPyDict_GetItem(r26, r27)
    if is_error(r28) goto L50 (error at <module>:10) else goto L9
L9:
    r29 = [r25]
    r30 = load_address r29
    r31 = PyObject_Vectorcall(r28, r30, 1, 0)
    dec_ref r28
    if is_error(r31) goto L50 (error at <module>:10) else goto L10
L10:
    r32 = dank_mids.brownie_patch.types.globals :: static
    r33 = '_T'
    r34 = CPyDict_SetItem(r32, r33, r31)
    dec_ref r31
    r35 = r34 >= 0 :: signed
    if not r35 goto L50 (error at <module>:10) else goto L11 :: bool
L11:
    r36 = dank_mids.brownie_patch.types.globals :: static
    r37 = 'Union'
    r38 = CPyDict_GetItem(r36, r37)
    if is_error(r38) goto L50 (error at <module>:12) else goto L12
L12:
    r39 = dank_mids.brownie_patch.types.globals :: static
    r40 = 'ContractCall'
    r41 = CPyDict_GetItem(r39, r40)
    if is_error(r41) goto L51 (error at <module>:12) else goto L13
L13:
    r42 = dank_mids.brownie_patch.types.globals :: static
    r43 = 'ContractTx'
    r44 = CPyDict_GetItem(r42, r43)
    if is_error(r44) goto L52 (error at <module>:12) else goto L14
L14:
    r45 = dank_mids.brownie_patch.types.globals :: static
    r46 = 'OverloadedMethod'
    r47 = CPyDict_GetItem(r45, r46)
    if is_error(r47) goto L53 (error at <module>:12) else goto L15
L15:
    r48 = (r41, r44, r47)
    r49 = box(tuple[object, object, object], r48)
    r50 = PyObject_GetItem(r38, r49)
    dec_ref r38
    dec_ref r49
    if is_error(r50) goto L50 (error at <module>:12) else goto L16
L16:
    r51 = dank_mids.brownie_patch.types.globals :: static
    r52 = 'ContractMethod'
    r53 = CPyDict_SetItem(r51, r52, r50)
    dec_ref r50
    r54 = r53 >= 0 :: signed
    if not r54 goto L50 (error at <module>:12) else goto L17 :: bool
L17:
    r55 = dank_mids.brownie_patch.types.globals :: static
    r56 = '_DankMethod'
    r57 = CPyDict_GetItem(r55, r56)
    if is_error(r57) goto L50 (error at <module>:17) else goto L18
L18:
    r58 = dank_mids.brownie_patch.types.globals :: static
    r59 = 'ContractCall'
    r60 = CPyDict_GetItem(r58, r59)
    if is_error(r60) goto L54 (error at <module>:17) else goto L19
L19:
    r61 = PyTuple_Pack(2, r57, r60)
    dec_ref r57
    dec_ref r60
    if is_error(r61) goto L50 (error at <module>:17) else goto L20
L20:
    r62 = 'dank_mids.brownie_patch.types'
    r63 = dank_mids.brownie_patch.types.DankContractCall_template :: type
    r64 = CPyType_FromTemplate(r63, r61, r62)
    dec_ref r61
    if is_error(r64) goto L50 (error at <module>:17) else goto L21
L21:
    r65 = DankContractCall_trait_vtable_setup()
    if is_error(r65) goto L55 (error at <module>:-1) else goto L22
L22:
    r66 = '__mypyc_attrs__'
    r67 = '__dict__'
    r68 = PyTuple_Pack(1, r67)
    if is_error(r68) goto L55 (error at <module>:17) else goto L23
L23:
    r69 = PyObject_SetAttr(r64, r66, r68)
    dec_ref r68
    r70 = r69 >= 0 :: signed
    if not r70 goto L55 (error at <module>:17) else goto L24 :: bool
L24:
    dank_mids.brownie_patch.types.DankContractCall = r64 :: type
    r71 = dank_mids.brownie_patch.types.globals :: static
    r72 = 'DankContractCall'
    r73 = CPyDict_SetItem(r71, r72, r64)
    dec_ref r64
    r74 = r73 >= 0 :: signed
    if not r74 goto L50 (error at <module>:17) else goto L25 :: bool
L25:
    r75 = dank_mids.brownie_patch.types.globals :: static
    r76 = '_DankMethod'
    r77 = CPyDict_GetItem(r75, r76)
    if is_error(r77) goto L50 (error at <module>:29) else goto L26
L26:
    r78 = dank_mids.brownie_patch.types.globals :: static
    r79 = 'ContractTx'
    r80 = CPyDict_GetItem(r78, r79)
    if is_error(r80) goto L56 (error at <module>:29) else goto L27
L27:
    r81 = PyTuple_Pack(2, r77, r80)
    dec_ref r77
    dec_ref r80
    if is_error(r81) goto L50 (error at <module>:29) else goto L28
L28:
    r82 = 'dank_mids.brownie_patch.types'
    r83 = dank_mids.brownie_patch.types.DankContractTx_template :: type
    r84 = CPyType_FromTemplate(r83, r81, r82)
    dec_ref r81
    if is_error(r84) goto L50 (error at <module>:29) else goto L29
L29:
    r85 = DankContractTx_trait_vtable_setup()
    if is_error(r85) goto L57 (error at <module>:-1) else goto L30
L30:
    r86 = '__mypyc_attrs__'
    r87 = '__dict__'
    r88 = PyTuple_Pack(1, r87)
    if is_error(r88) goto L57 (error at <module>:29) else goto L31
L31:
    r89 = PyObject_SetAttr(r84, r86, r88)
    dec_ref r88
    r90 = r89 >= 0 :: signed
    if not r90 goto L57 (error at <module>:29) else goto L32 :: bool
L32:
    dank_mids.brownie_patch.types.DankContractTx = r84 :: type
    r91 = dank_mids.brownie_patch.types.globals :: static
    r92 = 'DankContractTx'
    r93 = CPyDict_SetItem(r91, r92, r84)
    dec_ref r84
    r94 = r93 >= 0 :: signed
    if not r94 goto L50 (error at <module>:29) else goto L33 :: bool
L33:
    r95 = dank_mids.brownie_patch.types.globals :: static
    r96 = 'Union'
    r97 = CPyDict_GetItem(r95, r96)
    if is_error(r97) goto L50 (error at <module>:40) else goto L34
L34:
    r98 = dank_mids.brownie_patch.types.DankContractCall :: type
    r99 = dank_mids.brownie_patch.types.DankContractTx :: type
    inc_ref r98
    inc_ref r99
    r100 = (r98, r99)
    r101 = box(tuple[object, object], r100)
    r102 = PyObject_GetItem(r97, r101)
    dec_ref r97
    dec_ref r101
    if is_error(r102) goto L50 (error at <module>:40) else goto L35
L35:
    r103 = dank_mids.brownie_patch.types.globals :: static
    r104 = '_NonOverloaded'
    r105 = CPyDict_SetItem(r103, r104, r102)
    dec_ref r102
    r106 = r105 >= 0 :: signed
    if not r106 goto L50 (error at <module>:40) else goto L36 :: bool
L36:
    r107 = dank_mids.brownie_patch.types.globals :: static
    r108 = 'OverloadedMethod'
    r109 = CPyDict_GetItem(r107, r108)
    if is_error(r109) goto L50 (error at <module>:45) else goto L37
L37:
    r110 = dank_mids.brownie_patch.types.globals :: static
    r111 = '_DankMethodMixin'
    r112 = CPyDict_GetItem(r110, r111)
    if is_error(r112) goto L58 (error at <module>:45) else goto L38
L38:
    r113 = dank_mids.brownie_patch.types.globals :: static
    r114 = '_T'
    r115 = CPyDict_GetItem(r113, r114)
    if is_error(r115) goto L59 (error at <module>:45) else goto L39
L39:
    r116 = PyObject_GetItem(r112, r115)
    dec_ref r112
    dec_ref r115
    if is_error(r116) goto L58 (error at <module>:45) else goto L40
L40:
    r117 = PyTuple_Pack(2, r109, r116)
    dec_ref r109
    dec_ref r116
    if is_error(r117) goto L50 (error at <module>:45) else goto L41
L41:
    r118 = 'dank_mids.brownie_patch.types'
    r119 = dank_mids.brownie_patch.types.DankOverloadedMethod_template :: type
    r120 = CPyType_FromTemplate(r119, r117, r118)
    dec_ref r117
    if is_error(r120) goto L50 (error at <module>:45) else goto L42
L42:
    r121 = DankOverloadedMethod_trait_vtable_setup()
    if is_error(r121) goto L60 (error at <module>:-1) else goto L43
L43:
    r122 = '__mypyc_attrs__'
    r123 = 'methods'
    r124 = '__dict__'
    r125 = PyTuple_Pack(2, r123, r124)
    if is_error(r125) goto L60 (error at <module>:45) else goto L44
L44:
    r126 = PyObject_SetAttr(r120, r122, r125)
    dec_ref r125
    r127 = r126 >= 0 :: signed
    if not r127 goto L60 (error at <module>:45) else goto L45 :: bool
L45:
    dank_mids.brownie_patch.types.DankOverloadedMethod = r120 :: type
    r128 = dank_mids.brownie_patch.types.globals :: static
    r129 = 'DankOverloadedMethod'
    r130 = CPyDict_SetItem(r128, r129, r120)
    dec_ref r120
    r131 = r130 >= 0 :: signed
    if not r131 goto L50 (error at <module>:45) else goto L46 :: bool
L46:
    r132 = dank_mids.brownie_patch.types.globals :: static
    r133 = 'Union'
    r134 = CPyDict_GetItem(r132, r133)
    if is_error(r134) goto L50 (error at <module>:97) else goto L47
L47:
    r135 = dank_mids.brownie_patch.types.DankContractCall :: type
    r136 = dank_mids.brownie_patch.types.DankContractTx :: type
    r137 = dank_mids.brownie_patch.types.DankOverloadedMethod :: type
    inc_ref r135
    inc_ref r136
    inc_ref r137
    r138 = (r135, r136, r137)
    r139 = box(tuple[object, object, object], r138)
    r140 = PyObject_GetItem(r134, r139)
    dec_ref r134
    dec_ref r139
    if is_error(r140) goto L50 (error at <module>:97) else goto L48
L48:
    r141 = dank_mids.brownie_patch.types.globals :: static
    r142 = 'DankContractMethod'
    r143 = CPyDict_SetItem(r141, r142, r140)
    dec_ref r140
    r144 = r143 >= 0 :: signed
    if not r144 goto L50 (error at <module>:97) else goto L49 :: bool
L49:
    return 1
L50:
    r145 = <error> :: None
    return r145
L51:
    dec_ref r38
    goto L50
L52:
    dec_ref r38
    dec_ref r41
    goto L50
L53:
    dec_ref r38
    dec_ref r41
    dec_ref r44
    goto L50
L54:
    dec_ref r57
    goto L50
L55:
    dec_ref r64
    goto L50
L56:
    dec_ref r77
    goto L50
L57:
    dec_ref r84
    goto L50
L58:
    dec_ref r109
    goto L50
L59:
    dec_ref r109
    dec_ref r112
    goto L50
L60:
    dec_ref r120
    goto L50

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: object_ptr
    r10 :: object_ptr[1]
    r11 :: c_ptr
    r12 :: native_int[1]
    r13 :: c_ptr
    r14 :: object
    r15 :: dict
    r16, r17 :: str
    r18 :: bit
    r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26 :: object
    r27 :: str
    r28 :: dict
    r29 :: str
    r30 :: object
    r31 :: object[1]
    r32 :: object_ptr
    r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: i32
    r37 :: bit
    r38 :: object
    r39 :: bool
    r40 :: dict
    r41 :: str
    r42 :: object
    r43 :: str
    r44, r45 :: object
    r46 :: str
    r47 :: object[3]
    r48 :: object_ptr
    r49, r50 :: object
    r51 :: bool
    r52 :: dict
    r53 :: str
    r54 :: object
    r55 :: str
    r56, r57 :: object
    r58 :: str
    r59 :: object[3]
    r60 :: object_ptr
    r61, r62 :: object
    r63 :: bool
    r64 :: dict
    r65 :: str
    r66, r67 :: object
    r68 :: str
    r69 :: object[3]
    r70 :: object_ptr
    r71, r72 :: object
    r73 :: bool
    r74 :: str
    r75 :: object
    r76 :: dict
    r77 :: str
    r78 :: i32
    r79 :: bit
    r80 :: str
    r81 :: dict
    r82 :: str
    r83 :: object
    r84 :: object[1]
    r85 :: object_ptr
    r86 :: object
    r87 :: dict
    r88 :: str
    r89 :: i32
    r90 :: bit
    r91 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L36 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = dank_mids._envs.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L36 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address a_sync :: module
    r10 = [r9]
    r11 = load_address r10
    r12 = [3]
    r13 = load_address r12
    r14 = (('a_sync', 'a_sync', 'a_sync'),)
    r15 = dank_mids._envs.globals :: static
    r16 = 'dank_mids\\_envs.py'
    r17 = '<module>'
    r18 = CPyImport_ImportMany(r14, r11, r15, r16, r17, r13)
    if not r18 goto L36 else goto L5 :: bool
L5:
    r19 = ('EnvVarFactory',)
    r20 = 'typed_envs'
    r21 = dank_mids._envs.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L36 (error at <module>:4) else goto L6
L6:
    typed_envs = r22 :: module
    dec_ref r22
    r23 = ('BlockSemaphore',)
    r24 = 'dank_mids.semaphores'
    r25 = dank_mids._envs.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L36 (error at <module>:6) else goto L7
L7:
    dank_mids.semaphores = r26 :: module
    dec_ref r26
    r27 = 'DANKMIDS'
    r28 = dank_mids._envs.globals :: static
    r29 = 'EnvVarFactory'
    r30 = CPyDict_GetItem(r28, r29)
    if is_error(r30) goto L36 (error at <module>:9) else goto L8
L8:
    r31 = [r27]
    r32 = load_address r31
    r33 = PyObject_Vectorcall(r30, r32, 1, 0)
    dec_ref r30
    if is_error(r33) goto L36 (error at <module>:9) else goto L9
L9:
    dank_mids._envs._factory = r33 :: static
    r34 = dank_mids._envs.globals :: static
    r35 = '_factory'
    r36 = CPyDict_SetItem(r34, r35, r33)
    dec_ref r33
    r37 = r36 >= 0 :: signed
    if not r37 goto L36 (error at <module>:9) else goto L10 :: bool
L10:
    r38 = dank_mids._envs._factory :: static
    if is_error(r38) goto L11 else goto L13
L11:
    r39 = raise NameError('value for final name "_factory" was not set')
    if not r39 goto L36 (error at <module>:13) else goto L12 :: bool
L12:
    unreachable
L13:
    r40 = dank_mids._envs.globals :: static
    r41 = 'a_sync'
    r42 = CPyDict_GetItem(r40, r41)
    if is_error(r42) goto L36 (error at <module>:13) else goto L14
L14:
    r43 = 'Semaphore'
    r44 = CPyObject_GetAttr(r42, r43)
    dec_ref r42
    if is_error(r44) goto L36 (error at <module>:13) else goto L15
L15:
    r45 = load_address PyLong_Type
    r46 = 'register_string_converter'
    r47 = [r38, r44, r45]
    r48 = load_address r47
    r49 = PyObject_VectorcallMethod(r46, r48, 9223372036854775811, 0)
    if is_error(r49) goto L37 (error at <module>:13) else goto L38
L16:
    dec_ref r44
    r50 = dank_mids._envs._factory :: static
    if is_error(r50) goto L17 else goto L19
L17:
    r51 = raise NameError('value for final name "_factory" was not set')
    if not r51 goto L36 (error at <module>:14) else goto L18 :: bool
L18:
    unreachable
L19:
    r52 = dank_mids._envs.globals :: static
    r53 = 'a_sync'
    r54 = CPyDict_GetItem(r52, r53)
    if is_error(r54) goto L36 (error at <module>:14) else goto L20
L20:
    r55 = 'ProcessPoolExecutor'
    r56 = CPyObject_GetAttr(r54, r55)
    dec_ref r54
    if is_error(r56) goto L36 (error at <module>:14) else goto L21
L21:
    r57 = load_address PyLong_Type
    r58 = 'register_string_converter'
    r59 = [r50, r56, r57]
    r60 = load_address r59
    r61 = PyObject_VectorcallMethod(r58, r60, 9223372036854775811, 0)
    if is_error(r61) goto L39 (error at <module>:14) else goto L40
L22:
    dec_ref r56
    r62 = dank_mids._envs._factory :: static
    if is_error(r62) goto L23 else goto L25
L23:
    r63 = raise NameError('value for final name "_factory" was not set')
    if not r63 goto L36 (error at <module>:15) else goto L24 :: bool
L24:
    unreachable
L25:
    r64 = dank_mids._envs.globals :: static
    r65 = 'BlockSemaphore'
    r66 = CPyDict_GetItem(r64, r65)
    if is_error(r66) goto L36 (error at <module>:15) else goto L26
L26:
    r67 = load_address PyLong_Type
    r68 = 'register_string_converter'
    r69 = [r62, r66, r67]
    r70 = load_address r69
    r71 = PyObject_VectorcallMethod(r68, r70, 9223372036854775811, 0)
    if is_error(r71) goto L41 (error at <module>:15) else goto L42
L27:
    dec_ref r66
    r72 = dank_mids._envs._factory :: static
    if is_error(r72) goto L28 else goto L30
L28:
    r73 = raise NameError('value for final name "_factory" was not set')
    if not r73 goto L36 (error at <module>:17) else goto L29 :: bool
L29:
    unreachable
L30:
    r74 = 'create_env'
    r75 = CPyObject_GetAttr(r72, r74)
    if is_error(r75) goto L36 (error at <module>:17) else goto L31
L31:
    dank_mids._envs.create_env = r75 :: static
    r76 = dank_mids._envs.globals :: static
    r77 = 'create_env'
    r78 = CPyDict_SetItem(r76, r77, r75)
    dec_ref r75
    r79 = r78 >= 0 :: signed
    if not r79 goto L36 (error at <module>:17) else goto L32 :: bool
L32:
    r80 = 'DANK_MIDS'
    r81 = dank_mids._envs.globals :: static
    r82 = 'EnvVarFactory'
    r83 = CPyDict_GetItem(r81, r82)
    if is_error(r83) goto L36 (error at <module>:20) else goto L33
L33:
    r84 = [r80]
    r85 = load_address r84
    r86 = PyObject_Vectorcall(r83, r85, 1, 0)
    dec_ref r83
    if is_error(r86) goto L36 (error at <module>:20) else goto L34
L34:
    dank_mids._envs._deprecated_format = r86 :: static
    r87 = dank_mids._envs.globals :: static
    r88 = '_deprecated_format'
    r89 = CPyDict_SetItem(r87, r88, r86)
    dec_ref r86
    r90 = r89 >= 0 :: signed
    if not r90 goto L36 (error at <module>:20) else goto L35 :: bool
L35:
    return 1
L36:
    r91 = <error> :: None
    return r91
L37:
    dec_ref r44
    goto L36
L38:
    dec_ref r49
    goto L16
L39:
    dec_ref r56
    goto L36
L40:
    dec_ref r61
    goto L22
L41:
    dec_ref r66
    goto L36
L42:
    dec_ref r71
    goto L27

def __mypyc_lambda__0_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__0_obj.__call__(__mypyc_self__, self, args):
    __mypyc_self__ :: dank_mids.brownie_patch.call.__mypyc_lambda__0_obj
    self, args :: object
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: list
    r15, r16, r17, r18 :: ptr
    r19 :: object
    r20 :: tuple
    r21 :: dict
    r22, r23 :: object
L0:
    r0 = dank_mids.brownie_patch.call.globals :: static
    r1 = 'ENVS'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L12 (error at <lambda>:82) else goto L1
L1:
    r3 = 'BROWNIE_ENCODER_PROCESSES'
    r4 = CPyObject_GetAttr(r2, r3)
    dec_ref r2
    if is_error(r4) goto L12 (error at <lambda>:82) else goto L2
L2:
    r5 = dank_mids.brownie_patch.call.globals :: static
    r6 = '__encode_input'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L13 (error at <lambda>:82) else goto L3
L3:
    r8 = 'abi'
    r9 = CPyObject_GetAttr(self, r8)
    if is_error(r9) goto L14 (error at <lambda>:82) else goto L4
L4:
    r10 = 'signature'
    r11 = CPyObject_GetAttr(self, r10)
    if is_error(r11) goto L15 (error at <lambda>:82) else goto L5
L5:
    r12 = 'run'
    r13 = CPyObject_GetAttr(r4, r12)
    dec_ref r4
    if is_error(r13) goto L16 (error at <lambda>:82) else goto L6
L6:
    r14 = PyList_New(3)
    if is_error(r14) goto L17 (error at <lambda>:82) else goto L7
L7:
    r15 = get_element_ptr r14 ob_item :: PyListObject
    r16 = load_mem r15 :: ptr*
    set_mem r16, r7 :: builtins.object*
    r17 = r16 + 8
    set_mem r17, r9 :: builtins.object*
    r18 = r16 + 16
    set_mem r18, r11 :: builtins.object*
    r19 = CPyList_Extend(r14, args)
    if is_error(r19) goto L18 (error at <lambda>:82) else goto L19
L8:
    r20 = PyList_AsTuple(r14)
    dec_ref r14
    if is_error(r20) goto L20 (error at <lambda>:82) else goto L9
L9:
    r21 = PyDict_New()
    if is_error(r21) goto L21 (error at <lambda>:82) else goto L10
L10:
    r22 = PyObject_Call(r13, r20, r21)
    dec_ref r13
    dec_ref r20
    dec_ref r21
    if is_error(r22) goto L12 (error at <lambda>:82) else goto L11
L11:
    return r22
L12:
    r23 = <error> :: object
    return r23
L13:
    dec_ref r4
    goto L12
L14:
    dec_ref r4
    dec_ref r7
    goto L12
L15:
    dec_ref r4
    dec_ref r7
    dec_ref r9
    goto L12
L16:
    dec_ref r7
    dec_ref r9
    dec_ref r11
    goto L12
L17:
    dec_ref r7
    dec_ref r9
    dec_ref r11
    dec_ref r13
    goto L12
L18:
    dec_ref r13
    dec_ref r14
    goto L12
L19:
    dec_ref r19
    goto L8
L20:
    dec_ref r13
    goto L12
L21:
    dec_ref r13
    dec_ref r20
    goto L12

def __mypyc_lambda__1_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__1_obj.__call__(__mypyc_self__, self, data):
    __mypyc_self__ :: dank_mids.brownie_patch.call.__mypyc_lambda__1_obj
    self :: object
    data :: bytes
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: str
    r11 :: object[4]
    r12 :: object_ptr
    r13, r14 :: object
L0:
    r0 = dank_mids.brownie_patch.call.globals :: static
    r1 = 'ENVS'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L6 (error at <lambda>:101) else goto L1
L1:
    r3 = 'BROWNIE_DECODER_PROCESSES'
    r4 = CPyObject_GetAttr(r2, r3)
    dec_ref r2
    if is_error(r4) goto L6 (error at <lambda>:101) else goto L2
L2:
    r5 = dank_mids.brownie_patch.call.globals :: static
    r6 = '__decode_output'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L7 (error at <lambda>:101) else goto L3
L3:
    r8 = 'abi'
    r9 = CPyObject_GetAttr(self, r8)
    if is_error(r9) goto L8 (error at <lambda>:101) else goto L4
L4:
    r10 = 'run'
    r11 = [r4, r7, data, r9]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775812, 0)
    if is_error(r13) goto L9 (error at <lambda>:101) else goto L5
L5:
    dec_ref r4
    dec_ref r7
    dec_ref r9
    return r13
L6:
    r14 = <error> :: object
    return r14
L7:
    dec_ref r4
    goto L6
L8:
    dec_ref r4
    dec_ref r7
    goto L6
L9:
    dec_ref r4
    dec_ref r7
    dec_ref r9
    goto L6

def _patch_call(call, w3):
    call, w3 :: object
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: set
    r6 :: i32
    r7 :: bit
    r8 :: bool
    r9 :: str
    r10 :: object
    r11 :: i32
    r12 :: bit
    r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: int
    r18 :: dict
    r19 :: str
    r20, r21 :: object
    r22 :: object[2]
    r23 :: object_ptr
    r24 :: object
    r25 :: dict
    r26 :: str
    r27 :: object
    r28 :: object[2]
    r29 :: object_ptr
    r30 :: object
    r31 :: str
    r32 :: i32
    r33 :: bit
    r34 :: dict
    r35 :: str
    r36 :: object
    r37 :: dict
    r38 :: str
    r39 :: object
    r40 :: object[2]
    r41 :: object_ptr
    r42 :: object
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: None
L0:
    r0 = '_address'
    r1 = CPyObject_GetAttr(call, r0)
    if is_error(r1) goto L18 (error at _patch_call:135) else goto L1
L1:
    r2 = dank_mids.brownie_patch.call.globals :: static
    r3 = '_skip_proc_pool'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L19 (error at _patch_call:135) else goto L2
L2:
    r5 = cast(set, r4)
    if is_error(r5) goto L19 (error at _patch_call:135) else goto L3
L3:
    r6 = PySet_Contains(r5, r1)
    dec_ref r5
    dec_ref r1
    r7 = r6 >= 0 :: signed
    if not r7 goto L18 (error at _patch_call:135) else goto L4 :: bool
L4:
    r8 = truncate r6: i32 to builtins.bool
    r9 = '_skip_decoder_proc_pool'
    r10 = box(bool, r8)
    r11 = PyObject_SetAttr(call, r9, r10)
    r12 = r11 >= 0 :: signed
    if not r12 goto L18 (error at _patch_call:135) else goto L5 :: bool
L5:
    r13 = 'abi'
    r14 = CPyObject_GetAttr(call, r13)
    if is_error(r14) goto L18 (error at _patch_call:136) else goto L6
L6:
    r15 = 'inputs'
    r16 = PyObject_GetItem(r14, r15)
    dec_ref r14
    if is_error(r16) goto L18 (error at _patch_call:136) else goto L7
L7:
    r17 = CPyObject_Size(r16)
    dec_ref r16
    if is_error(r17) goto L18 (error at _patch_call:136) else goto L8
L8:
    r18 = dank_mids.brownie_patch.call.globals :: static
    r19 = '_get_coroutine_fn'
    r20 = CPyDict_GetItem(r18, r19)
    if is_error(r20) goto L20 (error at _patch_call:136) else goto L9
L9:
    r21 = box(int, r17)
    r22 = [w3, r21]
    r23 = load_address r22
    r24 = PyObject_Vectorcall(r20, r23, 2, 0)
    dec_ref r20
    if is_error(r24) goto L21 (error at _patch_call:136) else goto L10
L10:
    dec_ref r21
    r25 = dank_mids.brownie_patch.call.globals :: static
    r26 = 'MethodType'
    r27 = CPyDict_GetItem(r25, r26)
    if is_error(r27) goto L22 (error at _patch_call:136) else goto L11
L11:
    r28 = [r24, call]
    r29 = load_address r28
    r30 = PyObject_Vectorcall(r27, r29, 2, 0)
    dec_ref r27
    if is_error(r30) goto L22 (error at _patch_call:136) else goto L12
L12:
    dec_ref r24
    r31 = 'coroutine'
    r32 = PyObject_SetAttr(call, r31, r30)
    dec_ref r30
    r33 = r32 >= 0 :: signed
    if not r33 goto L18 (error at _patch_call:136) else goto L13 :: bool
L13:
    r34 = dank_mids.brownie_patch.call.globals :: static
    r35 = '_call_no_args'
    r36 = CPyDict_GetItem(r34, r35)
    if is_error(r36) goto L18 (error at _patch_call:137) else goto L14
L14:
    r37 = dank_mids.brownie_patch.call.globals :: static
    r38 = 'MethodType'
    r39 = CPyDict_GetItem(r37, r38)
    if is_error(r39) goto L23 (error at _patch_call:137) else goto L15
L15:
    r40 = [r36, call]
    r41 = load_address r40
    r42 = PyObject_Vectorcall(r39, r41, 2, 0)
    dec_ref r39
    if is_error(r42) goto L23 (error at _patch_call:137) else goto L16
L16:
    dec_ref r36
    r43 = '__await__'
    r44 = PyObject_SetAttr(call, r43, r42)
    dec_ref r42
    r45 = r44 >= 0 :: signed
    if not r45 goto L18 (error at _patch_call:137) else goto L17 :: bool
L17:
    return 1
L18:
    r46 = <error> :: None
    return r46
L19:
    dec_ref r1
    goto L18
L20:
    dec_ref r17 :: int
    goto L18
L21:
    dec_ref r21
    goto L18
L22:
    dec_ref r24
    goto L18
L23:
    dec_ref r36
    goto L18

def coroutine__get_coroutine_fn_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def coroutine__get_coroutine_fn_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    type, value, traceback, arg, r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11 :: object
    r12, r13 :: tuple[object, object, object]
    r14, r15, r16, r17 :: object
    r18, r19 :: tuple[object, object, object]
    r20, r21 :: object
    r22 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_env
    r23 :: int
    r24 :: dank_mids.brownie_patch.call._get_coroutine_fn_env
    r25 :: object
    r26 :: bit
    r27 :: union[dict, None]
    r28 :: object
    r29 :: bit
    r30 :: dict
    r31 :: native_int
    r32 :: short_int
    r33 :: bit
    r34 :: str
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: object[1]
    r39 :: object_ptr
    r40, r41 :: object
    r42 :: bool
    r43 :: union[object, None]
    r44, r45 :: object
    r46 :: str
    r47 :: object
    r48 :: bool
    r49 :: str
    r50 :: object
    r51 :: object[1]
    r52 :: object_ptr
    r53 :: object
    r54, r55 :: bool
    r56 :: object
    r57 :: bool
    r58, r59, r60, r61, r62 :: object
    r63 :: bool
    r64 :: object
    r65 :: bit
    r66 :: tuple[object, object, object]
    r67 :: bool
    r68 :: object_ptr
    r69 :: object
    r70 :: bool
    r71, r72, r73 :: tuple[object, object, object]
    r74 :: bit
    r75, r76, r77, r78 :: object
    r79 :: int
    r80 :: object
    r81 :: tuple
    r82 :: dict
    r83 :: str
    r84 :: object
    r85 :: list
    r86 :: object
    r87, r88, r89, r90 :: ptr
    r91 :: object
    r92 :: tuple
    r93 :: dict
    r94, r95 :: object
    r96 :: bool
    r97, r98, r99, r100, r101 :: object
    r102 :: bool
    r103 :: object
    r104 :: bit
    r105 :: tuple[object, object, object]
    r106 :: bool
    r107 :: object_ptr
    r108 :: object
    r109 :: bool
    r110, r111, r112 :: tuple[object, object, object]
    r113 :: bit
    r114, r115, r116 :: object
    r117 :: bool
    r118 :: object
    r119 :: bool
    r120 :: union[object, None]
    r121, r122 :: object
    r123 :: str
    r124 :: object
    r125 :: bool
    r126 :: str
    r127 :: object
    r128 :: object[1]
    r129 :: object_ptr
    r130 :: object
    r131, r132 :: bool
    r133 :: object
    r134 :: bool
    r135, r136, r137, r138, r139 :: object
    r140 :: bool
    r141 :: object
    r142 :: bit
    r143 :: tuple[object, object, object]
    r144 :: bool
    r145 :: object_ptr
    r146 :: object
    r147 :: bool
    r148, r149, r150 :: tuple[object, object, object]
    r151 :: bit
    r152, r153, r154, r155 :: object
    r156 :: str
    r157 :: object
    r158 :: str
    r159 :: object
    r160 :: str
    r161 :: object
    r162 :: str
    r163 :: object
    r164 :: dict
    r165 :: union[object, None]
    r166 :: str
    r167 :: object[3]
    r168 :: object_ptr
    r169, r170 :: object
    r171 :: bool
    r172, r173, r174, r175, r176 :: object
    r177 :: bool
    r178 :: object
    r179 :: bit
    r180 :: tuple[object, object, object]
    r181 :: bool
    r182 :: object_ptr
    r183 :: object
    r184 :: bool
    r185, r186, r187 :: tuple[object, object, object]
    r188 :: bit
    r189, r190, r191 :: object
    r192 :: bool
    r193 :: tuple[object, object, object]
    r194, r195 :: bool
    r196 :: tuple[object, object, object]
    r197, r198, r199, r200, r201 :: object
    r202 :: object[4]
    r203 :: object_ptr
    r204, r205 :: object
    r206 :: bool
    r207, r208, r209, r210, r211 :: object
    r212 :: bool
    r213 :: object
    r214 :: bit
    r215 :: tuple[object, object, object]
    r216 :: bool
    r217 :: object_ptr
    r218 :: object
    r219 :: bool
    r220, r221, r222 :: tuple[object, object, object]
    r223 :: bit
    r224, r225, r226 :: object
    r227 :: i32
    r228 :: bit
    r229 :: bool
    r230, r231 :: tuple[object, object, object]
    r232 :: bit
    r233, r234 :: tuple[object, object, object]
    r235 :: bool
    r236, r237, r238 :: object
    r239 :: object[4]
    r240 :: object_ptr
    r241, r242 :: object
    r243 :: bool
    r244, r245, r246, r247, r248 :: object
    r249 :: bool
    r250 :: object
    r251 :: bit
    r252 :: tuple[object, object, object]
    r253 :: bool
    r254 :: object_ptr
    r255 :: object
    r256 :: bool
    r257, r258, r259 :: tuple[object, object, object]
    r260 :: bit
    r261, r262, r263 :: object
    r264 :: bit
    r265 :: tuple[object, object, object]
    r266, r267 :: bool
    r268 :: tuple[object, object, object]
    r269, r270, r271, r272, r273 :: object
    r274 :: object[4]
    r275 :: object_ptr
    r276, r277 :: object
    r278 :: bool
    r279, r280, r281, r282, r283 :: object
    r284 :: bool
    r285 :: object
    r286 :: bit
    r287 :: tuple[object, object, object]
    r288 :: bool
    r289 :: object_ptr
    r290 :: object
    r291 :: bool
    r292, r293, r294 :: tuple[object, object, object]
    r295 :: bit
    r296, r297, r298 :: object
    r299 :: i32
    r300 :: bit
    r301 :: bool
    r302, r303 :: tuple[object, object, object]
    r304 :: bit
    r305, r306 :: tuple[object, object, object]
    r307 :: bool
    r308, r309, r310 :: object
    r311 :: object[4]
    r312 :: object_ptr
    r313, r314 :: object
    r315 :: bool
    r316, r317, r318, r319, r320 :: object
    r321 :: bool
    r322 :: object
    r323 :: bit
    r324 :: tuple[object, object, object]
    r325 :: bool
    r326 :: object_ptr
    r327 :: object
    r328 :: bool
    r329, r330, r331 :: tuple[object, object, object]
    r332 :: bit
    r333, r334, r335 :: object
    r336 :: bit
    r337, r338 :: object
    r339 :: bytes
    r340, r341 :: object
    r342 :: bool
    r343, r344, r345, r346, r347 :: object
    r348 :: bool
    r349 :: object
    r350 :: bit
    r351 :: tuple[object, object, object]
    r352 :: bool
    r353 :: object_ptr
    r354 :: object
    r355 :: bool
    r356, r357, r358 :: tuple[object, object, object]
    r359 :: bit
    r360, r361, r362 :: object
    r363 :: bool
    r364 :: tuple[object, object, object]
    r365 :: bool
    r366 :: dict
    r367 :: str
    r368 :: object
    r369 :: bit
    r370 :: object
    r371 :: bool
    r372 :: object
    r373 :: str
    r374, r375 :: object
    r376 :: str
    r377, r378 :: object
    r379 :: dict
    r380 :: str
    r381 :: object
    r382 :: object[4]
    r383 :: object_ptr
    r384 :: object
    r385 :: tuple[object, object, object]
    r386 :: bit
    r387 :: union[int, None]
    r388 :: object
    r389 :: bit
    r390, r391, r392 :: object
    r393 :: union[int, None]
    r394 :: int
    r395 :: object
    r396 :: bool
    r397 :: object
    r398 :: object[1]
    r399 :: object_ptr
    r400, r401, r402, r403 :: object
    r404 :: bool
    r405, r406, r407, r408, r409, r410, r411, r412, r413, r414 :: bit
    r415 :: bool
    r416 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = <error> :: object
    r5 = r4
    r6 = <error> :: object
    r7 = r6
    r8 = <error> :: object
    r9 = r8
    r10 = <error> :: object
    r11 = r10
    r12 = <error> :: tuple[object, object, object]
    r13 = r12
    r14 = <error> :: object
    r15 = r14
    r16 = <error> :: object
    r17 = r16
    r18 = <error> :: tuple[object, object, object]
    r19 = r18
    r20 = <error> :: object
    r21 = r20
    r22 = __mypyc_self__.__mypyc_env__
    if is_error(r22) goto L427 (error at coroutine:147) else goto L1
L1:
    r23 = r22.__mypyc_next_label__
    if is_error(r23) goto L428 (error at coroutine:147) else goto L2
L2:
    r24 = r22.__mypyc_env__
    if is_error(r24) goto L429 (error at coroutine:147) else goto L414
L3:
    r25 = load_address _Py_NoneStruct
    r26 = type != r25
    if r26 goto L430 else goto L6 :: bool
L4:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L426 (error at coroutine:147) else goto L5 :: bool
L5:
    unreachable
L6:
    r27 = r22.override
    if is_error(r27) goto L431 (error at coroutine:154) else goto L7
L7:
    r28 = load_address _Py_NoneStruct
    r29 = r27 != r28
    if r29 goto L8 else goto L432 :: bool
L8:
    r30 = cast(dict, r27)
    if is_error(r30) goto L431 (error at coroutine:154) else goto L9
L9:
    r31 = PyDict_Size(r30)
    dec_ref r30
    r32 = r31 << 1
    r33 = r32 != 0
    if r33 goto L433 else goto L14 :: bool
L10:
    r34 = 'Cannot use state override with `coroutine`.'
    r35 = builtins :: module
    r36 = 'ValueError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L426 (error at coroutine:155) else goto L11
L11:
    r38 = [r34]
    r39 = load_address r38
    r40 = PyObject_Vectorcall(r37, r39, 1, 0)
    dec_ref r37
    if is_error(r40) goto L426 (error at coroutine:155) else goto L12
L12:
    CPy_Raise(r40)
    dec_ref r40
    if not 0 goto L426 (error at coroutine:155) else goto L13 :: bool
L13:
    unreachable
L14:
    r41 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_ENCODER_SEMAPHORE :: static
    if is_error(r41) goto L434 else goto L17
L15:
    r42 = raise NameError('value for final name "BROWNIE_ENCODER_SEMAPHORE" was not set')
    if not r42 goto L426 (error at coroutine:156) else goto L16 :: bool
L16:
    unreachable
L17:
    r43 = r22.block_identifier
    if is_error(r43) goto L431 (error at coroutine:156) else goto L18
L18:
    r44 = PyObject_GetItem(r41, r43)
    dec_ref r43
    if is_error(r44) goto L431 (error at coroutine:156) else goto L19
L19:
    r45 = PyObject_Type(r44)
    r46 = '__aexit__'
    r47 = CPyObject_GetAttr(r45, r46)
    if is_error(r47) goto L435 (error at coroutine:156) else goto L20
L20:
    r22.__mypyc_temp__0 = r47; r48 = is_error
    if not r48 goto L435 (error at coroutine:-1) else goto L21 :: bool
L21:
    r49 = '__aenter__'
    r50 = CPyObject_GetAttr(r45, r49)
    dec_ref r45
    if is_error(r50) goto L436 (error at coroutine:156) else goto L22
L22:
    r51 = [r44]
    r52 = load_address r51
    r53 = PyObject_Vectorcall(r50, r52, 1, 0)
    dec_ref r50
    if is_error(r53) goto L436 (error at coroutine:156) else goto L23
L23:
    r22.__mypyc_temp__1 = r44; r54 = is_error
    if not r54 goto L437 (error at coroutine:-1) else goto L24 :: bool
L24:
    r22.__mypyc_temp__2 = 1; r55 = is_error
    if not r55 goto L437 (error at coroutine:-1) else goto L25 :: bool
L25:
    r56 = CPy_GetCoro(r53)
    dec_ref r53
    if is_error(r56) goto L431 (error at coroutine:156) else goto L26
L26:
    r22.__mypyc_temp__3 = r56; r57 = is_error
    if not r57 goto L431 (error at coroutine:-1) else goto L27 :: bool
L27:
    r58 = r22.__mypyc_temp__3
    if is_error(r58) goto L431 (error at coroutine:-1) else goto L28
L28:
    r59 = CPyIter_Next(r58)
    dec_ref r58
    if is_error(r59) goto L438 else goto L31
L29:
    r60 = CPy_FetchStopIterationValue()
    if is_error(r60) goto L439 (error at coroutine:156) else goto L30
L30:
    r61 = r60
    dec_ref r61
    goto L54
L31:
    r62 = r59
L32:
    r22.__mypyc_next_label__ = 2; r63 = is_error
    if not r63 goto L440 (error at coroutine:156) else goto L441 :: bool
L33:
    return r62
L34:
    r64 = load_address _Py_NoneStruct
    r65 = type != r64
    if r65 goto L35 else goto L37 :: bool
L35:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L38 (error at coroutine:156) else goto L442 :: bool
L36:
    unreachable
L37:
    inc_ref arg
    goto L49
L38:
    r66 = CPy_CatchError()
    r22.__mypyc_temp__4 = r66; r67 = is_error
    if not r67 goto L443 (error at coroutine:-1) else goto L39 :: bool
L39:
    r68 = load_address r1
    r69 = r22.__mypyc_temp__3
    if is_error(r69) goto L443 (error at coroutine:-1) else goto L40
L40:
    r70 = CPy_YieldFromErrorHandle(r69, r68)
    dec_ref r69
    if is_error(r70) goto L443 (error at coroutine:156) else goto L41
L41:
    if r70 goto L44 else goto L42 :: bool
L42:
    inc_ref r1
    r62 = r1
    r71 = r22.__mypyc_temp__4
    if is_error(r71) goto L444 (error at coroutine:-1) else goto L43
L43:
    CPy_RestoreExcInfo(r71)
    dec_ref r71
    goto L32
L44:
    r61 = r1
    dec_ref r61
    r72 = r22.__mypyc_temp__4
    if is_error(r72) goto L445 (error at coroutine:-1) else goto L45
L45:
    CPy_RestoreExcInfo(r72)
    dec_ref r72
    goto L54
L46:
    r73 = r22.__mypyc_temp__4
    dec_ref r22
    if is_error(r73) goto L426 (error at coroutine:-1) else goto L47
L47:
    CPy_RestoreExcInfo(r73)
    dec_ref r73
    r74 = CPy_KeepPropagating()
    if not r74 goto L426 else goto L48 :: bool
L48:
    unreachable
L49:
    r75 = r22.__mypyc_temp__3
    if is_error(r75) goto L446 (error at coroutine:-1) else goto L50
L50:
    r76 = CPyIter_Send(r75, arg)
    dec_ref r75
    dec_ref arg
    if is_error(r76) goto L447 else goto L51
L51:
    r62 = r76
    goto L32
L52:
    r77 = CPy_FetchStopIterationValue()
    if is_error(r77) goto L439 (error at coroutine:156) else goto L53
L53:
    r61 = r77
    dec_ref r61
L54:
    r78 = r22.self
    if is_error(r78) goto L448 (error at coroutine:157) else goto L55
L55:
    r79 = r24.len_inputs
    if is_error(r79) goto L449 (error at coroutine:157) else goto L56
L56:
    r80 = r24.get_request_data
    if is_error(r80) goto L450 (error at coroutine:157) else goto L57
L57:
    r81 = r22.args
    if is_error(r81) goto L451 (error at coroutine:157) else goto L58
L58:
    r82 = dank_mids.brownie_patch.call.globals :: static
    r83 = 'encode_input'
    r84 = CPyDict_GetItem(r82, r83)
    if is_error(r84) goto L452 (error at coroutine:157) else goto L59
L59:
    r85 = PyList_New(3)
    if is_error(r85) goto L453 (error at coroutine:157) else goto L60
L60:
    r86 = box(int, r79)
    r87 = get_element_ptr r85 ob_item :: PyListObject
    r88 = load_mem r87 :: ptr*
    set_mem r88, r78 :: builtins.object*
    r89 = r88 + 8
    set_mem r89, r86 :: builtins.object*
    r90 = r88 + 16
    set_mem r90, r80 :: builtins.object*
    r91 = CPyList_Extend(r85, r81)
    dec_ref r81
    if is_error(r91) goto L454 (error at coroutine:157) else goto L455
L61:
    r92 = PyList_AsTuple(r85)
    dec_ref r85
    if is_error(r92) goto L456 (error at coroutine:157) else goto L62
L62:
    r93 = PyDict_New()
    if is_error(r93) goto L457 (error at coroutine:157) else goto L63
L63:
    r94 = PyObject_Call(r84, r92, r93)
    dec_ref r84
    dec_ref r92
    dec_ref r93
    if is_error(r94) goto L448 (error at coroutine:157) else goto L64
L64:
    r95 = CPy_GetCoro(r94)
    dec_ref r94
    if is_error(r95) goto L448 (error at coroutine:157) else goto L65
L65:
    r22.__mypyc_temp__5 = r95; r96 = is_error
    if not r96 goto L448 (error at coroutine:-1) else goto L66 :: bool
L66:
    r97 = r22.__mypyc_temp__5
    if is_error(r97) goto L448 (error at coroutine:-1) else goto L67
L67:
    r98 = CPyIter_Next(r97)
    dec_ref r97
    if is_error(r98) goto L458 else goto L70
L68:
    r99 = CPy_FetchStopIterationValue()
    if is_error(r99) goto L459 (error at coroutine:157) else goto L69
L69:
    r100 = r99
    goto L93
L70:
    r101 = r98
L71:
    r22.__mypyc_next_label__ = 4; r102 = is_error
    if not r102 goto L460 (error at coroutine:157) else goto L461 :: bool
L72:
    return r101
L73:
    r103 = load_address _Py_NoneStruct
    r104 = type != r103
    if r104 goto L74 else goto L76 :: bool
L74:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L77 (error at coroutine:157) else goto L462 :: bool
L75:
    unreachable
L76:
    inc_ref arg
    goto L88
L77:
    r105 = CPy_CatchError()
    r22.__mypyc_temp__6 = r105; r106 = is_error
    if not r106 goto L463 (error at coroutine:-1) else goto L78 :: bool
L78:
    r107 = load_address r3
    r108 = r22.__mypyc_temp__5
    if is_error(r108) goto L463 (error at coroutine:-1) else goto L79
L79:
    r109 = CPy_YieldFromErrorHandle(r108, r107)
    dec_ref r108
    if is_error(r109) goto L463 (error at coroutine:157) else goto L80
L80:
    if r109 goto L83 else goto L81 :: bool
L81:
    inc_ref r3
    r101 = r3
    r110 = r22.__mypyc_temp__6
    if is_error(r110) goto L464 (error at coroutine:-1) else goto L82
L82:
    CPy_RestoreExcInfo(r110)
    dec_ref r110
    goto L71
L83:
    r100 = r3
    r111 = r22.__mypyc_temp__6
    if is_error(r111) goto L465 (error at coroutine:-1) else goto L84
L84:
    CPy_RestoreExcInfo(r111)
    dec_ref r111
    goto L93
L85:
    r112 = r22.__mypyc_temp__6
    if is_error(r112) goto L258 (error at coroutine:-1) else goto L86
L86:
    CPy_RestoreExcInfo(r112)
    dec_ref r112
    r113 = CPy_KeepPropagating()
    if not r113 goto L258 else goto L466 :: bool
L87:
    unreachable
L88:
    r114 = r22.__mypyc_temp__5
    if is_error(r114) goto L467 (error at coroutine:-1) else goto L89
L89:
    r115 = CPyIter_Send(r114, arg)
    dec_ref r114
    dec_ref arg
    if is_error(r115) goto L468 else goto L90
L90:
    r101 = r115
    goto L71
L91:
    r116 = CPy_FetchStopIterationValue()
    if is_error(r116) goto L459 (error at coroutine:157) else goto L92
L92:
    r100 = r116
L93:
    r22.data = r100; r117 = is_error
    if not r117 goto L459 (error at coroutine:157) else goto L94 :: bool
L94:
    r118 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE :: static
    if is_error(r118) goto L469 else goto L97
L95:
    r119 = raise NameError('value for final name "BROWNIE_CALL_SEMAPHORE" was not set')
    if not r119 goto L258 (error at coroutine:158) else goto L470 :: bool
L96:
    unreachable
L97:
    r120 = r22.block_identifier
    if is_error(r120) goto L459 (error at coroutine:158) else goto L98
L98:
    r121 = PyObject_GetItem(r118, r120)
    dec_ref r120
    if is_error(r121) goto L459 (error at coroutine:158) else goto L99
L99:
    r122 = PyObject_Type(r121)
    r123 = '__aexit__'
    r124 = CPyObject_GetAttr(r122, r123)
    if is_error(r124) goto L471 (error at coroutine:158) else goto L100
L100:
    r22.__mypyc_temp__7 = r124; r125 = is_error
    if not r125 goto L471 (error at coroutine:-1) else goto L101 :: bool
L101:
    r126 = '__aenter__'
    r127 = CPyObject_GetAttr(r122, r126)
    dec_ref r122
    if is_error(r127) goto L472 (error at coroutine:158) else goto L102
L102:
    r128 = [r121]
    r129 = load_address r128
    r130 = PyObject_Vectorcall(r127, r129, 1, 0)
    dec_ref r127
    if is_error(r130) goto L472 (error at coroutine:158) else goto L103
L103:
    r22.__mypyc_temp__8 = r121; r131 = is_error
    if not r131 goto L473 (error at coroutine:-1) else goto L104 :: bool
L104:
    r22.__mypyc_temp__9 = 1; r132 = is_error
    if not r132 goto L473 (error at coroutine:-1) else goto L105 :: bool
L105:
    r133 = CPy_GetCoro(r130)
    dec_ref r130
    if is_error(r133) goto L459 (error at coroutine:158) else goto L106
L106:
    r22.__mypyc_temp__10 = r133; r134 = is_error
    if not r134 goto L459 (error at coroutine:-1) else goto L107 :: bool
L107:
    r135 = r22.__mypyc_temp__10
    if is_error(r135) goto L459 (error at coroutine:-1) else goto L108
L108:
    r136 = CPyIter_Next(r135)
    dec_ref r135
    if is_error(r136) goto L474 else goto L111
L109:
    r137 = CPy_FetchStopIterationValue()
    if is_error(r137) goto L475 (error at coroutine:158) else goto L110
L110:
    r138 = r137
    dec_ref r138
    goto L134
L111:
    r139 = r136
L112:
    r22.__mypyc_next_label__ = 6; r140 = is_error
    if not r140 goto L476 (error at coroutine:158) else goto L477 :: bool
L113:
    return r139
L114:
    r141 = load_address _Py_NoneStruct
    r142 = type != r141
    if r142 goto L115 else goto L117 :: bool
L115:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L118 (error at coroutine:158) else goto L478 :: bool
L116:
    unreachable
L117:
    inc_ref arg
    goto L129
L118:
    r143 = CPy_CatchError()
    r22.__mypyc_temp__11 = r143; r144 = is_error
    if not r144 goto L479 (error at coroutine:-1) else goto L119 :: bool
L119:
    r145 = load_address r5
    r146 = r22.__mypyc_temp__10
    if is_error(r146) goto L479 (error at coroutine:-1) else goto L120
L120:
    r147 = CPy_YieldFromErrorHandle(r146, r145)
    dec_ref r146
    if is_error(r147) goto L479 (error at coroutine:158) else goto L121
L121:
    if r147 goto L124 else goto L122 :: bool
L122:
    inc_ref r5
    r139 = r5
    r148 = r22.__mypyc_temp__11
    if is_error(r148) goto L480 (error at coroutine:-1) else goto L123
L123:
    CPy_RestoreExcInfo(r148)
    dec_ref r148
    goto L112
L124:
    r138 = r5
    dec_ref r138
    r149 = r22.__mypyc_temp__11
    if is_error(r149) goto L481 (error at coroutine:-1) else goto L125
L125:
    CPy_RestoreExcInfo(r149)
    dec_ref r149
    goto L134
L126:
    r150 = r22.__mypyc_temp__11
    if is_error(r150) goto L258 (error at coroutine:-1) else goto L127
L127:
    CPy_RestoreExcInfo(r150)
    dec_ref r150
    r151 = CPy_KeepPropagating()
    if not r151 goto L258 else goto L482 :: bool
L128:
    unreachable
L129:
    r152 = r22.__mypyc_temp__10
    if is_error(r152) goto L483 (error at coroutine:-1) else goto L130
L130:
    r153 = CPyIter_Send(r152, arg)
    dec_ref r152
    dec_ref arg
    if is_error(r153) goto L484 else goto L131
L131:
    r139 = r153
    goto L112
L132:
    r154 = CPy_FetchStopIterationValue()
    if is_error(r154) goto L475 (error at coroutine:158) else goto L133
L133:
    r138 = r154
    dec_ref r138
L134:
    r155 = r24.w3
    dec_ref r24
    if is_error(r155) goto L485 (error at coroutine:159) else goto L135
L135:
    r156 = 'eth'
    r157 = CPyObject_GetAttr(r155, r156)
    dec_ref r155
    if is_error(r157) goto L485 (error at coroutine:159) else goto L136
L136:
    r158 = 'to'
    r159 = r22.self
    if is_error(r159) goto L486 (error at coroutine:159) else goto L137
L137:
    r160 = '_address'
    r161 = CPyObject_GetAttr(r159, r160)
    dec_ref r159
    if is_error(r161) goto L486 (error at coroutine:159) else goto L138
L138:
    r162 = 'data'
    r163 = r22.data
    if is_error(r163) goto L487 (error at coroutine:159) else goto L139
L139:
    r164 = CPyDict_Build(2, r158, r161, r162, r163)
    dec_ref r161
    dec_ref r163
    if is_error(r164) goto L486 (error at coroutine:159) else goto L140
L140:
    r165 = r22.block_identifier
    if is_error(r165) goto L488 (error at coroutine:159) else goto L141
L141:
    r166 = 'call'
    r167 = [r157, r164, r165]
    r168 = load_address r167
    r169 = PyObject_VectorcallMethod(r166, r168, 9223372036854775811, 0)
    if is_error(r169) goto L489 (error at coroutine:159) else goto L142
L142:
    dec_ref r157
    dec_ref r164
    dec_ref r165
    r170 = CPy_GetCoro(r169)
    dec_ref r169
    if is_error(r170) goto L485 (error at coroutine:159) else goto L143
L143:
    r22.__mypyc_temp__12 = r170; r171 = is_error
    if not r171 goto L485 (error at coroutine:-1) else goto L144 :: bool
L144:
    r172 = r22.__mypyc_temp__12
    if is_error(r172) goto L485 (error at coroutine:-1) else goto L145
L145:
    r173 = CPyIter_Next(r172)
    dec_ref r172
    if is_error(r173) goto L490 else goto L148
L146:
    r174 = CPy_FetchStopIterationValue()
    if is_error(r174) goto L172 (error at coroutine:159) else goto L147
L147:
    r175 = r174
    goto L171
L148:
    r176 = r173
L149:
    r22.__mypyc_next_label__ = 8; r177 = is_error
    if not r177 goto L491 (error at coroutine:159) else goto L492 :: bool
L150:
    return r176
L151:
    r178 = load_address _Py_NoneStruct
    r179 = type != r178
    if r179 goto L152 else goto L154 :: bool
L152:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L155 (error at coroutine:159) else goto L493 :: bool
L153:
    unreachable
L154:
    inc_ref arg
    goto L166
L155:
    r180 = CPy_CatchError()
    r22.__mypyc_temp__13 = r180; r181 = is_error
    if not r181 goto L494 (error at coroutine:-1) else goto L156 :: bool
L156:
    r182 = load_address r7
    r183 = r22.__mypyc_temp__12
    if is_error(r183) goto L494 (error at coroutine:-1) else goto L157
L157:
    r184 = CPy_YieldFromErrorHandle(r183, r182)
    dec_ref r183
    if is_error(r184) goto L494 (error at coroutine:159) else goto L158
L158:
    if r184 goto L161 else goto L159 :: bool
L159:
    inc_ref r7
    r176 = r7
    r185 = r22.__mypyc_temp__13
    if is_error(r185) goto L495 (error at coroutine:-1) else goto L160
L160:
    CPy_RestoreExcInfo(r185)
    dec_ref r185
    goto L149
L161:
    r175 = r7
    r186 = r22.__mypyc_temp__13
    if is_error(r186) goto L496 (error at coroutine:-1) else goto L162
L162:
    CPy_RestoreExcInfo(r186)
    dec_ref r186
    goto L171
L163:
    r187 = r22.__mypyc_temp__13
    if is_error(r187) goto L172 (error at coroutine:-1) else goto L164
L164:
    CPy_RestoreExcInfo(r187)
    dec_ref r187
    r188 = CPy_KeepPropagating()
    if not r188 goto L172 else goto L497 :: bool
L165:
    unreachable
L166:
    r189 = r22.__mypyc_temp__12
    if is_error(r189) goto L498 (error at coroutine:-1) else goto L167
L167:
    r190 = CPyIter_Send(r189, arg)
    dec_ref r189
    dec_ref arg
    if is_error(r190) goto L499 else goto L168
L168:
    r176 = r190
    goto L149
L169:
    r191 = CPy_FetchStopIterationValue()
    if is_error(r191) goto L172 (error at coroutine:159) else goto L170
L170:
    r175 = r191
L171:
    r22.output = r175; r192 = is_error
    if not r192 goto L172 (error at coroutine:159) else goto L500 :: bool
L172:
    r193 = CPy_CatchError()
    r22.__mypyc_temp__14 = r193; r194 = is_error
    if not r194 goto L501 (error at coroutine:-1) else goto L173 :: bool
L173:
    r22.__mypyc_temp__9 = 0; r195 = is_error
    if not r195 goto L501 (error at coroutine:158) else goto L174 :: bool
L174:
    r196 = CPy_GetExcInfo()
    r197 = r196[0]
    r198 = r196[1]
    r199 = r196[2]
    dec_ref r196
    r200 = r22.__mypyc_temp__7
    if is_error(r200) goto L502 (error at coroutine:-1) else goto L175
L175:
    r201 = r22.__mypyc_temp__8
    if is_error(r201) goto L503 (error at coroutine:-1) else goto L176
L176:
    r202 = [r201, r197, r198, r199]
    r203 = load_address r202
    r204 = PyObject_Vectorcall(r200, r203, 4, 0)
    dec_ref r200
    if is_error(r204) goto L504 (error at coroutine:158) else goto L177
L177:
    dec_ref r201
    dec_ref r197
    dec_ref r198
    dec_ref r199
    r205 = CPy_GetCoro(r204)
    dec_ref r204
    if is_error(r205) goto L501 (error at coroutine:158) else goto L178
L178:
    r22.__mypyc_temp__15 = r205; r206 = is_error
    if not r206 goto L501 (error at coroutine:-1) else goto L179 :: bool
L179:
    r207 = r22.__mypyc_temp__15
    if is_error(r207) goto L501 (error at coroutine:-1) else goto L180
L180:
    r208 = CPyIter_Next(r207)
    dec_ref r207
    if is_error(r208) goto L505 else goto L183
L181:
    r209 = CPy_FetchStopIterationValue()
    if is_error(r209) goto L212 (error at coroutine:158) else goto L182
L182:
    r210 = r209
    goto L206
L183:
    r211 = r208
L184:
    r22.__mypyc_next_label__ = 10; r212 = is_error
    if not r212 goto L506 (error at coroutine:158) else goto L507 :: bool
L185:
    return r211
L186:
    r213 = load_address _Py_NoneStruct
    r214 = type != r213
    if r214 goto L187 else goto L189 :: bool
L187:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L190 (error at coroutine:158) else goto L508 :: bool
L188:
    unreachable
L189:
    inc_ref arg
    goto L201
L190:
    r215 = CPy_CatchError()
    r22.__mypyc_temp__16 = r215; r216 = is_error
    if not r216 goto L509 (error at coroutine:-1) else goto L191 :: bool
L191:
    r217 = load_address r9
    r218 = r22.__mypyc_temp__15
    if is_error(r218) goto L509 (error at coroutine:-1) else goto L192
L192:
    r219 = CPy_YieldFromErrorHandle(r218, r217)
    dec_ref r218
    if is_error(r219) goto L509 (error at coroutine:158) else goto L193
L193:
    if r219 goto L196 else goto L194 :: bool
L194:
    inc_ref r9
    r211 = r9
    r220 = r22.__mypyc_temp__16
    if is_error(r220) goto L510 (error at coroutine:-1) else goto L195
L195:
    CPy_RestoreExcInfo(r220)
    dec_ref r220
    goto L184
L196:
    r210 = r9
    r221 = r22.__mypyc_temp__16
    if is_error(r221) goto L511 (error at coroutine:-1) else goto L197
L197:
    CPy_RestoreExcInfo(r221)
    dec_ref r221
    goto L206
L198:
    r222 = r22.__mypyc_temp__16
    if is_error(r222) goto L212 (error at coroutine:-1) else goto L199
L199:
    CPy_RestoreExcInfo(r222)
    dec_ref r222
    r223 = CPy_KeepPropagating()
    if not r223 goto L212 else goto L512 :: bool
L200:
    unreachable
L201:
    r224 = r22.__mypyc_temp__15
    if is_error(r224) goto L513 (error at coroutine:-1) else goto L202
L202:
    r225 = CPyIter_Send(r224, arg)
    dec_ref r224
    dec_ref arg
    if is_error(r225) goto L514 else goto L203
L203:
    r211 = r225
    goto L184
L204:
    r226 = CPy_FetchStopIterationValue()
    if is_error(r226) goto L212 (error at coroutine:158) else goto L205
L205:
    r210 = r226
L206:
    r227 = PyObject_IsTrue(r210)
    dec_ref r210
    r228 = r227 >= 0 :: signed
    if not r228 goto L212 (error at coroutine:-1) else goto L207 :: bool
L207:
    r229 = truncate r227: i32 to builtins.bool
    if r229 goto L210 else goto L208 :: bool
L208:
    CPy_Reraise()
    if not 0 goto L212 else goto L515 :: bool
L209:
    unreachable
L210:
    r230 = r22.__mypyc_temp__14
    if is_error(r230) goto L216 (error at coroutine:-1) else goto L211
L211:
    CPy_RestoreExcInfo(r230)
    dec_ref r230
    goto L215
L212:
    r231 = r22.__mypyc_temp__14
    if is_error(r231) goto L216 (error at coroutine:-1) else goto L213
L213:
    CPy_RestoreExcInfo(r231)
    dec_ref r231
    r232 = CPy_KeepPropagating()
    if not r232 goto L216 else goto L516 :: bool
L214:
    unreachable
L215:
    r233 = <error> :: tuple[object, object, object]
    r13 = r233
    goto L217
L216:
    r234 = CPy_CatchError()
    r13 = r234
L217:
    r235 = r22.__mypyc_temp__9
    if is_error(r235) goto L517 (error at coroutine:-1) else goto L218
L218:
    if r235 goto L219 else goto L518 :: bool
L219:
    r236 = load_address _Py_NoneStruct
    r237 = r22.__mypyc_temp__7
    if is_error(r237) goto L517 (error at coroutine:-1) else goto L220
L220:
    r238 = r22.__mypyc_temp__8
    if is_error(r238) goto L519 (error at coroutine:-1) else goto L221
L221:
    r239 = [r238, r236, r236, r236]
    r240 = load_address r239
    r241 = PyObject_Vectorcall(r237, r240, 4, 0)
    dec_ref r237
    if is_error(r241) goto L520 (error at coroutine:158) else goto L222
L222:
    dec_ref r238
    r242 = CPy_GetCoro(r241)
    dec_ref r241
    if is_error(r242) goto L517 (error at coroutine:158) else goto L223
L223:
    r22.__mypyc_temp__17 = r242; r243 = is_error
    if not r243 goto L517 (error at coroutine:-1) else goto L224 :: bool
L224:
    r244 = r22.__mypyc_temp__17
    if is_error(r244) goto L517 (error at coroutine:-1) else goto L225
L225:
    r245 = CPyIter_Next(r244)
    dec_ref r244
    if is_error(r245) goto L521 else goto L228
L226:
    r246 = CPy_FetchStopIterationValue()
    if is_error(r246) goto L254 (error at coroutine:158) else goto L227
L227:
    r247 = r246
    dec_ref r247
    goto L251
L228:
    r248 = r245
L229:
    r22.__mypyc_next_label__ = 12; r249 = is_error
    if not r249 goto L522 (error at coroutine:158) else goto L523 :: bool
L230:
    return r248
L231:
    r250 = load_address _Py_NoneStruct
    r251 = type != r250
    if r251 goto L232 else goto L234 :: bool
L232:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L235 (error at coroutine:158) else goto L524 :: bool
L233:
    unreachable
L234:
    inc_ref arg
    goto L246
L235:
    r252 = CPy_CatchError()
    r22.__mypyc_temp__18 = r252; r253 = is_error
    if not r253 goto L525 (error at coroutine:-1) else goto L236 :: bool
L236:
    r254 = load_address r11
    r255 = r22.__mypyc_temp__17
    if is_error(r255) goto L525 (error at coroutine:-1) else goto L237
L237:
    r256 = CPy_YieldFromErrorHandle(r255, r254)
    dec_ref r255
    if is_error(r256) goto L525 (error at coroutine:158) else goto L238
L238:
    if r256 goto L241 else goto L239 :: bool
L239:
    inc_ref r11
    r248 = r11
    r257 = r22.__mypyc_temp__18
    if is_error(r257) goto L526 (error at coroutine:-1) else goto L240
L240:
    CPy_RestoreExcInfo(r257)
    dec_ref r257
    goto L229
L241:
    r247 = r11
    dec_ref r247
    r258 = r22.__mypyc_temp__18
    if is_error(r258) goto L243 (error at coroutine:-1) else goto L242
L242:
    CPy_RestoreExcInfo(r258)
    dec_ref r258
    goto L251
L243:
    r259 = r22.__mypyc_temp__18
    if is_error(r259) goto L254 (error at coroutine:-1) else goto L244
L244:
    CPy_RestoreExcInfo(r259)
    dec_ref r259
    r260 = CPy_KeepPropagating()
    if not r260 goto L254 else goto L527 :: bool
L245:
    unreachable
L246:
    r261 = r22.__mypyc_temp__17
    if is_error(r261) goto L528 (error at coroutine:-1) else goto L247
L247:
    r262 = CPyIter_Send(r261, arg)
    dec_ref r261
    dec_ref arg
    if is_error(r262) goto L529 else goto L248
L248:
    r248 = r262
    goto L229
L249:
    r263 = CPy_FetchStopIterationValue()
    if is_error(r263) goto L254 (error at coroutine:158) else goto L250
L250:
    r247 = r263
    dec_ref r247
L251:
    if is_error(r13) goto L530 else goto L252
L252:
    CPy_Reraise()
    if not 0 goto L254 else goto L531 :: bool
L253:
    unreachable
L254:
    if is_error(r13) goto L256 else goto L255
L255:
    CPy_RestoreExcInfo(r13)
    xdec_ref r13
L256:
    r264 = CPy_KeepPropagating()
    if not r264 goto L258 else goto L532 :: bool
L257:
    unreachable
L258:
    r265 = CPy_CatchError()
    r22.__mypyc_temp__19 = r265; r266 = is_error
    if not r266 goto L533 (error at coroutine:-1) else goto L259 :: bool
L259:
    r22.__mypyc_temp__2 = 0; r267 = is_error
    if not r267 goto L533 (error at coroutine:156) else goto L260 :: bool
L260:
    r268 = CPy_GetExcInfo()
    r269 = r268[0]
    r270 = r268[1]
    r271 = r268[2]
    dec_ref r268
    r272 = r22.__mypyc_temp__0
    if is_error(r272) goto L534 (error at coroutine:-1) else goto L261
L261:
    r273 = r22.__mypyc_temp__1
    if is_error(r273) goto L535 (error at coroutine:-1) else goto L262
L262:
    r274 = [r273, r269, r270, r271]
    r275 = load_address r274
    r276 = PyObject_Vectorcall(r272, r275, 4, 0)
    dec_ref r272
    if is_error(r276) goto L536 (error at coroutine:156) else goto L263
L263:
    dec_ref r273
    dec_ref r269
    dec_ref r270
    dec_ref r271
    r277 = CPy_GetCoro(r276)
    dec_ref r276
    if is_error(r277) goto L533 (error at coroutine:156) else goto L264
L264:
    r22.__mypyc_temp__20 = r277; r278 = is_error
    if not r278 goto L533 (error at coroutine:-1) else goto L265 :: bool
L265:
    r279 = r22.__mypyc_temp__20
    if is_error(r279) goto L533 (error at coroutine:-1) else goto L266
L266:
    r280 = CPyIter_Next(r279)
    dec_ref r279
    if is_error(r280) goto L537 else goto L269
L267:
    r281 = CPy_FetchStopIterationValue()
    if is_error(r281) goto L298 (error at coroutine:156) else goto L268
L268:
    r282 = r281
    goto L292
L269:
    r283 = r280
L270:
    r22.__mypyc_next_label__ = 14; r284 = is_error
    if not r284 goto L538 (error at coroutine:156) else goto L539 :: bool
L271:
    return r283
L272:
    r285 = load_address _Py_NoneStruct
    r286 = type != r285
    if r286 goto L273 else goto L275 :: bool
L273:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L276 (error at coroutine:156) else goto L540 :: bool
L274:
    unreachable
L275:
    inc_ref arg
    goto L287
L276:
    r287 = CPy_CatchError()
    r22.__mypyc_temp__21 = r287; r288 = is_error
    if not r288 goto L541 (error at coroutine:-1) else goto L277 :: bool
L277:
    r289 = load_address r15
    r290 = r22.__mypyc_temp__20
    if is_error(r290) goto L541 (error at coroutine:-1) else goto L278
L278:
    r291 = CPy_YieldFromErrorHandle(r290, r289)
    dec_ref r290
    if is_error(r291) goto L541 (error at coroutine:156) else goto L279
L279:
    if r291 goto L282 else goto L280 :: bool
L280:
    inc_ref r15
    r283 = r15
    r292 = r22.__mypyc_temp__21
    if is_error(r292) goto L542 (error at coroutine:-1) else goto L281
L281:
    CPy_RestoreExcInfo(r292)
    dec_ref r292
    goto L270
L282:
    r282 = r15
    r293 = r22.__mypyc_temp__21
    if is_error(r293) goto L543 (error at coroutine:-1) else goto L283
L283:
    CPy_RestoreExcInfo(r293)
    dec_ref r293
    goto L292
L284:
    r294 = r22.__mypyc_temp__21
    if is_error(r294) goto L298 (error at coroutine:-1) else goto L285
L285:
    CPy_RestoreExcInfo(r294)
    dec_ref r294
    r295 = CPy_KeepPropagating()
    if not r295 goto L298 else goto L544 :: bool
L286:
    unreachable
L287:
    r296 = r22.__mypyc_temp__20
    if is_error(r296) goto L545 (error at coroutine:-1) else goto L288
L288:
    r297 = CPyIter_Send(r296, arg)
    dec_ref r296
    dec_ref arg
    if is_error(r297) goto L546 else goto L289
L289:
    r283 = r297
    goto L270
L290:
    r298 = CPy_FetchStopIterationValue()
    if is_error(r298) goto L298 (error at coroutine:156) else goto L291
L291:
    r282 = r298
L292:
    r299 = PyObject_IsTrue(r282)
    dec_ref r282
    r300 = r299 >= 0 :: signed
    if not r300 goto L298 (error at coroutine:-1) else goto L293 :: bool
L293:
    r301 = truncate r299: i32 to builtins.bool
    if r301 goto L296 else goto L294 :: bool
L294:
    CPy_Reraise()
    if not 0 goto L298 else goto L547 :: bool
L295:
    unreachable
L296:
    r302 = r22.__mypyc_temp__19
    if is_error(r302) goto L302 (error at coroutine:-1) else goto L297
L297:
    CPy_RestoreExcInfo(r302)
    dec_ref r302
    goto L301
L298:
    r303 = r22.__mypyc_temp__19
    if is_error(r303) goto L302 (error at coroutine:-1) else goto L299
L299:
    CPy_RestoreExcInfo(r303)
    dec_ref r303
    r304 = CPy_KeepPropagating()
    if not r304 goto L302 else goto L548 :: bool
L300:
    unreachable
L301:
    r305 = <error> :: tuple[object, object, object]
    r19 = r305
    goto L303
L302:
    r306 = CPy_CatchError()
    r19 = r306
L303:
    r307 = r22.__mypyc_temp__2
    if is_error(r307) goto L549 (error at coroutine:-1) else goto L304
L304:
    if r307 goto L305 else goto L550 :: bool
L305:
    r308 = load_address _Py_NoneStruct
    r309 = r22.__mypyc_temp__0
    if is_error(r309) goto L549 (error at coroutine:-1) else goto L306
L306:
    r310 = r22.__mypyc_temp__1
    if is_error(r310) goto L551 (error at coroutine:-1) else goto L307
L307:
    r311 = [r310, r308, r308, r308]
    r312 = load_address r311
    r313 = PyObject_Vectorcall(r309, r312, 4, 0)
    dec_ref r309
    if is_error(r313) goto L552 (error at coroutine:156) else goto L308
L308:
    dec_ref r310
    r314 = CPy_GetCoro(r313)
    dec_ref r313
    if is_error(r314) goto L549 (error at coroutine:156) else goto L309
L309:
    r22.__mypyc_temp__22 = r314; r315 = is_error
    if not r315 goto L549 (error at coroutine:-1) else goto L310 :: bool
L310:
    r316 = r22.__mypyc_temp__22
    if is_error(r316) goto L549 (error at coroutine:-1) else goto L311
L311:
    r317 = CPyIter_Next(r316)
    dec_ref r316
    if is_error(r317) goto L553 else goto L314
L312:
    r318 = CPy_FetchStopIterationValue()
    if is_error(r318) goto L554 (error at coroutine:156) else goto L313
L313:
    r319 = r318
    dec_ref r319
    goto L337
L314:
    r320 = r317
L315:
    r22.__mypyc_next_label__ = 16; r321 = is_error
    if not r321 goto L555 (error at coroutine:156) else goto L556 :: bool
L316:
    return r320
L317:
    r322 = load_address _Py_NoneStruct
    r323 = type != r322
    if r323 goto L318 else goto L320 :: bool
L318:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L321 (error at coroutine:156) else goto L557 :: bool
L319:
    unreachable
L320:
    inc_ref arg
    goto L332
L321:
    r324 = CPy_CatchError()
    r22.__mypyc_temp__23 = r324; r325 = is_error
    if not r325 goto L558 (error at coroutine:-1) else goto L322 :: bool
L322:
    r326 = load_address r17
    r327 = r22.__mypyc_temp__22
    if is_error(r327) goto L558 (error at coroutine:-1) else goto L323
L323:
    r328 = CPy_YieldFromErrorHandle(r327, r326)
    dec_ref r327
    if is_error(r328) goto L558 (error at coroutine:156) else goto L324
L324:
    if r328 goto L327 else goto L325 :: bool
L325:
    inc_ref r17
    r320 = r17
    r329 = r22.__mypyc_temp__23
    if is_error(r329) goto L559 (error at coroutine:-1) else goto L326
L326:
    CPy_RestoreExcInfo(r329)
    dec_ref r329
    goto L315
L327:
    r319 = r17
    dec_ref r319
    r330 = r22.__mypyc_temp__23
    if is_error(r330) goto L560 (error at coroutine:-1) else goto L328
L328:
    CPy_RestoreExcInfo(r330)
    dec_ref r330
    goto L337
L329:
    r331 = r22.__mypyc_temp__23
    dec_ref r22
    if is_error(r331) goto L340 (error at coroutine:-1) else goto L330
L330:
    CPy_RestoreExcInfo(r331)
    dec_ref r331
    r332 = CPy_KeepPropagating()
    if not r332 goto L340 else goto L561 :: bool
L331:
    unreachable
L332:
    r333 = r22.__mypyc_temp__22
    if is_error(r333) goto L562 (error at coroutine:-1) else goto L333
L333:
    r334 = CPyIter_Send(r333, arg)
    dec_ref r333
    dec_ref arg
    if is_error(r334) goto L563 else goto L334
L334:
    r320 = r334
    goto L315
L335:
    r335 = CPy_FetchStopIterationValue()
    if is_error(r335) goto L554 (error at coroutine:156) else goto L336
L336:
    r319 = r335
    dec_ref r319
L337:
    if is_error(r19) goto L344 else goto L564
L338:
    CPy_Reraise()
    if not 0 goto L340 else goto L565 :: bool
L339:
    unreachable
L340:
    if is_error(r19) goto L342 else goto L341
L341:
    CPy_RestoreExcInfo(r19)
    xdec_ref r19
L342:
    r336 = CPy_KeepPropagating()
    if not r336 goto L426 else goto L343 :: bool
L343:
    unreachable
L344:
    r337 = r22.self
    if is_error(r337) goto L566 (error at coroutine:161) else goto L345
L345:
    r338 = r22.output
    if is_error(r338) goto L567 (error at coroutine:161) else goto L346
L346:
    r339 = cast(bytes, r338)
    if is_error(r339) goto L567 (error at coroutine:161) else goto L347
L347:
    r340 = decode_output(r337, r339)
    dec_ref r337
    dec_ref r339
    if is_error(r340) goto L566 (error at coroutine:161) else goto L348
L348:
    r341 = CPy_GetCoro(r340)
    dec_ref r340
    if is_error(r341) goto L566 (error at coroutine:161) else goto L349
L349:
    r22.__mypyc_temp__24 = r341; r342 = is_error
    if not r342 goto L566 (error at coroutine:-1) else goto L350 :: bool
L350:
    r343 = r22.__mypyc_temp__24
    if is_error(r343) goto L566 (error at coroutine:-1) else goto L351
L351:
    r344 = CPyIter_Next(r343)
    dec_ref r343
    if is_error(r344) goto L568 else goto L354
L352:
    r345 = CPy_FetchStopIterationValue()
    if is_error(r345) goto L378 (error at coroutine:161) else goto L353
L353:
    r346 = r345
    goto L377
L354:
    r347 = r344
L355:
    r22.__mypyc_next_label__ = 18; r348 = is_error
    if not r348 goto L569 (error at coroutine:161) else goto L570 :: bool
L356:
    return r347
L357:
    r349 = load_address _Py_NoneStruct
    r350 = type != r349
    if r350 goto L358 else goto L360 :: bool
L358:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L361 (error at coroutine:161) else goto L571 :: bool
L359:
    unreachable
L360:
    inc_ref arg
    goto L372
L361:
    r351 = CPy_CatchError()
    r22.__mypyc_temp__25 = r351; r352 = is_error
    if not r352 goto L572 (error at coroutine:-1) else goto L362 :: bool
L362:
    r353 = load_address r21
    r354 = r22.__mypyc_temp__24
    if is_error(r354) goto L572 (error at coroutine:-1) else goto L363
L363:
    r355 = CPy_YieldFromErrorHandle(r354, r353)
    dec_ref r354
    if is_error(r355) goto L572 (error at coroutine:161) else goto L364
L364:
    if r355 goto L367 else goto L365 :: bool
L365:
    inc_ref r21
    r347 = r21
    r356 = r22.__mypyc_temp__25
    if is_error(r356) goto L573 (error at coroutine:-1) else goto L366
L366:
    CPy_RestoreExcInfo(r356)
    dec_ref r356
    goto L355
L367:
    r346 = r21
    r357 = r22.__mypyc_temp__25
    if is_error(r357) goto L574 (error at coroutine:-1) else goto L368
L368:
    CPy_RestoreExcInfo(r357)
    dec_ref r357
    goto L377
L369:
    r358 = r22.__mypyc_temp__25
    if is_error(r358) goto L378 (error at coroutine:-1) else goto L370
L370:
    CPy_RestoreExcInfo(r358)
    dec_ref r358
    r359 = CPy_KeepPropagating()
    if not r359 goto L378 else goto L575 :: bool
L371:
    unreachable
L372:
    r360 = r22.__mypyc_temp__24
    if is_error(r360) goto L576 (error at coroutine:-1) else goto L373
L373:
    r361 = CPyIter_Send(r360, arg)
    dec_ref r360
    dec_ref arg
    if is_error(r361) goto L577 else goto L374
L374:
    r347 = r361
    goto L355
L375:
    r362 = CPy_FetchStopIterationValue()
    if is_error(r362) goto L378 (error at coroutine:161) else goto L376
L376:
    r346 = r362
L377:
    r22.decoded = r346; r363 = is_error
    if not r363 goto L378 (error at coroutine:161) else goto L397 :: bool
L378:
    r364 = CPy_CatchError()
    r22.__mypyc_temp__26 = r364; r365 = is_error
    if not r365 goto L394 (error at coroutine:-1) else goto L379 :: bool
L379:
    r366 = dank_mids.brownie_patch.call.globals :: static
    r367 = 'InsufficientDataBytes'
    r368 = CPyDict_GetItem(r366, r367)
    if is_error(r368) goto L394 (error at coroutine:162) else goto L380
L380:
    r369 = CPy_ExceptionMatches(r368)
    dec_ref r368
    if r369 goto L381 else goto L392 :: bool
L381:
    r370 = CPy_GetExcValue()
    r22.e = r370; r371 = is_error
    if not r371 goto L394 (error at coroutine:162) else goto L382 :: bool
L382:
    r372 = r22.e
    if is_error(r372) goto L394 (error at coroutine:163) else goto L383
L383:
    r373 = PyObject_Str(r372)
    dec_ref r372
    if is_error(r373) goto L394 (error at coroutine:163) else goto L384
L384:
    r374 = r22.self
    if is_error(r374) goto L578 (error at coroutine:163) else goto L385
L385:
    r375 = r22.self
    if is_error(r375) goto L579 (error at coroutine:163) else goto L386
L386:
    r376 = '_address'
    r377 = CPyObject_GetAttr(r375, r376)
    dec_ref r375
    if is_error(r377) goto L579 (error at coroutine:163) else goto L387
L387:
    r378 = r22.output
    if is_error(r378) goto L580 (error at coroutine:163) else goto L388
L388:
    r379 = dank_mids.brownie_patch.call.globals :: static
    r380 = 'InsufficientDataBytes'
    r381 = CPyDict_GetItem(r379, r380)
    if is_error(r381) goto L581 (error at coroutine:163) else goto L389
L389:
    r382 = [r373, r374, r377, r378]
    r383 = load_address r382
    r384 = PyObject_Vectorcall(r381, r383, 4, 0)
    dec_ref r381
    if is_error(r384) goto L581 (error at coroutine:163) else goto L390
L390:
    dec_ref r373
    dec_ref r374
    dec_ref r377
    dec_ref r378
    CPy_Raise(r384)
    dec_ref r384
    if not 0 goto L394 (error at coroutine:163) else goto L582 :: bool
L391:
    unreachable
L392:
    CPy_Reraise()
    if not 0 goto L394 else goto L583 :: bool
L393:
    unreachable
L394:
    r385 = r22.__mypyc_temp__26
    dec_ref r22
    if is_error(r385) goto L426 (error at coroutine:-1) else goto L395
L395:
    CPy_RestoreExcInfo(r385)
    dec_ref r385
    r386 = CPy_KeepPropagating()
    if not r386 goto L426 else goto L396 :: bool
L396:
    unreachable
L397:
    r387 = r22.decimals
    if is_error(r387) goto L584 (error at coroutine:165) else goto L398
L398:
    r388 = load_address _Py_NoneStruct
    r389 = r387 == r388
    dec_ref r387
    if r389 goto L399 else goto L401 :: bool
L399:
    r390 = r22.decoded
    if is_error(r390) goto L584 (error at coroutine:165) else goto L400
L400:
    r391 = r390
    goto L411
L401:
    r392 = r22.decoded
    if is_error(r392) goto L584 (error at coroutine:165) else goto L402
L402:
    r393 = r22.decimals
    if is_error(r393) goto L585 (error at coroutine:165) else goto L403
L403:
    r394 = unbox(int, r393)
    dec_ref r393
    if is_error(r394) goto L585 (error at coroutine:165) else goto L404
L404:
    r395 = dank_mids.brownie_patch.call.Decimal :: static
    if is_error(r395) goto L586 else goto L407
L405:
    r396 = raise NameError('value for final name "Decimal" was not set')
    if not r396 goto L426 (error at coroutine:165) else goto L406 :: bool
L406:
    unreachable
L407:
    r397 = box(int, r394)
    r398 = [r397]
    r399 = load_address r398
    r400 = PyObject_Vectorcall(r395, r399, 1, 0)
    if is_error(r400) goto L587 (error at coroutine:165) else goto L408
L408:
    dec_ref r397
    r401 = object 10
    r402 = CPyNumber_Power(r401, r400)
    dec_ref r400
    if is_error(r402) goto L585 (error at coroutine:165) else goto L409
L409:
    r403 = PyNumber_TrueDivide(r392, r402)
    dec_ref r392
    dec_ref r402
    if is_error(r403) goto L584 (error at coroutine:165) else goto L410
L410:
    r391 = r403
L411:
    r22.__mypyc_next_label__ = -2; r404 = is_error
    dec_ref r22
    if not r404 goto L588 (error at coroutine:165) else goto L412 :: bool
L412:
    CPyGen_SetStopIterationValue(r391)
    dec_ref r391
    if not 0 goto L426 else goto L413 :: bool
L413:
    unreachable
L414:
    r405 = r23 == 0
    if r405 goto L589 else goto L415 :: bool
L415:
    r406 = r23 == 2
    if r406 goto L590 else goto L591 :: bool
L416:
    r407 = r23 == 4
    if r407 goto L592 else goto L593 :: bool
L417:
    r408 = r23 == 6
    if r408 goto L594 else goto L595 :: bool
L418:
    r409 = r23 == 8
    if r409 goto L596 else goto L597 :: bool
L419:
    r410 = r23 == 10
    if r410 goto L598 else goto L599 :: bool
L420:
    r411 = r23 == 12
    if r411 goto L600 else goto L601 :: bool
L421:
    r412 = r23 == 14
    if r412 goto L602 else goto L603 :: bool
L422:
    r413 = r23 == 16
    if r413 goto L604 else goto L605 :: bool
L423:
    r414 = r23 == 18
    dec_ref r23 :: int
    if r414 goto L357 else goto L606 :: bool
L424:
    r415 = raise StopIteration
    if not r415 goto L426 (error at coroutine:147) else goto L425 :: bool
L425:
    unreachable
L426:
    r416 = <error> :: object
    return r416
L427:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    goto L426
L428:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    dec_ref r22
    goto L426
L429:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    dec_ref r22
    dec_ref r23 :: int
    goto L426
L430:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L4
L431:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L426
L432:
    dec_ref r27
    goto L14
L433:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L10
L434:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L15
L435:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    dec_ref r44
    dec_ref r45
    goto L426
L436:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    dec_ref r44
    goto L426
L437:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    dec_ref r53
    goto L426
L438:
    xdec_ref r1
    goto L29
L439:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L426
L440:
    dec_ref r62
    goto L38
L441:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L33
L442:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L36
L443:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r24
    goto L46
L444:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r24
    dec_ref r62
    goto L46
L445:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r24
    goto L46
L446:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    dec_ref arg
    goto L426
L447:
    xdec_ref r1
    goto L52
L448:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L258
L449:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r78
    goto L258
L450:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r78
    dec_ref r79 :: int
    goto L258
L451:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r78
    dec_ref r79 :: int
    dec_ref r80
    goto L258
L452:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r78
    dec_ref r79 :: int
    dec_ref r80
    dec_ref r81
    goto L258
L453:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r78
    dec_ref r79 :: int
    dec_ref r80
    dec_ref r81
    dec_ref r84
    goto L258
L454:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r84
    dec_ref r85
    goto L258
L455:
    dec_ref r91
    goto L61
L456:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r84
    goto L258
L457:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r84
    dec_ref r92
    goto L258
L458:
    xdec_ref r3
    goto L68
L459:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L258
L460:
    dec_ref r101
    goto L77
L461:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L72
L462:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L75
L463:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L85
L464:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r101
    goto L85
L465:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r100
    goto L85
L466:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L87
L467:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref arg
    goto L258
L468:
    xdec_ref r3
    goto L91
L469:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L95
L470:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L96
L471:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r121
    dec_ref r122
    goto L258
L472:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r121
    goto L258
L473:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r130
    goto L258
L474:
    xdec_ref r5
    goto L109
L475:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L258
L476:
    dec_ref r139
    goto L118
L477:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L113
L478:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L116
L479:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L126
L480:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r139
    goto L126
L481:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L126
L482:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L128
L483:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref arg
    goto L258
L484:
    xdec_ref r5
    goto L132
L485:
    xdec_ref r7
    goto L172
L486:
    xdec_ref r7
    dec_ref r157
    goto L172
L487:
    xdec_ref r7
    dec_ref r157
    dec_ref r161
    goto L172
L488:
    xdec_ref r7
    dec_ref r157
    dec_ref r164
    goto L172
L489:
    xdec_ref r7
    dec_ref r157
    dec_ref r164
    dec_ref r165
    goto L172
L490:
    xdec_ref r7
    goto L146
L491:
    dec_ref r176
    goto L155
L492:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L150
L493:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L153
L494:
    xdec_ref r7
    goto L163
L495:
    xdec_ref r7
    dec_ref r176
    goto L163
L496:
    dec_ref r175
    goto L163
L497:
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L165
L498:
    xdec_ref r7
    dec_ref arg
    goto L172
L499:
    xdec_ref r7
    goto L169
L500:
    xdec_ref r9
    goto L215
L501:
    xdec_ref r9
    goto L212
L502:
    xdec_ref r9
    dec_ref r197
    dec_ref r198
    dec_ref r199
    goto L212
L503:
    xdec_ref r9
    dec_ref r197
    dec_ref r198
    dec_ref r199
    dec_ref r200
    goto L212
L504:
    xdec_ref r9
    dec_ref r197
    dec_ref r198
    dec_ref r199
    dec_ref r201
    goto L212
L505:
    xdec_ref r9
    goto L181
L506:
    dec_ref r211
    goto L190
L507:
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L185
L508:
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L188
L509:
    xdec_ref r9
    goto L198
L510:
    xdec_ref r9
    dec_ref r211
    goto L198
L511:
    dec_ref r210
    goto L198
L512:
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L200
L513:
    xdec_ref r9
    dec_ref arg
    goto L212
L514:
    xdec_ref r9
    goto L204
L515:
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L209
L516:
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L214
L517:
    xdec_ref r11
    goto L254
L518:
    xdec_ref r11
    goto L251
L519:
    xdec_ref r11
    dec_ref r237
    goto L254
L520:
    xdec_ref r11
    dec_ref r238
    goto L254
L521:
    xdec_ref r11
    goto L226
L522:
    dec_ref r248
    goto L235
L523:
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L230
L524:
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L233
L525:
    xdec_ref r11
    goto L243
L526:
    xdec_ref r11
    dec_ref r248
    goto L243
L527:
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L245
L528:
    xdec_ref r11
    dec_ref arg
    goto L254
L529:
    xdec_ref r11
    goto L249
L530:
    xdec_ref r15
    goto L301
L531:
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L253
L532:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L257
L533:
    xdec_ref r15
    goto L298
L534:
    xdec_ref r15
    dec_ref r269
    dec_ref r270
    dec_ref r271
    goto L298
L535:
    xdec_ref r15
    dec_ref r269
    dec_ref r270
    dec_ref r271
    dec_ref r272
    goto L298
L536:
    xdec_ref r15
    dec_ref r269
    dec_ref r270
    dec_ref r271
    dec_ref r273
    goto L298
L537:
    xdec_ref r15
    goto L267
L538:
    dec_ref r283
    goto L276
L539:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L271
L540:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L274
L541:
    xdec_ref r15
    goto L284
L542:
    xdec_ref r15
    dec_ref r283
    goto L284
L543:
    dec_ref r282
    goto L284
L544:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L286
L545:
    xdec_ref r15
    dec_ref arg
    goto L298
L546:
    xdec_ref r15
    goto L290
L547:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L295
L548:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L300
L549:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L340
L550:
    xdec_ref r17
    goto L337
L551:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r309
    goto L340
L552:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r310
    goto L340
L553:
    xdec_ref r17
    goto L312
L554:
    xdec_ref r21
    dec_ref r22
    goto L340
L555:
    dec_ref r320
    goto L321
L556:
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    dec_ref r22
    goto L316
L557:
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    dec_ref r22
    goto L319
L558:
    xdec_ref r17
    xdec_ref r21
    goto L329
L559:
    xdec_ref r17
    xdec_ref r21
    dec_ref r320
    goto L329
L560:
    xdec_ref r21
    goto L329
L561:
    xdec_ref r19
    goto L331
L562:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref arg
    goto L340
L563:
    xdec_ref r17
    goto L335
L564:
    xdec_ref r21
    dec_ref r22
    goto L338
L565:
    xdec_ref r19
    goto L339
L566:
    xdec_ref r21
    goto L378
L567:
    xdec_ref r21
    dec_ref r337
    goto L378
L568:
    xdec_ref r21
    goto L352
L569:
    dec_ref r347
    goto L361
L570:
    xdec_ref r21
    dec_ref r22
    goto L356
L571:
    xdec_ref r21
    dec_ref r22
    goto L359
L572:
    xdec_ref r21
    goto L369
L573:
    xdec_ref r21
    dec_ref r347
    goto L369
L574:
    dec_ref r346
    goto L369
L575:
    dec_ref r22
    goto L371
L576:
    xdec_ref r21
    dec_ref arg
    goto L378
L577:
    xdec_ref r21
    goto L375
L578:
    dec_ref r373
    goto L394
L579:
    dec_ref r373
    dec_ref r374
    goto L394
L580:
    dec_ref r373
    dec_ref r374
    dec_ref r377
    goto L394
L581:
    dec_ref r373
    dec_ref r374
    dec_ref r377
    dec_ref r378
    goto L394
L582:
    dec_ref r22
    goto L391
L583:
    dec_ref r22
    goto L393
L584:
    dec_ref r22
    goto L426
L585:
    dec_ref r22
    dec_ref r392
    goto L426
L586:
    dec_ref r22
    dec_ref r392
    dec_ref r394 :: int
    goto L405
L587:
    dec_ref r22
    dec_ref r392
    dec_ref r397
    goto L426
L588:
    dec_ref r391
    goto L426
L589:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L3
L590:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L34
L591:
    xdec_ref r1
    goto L416
L592:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L73
L593:
    xdec_ref r3
    goto L417
L594:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L114
L595:
    xdec_ref r5
    dec_ref r24
    goto L418
L596:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L151
L597:
    xdec_ref r7
    goto L419
L598:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L186
L599:
    xdec_ref r9
    goto L420
L600:
    xdec_ref r19
    dec_ref r23 :: int
    goto L231
L601:
    xdec_ref r11
    xdec_ref r13
    goto L421
L602:
    xdec_ref r19
    dec_ref r23 :: int
    goto L272
L603:
    xdec_ref r15
    goto L422
L604:
    dec_ref r23 :: int
    goto L317
L605:
    xdec_ref r17
    xdec_ref r19
    goto L423
L606:
    xdec_ref r21
    dec_ref r22
    goto L424

def coroutine__get_coroutine_fn_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine__get_coroutine_fn_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine__get_coroutine_fn_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine__get_coroutine_fn_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine__get_coroutine_fn_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine__get_coroutine_fn_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutine__get_coroutine_fn_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutine__get_coroutine_fn_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def coroutine__get_coroutine_fn_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine__get_coroutine_fn_obj.__call__(__mypyc_self__, self, args, block_identifier, decimals, override):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_obj
    self :: object
    args :: tuple
    block_identifier :: union[object, None]
    decimals :: union[int, None]
    override :: union[dict, None]
    r0 :: dank_mids.brownie_patch.call._get_coroutine_fn_env
    r1, r2, r3 :: object
    r4 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_env
    r5, r6, r7, r8, r9, r10 :: bool
    r11 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    r12, r13 :: bool
    r14 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L18 (error at coroutine:147) else goto L1
L1:
    if is_error(block_identifier) goto L2 else goto L19
L2:
    r1 = box(None, 1)
    inc_ref r1
    block_identifier = r1
L3:
    if is_error(decimals) goto L4 else goto L20
L4:
    r2 = box(None, 1)
    inc_ref r2
    decimals = r2
L5:
    if is_error(override) goto L6 else goto L21
L6:
    r3 = box(None, 1)
    inc_ref r3
    override = r3
L7:
    r4 = coroutine__get_coroutine_fn_env()
    if is_error(r4) goto L22 (error at coroutine:147) else goto L8
L8:
    r4.__mypyc_env__ = r0; r5 = is_error
    if not r5 goto L23 (error at coroutine:147) else goto L9 :: bool
L9:
    inc_ref self
    r4.self = self; r6 = is_error
    if not r6 goto L23 (error at coroutine:147) else goto L10 :: bool
L10:
    inc_ref args
    r4.args = args; r7 = is_error
    if not r7 goto L23 (error at coroutine:147) else goto L11 :: bool
L11:
    r4.block_identifier = block_identifier; r8 = is_error
    if not r8 goto L24 (error at coroutine:147) else goto L12 :: bool
L12:
    r4.decimals = decimals; r9 = is_error
    if not r9 goto L25 (error at coroutine:147) else goto L13 :: bool
L13:
    r4.override = override; r10 = is_error
    if not r10 goto L26 (error at coroutine:147) else goto L14 :: bool
L14:
    r11 = coroutine__get_coroutine_fn_gen()
    if is_error(r11) goto L26 (error at coroutine:147) else goto L15
L15:
    inc_ref r4
    r11.__mypyc_env__ = r4; r12 = is_error
    if not r12 goto L27 (error at coroutine:147) else goto L16 :: bool
L16:
    r4.__mypyc_next_label__ = 0; r13 = is_error
    dec_ref r4
    if not r13 goto L28 (error at coroutine:147) else goto L17 :: bool
L17:
    return r11
L18:
    r14 = <error> :: object
    return r14
L19:
    inc_ref block_identifier
    goto L3
L20:
    inc_ref decimals
    goto L5
L21:
    inc_ref override
    goto L7
L22:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r0
    goto L18
L23:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L18
L24:
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L18
L25:
    dec_ref override
    dec_ref r4
    goto L18
L26:
    dec_ref r4
    goto L18
L27:
    dec_ref r4
    dec_ref r11
    goto L18
L28:
    dec_ref r11
    goto L18

def _get_coroutine_fn(w3, len_inputs):
    w3 :: object
    len_inputs :: int
    r0 :: dank_mids.brownie_patch.call._get_coroutine_fn_env
    r1, r2, r3, r4 :: bool
    r5 :: int
    r6 :: bit
    r7 :: object
    r8, r9 :: bool
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: bool
    r14 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_obj
    r15 :: bool
    coroutine, r16 :: object
L0:
    r0 = _get_coroutine_fn_env()
    if is_error(r0) goto L18 (error at _get_coroutine_fn:141) else goto L1
L1:
    inc_ref w3
    r0.w3 = w3; r1 = is_error
    if not r1 goto L19 (error at _get_coroutine_fn:141) else goto L2 :: bool
L2:
    inc_ref len_inputs :: int
    r0.len_inputs = len_inputs; r2 = is_error
    if not r2 goto L19 (error at _get_coroutine_fn:141) else goto L3 :: bool
L3:
    r3 = dank_mids.brownie_patch.call.APPLICATION_MODE :: static
    if is_error(r3) goto L20 else goto L6
L4:
    r4 = raise NameError('value for final name "APPLICATION_MODE" was not set')
    if not r4 goto L18 (error at _get_coroutine_fn:142) else goto L5 :: bool
L5:
    unreachable
L6:
    if r3 goto L9 else goto L7 :: bool
L7:
    r5 = r0.len_inputs
    if is_error(r5) goto L19 (error at _get_coroutine_fn:142) else goto L8
L8:
    r6 = r5 != 0
    dec_ref r5 :: int
    if r6 goto L9 else goto L13 :: bool
L9:
    r7 = dank_mids.brownie_patch.call.encode :: static
    if is_error(r7) goto L21 else goto L12
L10:
    r8 = raise NameError('value for final name "encode" was not set')
    if not r8 goto L18 (error at _get_coroutine_fn:143) else goto L11 :: bool
L11:
    unreachable
L12:
    inc_ref r7
    r0.get_request_data = r7; r9 = is_error
    if not r9 goto L19 (error at _get_coroutine_fn:143) else goto L15 :: bool
L13:
    r10 = dank_mids.brownie_patch.call.globals :: static
    r11 = '_request_data_no_args'
    r12 = CPyDict_GetItem(r10, r11)
    if is_error(r12) goto L19 (error at _get_coroutine_fn:145) else goto L14
L14:
    r0.get_request_data = r12; r13 = is_error
    if not r13 goto L19 (error at _get_coroutine_fn:145) else goto L15 :: bool
L15:
    r14 = coroutine__get_coroutine_fn_obj()
    if is_error(r14) goto L19 (error at _get_coroutine_fn:147) else goto L16
L16:
    r14.__mypyc_env__ = r0; r15 = is_error
    if not r15 goto L22 (error at _get_coroutine_fn:147) else goto L17 :: bool
L17:
    coroutine = r14
    return coroutine
L18:
    r16 = <error> :: object
    return r16
L19:
    dec_ref r0
    goto L18
L20:
    dec_ref r0
    goto L4
L21:
    dec_ref r0
    goto L10
L22:
    dec_ref r14
    goto L18

def _call_no_args(self):
    self :: object
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4 :: str
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
L0:
    r0 = 'coroutine'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L3 (error at _call_no_args:172) else goto L1
L1:
    r4 = '__await__'
    r5 = [r3]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r4, r6, 9223372036854775809, 0)
    if is_error(r7) goto L4 (error at _call_no_args:172) else goto L2
L2:
    dec_ref r3
    return r7
L3:
    r8 = <error> :: object
    return r8
L4:
    dec_ref r3
    goto L3

def encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    type, value, traceback, arg, r0, r1 :: object
    r2 :: dank_mids.brownie_patch.call.encode_input_env
    r3 :: int
    r4 :: object
    r5 :: bit
    r6 :: bool
    r7 :: tuple
    r8, r9 :: bool
    r10 :: tuple
    r11 :: ptr
    r12 :: native_int
    r13, r14 :: short_int
    r15 :: bit
    r16 :: tuple
    r17 :: short_int
    r18 :: object
    r19 :: bool
    r20, r21 :: object
    r22 :: bool
    r23 :: i32
    r24 :: bit
    r25 :: bool
    r26 :: object
    r27 :: str
    r28 :: bool
    r29, r30 :: short_int
    r31 :: bool
    r32 :: object
    r33 :: str
    r34, r35 :: object
    r36 :: str
    r37 :: object
    r38 :: tuple
    r39 :: dict
    r40 :: str
    r41 :: object
    r42 :: list
    r43, r44, r45 :: ptr
    r46 :: object
    r47 :: tuple
    r48 :: dict
    r49 :: object
    r50 :: bool
    r51 :: object
    r52 :: tuple
    r53 :: object
    r54 :: list
    r55, r56 :: ptr
    r57 :: object
    r58 :: tuple
    r59 :: dict
    r60, r61 :: object
    r62 :: bool
    r63, r64, r65, r66, r67 :: object
    r68 :: bool
    r69 :: object
    r70 :: bit
    r71 :: tuple[object, object, object]
    r72 :: bool
    r73 :: object_ptr
    r74 :: object
    r75 :: bool
    r76, r77, r78 :: tuple[object, object, object]
    r79 :: bit
    r80, r81, r82 :: object
    r83 :: bool
    r84 :: tuple[object, object, object]
    r85 :: bool
    r86 :: object
    r87 :: str
    r88, r89 :: object
    r90 :: str
    r91 :: object
    r92 :: tuple[object, object]
    r93 :: object
    r94 :: bit
    r95 :: object
    r96 :: str
    r97, r98 :: object
    r99 :: str
    r100 :: object
    r101 :: tuple
    r102 :: dict
    r103 :: str
    r104 :: object
    r105 :: list
    r106, r107, r108 :: ptr
    r109 :: object
    r110 :: tuple
    r111 :: dict
    r112 :: object
    r113 :: bool
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: bit
    r118 :: object
    r119 :: bool
    r120 :: str
    r121 :: dict
    r122 :: str
    r123 :: object
    r124 :: str
    r125, r126, r127 :: object
    r128 :: str
    r129 :: object
    r130 :: str
    r131 :: object[5]
    r132 :: object_ptr
    r133 :: object
    r134 :: dict
    r135 :: str
    r136 :: object
    r137 :: str
    r138 :: object
    r139 :: str
    r140 :: object
    r141 :: dict
    r142 :: str
    r143 :: object
    r144 :: object[1]
    r145 :: object_ptr
    r146 :: object
    r147 :: dict
    r148 :: str
    r149 :: object
    r150 :: str
    r151 :: i32
    r152 :: bit
    r153 :: int
    r154 :: bit
    r155 :: object
    r156 :: str
    r157, r158 :: object
    r159 :: str
    r160 :: object
    r161 :: tuple
    r162 :: dict
    r163 :: str
    r164 :: object
    r165 :: list
    r166, r167, r168 :: ptr
    r169 :: object
    r170 :: tuple
    r171 :: dict
    r172, r173, r174 :: object
    r175 :: str
    r176 :: object
    r177 :: bool
    r178 :: dict
    r179 :: str
    r180 :: object
    r181 :: bit
    r182 :: int
    r183 :: bit
    r184 :: object
    r185 :: str
    r186, r187 :: object
    r188 :: str
    r189 :: object
    r190 :: tuple
    r191 :: dict
    r192 :: str
    r193 :: object
    r194 :: list
    r195, r196, r197 :: ptr
    r198 :: object
    r199 :: tuple
    r200 :: dict
    r201, r202, r203 :: object
    r204 :: str
    r205 :: object
    r206 :: bool
    r207, r208 :: tuple[object, object, object]
    r209 :: bit
    r210, r211 :: object
    r212 :: str
    r213 :: object
    r214 :: i32
    r215 :: bit
    r216 :: bool
    r217 :: object
    r218 :: str
    r219 :: object
    r220 :: tuple
    r221 :: ptr
    r222 :: native_int
    r223 :: short_int
    r224 :: bit
    r225, r226 :: object
    r227 :: str
    r228 :: bool
    r229 :: str
    r230 :: object
    r231 :: str
    r232 :: object
    r233 :: str
    r234 :: object[2]
    r235 :: object_ptr
    r236 :: object
    r237 :: bool
    r238, r239 :: str
    r240 :: list
    r241 :: object
    r242 :: str
    r243 :: bool
    r244, r245, r246 :: str
    r247 :: bool
    r248, r249 :: object
    r250 :: str
    r251 :: object
    r252 :: str
    r253 :: object
    r254, r255 :: str
    r256 :: object
    r257 :: str
    r258 :: object
    r259, r260, r261, r262 :: str
    r263 :: object[1]
    r264 :: object_ptr
    r265, r266 :: object
    r267 :: bool
    r268, r269 :: bit
    r270 :: bool
    r271 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_env__
    if is_error(r2) goto L206 (error at encode_input:175) else goto L1
L1:
    r3 = r2.__mypyc_next_label__
    if is_error(r3) goto L207 (error at encode_input:175) else goto L201
L2:
    r4 = load_address _Py_NoneStruct
    r5 = type != r4
    if r5 goto L208 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L205 (error at encode_input:175) else goto L4 :: bool
L4:
    unreachable
L5:
    r6 = 0
    r7 = r2.args
    if is_error(r7) goto L207 (error at encode_input:177) else goto L6
L6:
    r2.__mypyc_temp__27 = r7; r8 = is_error
    if not r8 goto L207 (error at encode_input:-1) else goto L7 :: bool
L7:
    r2.__mypyc_temp__28 = 0; r9 = is_error
    if not r9 goto L207 (error at encode_input:-1) else goto L8 :: bool
L8:
    r10 = r2.__mypyc_temp__27
    if is_error(r10) goto L207 (error at encode_input:177) else goto L9
L9:
    r11 = get_element_ptr r10 ob_size :: PyVarObject
    r12 = load_mem r11 :: native_int*
    dec_ref r10
    r13 = r12 << 1
    r14 = r2.__mypyc_temp__28
    if is_error(r14) goto L207 (error at encode_input:177) else goto L10
L10:
    r15 = r14 < r13 :: signed
    if r15 goto L11 else goto L27 :: bool
L11:
    r16 = r2.__mypyc_temp__27
    if is_error(r16) goto L207 (error at encode_input:177) else goto L12
L12:
    r17 = r2.__mypyc_temp__28
    if is_error(r17) goto L209 (error at encode_input:177) else goto L13
L13:
    r18 = CPySequenceTuple_GetItem(r16, r17)
    dec_ref r16
    if is_error(r18) goto L207 (error at encode_input:177) else goto L14
L14:
    r2.arg = r18; r19 = is_error
    if not r19 goto L207 (error at encode_input:177) else goto L15 :: bool
L15:
    r20 = r2.arg
    if is_error(r20) goto L207 (error at encode_input:177) else goto L16
L16:
    r21 = dank_mids.brownie_patch.call.Contract :: static
    if is_error(r21) goto L210 else goto L19
L17:
    r22 = raise NameError('value for final name "Contract" was not set')
    if not r22 goto L205 (error at encode_input:177) else goto L18 :: bool
L18:
    unreachable
L19:
    r23 = PyObject_IsInstance(r20, r21)
    dec_ref r20
    r24 = r23 >= 0 :: signed
    if not r24 goto L207 (error at encode_input:177) else goto L20 :: bool
L20:
    r25 = truncate r23: i32 to builtins.bool
    if r25 goto L21 else goto L22 :: bool
L21:
    if r25 goto L24 else goto L25 :: bool
L22:
    r26 = r2.arg
    if is_error(r26) goto L207 (error at encode_input:177) else goto L23
L23:
    r27 = '__contains__'
    r28 = PyObject_HasAttr(r26, r27)
    dec_ref r26
    if r28 goto L24 else goto L25 :: bool
L24:
    r6 = 1
    goto L27
L25:
    r29 = r2.__mypyc_temp__28
    if is_error(r29) goto L207 (error at encode_input:177) else goto L26
L26:
    r30 = r29 + 2
    r2.__mypyc_temp__28 = r30; r31 = is_error
    if not r31 goto L207 (error at encode_input:177) else goto L8 :: bool
L27:
    if r6 goto L211 else goto L40 :: bool
L28:
    r32 = r2.call
    if is_error(r32) goto L212 (error at encode_input:179) else goto L29
L29:
    r33 = 'abi'
    r34 = CPyObject_GetAttr(r32, r33)
    dec_ref r32
    if is_error(r34) goto L212 (error at encode_input:179) else goto L30
L30:
    r35 = r2.call
    if is_error(r35) goto L213 (error at encode_input:179) else goto L31
L31:
    r36 = 'signature'
    r37 = CPyObject_GetAttr(r35, r36)
    dec_ref r35
    if is_error(r37) goto L213 (error at encode_input:179) else goto L32
L32:
    r38 = r2.args
    if is_error(r38) goto L214 (error at encode_input:179) else goto L33
L33:
    r39 = dank_mids.brownie_patch.call.globals :: static
    r40 = '__encode_input'
    r41 = CPyDict_GetItem(r39, r40)
    if is_error(r41) goto L215 (error at encode_input:179) else goto L34
L34:
    r42 = PyList_New(2)
    if is_error(r42) goto L216 (error at encode_input:179) else goto L35
L35:
    r43 = get_element_ptr r42 ob_item :: PyListObject
    r44 = load_mem r43 :: ptr*
    set_mem r44, r34 :: builtins.object*
    r45 = r44 + 8
    set_mem r45, r37 :: builtins.object*
    r46 = CPyList_Extend(r42, r38)
    dec_ref r38
    if is_error(r46) goto L217 (error at encode_input:179) else goto L218
L36:
    r47 = PyList_AsTuple(r42)
    dec_ref r42
    if is_error(r47) goto L219 (error at encode_input:179) else goto L37
L37:
    r48 = PyDict_New()
    if is_error(r48) goto L220 (error at encode_input:179) else goto L38
L38:
    r49 = PyObject_Call(r41, r47, r48)
    dec_ref r41
    dec_ref r47
    dec_ref r48
    if is_error(r49) goto L212 (error at encode_input:179) else goto L39
L39:
    r2.data = r49; r50 = is_error
    if not r50 goto L212 (error at encode_input:179) else goto L157 :: bool
L40:
    r51 = r2.call
    if is_error(r51) goto L221 (error at encode_input:182) else goto L41
L41:
    r52 = r2.args
    if is_error(r52) goto L222 (error at encode_input:182) else goto L42
L42:
    r53 = r2.get_request_data
    if is_error(r53) goto L223 (error at encode_input:182) else goto L43
L43:
    r54 = PyList_New(1)
    if is_error(r54) goto L224 (error at encode_input:182) else goto L44
L44:
    r55 = get_element_ptr r54 ob_item :: PyListObject
    r56 = load_mem r55 :: ptr*
    set_mem r56, r51 :: builtins.object*
    r57 = CPyList_Extend(r54, r52)
    dec_ref r52
    if is_error(r57) goto L225 (error at encode_input:182) else goto L226
L45:
    r58 = PyList_AsTuple(r54)
    dec_ref r54
    if is_error(r58) goto L227 (error at encode_input:182) else goto L46
L46:
    r59 = PyDict_New()
    if is_error(r59) goto L228 (error at encode_input:182) else goto L47
L47:
    r60 = PyObject_Call(r53, r58, r59)
    dec_ref r53
    dec_ref r58
    dec_ref r59
    if is_error(r60) goto L221 (error at encode_input:182) else goto L48
L48:
    r61 = CPy_GetCoro(r60)
    dec_ref r60
    if is_error(r61) goto L221 (error at encode_input:182) else goto L49
L49:
    r2.__mypyc_temp__29 = r61; r62 = is_error
    if not r62 goto L221 (error at encode_input:-1) else goto L50 :: bool
L50:
    r63 = r2.__mypyc_temp__29
    if is_error(r63) goto L221 (error at encode_input:-1) else goto L51
L51:
    r64 = CPyIter_Next(r63)
    dec_ref r63
    if is_error(r64) goto L229 else goto L54
L52:
    r65 = CPy_FetchStopIterationValue()
    if is_error(r65) goto L78 (error at encode_input:182) else goto L53
L53:
    r66 = r65
    goto L77
L54:
    r67 = r64
L55:
    r2.__mypyc_next_label__ = 2; r68 = is_error
    if not r68 goto L230 (error at encode_input:182) else goto L231 :: bool
L56:
    return r67
L57:
    r69 = load_address _Py_NoneStruct
    r70 = type != r69
    if r70 goto L58 else goto L60 :: bool
L58:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L61 (error at encode_input:182) else goto L232 :: bool
L59:
    unreachable
L60:
    inc_ref arg
    goto L72
L61:
    r71 = CPy_CatchError()
    r2.__mypyc_temp__30 = r71; r72 = is_error
    if not r72 goto L233 (error at encode_input:-1) else goto L62 :: bool
L62:
    r73 = load_address r1
    r74 = r2.__mypyc_temp__29
    if is_error(r74) goto L233 (error at encode_input:-1) else goto L63
L63:
    r75 = CPy_YieldFromErrorHandle(r74, r73)
    dec_ref r74
    if is_error(r75) goto L233 (error at encode_input:182) else goto L64
L64:
    if r75 goto L67 else goto L65 :: bool
L65:
    inc_ref r1
    r67 = r1
    r76 = r2.__mypyc_temp__30
    if is_error(r76) goto L234 (error at encode_input:-1) else goto L66
L66:
    CPy_RestoreExcInfo(r76)
    dec_ref r76
    goto L55
L67:
    r66 = r1
    r77 = r2.__mypyc_temp__30
    if is_error(r77) goto L235 (error at encode_input:-1) else goto L68
L68:
    CPy_RestoreExcInfo(r77)
    dec_ref r77
    goto L77
L69:
    r78 = r2.__mypyc_temp__30
    if is_error(r78) goto L78 (error at encode_input:-1) else goto L70
L70:
    CPy_RestoreExcInfo(r78)
    dec_ref r78
    r79 = CPy_KeepPropagating()
    if not r79 goto L78 else goto L236 :: bool
L71:
    unreachable
L72:
    r80 = r2.__mypyc_temp__29
    if is_error(r80) goto L237 (error at encode_input:-1) else goto L73
L73:
    r81 = CPyIter_Send(r80, arg)
    dec_ref r80
    dec_ref arg
    if is_error(r81) goto L238 else goto L74
L74:
    r67 = r81
    goto L55
L75:
    r82 = CPy_FetchStopIterationValue()
    if is_error(r82) goto L78 (error at encode_input:182) else goto L76
L76:
    r66 = r82
L77:
    r2.data = r66; r83 = is_error
    if not r83 goto L78 (error at encode_input:182) else goto L157 :: bool
L78:
    r84 = CPy_CatchError()
    r2.__mypyc_temp__31 = r84; r85 = is_error
    if not r85 goto L154 (error at encode_input:-1) else goto L79 :: bool
L79:
    r86 = builtins :: module
    r87 = 'AttributeError'
    r88 = CPyObject_GetAttr(r86, r87)
    if is_error(r88) goto L154 (error at encode_input:183) else goto L80
L80:
    r89 = builtins :: module
    r90 = 'TypeError'
    r91 = CPyObject_GetAttr(r89, r90)
    if is_error(r91) goto L239 (error at encode_input:183) else goto L81
L81:
    r92 = (r88, r91)
    r93 = box(tuple[object, object], r92)
    r94 = CPy_ExceptionMatches(r93)
    dec_ref r93
    if r94 goto L82 else goto L94 :: bool
L82:
    r95 = r2.call
    if is_error(r95) goto L154 (error at encode_input:185) else goto L83
L83:
    r96 = 'abi'
    r97 = CPyObject_GetAttr(r95, r96)
    dec_ref r95
    if is_error(r97) goto L154 (error at encode_input:185) else goto L84
L84:
    r98 = r2.call
    if is_error(r98) goto L240 (error at encode_input:185) else goto L85
L85:
    r99 = 'signature'
    r100 = CPyObject_GetAttr(r98, r99)
    dec_ref r98
    if is_error(r100) goto L240 (error at encode_input:185) else goto L86
L86:
    r101 = r2.args
    if is_error(r101) goto L241 (error at encode_input:185) else goto L87
L87:
    r102 = dank_mids.brownie_patch.call.globals :: static
    r103 = '__encode_input'
    r104 = CPyDict_GetItem(r102, r103)
    if is_error(r104) goto L242 (error at encode_input:185) else goto L88
L88:
    r105 = PyList_New(2)
    if is_error(r105) goto L243 (error at encode_input:185) else goto L89
L89:
    r106 = get_element_ptr r105 ob_item :: PyListObject
    r107 = load_mem r106 :: ptr*
    set_mem r107, r97 :: builtins.object*
    r108 = r107 + 8
    set_mem r108, r100 :: builtins.object*
    r109 = CPyList_Extend(r105, r101)
    dec_ref r101
    if is_error(r109) goto L244 (error at encode_input:185) else goto L245
L90:
    r110 = PyList_AsTuple(r105)
    dec_ref r105
    if is_error(r110) goto L246 (error at encode_input:185) else goto L91
L91:
    r111 = PyDict_New()
    if is_error(r111) goto L247 (error at encode_input:185) else goto L92
L92:
    r112 = PyObject_Call(r104, r110, r111)
    dec_ref r104
    dec_ref r110
    dec_ref r111
    if is_error(r112) goto L154 (error at encode_input:185) else goto L93
L93:
    r2.data = r112; r113 = is_error
    if not r113 goto L154 (error at encode_input:185) else goto L152 :: bool
L94:
    r114 = dank_mids.brownie_patch.call.globals :: static
    r115 = 'BrokenProcessPool'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L154 (error at encode_input:187) else goto L95
L95:
    r117 = CPy_ExceptionMatches(r116)
    dec_ref r116
    if r117 goto L96 else goto L130 :: bool
L96:
    r118 = dank_mids.brownie_patch.call.logger :: static
    if is_error(r118) goto L97 else goto L99
L97:
    r119 = raise NameError('value for final name "logger" was not set')
    if not r119 goto L154 (error at encode_input:188) else goto L248 :: bool
L98:
    unreachable
L99:
    r120 = 'Oh fuck, you broke the %s while decoding %s with abi %s'
    r121 = dank_mids.brownie_patch.call.globals :: static
    r122 = 'ENVS'
    r123 = CPyDict_GetItem(r121, r122)
    if is_error(r123) goto L154 (error at encode_input:188) else goto L100
L100:
    r124 = 'BROWNIE_ENCODER_PROCESSES'
    r125 = CPyObject_GetAttr(r123, r124)
    dec_ref r123
    if is_error(r125) goto L154 (error at encode_input:188) else goto L101
L101:
    r126 = r2.data
    if is_error(r126) goto L249 (error at encode_input:188) else goto L102
L102:
    r127 = r2.call
    if is_error(r127) goto L250 (error at encode_input:188) else goto L103
L103:
    r128 = 'abi'
    r129 = CPyObject_GetAttr(r127, r128)
    dec_ref r127
    if is_error(r129) goto L250 (error at encode_input:188) else goto L104
L104:
    r130 = 'critical'
    r131 = [r118, r120, r125, r126, r129]
    r132 = load_address r131
    r133 = PyObject_VectorcallMethod(r130, r132, 9223372036854775813, 0)
    if is_error(r133) goto L251 (error at encode_input:188) else goto L252
L105:
    dec_ref r125
    dec_ref r126
    dec_ref r129
    r134 = dank_mids.brownie_patch.call.globals :: static
    r135 = 'ENVS'
    r136 = CPyDict_GetItem(r134, r135)
    if is_error(r136) goto L154 (error at encode_input:190) else goto L106
L106:
    r137 = 'BROWNIE_ENCODER_PROCESSES'
    r138 = CPyObject_GetAttr(r136, r137)
    dec_ref r136
    if is_error(r138) goto L154 (error at encode_input:190) else goto L107
L107:
    r139 = '_max_workers'
    r140 = CPyObject_GetAttr(r138, r139)
    dec_ref r138
    if is_error(r140) goto L154 (error at encode_input:190) else goto L108
L108:
    r141 = dank_mids.brownie_patch.call.globals :: static
    r142 = 'AsyncProcessPoolExecutor'
    r143 = CPyDict_GetItem(r141, r142)
    if is_error(r143) goto L253 (error at encode_input:190) else goto L109
L109:
    r144 = [r140]
    r145 = load_address r144
    r146 = PyObject_Vectorcall(r143, r145, 1, 0)
    dec_ref r143
    if is_error(r146) goto L253 (error at encode_input:190) else goto L110
L110:
    dec_ref r140
    r147 = dank_mids.brownie_patch.call.globals :: static
    r148 = 'ENVS'
    r149 = CPyDict_GetItem(r147, r148)
    if is_error(r149) goto L254 (error at encode_input:190) else goto L111
L111:
    r150 = 'BROWNIE_ENCODER_PROCESSES'
    r151 = PyObject_SetAttr(r149, r150, r146)
    dec_ref r149
    dec_ref r146
    r152 = r151 >= 0 :: signed
    if not r152 goto L154 (error at encode_input:190) else goto L112 :: bool
L112:
    r153 = r2.len_inputs
    if is_error(r153) goto L154 (error at encode_input:191) else goto L113
L113:
    r154 = r153 != 0
    dec_ref r153 :: int
    if r154 goto L114 else goto L126 :: bool
L114:
    r155 = r2.call
    if is_error(r155) goto L154 (error at encode_input:191) else goto L115
L115:
    r156 = 'abi'
    r157 = CPyObject_GetAttr(r155, r156)
    dec_ref r155
    if is_error(r157) goto L154 (error at encode_input:191) else goto L116
L116:
    r158 = r2.call
    if is_error(r158) goto L255 (error at encode_input:191) else goto L117
L117:
    r159 = 'signature'
    r160 = CPyObject_GetAttr(r158, r159)
    dec_ref r158
    if is_error(r160) goto L255 (error at encode_input:191) else goto L118
L118:
    r161 = r2.args
    if is_error(r161) goto L256 (error at encode_input:191) else goto L119
L119:
    r162 = dank_mids.brownie_patch.call.globals :: static
    r163 = '__encode_input'
    r164 = CPyDict_GetItem(r162, r163)
    if is_error(r164) goto L257 (error at encode_input:191) else goto L120
L120:
    r165 = PyList_New(2)
    if is_error(r165) goto L258 (error at encode_input:191) else goto L121
L121:
    r166 = get_element_ptr r165 ob_item :: PyListObject
    r167 = load_mem r166 :: ptr*
    set_mem r167, r157 :: builtins.object*
    r168 = r167 + 8
    set_mem r168, r160 :: builtins.object*
    r169 = CPyList_Extend(r165, r161)
    dec_ref r161
    if is_error(r169) goto L259 (error at encode_input:191) else goto L260
L122:
    r170 = PyList_AsTuple(r165)
    dec_ref r165
    if is_error(r170) goto L261 (error at encode_input:191) else goto L123
L123:
    r171 = PyDict_New()
    if is_error(r171) goto L262 (error at encode_input:191) else goto L124
L124:
    r172 = PyObject_Call(r164, r170, r171)
    dec_ref r164
    dec_ref r170
    dec_ref r171
    if is_error(r172) goto L154 (error at encode_input:191) else goto L125
L125:
    r173 = r172
    goto L129
L126:
    r174 = r2.call
    if is_error(r174) goto L154 (error at encode_input:191) else goto L127
L127:
    r175 = 'signature'
    r176 = CPyObject_GetAttr(r174, r175)
    dec_ref r174
    if is_error(r176) goto L154 (error at encode_input:191) else goto L128
L128:
    r173 = r176
L129:
    r2.data = r173; r177 = is_error
    if not r177 goto L154 (error at encode_input:191) else goto L152 :: bool
L130:
    r178 = dank_mids.brownie_patch.call.globals :: static
    r179 = 'PicklingError'
    r180 = CPyDict_GetItem(r178, r179)
    if is_error(r180) goto L154 (error at encode_input:192) else goto L131
L131:
    r181 = CPy_ExceptionMatches(r180)
    dec_ref r180
    if r181 goto L132 else goto L150 :: bool
L132:
    r182 = r2.len_inputs
    if is_error(r182) goto L154 (error at encode_input:193) else goto L133
L133:
    r183 = r182 != 0
    dec_ref r182 :: int
    if r183 goto L134 else goto L146 :: bool
L134:
    r184 = r2.call
    if is_error(r184) goto L154 (error at encode_input:193) else goto L135
L135:
    r185 = 'abi'
    r186 = CPyObject_GetAttr(r184, r185)
    dec_ref r184
    if is_error(r186) goto L154 (error at encode_input:193) else goto L136
L136:
    r187 = r2.call
    if is_error(r187) goto L263 (error at encode_input:193) else goto L137
L137:
    r188 = 'signature'
    r189 = CPyObject_GetAttr(r187, r188)
    dec_ref r187
    if is_error(r189) goto L263 (error at encode_input:193) else goto L138
L138:
    r190 = r2.args
    if is_error(r190) goto L264 (error at encode_input:193) else goto L139
L139:
    r191 = dank_mids.brownie_patch.call.globals :: static
    r192 = '__encode_input'
    r193 = CPyDict_GetItem(r191, r192)
    if is_error(r193) goto L265 (error at encode_input:193) else goto L140
L140:
    r194 = PyList_New(2)
    if is_error(r194) goto L266 (error at encode_input:193) else goto L141
L141:
    r195 = get_element_ptr r194 ob_item :: PyListObject
    r196 = load_mem r195 :: ptr*
    set_mem r196, r186 :: builtins.object*
    r197 = r196 + 8
    set_mem r197, r189 :: builtins.object*
    r198 = CPyList_Extend(r194, r190)
    dec_ref r190
    if is_error(r198) goto L267 (error at encode_input:193) else goto L268
L142:
    r199 = PyList_AsTuple(r194)
    dec_ref r194
    if is_error(r199) goto L269 (error at encode_input:193) else goto L143
L143:
    r200 = PyDict_New()
    if is_error(r200) goto L270 (error at encode_input:193) else goto L144
L144:
    r201 = PyObject_Call(r193, r199, r200)
    dec_ref r193
    dec_ref r199
    dec_ref r200
    if is_error(r201) goto L154 (error at encode_input:193) else goto L145
L145:
    r202 = r201
    goto L149
L146:
    r203 = r2.call
    if is_error(r203) goto L154 (error at encode_input:193) else goto L147
L147:
    r204 = 'signature'
    r205 = CPyObject_GetAttr(r203, r204)
    dec_ref r203
    if is_error(r205) goto L154 (error at encode_input:193) else goto L148
L148:
    r202 = r205
L149:
    r2.data = r202; r206 = is_error
    if not r206 goto L154 (error at encode_input:193) else goto L152 :: bool
L150:
    CPy_Reraise()
    if not 0 goto L154 else goto L271 :: bool
L151:
    unreachable
L152:
    r207 = r2.__mypyc_temp__31
    if is_error(r207) goto L212 (error at encode_input:-1) else goto L153
L153:
    CPy_RestoreExcInfo(r207)
    dec_ref r207
    goto L157
L154:
    r208 = r2.__mypyc_temp__31
    dec_ref r2
    if is_error(r208) goto L205 (error at encode_input:-1) else goto L155
L155:
    CPy_RestoreExcInfo(r208)
    dec_ref r208
    r209 = CPy_KeepPropagating()
    if not r209 goto L205 else goto L156 :: bool
L156:
    unreachable
L157:
    r210 = r2.data
    if is_error(r210) goto L212 (error at encode_input:195) else goto L158
L158:
    r211 = builtins :: module
    r212 = 'Exception'
    r213 = CPyObject_GetAttr(r211, r212)
    if is_error(r213) goto L272 (error at encode_input:195) else goto L159
L159:
    r214 = PyObject_IsInstance(r210, r213)
    dec_ref r210
    dec_ref r213
    r215 = r214 >= 0 :: signed
    if not r215 goto L212 (error at encode_input:195) else goto L160 :: bool
L160:
    r216 = truncate r214: i32 to builtins.bool
    if r216 goto L161 else goto L197 :: bool
L161:
    r217 = r2.data
    if is_error(r217) goto L212 (error at encode_input:196) else goto L162
L162:
    r218 = 'args'
    r219 = CPyObject_GetAttr(r217, r218)
    dec_ref r217
    if is_error(r219) goto L212 (error at encode_input:196) else goto L163
L163:
    r220 = cast(tuple, r219)
    if is_error(r220) goto L212 (error at encode_input:196) else goto L164
L164:
    r221 = get_element_ptr r220 ob_size :: PyVarObject
    r222 = load_mem r221 :: native_int*
    dec_ref r220
    r223 = r222 << 1
    r224 = r223 != 2
    if r224 goto L165 else goto L168 :: bool
L165:
    r225 = r2.data
    dec_ref r2
    if is_error(r225) goto L205 (error at encode_input:197) else goto L166
L166:
    CPy_Raise(r225)
    dec_ref r225
    if not 0 goto L205 (error at encode_input:197) else goto L167 :: bool
L167:
    unreachable
L168:
    r226 = r2.data
    if is_error(r226) goto L212 (error at encode_input:198) else goto L169
L169:
    r227 = PyObject_Str(r226)
    dec_ref r226
    if is_error(r227) goto L212 (error at encode_input:198) else goto L170
L170:
    r2.exc_str = r227; r228 = is_error
    if not r228 goto L212 (error at encode_input:198) else goto L171 :: bool
L171:
    r229 = r2.exc_str
    if is_error(r229) goto L212 (error at encode_input:199) else goto L172
L172:
    r230 = r2.call
    if is_error(r230) goto L273 (error at encode_input:199) else goto L173
L173:
    r231 = '_name'
    r232 = CPyObject_GetAttr(r230, r231)
    dec_ref r230
    if is_error(r232) goto L273 (error at encode_input:199) else goto L174
L174:
    r233 = 'startswith'
    r234 = [r229, r232]
    r235 = load_address r234
    r236 = PyObject_VectorcallMethod(r233, r235, 9223372036854775810, 0)
    if is_error(r236) goto L274 (error at encode_input:199) else goto L175
L175:
    dec_ref r229
    dec_ref r232
    r237 = unbox(bool, r236)
    dec_ref r236
    if is_error(r237) goto L212 (error at encode_input:199) else goto L176
L176:
    if r237 goto L177 else goto L182 :: bool
L177:
    r238 = r2.exc_str
    if is_error(r238) goto L212 (error at encode_input:200) else goto L178
L178:
    r239 = ' '
    r240 = CPyStr_Split(r238, r239, 2)
    dec_ref r238
    if is_error(r240) goto L212 (error at encode_input:200) else goto L179
L179:
    r241 = CPyList_GetItemShort(r240, 2)
    dec_ref r240
    if is_error(r241) goto L212 (error at encode_input:200) else goto L180
L180:
    r242 = cast(str, r241)
    if is_error(r242) goto L212 (error at encode_input:200) else goto L181
L181:
    r2.exc_str = r242; r243 = is_error
    if not r243 goto L212 (error at encode_input:200) else goto L185 :: bool
L182:
    r244 = ': '
    r245 = r2.exc_str
    if is_error(r245) goto L212 (error at encode_input:202) else goto L183
L183:
    r246 = CPyStr_Build(2, r244, r245)
    dec_ref r245
    if is_error(r246) goto L212 (error at encode_input:202) else goto L184
L184:
    r2.exc_str = r246; r247 = is_error
    if not r247 goto L212 (error at encode_input:202) else goto L185 :: bool
L185:
    r248 = r2.data
    if is_error(r248) goto L212 (error at encode_input:203) else goto L186
L186:
    r249 = PyObject_Type(r248)
    dec_ref r248
    r250 = "Contract('"
    r251 = r2.call
    if is_error(r251) goto L275 (error at encode_input:203) else goto L187
L187:
    r252 = '_address'
    r253 = CPyObject_GetAttr(r251, r252)
    dec_ref r251
    if is_error(r253) goto L275 (error at encode_input:203) else goto L188
L188:
    r254 = PyObject_Str(r253)
    dec_ref r253
    if is_error(r254) goto L275 (error at encode_input:203) else goto L189
L189:
    r255 = "')."
    r256 = r2.call
    if is_error(r256) goto L276 (error at encode_input:203) else goto L190
L190:
    r257 = '_name'
    r258 = CPyObject_GetAttr(r256, r257)
    dec_ref r256
    if is_error(r258) goto L276 (error at encode_input:203) else goto L191
L191:
    r259 = PyObject_Str(r258)
    dec_ref r258
    if is_error(r259) goto L276 (error at encode_input:203) else goto L192
L192:
    r260 = ': '
    r261 = r2.exc_str
    dec_ref r2
    if is_error(r261) goto L277 (error at encode_input:203) else goto L193
L193:
    r262 = CPyStr_Build(6, r250, r254, r255, r259, r260, r261)
    dec_ref r254
    dec_ref r259
    dec_ref r261
    if is_error(r262) goto L278 (error at encode_input:203) else goto L194
L194:
    r263 = [r262]
    r264 = load_address r263
    r265 = PyObject_Vectorcall(r249, r264, 1, 0)
    dec_ref r249
    if is_error(r265) goto L279 (error at encode_input:203) else goto L195
L195:
    dec_ref r262
    CPy_Raise(r265)
    dec_ref r265
    if not 0 goto L205 (error at encode_input:203) else goto L196 :: bool
L196:
    unreachable
L197:
    r266 = r2.data
    if is_error(r266) goto L212 (error at encode_input:204) else goto L198
L198:
    r2.__mypyc_next_label__ = -2; r267 = is_error
    dec_ref r2
    if not r267 goto L280 (error at encode_input:204) else goto L199 :: bool
L199:
    CPyGen_SetStopIterationValue(r266)
    dec_ref r266
    if not 0 goto L205 else goto L200 :: bool
L200:
    unreachable
L201:
    r268 = r3 == 0
    if r268 goto L281 else goto L202 :: bool
L202:
    r269 = r3 == 2
    dec_ref r3 :: int
    if r269 goto L57 else goto L282 :: bool
L203:
    r270 = raise StopIteration
    if not r270 goto L205 (error at encode_input:175) else goto L204 :: bool
L204:
    unreachable
L205:
    r271 = <error> :: object
    return r271
L206:
    xdec_ref r1
    goto L205
L207:
    xdec_ref r1
    dec_ref r2
    goto L205
L208:
    xdec_ref r1
    dec_ref r2
    goto L3
L209:
    xdec_ref r1
    dec_ref r2
    dec_ref r16
    goto L205
L210:
    xdec_ref r1
    dec_ref r2
    dec_ref r20
    goto L17
L211:
    xdec_ref r1
    goto L28
L212:
    dec_ref r2
    goto L205
L213:
    dec_ref r2
    dec_ref r34
    goto L205
L214:
    dec_ref r2
    dec_ref r34
    dec_ref r37
    goto L205
L215:
    dec_ref r2
    dec_ref r34
    dec_ref r37
    dec_ref r38
    goto L205
L216:
    dec_ref r2
    dec_ref r34
    dec_ref r37
    dec_ref r38
    dec_ref r41
    goto L205
L217:
    dec_ref r2
    dec_ref r41
    dec_ref r42
    goto L205
L218:
    dec_ref r46
    goto L36
L219:
    dec_ref r2
    dec_ref r41
    goto L205
L220:
    dec_ref r2
    dec_ref r41
    dec_ref r47
    goto L205
L221:
    xdec_ref r1
    goto L78
L222:
    xdec_ref r1
    dec_ref r51
    goto L78
L223:
    xdec_ref r1
    dec_ref r51
    dec_ref r52
    goto L78
L224:
    xdec_ref r1
    dec_ref r51
    dec_ref r52
    dec_ref r53
    goto L78
L225:
    xdec_ref r1
    dec_ref r53
    dec_ref r54
    goto L78
L226:
    dec_ref r57
    goto L45
L227:
    xdec_ref r1
    dec_ref r53
    goto L78
L228:
    xdec_ref r1
    dec_ref r53
    dec_ref r58
    goto L78
L229:
    xdec_ref r1
    goto L52
L230:
    dec_ref r67
    goto L61
L231:
    xdec_ref r1
    dec_ref r2
    goto L56
L232:
    xdec_ref r1
    dec_ref r2
    goto L59
L233:
    xdec_ref r1
    goto L69
L234:
    xdec_ref r1
    dec_ref r67
    goto L69
L235:
    dec_ref r66
    goto L69
L236:
    dec_ref r2
    goto L71
L237:
    xdec_ref r1
    dec_ref arg
    goto L78
L238:
    xdec_ref r1
    goto L75
L239:
    dec_ref r88
    goto L154
L240:
    dec_ref r97
    goto L154
L241:
    dec_ref r97
    dec_ref r100
    goto L154
L242:
    dec_ref r97
    dec_ref r100
    dec_ref r101
    goto L154
L243:
    dec_ref r97
    dec_ref r100
    dec_ref r101
    dec_ref r104
    goto L154
L244:
    dec_ref r104
    dec_ref r105
    goto L154
L245:
    dec_ref r109
    goto L90
L246:
    dec_ref r104
    goto L154
L247:
    dec_ref r104
    dec_ref r110
    goto L154
L248:
    dec_ref r2
    goto L98
L249:
    dec_ref r125
    goto L154
L250:
    dec_ref r125
    dec_ref r126
    goto L154
L251:
    dec_ref r125
    dec_ref r126
    dec_ref r129
    goto L154
L252:
    dec_ref r133
    goto L105
L253:
    dec_ref r140
    goto L154
L254:
    dec_ref r146
    goto L154
L255:
    dec_ref r157
    goto L154
L256:
    dec_ref r157
    dec_ref r160
    goto L154
L257:
    dec_ref r157
    dec_ref r160
    dec_ref r161
    goto L154
L258:
    dec_ref r157
    dec_ref r160
    dec_ref r161
    dec_ref r164
    goto L154
L259:
    dec_ref r164
    dec_ref r165
    goto L154
L260:
    dec_ref r169
    goto L122
L261:
    dec_ref r164
    goto L154
L262:
    dec_ref r164
    dec_ref r170
    goto L154
L263:
    dec_ref r186
    goto L154
L264:
    dec_ref r186
    dec_ref r189
    goto L154
L265:
    dec_ref r186
    dec_ref r189
    dec_ref r190
    goto L154
L266:
    dec_ref r186
    dec_ref r189
    dec_ref r190
    dec_ref r193
    goto L154
L267:
    dec_ref r193
    dec_ref r194
    goto L154
L268:
    dec_ref r198
    goto L142
L269:
    dec_ref r193
    goto L154
L270:
    dec_ref r193
    dec_ref r199
    goto L154
L271:
    dec_ref r2
    goto L151
L272:
    dec_ref r2
    dec_ref r210
    goto L205
L273:
    dec_ref r2
    dec_ref r229
    goto L205
L274:
    dec_ref r2
    dec_ref r229
    dec_ref r232
    goto L205
L275:
    dec_ref r2
    dec_ref r249
    goto L205
L276:
    dec_ref r2
    dec_ref r249
    dec_ref r254
    goto L205
L277:
    dec_ref r249
    dec_ref r254
    dec_ref r259
    goto L205
L278:
    dec_ref r249
    goto L205
L279:
    dec_ref r262
    goto L205
L280:
    dec_ref r266
    goto L205
L281:
    dec_ref r3 :: int
    goto L2
L282:
    xdec_ref r1
    dec_ref r2
    goto L203

def encode_input_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def encode_input_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def encode_input_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def encode_input_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def encode_input_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def encode_input_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def encode_input(call, len_inputs, get_request_data, args):
    call :: object
    len_inputs :: int
    get_request_data :: object
    args :: tuple
    r0 :: dank_mids.brownie_patch.call.encode_input_env
    r1, r2, r3, r4 :: bool
    r5 :: dank_mids.brownie_patch.call.encode_input_gen
    r6, r7 :: bool
    r8 :: object
L0:
    r0 = encode_input_env()
    if is_error(r0) goto L9 (error at encode_input:175) else goto L1
L1:
    inc_ref call
    r0.call = call; r1 = is_error
    if not r1 goto L10 (error at encode_input:175) else goto L2 :: bool
L2:
    inc_ref len_inputs :: int
    r0.len_inputs = len_inputs; r2 = is_error
    if not r2 goto L10 (error at encode_input:175) else goto L3 :: bool
L3:
    inc_ref get_request_data
    r0.get_request_data = get_request_data; r3 = is_error
    if not r3 goto L10 (error at encode_input:175) else goto L4 :: bool
L4:
    inc_ref args
    r0.args = args; r4 = is_error
    if not r4 goto L10 (error at encode_input:175) else goto L5 :: bool
L5:
    r5 = encode_input_gen()
    if is_error(r5) goto L10 (error at encode_input:175) else goto L6
L6:
    inc_ref r0
    r5.__mypyc_env__ = r0; r6 = is_error
    if not r6 goto L11 (error at encode_input:175) else goto L7 :: bool
L7:
    r0.__mypyc_next_label__ = 0; r7 = is_error
    dec_ref r0
    if not r7 goto L12 (error at encode_input:175) else goto L8 :: bool
L8:
    return r5
L9:
    r8 = <error> :: object
    return r8
L10:
    dec_ref r0
    goto L9
L11:
    dec_ref r0
    dec_ref r5
    goto L9
L12:
    dec_ref r5
    goto L9

def decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    type, value, traceback, arg, r0, r1, r2, r3 :: object
    r4 :: dank_mids.brownie_patch.call.decode_output_env
    r5 :: int
    r6 :: object
    r7 :: bit
    r8 :: object
    r9 :: str
    r10 :: object
    r11 :: bytes
    r12 :: dict
    r13 :: None
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: i32
    r18 :: bit
    r19 :: bool
    r20, r21 :: bytes
    r22 :: i32
    r23 :: bit
    r24 :: bool
    r25 :: bytes
    r26 :: object
    r27 :: str
    r28 :: object
    r29 :: dict
    r30 :: object
    r31 :: bool
    r32 :: object
    r33 :: bytes
    r34 :: object
    r35 :: bool
    r36 :: object[2]
    r37 :: object_ptr
    r38, r39 :: object
    r40 :: bool
    r41, r42, r43, r44, r45 :: object
    r46 :: bool
    r47 :: object
    r48 :: bit
    r49 :: tuple[object, object, object]
    r50 :: bool
    r51 :: object_ptr
    r52 :: object
    r53 :: bool
    r54, r55, r56 :: tuple[object, object, object]
    r57 :: bit
    r58, r59, r60 :: object
    r61 :: bool
    r62 :: tuple[object, object, object]
    r63 :: bool
    r64 :: dict
    r65 :: str
    r66 :: object
    r67 :: bit
    r68 :: object
    r69 :: bool
    r70 :: str
    r71 :: dict
    r72 :: str
    r73 :: object
    r74 :: str
    r75 :: object
    r76 :: bytes
    r77 :: object
    r78 :: str
    r79 :: object
    r80 :: str
    r81 :: object[5]
    r82 :: object_ptr
    r83 :: object
    r84 :: dict
    r85 :: str
    r86 :: object
    r87 :: str
    r88 :: object
    r89 :: str
    r90 :: object
    r91 :: dict
    r92 :: str
    r93 :: object
    r94 :: object[1]
    r95 :: object_ptr
    r96 :: object
    r97 :: dict
    r98 :: str
    r99 :: object
    r100 :: str
    r101 :: i32
    r102 :: bit
    r103 :: bytes
    r104 :: object
    r105 :: str
    r106 :: object
    r107 :: dict
    r108 :: object
    r109 :: bool
    r110, r111 :: tuple[object, object, object]
    r112 :: bit
    r113, r114 :: object
    r115 :: str
    r116 :: object
    r117 :: i32
    r118 :: bit
    r119 :: bool
    r120, r121 :: object
    r122 :: bool
    r123 :: tuple[object, object, object]
    r124 :: bool
    r125 :: dict
    r126 :: str
    r127 :: object
    r128 :: bit
    r129 :: object
    r130 :: bool
    r131 :: object
    r132 :: str
    r133, r134, r135 :: object
    r136 :: str
    r137 :: object
    r138 :: bytes
    r139 :: list
    r140 :: object
    r141 :: i32
    r142 :: bit
    r143 :: i32
    r144 :: bit
    r145 :: i32
    r146 :: bit
    r147 :: tuple
    r148 :: object
    r149 :: str
    r150 :: i32
    r151 :: bit
    r152 :: object
    r153 :: str
    r154 :: object
    r155 :: bit
    r156 :: object
    r157 :: bool
    r158 :: object
    r159, r160 :: str
    r161 :: i32
    r162 :: bool
    r163 :: object
    r164 :: bool
    r165 :: str
    r166 :: object
    r167 :: str
    r168 :: object[3]
    r169 :: object_ptr
    r170, r171 :: object
    r172 :: str
    r173 :: object
    r174 :: dict
    r175 :: str
    r176 :: object
    r177 :: set
    r178 :: i32
    r179 :: bit
    r180 :: bool
    r181 :: object
    r182 :: str
    r183 :: object
    r184 :: i32
    r185 :: bit
    r186 :: object
    r187 :: bytes
    r188, r189 :: object
    r190 :: bool
    r191, r192, r193, r194, r195 :: object
    r196 :: bool
    r197 :: object
    r198 :: bit
    r199 :: tuple[object, object, object]
    r200 :: bool
    r201 :: object_ptr
    r202 :: object
    r203 :: bool
    r204, r205, r206 :: tuple[object, object, object]
    r207 :: bit
    r208, r209, r210 :: object
    r211 :: tuple[object, object, object]
    r212 :: bool
    r213 :: tuple[object, object, object]
    r214, r215, r216, r217 :: bit
    r218 :: bool
    r219 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = __mypyc_self__.__mypyc_env__
    if is_error(r4) goto L189 (error at decode_output:207) else goto L1
L1:
    r5 = r4.__mypyc_next_label__
    if is_error(r5) goto L190 (error at decode_output:207) else goto L183
L2:
    r6 = load_address _Py_NoneStruct
    r7 = type != r6
    if r7 goto L191 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L188 (error at decode_output:207) else goto L4 :: bool
L4:
    unreachable
L5:
    r8 = r4.call
    if is_error(r8) goto L190 (error at decode_output:208) else goto L6
L6:
    r9 = 'abi'
    r10 = CPyObject_GetAttr(r8, r9)
    dec_ref r8
    if is_error(r10) goto L190 (error at decode_output:208) else goto L7
L7:
    r11 = r4.data
    if is_error(r11) goto L192 (error at decode_output:208) else goto L8
L8:
    r12 = cast(dict, r10)
    if is_error(r12) goto L193 (error at decode_output:208) else goto L9
L9:
    r13 = __validate_output(r12, r11)
    dec_ref r12
    dec_ref r11
    if is_error(r13) goto L190 (error at decode_output:208) else goto L10
L10:
    r14 = r4.call
    if is_error(r14) goto L194 (error at decode_output:210) else goto L11
L11:
    r15 = '_skip_decoder_proc_pool'
    r16 = CPyObject_GetAttr(r14, r15)
    dec_ref r14
    if is_error(r16) goto L194 (error at decode_output:210) else goto L12
L12:
    r17 = PyObject_IsTrue(r16)
    dec_ref r16
    r18 = r17 >= 0 :: signed
    if not r18 goto L194 (error at decode_output:210) else goto L13 :: bool
L13:
    r19 = truncate r17: i32 to builtins.bool
    if r19 goto L195 else goto L14 :: bool
L14:
    r20 = b'Unexpected error'
    r21 = r4.data
    if is_error(r21) goto L194 (error at decode_output:210) else goto L15
L15:
    r22 = PySequence_Contains(r21, r20)
    dec_ref r21
    r23 = r22 >= 0 :: signed
    if not r23 goto L194 (error at decode_output:210) else goto L16 :: bool
L16:
    r24 = truncate r22: i32 to builtins.bool
    if r24 goto L195 else goto L23 :: bool
L17:
    r25 = r4.data
    if is_error(r25) goto L102 (error at decode_output:212) else goto L18
L18:
    r26 = r4.call
    if is_error(r26) goto L196 (error at decode_output:212) else goto L19
L19:
    r27 = 'abi'
    r28 = CPyObject_GetAttr(r26, r27)
    dec_ref r26
    if is_error(r28) goto L196 (error at decode_output:212) else goto L20
L20:
    r29 = cast(dict, r28)
    if is_error(r29) goto L196 (error at decode_output:212) else goto L21
L21:
    r30 = __decode_output(r25, r29)
    dec_ref r25
    dec_ref r29
    if is_error(r30) goto L102 (error at decode_output:212) else goto L22
L22:
    r4.decoded = r30; r31 = is_error
    if not r31 goto L102 (error at decode_output:212) else goto L91 :: bool
L23:
    r32 = r4.call
    if is_error(r32) goto L197 (error at decode_output:215) else goto L24
L24:
    r33 = r4.data
    if is_error(r33) goto L198 (error at decode_output:215) else goto L25
L25:
    r34 = dank_mids.brownie_patch.call.decode :: static
    if is_error(r34) goto L199 else goto L28
L26:
    r35 = raise NameError('value for final name "decode" was not set')
    if not r35 goto L59 (error at decode_output:215) else goto L200 :: bool
L27:
    unreachable
L28:
    r36 = [r32, r33]
    r37 = load_address r36
    r38 = PyObject_Vectorcall(r34, r37, 2, 0)
    if is_error(r38) goto L201 (error at decode_output:215) else goto L29
L29:
    dec_ref r32
    dec_ref r33
    r39 = CPy_GetCoro(r38)
    dec_ref r38
    if is_error(r39) goto L197 (error at decode_output:215) else goto L30
L30:
    r4.__mypyc_temp__32 = r39; r40 = is_error
    if not r40 goto L197 (error at decode_output:-1) else goto L31 :: bool
L31:
    r41 = r4.__mypyc_temp__32
    if is_error(r41) goto L197 (error at decode_output:-1) else goto L32
L32:
    r42 = CPyIter_Next(r41)
    dec_ref r41
    if is_error(r42) goto L202 else goto L35
L33:
    r43 = CPy_FetchStopIterationValue()
    if is_error(r43) goto L59 (error at decode_output:215) else goto L34
L34:
    r44 = r43
    goto L58
L35:
    r45 = r42
L36:
    r4.__mypyc_next_label__ = 2; r46 = is_error
    if not r46 goto L203 (error at decode_output:215) else goto L204 :: bool
L37:
    return r45
L38:
    r47 = load_address _Py_NoneStruct
    r48 = type != r47
    if r48 goto L39 else goto L41 :: bool
L39:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L42 (error at decode_output:215) else goto L205 :: bool
L40:
    unreachable
L41:
    inc_ref arg
    goto L53
L42:
    r49 = CPy_CatchError()
    r4.__mypyc_temp__33 = r49; r50 = is_error
    if not r50 goto L206 (error at decode_output:-1) else goto L43 :: bool
L43:
    r51 = load_address r1
    r52 = r4.__mypyc_temp__32
    if is_error(r52) goto L206 (error at decode_output:-1) else goto L44
L44:
    r53 = CPy_YieldFromErrorHandle(r52, r51)
    dec_ref r52
    if is_error(r53) goto L206 (error at decode_output:215) else goto L45
L45:
    if r53 goto L48 else goto L46 :: bool
L46:
    inc_ref r1
    r45 = r1
    r54 = r4.__mypyc_temp__33
    if is_error(r54) goto L207 (error at decode_output:-1) else goto L47
L47:
    CPy_RestoreExcInfo(r54)
    dec_ref r54
    goto L36
L48:
    r44 = r1
    r55 = r4.__mypyc_temp__33
    if is_error(r55) goto L208 (error at decode_output:-1) else goto L49
L49:
    CPy_RestoreExcInfo(r55)
    dec_ref r55
    goto L58
L50:
    r56 = r4.__mypyc_temp__33
    if is_error(r56) goto L59 (error at decode_output:-1) else goto L51
L51:
    CPy_RestoreExcInfo(r56)
    dec_ref r56
    r57 = CPy_KeepPropagating()
    if not r57 goto L59 else goto L209 :: bool
L52:
    unreachable
L53:
    r58 = r4.__mypyc_temp__32
    if is_error(r58) goto L210 (error at decode_output:-1) else goto L54
L54:
    r59 = CPyIter_Send(r58, arg)
    dec_ref r58
    dec_ref arg
    if is_error(r59) goto L211 else goto L55
L55:
    r45 = r59
    goto L36
L56:
    r60 = CPy_FetchStopIterationValue()
    if is_error(r60) goto L59 (error at decode_output:215) else goto L57
L57:
    r44 = r60
L58:
    r4.decoded = r44; r61 = is_error
    if not r61 goto L59 (error at decode_output:215) else goto L91 :: bool
L59:
    r62 = CPy_CatchError()
    r4.__mypyc_temp__34 = r62; r63 = is_error
    if not r63 goto L88 (error at decode_output:-1) else goto L60 :: bool
L60:
    r64 = dank_mids.brownie_patch.call.globals :: static
    r65 = 'BrokenProcessPool'
    r66 = CPyDict_GetItem(r64, r65)
    if is_error(r66) goto L88 (error at decode_output:217) else goto L61
L61:
    r67 = CPy_ExceptionMatches(r66)
    dec_ref r66
    if r67 goto L62 else goto L84 :: bool
L62:
    r68 = dank_mids.brownie_patch.call.logger :: static
    if is_error(r68) goto L63 else goto L65
L63:
    r69 = raise NameError('value for final name "logger" was not set')
    if not r69 goto L88 (error at decode_output:219) else goto L212 :: bool
L64:
    unreachable
L65:
    r70 = 'Oh fuck, you broke the %s while decoding %s with abi %s'
    r71 = dank_mids.brownie_patch.call.globals :: static
    r72 = 'ENVS'
    r73 = CPyDict_GetItem(r71, r72)
    if is_error(r73) goto L88 (error at decode_output:219) else goto L66
L66:
    r74 = 'BROWNIE_DECODER_PROCESSES'
    r75 = CPyObject_GetAttr(r73, r74)
    dec_ref r73
    if is_error(r75) goto L88 (error at decode_output:219) else goto L67
L67:
    r76 = r4.data
    if is_error(r76) goto L213 (error at decode_output:219) else goto L68
L68:
    r77 = r4.call
    if is_error(r77) goto L214 (error at decode_output:219) else goto L69
L69:
    r78 = 'abi'
    r79 = CPyObject_GetAttr(r77, r78)
    dec_ref r77
    if is_error(r79) goto L214 (error at decode_output:219) else goto L70
L70:
    r80 = 'critical'
    r81 = [r68, r70, r75, r76, r79]
    r82 = load_address r81
    r83 = PyObject_VectorcallMethod(r80, r82, 9223372036854775813, 0)
    if is_error(r83) goto L215 (error at decode_output:219) else goto L216
L71:
    dec_ref r75
    dec_ref r76
    dec_ref r79
    r84 = dank_mids.brownie_patch.call.globals :: static
    r85 = 'ENVS'
    r86 = CPyDict_GetItem(r84, r85)
    if is_error(r86) goto L88 (error at decode_output:220) else goto L72
L72:
    r87 = 'BROWNIE_DECODER_PROCESSES'
    r88 = CPyObject_GetAttr(r86, r87)
    dec_ref r86
    if is_error(r88) goto L88 (error at decode_output:220) else goto L73
L73:
    r89 = '_max_workers'
    r90 = CPyObject_GetAttr(r88, r89)
    dec_ref r88
    if is_error(r90) goto L88 (error at decode_output:220) else goto L74
L74:
    r91 = dank_mids.brownie_patch.call.globals :: static
    r92 = 'AsyncProcessPoolExecutor'
    r93 = CPyDict_GetItem(r91, r92)
    if is_error(r93) goto L217 (error at decode_output:220) else goto L75
L75:
    r94 = [r90]
    r95 = load_address r94
    r96 = PyObject_Vectorcall(r93, r95, 1, 0)
    dec_ref r93
    if is_error(r96) goto L217 (error at decode_output:220) else goto L76
L76:
    dec_ref r90
    r97 = dank_mids.brownie_patch.call.globals :: static
    r98 = 'ENVS'
    r99 = CPyDict_GetItem(r97, r98)
    if is_error(r99) goto L218 (error at decode_output:220) else goto L77
L77:
    r100 = 'BROWNIE_DECODER_PROCESSES'
    r101 = PyObject_SetAttr(r99, r100, r96)
    dec_ref r99
    dec_ref r96
    r102 = r101 >= 0 :: signed
    if not r102 goto L88 (error at decode_output:220) else goto L78 :: bool
L78:
    r103 = r4.data
    if is_error(r103) goto L88 (error at decode_output:221) else goto L79
L79:
    r104 = r4.call
    if is_error(r104) goto L219 (error at decode_output:221) else goto L80
L80:
    r105 = 'abi'
    r106 = CPyObject_GetAttr(r104, r105)
    dec_ref r104
    if is_error(r106) goto L219 (error at decode_output:221) else goto L81
L81:
    r107 = cast(dict, r106)
    if is_error(r107) goto L219 (error at decode_output:221) else goto L82
L82:
    r108 = __decode_output(r103, r107)
    dec_ref r103
    dec_ref r107
    if is_error(r108) goto L88 (error at decode_output:221) else goto L83
L83:
    r4.decoded = r108; r109 = is_error
    if not r109 goto L88 (error at decode_output:221) else goto L86 :: bool
L84:
    CPy_Reraise()
    if not 0 goto L88 else goto L220 :: bool
L85:
    unreachable
L86:
    r110 = r4.__mypyc_temp__34
    if is_error(r110) goto L102 (error at decode_output:-1) else goto L87
L87:
    CPy_RestoreExcInfo(r110)
    dec_ref r110
    goto L91
L88:
    r111 = r4.__mypyc_temp__34
    if is_error(r111) goto L102 (error at decode_output:-1) else goto L89
L89:
    CPy_RestoreExcInfo(r111)
    dec_ref r111
    r112 = CPy_KeepPropagating()
    if not r112 goto L102 else goto L221 :: bool
L90:
    unreachable
L91:
    r113 = r4.decoded
    if is_error(r113) goto L102 (error at decode_output:223) else goto L92
L92:
    r114 = builtins :: module
    r115 = 'Exception'
    r116 = CPyObject_GetAttr(r114, r115)
    if is_error(r116) goto L222 (error at decode_output:223) else goto L93
L93:
    r117 = PyObject_IsInstance(r113, r116)
    dec_ref r113
    dec_ref r116
    r118 = r117 >= 0 :: signed
    if not r118 goto L102 (error at decode_output:223) else goto L94 :: bool
L94:
    r119 = truncate r117: i32 to builtins.bool
    if r119 goto L95 else goto L98 :: bool
L95:
    r120 = r4.decoded
    if is_error(r120) goto L102 (error at decode_output:224) else goto L96
L96:
    CPy_Raise(r120)
    dec_ref r120
    if not 0 goto L102 (error at decode_output:224) else goto L223 :: bool
L97:
    unreachable
L98:
    r121 = r4.decoded
    if is_error(r121) goto L102 (error at decode_output:225) else goto L99
L99:
    r4.__mypyc_next_label__ = -2; r122 = is_error
    if not r122 goto L224 (error at decode_output:225) else goto L225 :: bool
L100:
    CPyGen_SetStopIterationValue(r121)
    dec_ref r121
    if not 0 goto L188 else goto L101 :: bool
L101:
    unreachable
L102:
    r123 = CPy_CatchError()
    r4.__mypyc_temp__35 = r123; r124 = is_error
    if not r124 goto L226 (error at decode_output:-1) else goto L103 :: bool
L103:
    r125 = dank_mids.brownie_patch.call.globals :: static
    r126 = 'InsufficientDataBytes'
    r127 = CPyDict_GetItem(r125, r126)
    if is_error(r127) goto L226 (error at decode_output:226) else goto L104
L104:
    r128 = CPy_ExceptionMatches(r127)
    dec_ref r127
    if r128 goto L227 else goto L122 :: bool
L105:
    r129 = CPy_GetExcValue()
    r4.e = r129; r130 = is_error
    if not r130 goto L180 (error at decode_output:226) else goto L106 :: bool
L106:
    r131 = r4.e
    if is_error(r131) goto L180 (error at decode_output:228) else goto L107
L107:
    r132 = 'args'
    r133 = CPyObject_GetAttr(r131, r132)
    dec_ref r131
    if is_error(r133) goto L180 (error at decode_output:228) else goto L108
L108:
    r134 = r4.call
    if is_error(r134) goto L228 (error at decode_output:228) else goto L109
L109:
    r135 = r4.call
    if is_error(r135) goto L229 (error at decode_output:228) else goto L110
L110:
    r136 = '_address'
    r137 = CPyObject_GetAttr(r135, r136)
    dec_ref r135
    if is_error(r137) goto L229 (error at decode_output:228) else goto L111
L111:
    r138 = r4.data
    if is_error(r138) goto L230 (error at decode_output:228) else goto L112
L112:
    r139 = PyList_New(0)
    if is_error(r139) goto L231 (error at decode_output:228) else goto L113
L113:
    r140 = CPyList_Extend(r139, r133)
    dec_ref r133
    if is_error(r140) goto L232 (error at decode_output:228) else goto L233
L114:
    r141 = PyList_Append(r139, r134)
    dec_ref r134
    r142 = r141 >= 0 :: signed
    if not r142 goto L234 (error at decode_output:228) else goto L115 :: bool
L115:
    r143 = PyList_Append(r139, r137)
    dec_ref r137
    r144 = r143 >= 0 :: signed
    if not r144 goto L235 (error at decode_output:228) else goto L116 :: bool
L116:
    r145 = PyList_Append(r139, r138)
    dec_ref r138
    r146 = r145 >= 0 :: signed
    if not r146 goto L236 (error at decode_output:228) else goto L117 :: bool
L117:
    r147 = PyList_AsTuple(r139)
    dec_ref r139
    if is_error(r147) goto L180 (error at decode_output:228) else goto L118
L118:
    r148 = r4.e
    if is_error(r148) goto L237 (error at decode_output:228) else goto L119
L119:
    r149 = 'args'
    r150 = PyObject_SetAttr(r148, r149, r147)
    dec_ref r148
    dec_ref r147
    r151 = r150 >= 0 :: signed
    if not r151 goto L180 (error at decode_output:228) else goto L120 :: bool
L120:
    CPy_Reraise()
    if not 0 goto L180 else goto L238 :: bool
L121:
    unreachable
L122:
    r152 = builtins :: module
    r153 = 'AttributeError'
    r154 = CPyObject_GetAttr(r152, r153)
    if is_error(r154) goto L226 (error at decode_output:230) else goto L123
L123:
    r155 = CPy_ExceptionMatches(r154)
    dec_ref r154
    if r155 goto L124 else goto L239 :: bool
L124:
    r156 = CPy_GetExcValue()
    r4.e = r156; r157 = is_error
    if not r157 goto L226 (error at decode_output:230) else goto L125 :: bool
L125:
    r158 = r4.e
    if is_error(r158) goto L226 (error at decode_output:232) else goto L126
L126:
    r159 = PyObject_Str(r158)
    dec_ref r158
    if is_error(r159) goto L226 (error at decode_output:232) else goto L127
L127:
    r160 = " object has no attribute '_skip_decoder_proc_pool'"
    r161 = CPyStr_Endswith(r159, r160)
    dec_ref r159
    r162 = truncate r161: i32 to builtins.bool
    if r162 goto L130 else goto L240 :: bool
L128:
    CPy_Reraise()
    if not 0 goto L180 else goto L241 :: bool
L129:
    unreachable
L130:
    r163 = dank_mids.brownie_patch.call.logger :: static
    if is_error(r163) goto L242 else goto L133
L131:
    r164 = raise NameError('value for final name "logger" was not set')
    if not r164 goto L180 (error at decode_output:234) else goto L243 :: bool
L132:
    unreachable
L133:
    r165 = 'DEBUG ME BRO: %s'
    r166 = r4.e
    if is_error(r166) goto L226 (error at decode_output:234) else goto L134
L134:
    r167 = 'debug'
    r168 = [r163, r165, r166]
    r169 = load_address r168
    r170 = PyObject_VectorcallMethod(r167, r169, 9223372036854775811, 0)
    if is_error(r170) goto L244 (error at decode_output:234) else goto L245
L135:
    dec_ref r166
    r171 = r4.call
    if is_error(r171) goto L226 (error at decode_output:235) else goto L136
L136:
    r172 = '_address'
    r173 = CPyObject_GetAttr(r171, r172)
    dec_ref r171
    if is_error(r173) goto L226 (error at decode_output:235) else goto L137
L137:
    r174 = dank_mids.brownie_patch.call.globals :: static
    r175 = '_skip_proc_pool'
    r176 = CPyDict_GetItem(r174, r175)
    if is_error(r176) goto L246 (error at decode_output:235) else goto L138
L138:
    r177 = cast(set, r176)
    if is_error(r177) goto L246 (error at decode_output:235) else goto L139
L139:
    r178 = PySet_Contains(r177, r173)
    dec_ref r177
    dec_ref r173
    r179 = r178 >= 0 :: signed
    if not r179 goto L226 (error at decode_output:235) else goto L140 :: bool
L140:
    r180 = truncate r178: i32 to builtins.bool
    r181 = r4.call
    if is_error(r181) goto L226 (error at decode_output:235) else goto L141
L141:
    r182 = '_skip_decoder_proc_pool'
    r183 = box(bool, r180)
    r184 = PyObject_SetAttr(r181, r182, r183)
    dec_ref r181
    r185 = r184 >= 0 :: signed
    if not r185 goto L226 (error at decode_output:235) else goto L142 :: bool
L142:
    r186 = r4.call
    if is_error(r186) goto L226 (error at decode_output:236) else goto L143
L143:
    r187 = r4.data
    if is_error(r187) goto L247 (error at decode_output:236) else goto L144
L144:
    r188 = decode_output(r186, r187)
    dec_ref r186
    dec_ref r187
    if is_error(r188) goto L226 (error at decode_output:236) else goto L145
L145:
    r189 = CPy_GetCoro(r188)
    dec_ref r188
    if is_error(r189) goto L226 (error at decode_output:236) else goto L146
L146:
    r4.__mypyc_temp__36 = r189; r190 = is_error
    if not r190 goto L226 (error at decode_output:-1) else goto L147 :: bool
L147:
    r191 = r4.__mypyc_temp__36
    if is_error(r191) goto L226 (error at decode_output:-1) else goto L148
L148:
    r192 = CPyIter_Next(r191)
    dec_ref r191
    if is_error(r192) goto L248 else goto L151
L149:
    r193 = CPy_FetchStopIterationValue()
    if is_error(r193) goto L180 (error at decode_output:236) else goto L150
L150:
    r194 = r193
    goto L174
L151:
    r195 = r192
L152:
    r4.__mypyc_next_label__ = 4; r196 = is_error
    if not r196 goto L249 (error at decode_output:236) else goto L250 :: bool
L153:
    return r195
L154:
    r197 = load_address _Py_NoneStruct
    r198 = type != r197
    if r198 goto L155 else goto L157 :: bool
L155:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L158 (error at decode_output:236) else goto L251 :: bool
L156:
    unreachable
L157:
    inc_ref arg
    goto L169
L158:
    r199 = CPy_CatchError()
    r4.__mypyc_temp__37 = r199; r200 = is_error
    if not r200 goto L252 (error at decode_output:-1) else goto L159 :: bool
L159:
    r201 = load_address r3
    r202 = r4.__mypyc_temp__36
    if is_error(r202) goto L252 (error at decode_output:-1) else goto L160
L160:
    r203 = CPy_YieldFromErrorHandle(r202, r201)
    dec_ref r202
    if is_error(r203) goto L252 (error at decode_output:236) else goto L161
L161:
    if r203 goto L164 else goto L162 :: bool
L162:
    inc_ref r3
    r195 = r3
    r204 = r4.__mypyc_temp__37
    if is_error(r204) goto L253 (error at decode_output:-1) else goto L163
L163:
    CPy_RestoreExcInfo(r204)
    dec_ref r204
    goto L152
L164:
    r194 = r3
    r205 = r4.__mypyc_temp__37
    if is_error(r205) goto L254 (error at decode_output:-1) else goto L165
L165:
    CPy_RestoreExcInfo(r205)
    dec_ref r205
    goto L174
L166:
    r206 = r4.__mypyc_temp__37
    if is_error(r206) goto L180 (error at decode_output:-1) else goto L167
L167:
    CPy_RestoreExcInfo(r206)
    dec_ref r206
    r207 = CPy_KeepPropagating()
    if not r207 goto L180 else goto L255 :: bool
L168:
    unreachable
L169:
    r208 = r4.__mypyc_temp__36
    if is_error(r208) goto L256 (error at decode_output:-1) else goto L170
L170:
    r209 = CPyIter_Send(r208, arg)
    dec_ref r208
    dec_ref arg
    if is_error(r209) goto L257 else goto L171
L171:
    r195 = r209
    goto L152
L172:
    r210 = CPy_FetchStopIterationValue()
    if is_error(r210) goto L180 (error at decode_output:236) else goto L173
L173:
    r194 = r210
L174:
    r211 = r4.__mypyc_temp__35
    if is_error(r211) goto L258 (error at decode_output:-1) else goto L175
L175:
    CPy_RestoreExcInfo(r211)
    dec_ref r211
    r4.__mypyc_next_label__ = -2; r212 = is_error
    if not r212 goto L258 (error at decode_output:236) else goto L259 :: bool
L176:
    CPyGen_SetStopIterationValue(r194)
    dec_ref r194
    if not 0 goto L188 else goto L177 :: bool
L177:
    unreachable
L178:
    CPy_Reraise()
    if not 0 goto L180 else goto L260 :: bool
L179:
    unreachable
L180:
    r213 = r4.__mypyc_temp__35
    dec_ref r4
    if is_error(r213) goto L188 (error at decode_output:-1) else goto L181
L181:
    CPy_RestoreExcInfo(r213)
    dec_ref r213
    r214 = CPy_KeepPropagating()
    if not r214 goto L188 else goto L182 :: bool
L182:
    unreachable
L183:
    r215 = r5 == 0
    if r215 goto L261 else goto L184 :: bool
L184:
    r216 = r5 == 2
    if r216 goto L262 else goto L263 :: bool
L185:
    r217 = r5 == 4
    dec_ref r5 :: int
    if r217 goto L154 else goto L264 :: bool
L186:
    r218 = raise StopIteration
    if not r218 goto L188 (error at decode_output:207) else goto L187 :: bool
L187:
    unreachable
L188:
    r219 = <error> :: object
    return r219
L189:
    xdec_ref r1
    xdec_ref r3
    goto L188
L190:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L188
L191:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L3
L192:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r10
    goto L188
L193:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r11
    goto L188
L194:
    xdec_ref r1
    goto L102
L195:
    xdec_ref r1
    goto L17
L196:
    dec_ref r25
    goto L102
L197:
    xdec_ref r1
    goto L59
L198:
    xdec_ref r1
    dec_ref r32
    goto L59
L199:
    xdec_ref r1
    dec_ref r32
    dec_ref r33
    goto L26
L200:
    xdec_ref r3
    dec_ref r4
    goto L27
L201:
    xdec_ref r1
    dec_ref r32
    dec_ref r33
    goto L59
L202:
    xdec_ref r1
    goto L33
L203:
    dec_ref r45
    goto L42
L204:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L37
L205:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L40
L206:
    xdec_ref r1
    goto L50
L207:
    xdec_ref r1
    dec_ref r45
    goto L50
L208:
    dec_ref r44
    goto L50
L209:
    xdec_ref r3
    dec_ref r4
    goto L52
L210:
    xdec_ref r1
    dec_ref arg
    goto L59
L211:
    xdec_ref r1
    goto L56
L212:
    xdec_ref r3
    dec_ref r4
    goto L64
L213:
    dec_ref r75
    goto L88
L214:
    dec_ref r75
    dec_ref r76
    goto L88
L215:
    dec_ref r75
    dec_ref r76
    dec_ref r79
    goto L88
L216:
    dec_ref r83
    goto L71
L217:
    dec_ref r90
    goto L88
L218:
    dec_ref r96
    goto L88
L219:
    dec_ref r103
    goto L88
L220:
    xdec_ref r3
    dec_ref r4
    goto L85
L221:
    xdec_ref r3
    dec_ref r4
    goto L90
L222:
    dec_ref r113
    goto L102
L223:
    xdec_ref r3
    dec_ref r4
    goto L97
L224:
    dec_ref r121
    goto L102
L225:
    xdec_ref r3
    dec_ref r4
    goto L100
L226:
    xdec_ref r3
    goto L180
L227:
    xdec_ref r3
    goto L105
L228:
    dec_ref r133
    goto L180
L229:
    dec_ref r133
    dec_ref r134
    goto L180
L230:
    dec_ref r133
    dec_ref r134
    dec_ref r137
    goto L180
L231:
    dec_ref r133
    dec_ref r134
    dec_ref r137
    dec_ref r138
    goto L180
L232:
    dec_ref r134
    dec_ref r137
    dec_ref r138
    dec_ref r139
    goto L180
L233:
    dec_ref r140
    goto L114
L234:
    dec_ref r137
    dec_ref r138
    dec_ref r139
    goto L180
L235:
    dec_ref r138
    dec_ref r139
    goto L180
L236:
    dec_ref r139
    goto L180
L237:
    dec_ref r147
    goto L180
L238:
    dec_ref r4
    goto L121
L239:
    xdec_ref r3
    goto L178
L240:
    xdec_ref r3
    goto L128
L241:
    dec_ref r4
    goto L129
L242:
    xdec_ref r3
    goto L131
L243:
    dec_ref r4
    goto L132
L244:
    xdec_ref r3
    dec_ref r166
    goto L180
L245:
    dec_ref r170
    goto L135
L246:
    xdec_ref r3
    dec_ref r173
    goto L180
L247:
    xdec_ref r3
    dec_ref r186
    goto L180
L248:
    xdec_ref r3
    goto L149
L249:
    dec_ref r195
    goto L158
L250:
    xdec_ref r3
    dec_ref r4
    goto L153
L251:
    xdec_ref r3
    dec_ref r4
    goto L156
L252:
    xdec_ref r3
    goto L166
L253:
    xdec_ref r3
    dec_ref r195
    goto L166
L254:
    dec_ref r194
    goto L166
L255:
    dec_ref r4
    goto L168
L256:
    xdec_ref r3
    dec_ref arg
    goto L180
L257:
    xdec_ref r3
    goto L172
L258:
    dec_ref r194
    goto L180
L259:
    dec_ref r4
    goto L176
L260:
    dec_ref r4
    goto L179
L261:
    dec_ref r5 :: int
    goto L2
L262:
    dec_ref r5 :: int
    goto L38
L263:
    xdec_ref r1
    goto L185
L264:
    xdec_ref r3
    dec_ref r4
    goto L186

def decode_output_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def decode_output_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def decode_output_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def decode_output_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def decode_output_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def decode_output_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def decode_output(call, data):
    call :: object
    data :: bytes
    r0 :: dank_mids.brownie_patch.call.decode_output_env
    r1, r2 :: bool
    r3 :: dank_mids.brownie_patch.call.decode_output_gen
    r4, r5 :: bool
    r6 :: object
L0:
    r0 = decode_output_env()
    if is_error(r0) goto L7 (error at decode_output:207) else goto L1
L1:
    inc_ref call
    r0.call = call; r1 = is_error
    if not r1 goto L8 (error at decode_output:207) else goto L2 :: bool
L2:
    inc_ref data
    r0.data = data; r2 = is_error
    if not r2 goto L8 (error at decode_output:207) else goto L3 :: bool
L3:
    r3 = decode_output_gen()
    if is_error(r3) goto L8 (error at decode_output:207) else goto L4
L4:
    inc_ref r0
    r3.__mypyc_env__ = r0; r4 = is_error
    if not r4 goto L9 (error at decode_output:207) else goto L5 :: bool
L5:
    r0.__mypyc_next_label__ = 0; r5 = is_error
    dec_ref r0
    if not r5 goto L10 (error at decode_output:207) else goto L6 :: bool
L6:
    return r3
L7:
    r6 = <error> :: object
    return r6
L8:
    dec_ref r0
    goto L7
L9:
    dec_ref r0
    dec_ref r3
    goto L7
L10:
    dec_ref r3
    goto L7

def _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    type, value, traceback, arg :: object
    r0 :: dank_mids.brownie_patch.call._request_data_no_args_env
    r1 :: int
    r2 :: object
    r3 :: bit
    r4 :: object
    r5 :: str
    r6 :: object
    r7 :: bool
    r8 :: bit
    r9 :: bool
    r10 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L13 (error at _request_data_no_args:239) else goto L1
L1:
    r1 = r0.__mypyc_next_label__
    if is_error(r1) goto L14 (error at _request_data_no_args:239) else goto L10
L2:
    r2 = load_address _Py_NoneStruct
    r3 = type != r2
    if r3 goto L15 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L13 (error at _request_data_no_args:239) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = r0.call
    if is_error(r4) goto L14 (error at _request_data_no_args:240) else goto L6
L6:
    r5 = 'signature'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L14 (error at _request_data_no_args:240) else goto L7
L7:
    r0.__mypyc_next_label__ = -2; r7 = is_error
    dec_ref r0
    if not r7 goto L16 (error at _request_data_no_args:240) else goto L8 :: bool
L8:
    CPyGen_SetStopIterationValue(r6)
    dec_ref r6
    if not 0 goto L13 else goto L9 :: bool
L9:
    unreachable
L10:
    r8 = r1 == 0
    dec_ref r1 :: int
    if r8 goto L2 else goto L17 :: bool
L11:
    r9 = raise StopIteration
    if not r9 goto L13 (error at _request_data_no_args:239) else goto L12 :: bool
L12:
    unreachable
L13:
    r10 = <error> :: object
    return r10
L14:
    dec_ref r0
    goto L13
L15:
    dec_ref r0
    goto L3
L16:
    dec_ref r6
    goto L13
L17:
    dec_ref r0
    goto L11

def _request_data_no_args_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _request_data_no_args_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _request_data_no_args_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _request_data_no_args_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def _request_data_no_args_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def _request_data_no_args_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _request_data_no_args(call):
    call :: object
    r0 :: dank_mids.brownie_patch.call._request_data_no_args_env
    r1 :: bool
    r2 :: dank_mids.brownie_patch.call._request_data_no_args_gen
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = _request_data_no_args_env()
    if is_error(r0) goto L6 (error at _request_data_no_args:239) else goto L1
L1:
    inc_ref call
    r0.call = call; r1 = is_error
    if not r1 goto L7 (error at _request_data_no_args:239) else goto L2 :: bool
L2:
    r2 = _request_data_no_args_gen()
    if is_error(r2) goto L7 (error at _request_data_no_args:239) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L8 (error at _request_data_no_args:239) else goto L4 :: bool
L4:
    r0.__mypyc_next_label__ = 0; r4 = is_error
    dec_ref r0
    if not r4 goto L9 (error at _request_data_no_args:239) else goto L5 :: bool
L5:
    return r2
L6:
    r5 = <error> :: object
    return r5
L7:
    dec_ref r0
    goto L6
L8:
    dec_ref r0
    dec_ref r2
    goto L6
L9:
    dec_ref r2
    goto L6

def __encode_input(abi, signature, args):
    abi :: dict
    signature :: str
    args :: tuple
    r0 :: list
    r1 :: str
    r2 :: object
    r3 :: dict
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8, r9 :: object
    r10 :: bool
    r11 :: object[2]
    r12 :: object_ptr
    r13 :: object
    r14 :: bytes
    r15 :: str
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19, r20 :: str
    r21 :: tuple[object, object, object]
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: bit
    r26 :: object
    r27 :: bit
    r28 :: object
L0:
L1:
    r0 = format_input_but_cache_checksums(abi, args)
    if is_error(r0) goto L14 (error at __encode_input:254) else goto L2
L2:
    r1 = 'inputs'
    r2 = CPyDict_GetItem(abi, r1)
    if is_error(r2) goto L22 (error at __encode_input:255) else goto L3
L3:
    r3 = dank_mids.brownie_patch.call.globals :: static
    r4 = 'get_type_strings'
    r5 = CPyDict_GetItem(r3, r4)
    if is_error(r5) goto L23 (error at __encode_input:255) else goto L4
L4:
    r6 = [r2]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r5, r7, 1, 0)
    dec_ref r5
    if is_error(r8) goto L23 (error at __encode_input:255) else goto L5
L5:
    dec_ref r2
    r9 = dank_mids.brownie_patch.call.__eth_abi_encode :: static
    if is_error(r9) goto L24 else goto L8
L6:
    r10 = raise NameError('value for final name "__eth_abi_encode" was not set')
    if not r10 goto L14 (error at __encode_input:256) else goto L7 :: bool
L7:
    unreachable
L8:
    r11 = [r8, r0]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r9, r12, 2, 0)
    if is_error(r13) goto L25 (error at __encode_input:256) else goto L9
L9:
    dec_ref r8
    dec_ref r0
    r14 = cast(bytes, r13)
    if is_error(r14) goto L14 (error at __encode_input:256) else goto L10
L10:
    r15 = 'hex'
    r16 = [r14]
    r17 = load_address r16
    r18 = PyObject_VectorcallMethod(r15, r17, 9223372036854775809, 0)
    if is_error(r18) goto L26 (error at __encode_input:256) else goto L11
L11:
    dec_ref r14
    r19 = cast(str, r18)
    if is_error(r19) goto L14 (error at __encode_input:256) else goto L12
L12:
    r20 = PyUnicode_Concat(signature, r19)
    dec_ref r19
    if is_error(r20) goto L14 (error at __encode_input:256) else goto L13
L13:
    return r20
L14:
    r21 = CPy_CatchError()
    r22 = builtins :: module
    r23 = 'Exception'
    r24 = CPyObject_GetAttr(r22, r23)
    if is_error(r24) goto L19 (error at __encode_input:257) else goto L15
L15:
    r25 = CPy_ExceptionMatches(r24)
    dec_ref r24
    if r25 goto L16 else goto L17 :: bool
L16:
    r26 = CPy_GetExcValue()
    CPy_RestoreExcInfo(r21)
    dec_ref r21
    return r26
L17:
    CPy_Reraise()
    if not 0 goto L19 else goto L27 :: bool
L18:
    unreachable
L19:
    CPy_RestoreExcInfo(r21)
    dec_ref r21
    r27 = CPy_KeepPropagating()
    if not r27 goto L21 else goto L20 :: bool
L20:
    unreachable
L21:
    r28 = <error> :: object
    return r28
L22:
    dec_ref r0
    goto L14
L23:
    dec_ref r0
    dec_ref r2
    goto L14
L24:
    dec_ref r0
    dec_ref r8
    goto L6
L25:
    dec_ref r0
    dec_ref r8
    goto L14
L26:
    dec_ref r14
    goto L14
L27:
    dec_ref r21
    goto L18

def __decode_output(hexstr, abi):
    hexstr :: object
    abi :: dict
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
    r9 :: bool
    r10 :: object[1]
    r11 :: object_ptr
    r12, r13 :: object
    r14 :: bool
    r15 :: object[2]
    r16 :: object_ptr
    r17 :: object
    r18, result :: tuple
    r19 :: object
    r20 :: tuple
    r21 :: ptr
    r22 :: native_int
    r23 :: short_int
    r24 :: bit
    r25, r26 :: object
    r27 :: tuple[object, object, object]
    r28 :: object
    r29 :: str
    r30 :: object
    r31 :: bit
    r32 :: object
    r33 :: bit
    r34 :: object
L0:
L1:
    r0 = 'outputs'
    r1 = CPyDict_GetItem(abi, r0)
    if is_error(r1) goto L20 (error at __decode_output:276) else goto L2
L2:
    r2 = dank_mids.brownie_patch.call.globals :: static
    r3 = 'get_type_strings'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L28 (error at __decode_output:276) else goto L3
L3:
    r5 = [r1]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r4, r6, 1, 0)
    dec_ref r4
    if is_error(r7) goto L28 (error at __decode_output:276) else goto L4
L4:
    dec_ref r1
    r8 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r8) goto L29 else goto L7
L5:
    r9 = raise NameError('value for final name "HexBytes" was not set')
    if not r9 goto L20 (error at __decode_output:277) else goto L6 :: bool
L6:
    unreachable
L7:
    r10 = [hexstr]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r8, r11, 1, 0)
    if is_error(r12) goto L30 (error at __decode_output:277) else goto L8
L8:
    r13 = dank_mids.brownie_patch.call.__eth_abi_decode :: static
    if is_error(r13) goto L31 else goto L11
L9:
    r14 = raise NameError('value for final name "__eth_abi_decode" was not set')
    if not r14 goto L20 (error at __decode_output:277) else goto L10 :: bool
L10:
    unreachable
L11:
    r15 = [r7, r12]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r13, r16, 2, 0)
    if is_error(r17) goto L32 (error at __decode_output:277) else goto L12
L12:
    dec_ref r7
    dec_ref r12
    r18 = cast(tuple, r17)
    if is_error(r18) goto L20 (error at __decode_output:277) else goto L13
L13:
    result = r18
    r19 = format_output_but_cache_checksums(abi, result)
    dec_ref result
    if is_error(r19) goto L20 (error at __decode_output:278) else goto L14
L14:
    r20 = cast(tuple, r19)
    if is_error(r20) goto L20 (error at __decode_output:278) else goto L15
L15:
    result = r20
    r21 = get_element_ptr result ob_size :: PyVarObject
    r22 = load_mem r21 :: native_int*
    r23 = r22 << 1
    r24 = r23 == 2
    if r24 goto L16 else goto L18 :: bool
L16:
    r25 = CPySequenceTuple_GetItem(result, 0)
    dec_ref result
    if is_error(r25) goto L20 (error at __decode_output:279) else goto L17
L17:
    r26 = r25
    goto L19
L18:
    r26 = result
L19:
    return r26
L20:
    r27 = CPy_CatchError()
    r28 = builtins :: module
    r29 = 'Exception'
    r30 = CPyObject_GetAttr(r28, r29)
    if is_error(r30) goto L25 (error at __decode_output:280) else goto L21
L21:
    r31 = CPy_ExceptionMatches(r30)
    dec_ref r30
    if r31 goto L22 else goto L23 :: bool
L22:
    r32 = CPy_GetExcValue()
    CPy_RestoreExcInfo(r27)
    dec_ref r27
    return r32
L23:
    CPy_Reraise()
    if not 0 goto L25 else goto L33 :: bool
L24:
    unreachable
L25:
    CPy_RestoreExcInfo(r27)
    dec_ref r27
    r33 = CPy_KeepPropagating()
    if not r33 goto L27 else goto L26 :: bool
L26:
    unreachable
L27:
    r34 = <error> :: object
    return r34
L28:
    dec_ref r1
    goto L20
L29:
    dec_ref r7
    goto L5
L30:
    dec_ref r7
    goto L20
L31:
    dec_ref r7
    dec_ref r12
    goto L9
L32:
    dec_ref r7
    dec_ref r12
    goto L20
L33:
    dec_ref r27
    goto L24

def __validate_output(abi, hexstr):
    abi :: dict
    hexstr, r0 :: object
    r1 :: bool
    r2 :: object[1]
    r3 :: object_ptr
    r4, r5, r6, r7, r8, r9 :: object
    r10 :: str
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: i32
    r17 :: bit
    r18 :: bool
    r19 :: dict
    r20 :: str
    r21 :: object
    r22 :: str
    r23 :: list
    r24, r25 :: ptr
    r26 :: object
    r27 :: bool
    r28 :: object[1]
    r29 :: object_ptr
    r30, r31, r32, r33, r34, r35 :: object
    r36 :: str
    r37 :: object[3]
    r38 :: object_ptr
    r39, r40, r41, revert_str :: object
    r42, r43, r44 :: str
    r45 :: object
    r46 :: bool
    r47 :: object[1]
    r48 :: object_ptr
    r49 :: object
    r50 :: str
    r51 :: object
    r52 :: i32
    r53 :: bit
    r54 :: bool
    r55 :: object
    r56 :: bool
    r57 :: object[1]
    r58 :: object_ptr
    r59, r60, r61, r62, r63, r64 :: object
    r65 :: str
    r66 :: object[1]
    r67 :: object_ptr
    r68, r69, r70 :: object
    r71 :: object[2]
    r72 :: object_ptr
    r73 :: object
    r74 :: int
    r75 :: dict
    r76 :: str
    r77, r78 :: object
    r79 :: i32
    r80 :: bit
    r81 :: bool
    r82 :: dict
    r83 :: str
    r84, r85, r86 :: object
    r87, r88, r89, r90, r91, r92, r93 :: str
    r94 :: object
    r95 :: bool
    r96 :: object[1]
    r97 :: object_ptr
    r98 :: object
    r99 :: str
    r100 :: object
    r101 :: i32
    r102 :: bit
    r103 :: bool
    r104 :: str
    r105 :: object
    r106 :: bool
    r107 :: object[1]
    r108 :: object_ptr
    r109 :: object
    r110 :: str
    r111 :: object
    r112 :: i32
    r113 :: bit
    r114 :: bool
    r115 :: i32
    r116 :: bit
    r117 :: bool
    r118 :: str
    r119 :: object
    r120 :: bool
    r121 :: object[1]
    r122 :: object_ptr
    r123 :: object
    r124 :: tuple[object, object, object]
    r125 :: object
    r126 :: str
    r127 :: object
    r128 :: bit
    r129 :: object
    r130 :: dict
    r131 :: str
    r132 :: object
    r133 :: object[1]
    r134 :: object_ptr
    r135 :: object
    r136 :: tuple[object, object, object]
    r137, r138 :: bit
    r139 :: None
L0:
L1:
    r0 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r0) goto L2 else goto L4
L2:
    r1 = raise NameError('value for final name "HexBytes" was not set')
    if not r1 goto L78 (error at __validate_output:286) else goto L3 :: bool
L3:
    unreachable
L4:
    r2 = [hexstr]
    r3 = load_address r2
    r4 = PyObject_Vectorcall(r0, r3, 1, 0)
    if is_error(r4) goto L78 (error at __validate_output:286) else goto L5
L5:
    r5 = load_address _Py_NoneStruct
    r6 = load_address _Py_NoneStruct
    r7 = object 4
    r8 = PySlice_New(r5, r7, r6)
    if is_error(r8) goto L95 (error at __validate_output:286) else goto L6
L6:
    r9 = PyObject_GetItem(r4, r8)
    dec_ref r4
    dec_ref r8
    if is_error(r9) goto L78 (error at __validate_output:286) else goto L7
L7:
    r10 = 'hex'
    r11 = [r9]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775809, 0)
    if is_error(r13) goto L96 (error at __validate_output:286) else goto L8
L8:
    dec_ref r9
    r14 = '0x08c379a0'
    r15 = PyObject_RichCompare(r13, r14, 2)
    if is_error(r15) goto L97 (error at __validate_output:287) else goto L9
L9:
    r16 = PyObject_IsTrue(r15)
    dec_ref r15
    r17 = r16 >= 0 :: signed
    if not r17 goto L97 (error at __validate_output:287) else goto L10 :: bool
L10:
    r18 = truncate r16: i32 to builtins.bool
    if r18 goto L98 else goto L29 :: bool
L11:
    r19 = dank_mids.brownie_patch.call.globals :: static
    r20 = 'eth_abi'
    r21 = CPyDict_GetItem(r19, r20)
    if is_error(r21) goto L78 (error at __validate_output:288) else goto L12
L12:
    r22 = 'string'
    r23 = PyList_New(1)
    if is_error(r23) goto L99 (error at __validate_output:288) else goto L13
L13:
    r24 = get_element_ptr r23 ob_item :: PyListObject
    r25 = load_mem r24 :: ptr*
    inc_ref r22
    set_mem r25, r22 :: builtins.object*
    r26 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r26) goto L100 else goto L16
L14:
    r27 = raise NameError('value for final name "HexBytes" was not set')
    if not r27 goto L78 (error at __validate_output:288) else goto L15 :: bool
L15:
    unreachable
L16:
    r28 = [hexstr]
    r29 = load_address r28
    r30 = PyObject_Vectorcall(r26, r29, 1, 0)
    if is_error(r30) goto L101 (error at __validate_output:288) else goto L17
L17:
    r31 = load_address _Py_NoneStruct
    r32 = load_address _Py_NoneStruct
    r33 = object 4
    r34 = PySlice_New(r33, r31, r32)
    if is_error(r34) goto L102 (error at __validate_output:288) else goto L18
L18:
    r35 = PyObject_GetItem(r30, r34)
    dec_ref r30
    dec_ref r34
    if is_error(r35) goto L101 (error at __validate_output:288) else goto L19
L19:
    r36 = 'decode_abi'
    r37 = [r21, r23, r35]
    r38 = load_address r37
    r39 = PyObject_VectorcallMethod(r36, r38, 9223372036854775811, 0)
    if is_error(r39) goto L103 (error at __validate_output:288) else goto L20
L20:
    dec_ref r21
    dec_ref r23
    dec_ref r35
    r40 = object 0
    r41 = PyObject_GetItem(r39, r40)
    dec_ref r39
    if is_error(r41) goto L78 (error at __validate_output:288) else goto L21
L21:
    revert_str = r41
    r42 = 'Call reverted: '
    r43 = PyObject_Str(revert_str)
    dec_ref revert_str
    if is_error(r43) goto L78 (error at __validate_output:289) else goto L22
L22:
    r44 = CPyStr_Build(2, r42, r43)
    dec_ref r43
    if is_error(r44) goto L78 (error at __validate_output:289) else goto L23
L23:
    r45 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r45) goto L104 else goto L26
L24:
    r46 = raise NameError('value for final name "Revert" was not set')
    if not r46 goto L78 (error at __validate_output:289) else goto L25 :: bool
L25:
    unreachable
L26:
    r47 = [r44]
    r48 = load_address r47
    r49 = PyObject_Vectorcall(r45, r48, 1, 0)
    if is_error(r49) goto L105 (error at __validate_output:289) else goto L27
L27:
    dec_ref r44
    CPy_Raise(r49)
    dec_ref r49
    if not 0 goto L78 (error at __validate_output:289) else goto L28 :: bool
L28:
    unreachable
L29:
    r50 = '0x4e487b71'
    r51 = PyObject_RichCompare(r13, r50, 2)
    if is_error(r51) goto L97 (error at __validate_output:290) else goto L30
L30:
    r52 = PyObject_IsTrue(r51)
    dec_ref r51
    r53 = r52 >= 0 :: signed
    if not r53 goto L97 (error at __validate_output:290) else goto L31 :: bool
L31:
    r54 = truncate r52: i32 to builtins.bool
    if r54 goto L106 else goto L58 :: bool
L32:
    r55 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r55) goto L33 else goto L35
L33:
    r56 = raise NameError('value for final name "HexBytes" was not set')
    if not r56 goto L78 (error at __validate_output:291) else goto L34 :: bool
L34:
    unreachable
L35:
    r57 = [hexstr]
    r58 = load_address r57
    r59 = PyObject_Vectorcall(r55, r58, 1, 0)
    if is_error(r59) goto L78 (error at __validate_output:291) else goto L36
L36:
    r60 = load_address _Py_NoneStruct
    r61 = load_address _Py_NoneStruct
    r62 = object 4
    r63 = PySlice_New(r62, r60, r61)
    if is_error(r63) goto L107 (error at __validate_output:291) else goto L37
L37:
    r64 = PyObject_GetItem(r59, r63)
    dec_ref r59
    dec_ref r63
    if is_error(r64) goto L78 (error at __validate_output:291) else goto L38
L38:
    r65 = 'hex'
    r66 = [r64]
    r67 = load_address r66
    r68 = PyObject_VectorcallMethod(r65, r67, 9223372036854775809, 0)
    if is_error(r68) goto L108 (error at __validate_output:291) else goto L39
L39:
    dec_ref r64
    r69 = load_address PyLong_Type
    r70 = object 16
    r71 = [r68, r70]
    r72 = load_address r71
    r73 = PyObject_Vectorcall(r69, r72, 2, 0)
    if is_error(r73) goto L109 (error at __validate_output:291) else goto L40
L40:
    dec_ref r68
    r74 = unbox(int, r73)
    dec_ref r73
    if is_error(r74) goto L78 (error at __validate_output:291) else goto L41
L41:
    r75 = dank_mids.brownie_patch.call.globals :: static
    r76 = 'SOLIDITY_ERROR_CODES'
    r77 = CPyDict_GetItem(r75, r76)
    if is_error(r77) goto L110 (error at __validate_output:292) else goto L42
L42:
    inc_ref r74 :: int
    r78 = box(int, r74)
    r79 = PySequence_Contains(r77, r78)
    dec_ref r77
    dec_ref r78
    r80 = r79 >= 0 :: signed
    if not r80 goto L110 (error at __validate_output:292) else goto L43 :: bool
L43:
    r81 = truncate r79: i32 to builtins.bool
    if r81 goto L44 else goto L47 :: bool
L44:
    r82 = dank_mids.brownie_patch.call.globals :: static
    r83 = 'SOLIDITY_ERROR_CODES'
    r84 = CPyDict_GetItem(r82, r83)
    if is_error(r84) goto L110 (error at __validate_output:293) else goto L45
L45:
    r85 = box(int, r74)
    r86 = PyObject_GetItem(r84, r85)
    dec_ref r84
    dec_ref r85
    if is_error(r86) goto L78 (error at __validate_output:293) else goto L46
L46:
    revert_str = r86
    goto L50
L47:
    r87 = 'Panic (error code: '
    r88 = CPyTagged_Str(r74)
    dec_ref r74 :: int
    if is_error(r88) goto L78 (error at __validate_output:295) else goto L48
L48:
    r89 = ')'
    r90 = CPyStr_Build(3, r87, r88, r89)
    dec_ref r88
    if is_error(r90) goto L78 (error at __validate_output:295) else goto L49
L49:
    revert_str = r90
L50:
    r91 = 'Call reverted: '
    r92 = PyObject_Str(revert_str)
    dec_ref revert_str
    if is_error(r92) goto L78 (error at __validate_output:296) else goto L51
L51:
    r93 = CPyStr_Build(2, r91, r92)
    dec_ref r92
    if is_error(r93) goto L78 (error at __validate_output:296) else goto L52
L52:
    r94 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r94) goto L111 else goto L55
L53:
    r95 = raise NameError('value for final name "Revert" was not set')
    if not r95 goto L78 (error at __validate_output:296) else goto L54 :: bool
L54:
    unreachable
L55:
    r96 = [r93]
    r97 = load_address r96
    r98 = PyObject_Vectorcall(r94, r97, 1, 0)
    if is_error(r98) goto L112 (error at __validate_output:296) else goto L56
L56:
    dec_ref r93
    CPy_Raise(r98)
    dec_ref r98
    if not 0 goto L78 (error at __validate_output:296) else goto L57 :: bool
L57:
    unreachable
L58:
    r99 = '0xc1b84b2f'
    r100 = PyObject_RichCompare(r13, r99, 2)
    dec_ref r13
    if is_error(r100) goto L78 (error at __validate_output:297) else goto L59
L59:
    r101 = PyObject_IsTrue(r100)
    dec_ref r100
    r102 = r101 >= 0 :: signed
    if not r102 goto L78 (error at __validate_output:297) else goto L60 :: bool
L60:
    r103 = truncate r101: i32 to builtins.bool
    if r103 goto L61 else goto L67 :: bool
L61:
    r104 = 'Call reverted: execution reverted'
    r105 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r105) goto L62 else goto L64
L62:
    r106 = raise NameError('value for final name "Revert" was not set')
    if not r106 goto L78 (error at __validate_output:298) else goto L63 :: bool
L63:
    unreachable
L64:
    r107 = [r104]
    r108 = load_address r107
    r109 = PyObject_Vectorcall(r105, r108, 1, 0)
    if is_error(r109) goto L78 (error at __validate_output:298) else goto L65
L65:
    CPy_Raise(r109)
    dec_ref r109
    if not 0 goto L78 (error at __validate_output:298) else goto L66 :: bool
L66:
    unreachable
L67:
    r110 = 'outputs'
    r111 = CPyDict_GetItem(abi, r110)
    if is_error(r111) goto L78 (error at __validate_output:299) else goto L68
L68:
    r112 = PyObject_IsTrue(r111)
    dec_ref r111
    r113 = r112 >= 0 :: signed
    if not r113 goto L78 (error at __validate_output:299) else goto L69 :: bool
L69:
    r114 = truncate r112: i32 to builtins.bool
    if r114 goto L70 else goto L93 :: bool
L70:
    r115 = PyObject_IsTrue(hexstr)
    r116 = r115 >= 0 :: signed
    if not r116 goto L78 (error at __validate_output:284) else goto L71 :: bool
L71:
    r117 = truncate r115: i32 to builtins.bool
    if r117 goto L93 else goto L72 :: bool
L72:
    r118 = 'No data was returned - the call likely reverted'
    r119 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r119) goto L73 else goto L75
L73:
    r120 = raise NameError('value for final name "Revert" was not set')
    if not r120 goto L78 (error at __validate_output:300) else goto L74 :: bool
L74:
    unreachable
L75:
    r121 = [r118]
    r122 = load_address r121
    r123 = PyObject_Vectorcall(r119, r122, 1, 0)
    if is_error(r123) goto L78 (error at __validate_output:300) else goto L76
L76:
    CPy_Raise(r123)
    dec_ref r123
    if not 0 goto L78 (error at __validate_output:300) else goto L77 :: bool
L77:
    unreachable
L78:
    r124 = CPy_CatchError()
    r125 = builtins :: module
    r126 = 'ValueError'
    r127 = CPyObject_GetAttr(r125, r126)
    if is_error(r127) goto L91 (error at __validate_output:301) else goto L79
L79:
    r128 = CPy_ExceptionMatches(r127)
    dec_ref r127
    if r128 goto L80 else goto L89 :: bool
L80:
    r129 = CPy_GetExcValue()
L81:
    r130 = dank_mids.brownie_patch.call.globals :: static
    r131 = 'VirtualMachineError'
    r132 = CPyDict_GetItem(r130, r131)
    if is_error(r132) goto L85 (error at __validate_output:303) else goto L82
L82:
    r133 = [r129]
    r134 = load_address r133
    r135 = PyObject_Vectorcall(r132, r134, 1, 0)
    dec_ref r132
    if is_error(r135) goto L85 (error at __validate_output:303) else goto L83
L83:
    CPy_Raise(r135)
    dec_ref r135
    if not 0 goto L85 (error at __validate_output:303) else goto L113 :: bool
L84:
    unreachable
L85:
    r136 = CPy_CatchError()
    CPy_Raise(r129)
    dec_ref r129
    if not 0 goto L87 (error at __validate_output:305) else goto L114 :: bool
L86:
    unreachable
L87:
    CPy_RestoreExcInfo(r136)
    dec_ref r136
    r137 = CPy_KeepPropagating()
    if not r137 goto L91 else goto L115 :: bool
L88:
    unreachable
L89:
    CPy_Reraise()
    if not 0 goto L91 else goto L116 :: bool
L90:
    unreachable
L91:
    CPy_RestoreExcInfo(r124)
    dec_ref r124
    r138 = CPy_KeepPropagating()
    if not r138 goto L94 else goto L92 :: bool
L92:
    unreachable
L93:
    return 1
L94:
    r139 = <error> :: None
    return r139
L95:
    dec_ref r4
    goto L78
L96:
    dec_ref r9
    goto L78
L97:
    dec_ref r13
    goto L78
L98:
    dec_ref r13
    goto L11
L99:
    dec_ref r21
    goto L78
L100:
    dec_ref r21
    dec_ref r23
    goto L14
L101:
    dec_ref r21
    dec_ref r23
    goto L78
L102:
    dec_ref r21
    dec_ref r23
    dec_ref r30
    goto L78
L103:
    dec_ref r21
    dec_ref r23
    dec_ref r35
    goto L78
L104:
    dec_ref r44
    goto L24
L105:
    dec_ref r44
    goto L78
L106:
    dec_ref r13
    goto L32
L107:
    dec_ref r59
    goto L78
L108:
    dec_ref r64
    goto L78
L109:
    dec_ref r68
    goto L78
L110:
    dec_ref r74 :: int
    goto L78
L111:
    dec_ref r93
    goto L53
L112:
    dec_ref r93
    goto L78
L113:
    dec_ref r124
    dec_ref r129
    goto L84
L114:
    dec_ref r124
    dec_ref r136
    goto L86
L115:
    dec_ref r124
    goto L88
L116:
    dec_ref r124
    goto L90

def format_input_but_cache_checksums(abi, inputs):
    abi :: dict
    inputs :: union[list, tuple]
    r0 :: int
    r1 :: bit
    r2 :: str
    r3 :: object
    r4 :: int
    r5 :: bit
    r6 :: str
    r7 :: object
    r8, r9, r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: str
    r18, r19 :: object
    r20 :: bool
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: list
    r25 :: tuple[object, object, object]
    r26 :: object
    r27 :: str
    r28 :: object
    r29 :: bit
    r30, r31 :: object
    r32 :: str
    r33 :: object
    r34, r35, r36, r37 :: str
    r38 :: object[1]
    r39 :: object_ptr
    r40 :: object
    r41 :: bit
    r42 :: list
L0:
    r0 = CPyObject_Size(inputs)
    if is_error(r0) goto L33 (error at format_input_but_cache_checksums:313) else goto L1
L1:
    r1 = r0 != 0
    dec_ref r0 :: int
    if r1 goto L2 else goto L12 :: bool
L2:
    r2 = 'inputs'
    r3 = CPyDict_GetItem(abi, r2)
    if is_error(r3) goto L33 (error at format_input_but_cache_checksums:313) else goto L3
L3:
    r4 = CPyObject_Size(r3)
    dec_ref r3
    if is_error(r4) goto L33 (error at format_input_but_cache_checksums:313) else goto L4
L4:
    r5 = r4 != 0
    dec_ref r4 :: int
    if r5 goto L12 else goto L5 :: bool
L5:
    r6 = 'name'
    r7 = CPyDict_GetItem(abi, r6)
    if is_error(r7) goto L33 (error at format_input_but_cache_checksums:314) else goto L6
L6:
    r8 = PyObject_Str(r7)
    dec_ref r7
    if is_error(r8) goto L33 (error at format_input_but_cache_checksums:314) else goto L7
L7:
    r9 = ' requires no arguments'
    r10 = CPyStr_Build(2, r8, r9)
    dec_ref r8
    if is_error(r10) goto L33 (error at format_input_but_cache_checksums:314) else goto L8
L8:
    r11 = builtins :: module
    r12 = 'TypeError'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L34 (error at format_input_but_cache_checksums:314) else goto L9
L9:
    r14 = [r10]
    r15 = load_address r14
    r16 = PyObject_Vectorcall(r13, r15, 1, 0)
    dec_ref r13
    if is_error(r16) goto L34 (error at format_input_but_cache_checksums:314) else goto L10
L10:
    dec_ref r10
    CPy_Raise(r16)
    dec_ref r16
    if not 0 goto L33 (error at format_input_but_cache_checksums:314) else goto L11 :: bool
L11:
    unreachable
L12:
    r17 = 'inputs'
    r18 = CPyDict_GetItem(abi, r17)
    if is_error(r18) goto L33 (error at format_input_but_cache_checksums:315) else goto L13
L13:
    r19 = dank_mids.brownie_patch.call._get_abi_types :: static
    if is_error(r19) goto L35 else goto L16
L14:
    r20 = raise NameError('value for final name "_get_abi_types" was not set')
    if not r20 goto L33 (error at format_input_but_cache_checksums:315) else goto L15 :: bool
L15:
    unreachable
L16:
    r21 = [r18]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(r19, r22, 1, 0)
    if is_error(r23) goto L36 (error at format_input_but_cache_checksums:315) else goto L17
L17:
    dec_ref r18
L18:
    r24 = _format_tuple_but_cache_checksums(r23, inputs)
    dec_ref r23
    if is_error(r24) goto L20 (error at format_input_but_cache_checksums:317) else goto L19
L19:
    return r24
L20:
    r25 = CPy_CatchError()
    r26 = builtins :: module
    r27 = 'Exception'
    r28 = CPyObject_GetAttr(r26, r27)
    if is_error(r28) goto L31 (error at format_input_but_cache_checksums:318) else goto L21
L21:
    r29 = CPy_ExceptionMatches(r28)
    dec_ref r28
    if r29 goto L22 else goto L29 :: bool
L22:
    r30 = CPy_GetExcValue()
    r31 = PyObject_Type(r30)
    r32 = 'name'
    r33 = CPyDict_GetItem(abi, r32)
    if is_error(r33) goto L37 (error at format_input_but_cache_checksums:319) else goto L23
L23:
    r34 = PyObject_Str(r33)
    dec_ref r33
    if is_error(r34) goto L37 (error at format_input_but_cache_checksums:319) else goto L24
L24:
    r35 = ' '
    r36 = PyObject_Str(r30)
    dec_ref r30
    if is_error(r36) goto L38 (error at format_input_but_cache_checksums:319) else goto L25
L25:
    r37 = CPyStr_Build(3, r34, r35, r36)
    dec_ref r34
    dec_ref r36
    if is_error(r37) goto L39 (error at format_input_but_cache_checksums:319) else goto L26
L26:
    r38 = [r37]
    r39 = load_address r38
    r40 = PyObject_Vectorcall(r31, r39, 1, 0)
    dec_ref r31
    if is_error(r40) goto L40 (error at format_input_but_cache_checksums:319) else goto L27
L27:
    dec_ref r37
    CPy_Raise(r40)
    dec_ref r40
    if not 0 goto L31 (error at format_input_but_cache_checksums:319) else goto L41 :: bool
L28:
    unreachable
L29:
    CPy_Reraise()
    if not 0 goto L31 else goto L42 :: bool
L30:
    unreachable
L31:
    CPy_RestoreExcInfo(r25)
    dec_ref r25
    r41 = CPy_KeepPropagating()
    if not r41 goto L33 else goto L32 :: bool
L32:
    unreachable
L33:
    r42 = <error> :: list
    return r42
L34:
    dec_ref r10
    goto L33
L35:
    dec_ref r18
    goto L14
L36:
    dec_ref r18
    goto L33
L37:
    dec_ref r30
    dec_ref r31
    goto L31
L38:
    dec_ref r31
    dec_ref r34
    goto L31
L39:
    dec_ref r31
    goto L31
L40:
    dec_ref r37
    goto L31
L41:
    dec_ref r25
    goto L28
L42:
    dec_ref r25
    goto L30

def format_output_but_cache_checksums(abi, outputs):
    abi :: dict
    outputs :: union[list, tuple]
    r0 :: str
    r1, r2 :: object
    r3 :: bool
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: list
    r8 :: str
    r9, r10 :: object
    r11 :: bool
    r12 :: object[2]
    r13 :: object_ptr
    r14, r15 :: object
L0:
    r0 = 'outputs'
    r1 = CPyDict_GetItem(abi, r0)
    if is_error(r1) goto L12 (error at format_output_but_cache_checksums:326) else goto L1
L1:
    r2 = dank_mids.brownie_patch.call._get_abi_types :: static
    if is_error(r2) goto L13 else goto L4
L2:
    r3 = raise NameError('value for final name "_get_abi_types" was not set')
    if not r3 goto L12 (error at format_output_but_cache_checksums:326) else goto L3 :: bool
L3:
    unreachable
L4:
    r4 = [r1]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r2, r5, 1, 0)
    if is_error(r6) goto L14 (error at format_output_but_cache_checksums:326) else goto L5
L5:
    dec_ref r1
    r7 = _format_tuple_but_cache_checksums(r6, outputs)
    dec_ref r6
    if is_error(r7) goto L12 (error at format_output_but_cache_checksums:327) else goto L6
L6:
    r8 = 'outputs'
    r9 = CPyDict_GetItem(abi, r8)
    if is_error(r9) goto L15 (error at format_output_but_cache_checksums:328) else goto L7
L7:
    r10 = dank_mids.brownie_patch.call.ReturnValue :: static
    if is_error(r10) goto L16 else goto L10
L8:
    r11 = raise NameError('value for final name "ReturnValue" was not set')
    if not r11 goto L12 (error at format_output_but_cache_checksums:328) else goto L9 :: bool
L9:
    unreachable
L10:
    r12 = [r7, r9]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r10, r13, 2, 0)
    if is_error(r14) goto L17 (error at format_output_but_cache_checksums:328) else goto L11
L11:
    dec_ref r7
    dec_ref r9
    return r14
L12:
    r15 = <error> :: object
    return r15
L13:
    dec_ref r1
    goto L2
L14:
    dec_ref r1
    goto L12
L15:
    dec_ref r7
    goto L12
L16:
    dec_ref r7
    dec_ref r9
    goto L8
L17:
    dec_ref r7
    dec_ref r9
    goto L12

def _format_tuple_but_cache_checksums(abi_types, values):
    abi_types :: object
    values :: union[list, tuple]
    r0 :: list
    r1 :: int
    r2 :: object
    r3 :: bool
    r4 :: object
    r5 :: object[2]
    r6 :: object_ptr
    r7, r8, r9, r10, r11 :: object
    r12 :: str
    r13 :: object
    r14 :: i32
    r15 :: bit
    r16 :: bool
    r17 :: union[list, tuple]
    r18 :: list
    r19 :: i32
    r20 :: bit
    r21 :: object
    r22 :: bool
    r23 :: i32
    r24 :: bit
    r25 :: bool
    r26 :: str
    r27 :: object
    r28 :: union[list, tuple]
    r29 :: list
    r30 :: i32
    r31 :: bit
    r32 :: str
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: i32
    r39 :: bit
    r40 :: tuple[object, object, object]
    r41 :: object
    r42 :: str
    r43 :: object
    r44 :: bit
    r45, r46 :: object
    r47, r48, r49, r50, r51 :: str
    r52 :: object[1]
    r53 :: object_ptr
    r54 :: object
    r55, r56, r57 :: bit
    r58 :: list
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L45 (error at _format_tuple_but_cache_checksums:338) else goto L1
L1:
    r1 = CPyObject_Size(abi_types)
    if is_error(r1) goto L46 (error at _format_tuple_but_cache_checksums:339) else goto L2
L2:
    r2 = dank_mids.brownie_patch.call._check_array :: static
    if is_error(r2) goto L47 else goto L5
L3:
    r3 = raise NameError('value for final name "_check_array" was not set')
    if not r3 goto L45 (error at _format_tuple_but_cache_checksums:339) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = box(int, r1)
    r5 = [values, r4]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r2, r6, 2, 0)
    if is_error(r7) goto L48 (error at _format_tuple_but_cache_checksums:339) else goto L49
L6:
    dec_ref r4
    r8 = PyObject_GetIter(abi_types)
    if is_error(r8) goto L46 (error at _format_tuple_but_cache_checksums:340) else goto L7
L7:
    r9 = PyObject_GetIter(values)
    if is_error(r9) goto L50 (error at _format_tuple_but_cache_checksums:340) else goto L8
L8:
    r10 = PyIter_Next(r8)
    if is_error(r10) goto L51 else goto L9
L9:
    r11 = PyIter_Next(r9)
    if is_error(r11) goto L52 else goto L10
L10:
L11:
    r12 = 'is_array'
    r13 = CPyObject_GetAttr(r10, r12)
    if is_error(r13) goto L53 (error at _format_tuple_but_cache_checksums:342) else goto L12
L12:
    r14 = PyObject_IsTrue(r13)
    dec_ref r13
    r15 = r14 >= 0 :: signed
    if not r15 goto L53 (error at _format_tuple_but_cache_checksums:342) else goto L13 :: bool
L13:
    r16 = truncate r14: i32 to builtins.bool
    if r16 goto L14 else goto L17 :: bool
L14:
    inc_ref r11
    r17 = cast(union[list, tuple], r11)
    if is_error(r17) goto L53 (error at _format_tuple_but_cache_checksums:343) else goto L15
L15:
    r18 = _format_array_but_cache_checksums(r10, r17)
    dec_ref r10
    dec_ref r17
    if is_error(r18) goto L54 (error at _format_tuple_but_cache_checksums:343) else goto L16
L16:
    r19 = PyList_Append(r0, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L54 (error at _format_tuple_but_cache_checksums:343) else goto L55 :: bool
L17:
    r21 = dank_mids.brownie_patch.call.TupleType :: static
    if is_error(r21) goto L56 else goto L20
L18:
    r22 = raise NameError('value for final name "TupleType" was not set')
    if not r22 goto L30 (error at _format_tuple_but_cache_checksums:344) else goto L57 :: bool
L19:
    unreachable
L20:
    r23 = PyObject_IsInstance(r10, r21)
    r24 = r23 >= 0 :: signed
    if not r24 goto L53 (error at _format_tuple_but_cache_checksums:344) else goto L21 :: bool
L21:
    r25 = truncate r23: i32 to builtins.bool
    if r25 goto L22 else goto L26 :: bool
L22:
    r26 = 'components'
    r27 = CPyObject_GetAttr(r10, r26)
    dec_ref r10
    if is_error(r27) goto L54 (error at _format_tuple_but_cache_checksums:345) else goto L23
L23:
    inc_ref r11
    r28 = cast(union[list, tuple], r11)
    if is_error(r28) goto L58 (error at _format_tuple_but_cache_checksums:345) else goto L24
L24:
    r29 = _format_tuple_but_cache_checksums(r27, r28)
    dec_ref r27
    dec_ref r28
    if is_error(r29) goto L54 (error at _format_tuple_but_cache_checksums:345) else goto L25
L25:
    r30 = PyList_Append(r0, r29)
    dec_ref r29
    r31 = r30 >= 0 :: signed
    if not r31 goto L54 (error at _format_tuple_but_cache_checksums:345) else goto L59 :: bool
L26:
    r32 = 'to_type_str'
    r33 = [r10]
    r34 = load_address r33
    r35 = PyObject_VectorcallMethod(r32, r34, 9223372036854775809, 0)
    if is_error(r35) goto L53 (error at _format_tuple_but_cache_checksums:347) else goto L27
L27:
    dec_ref r10
    r36 = cast(str, r35)
    if is_error(r36) goto L54 (error at _format_tuple_but_cache_checksums:347) else goto L28
L28:
    r37 = _format_single_but_cache_checksums(r36, r11)
    dec_ref r36
    if is_error(r37) goto L54 (error at _format_tuple_but_cache_checksums:347) else goto L29
L29:
    r38 = PyList_Append(r0, r37)
    dec_ref r37
    r39 = r38 >= 0 :: signed
    if not r39 goto L54 (error at _format_tuple_but_cache_checksums:347) else goto L60 :: bool
L30:
    r40 = CPy_CatchError()
    r41 = builtins :: module
    r42 = 'Exception'
    r43 = CPyObject_GetAttr(r41, r42)
    if is_error(r43) goto L61 (error at _format_tuple_but_cache_checksums:348) else goto L31
L31:
    r44 = CPy_ExceptionMatches(r43)
    dec_ref r43
    if r44 goto L32 else goto L62 :: bool
L32:
    r45 = CPy_GetExcValue()
    r46 = PyObject_Type(r45)
    r47 = "'"
    r48 = PyObject_Str(r11)
    dec_ref r11
    if is_error(r48) goto L63 (error at _format_tuple_but_cache_checksums:349) else goto L33
L33:
    r49 = "' - "
    r50 = PyObject_Str(r45)
    dec_ref r45
    if is_error(r50) goto L64 (error at _format_tuple_but_cache_checksums:349) else goto L34
L34:
    r51 = CPyStr_Build(4, r47, r48, r49, r50)
    dec_ref r48
    dec_ref r50
    if is_error(r51) goto L65 (error at _format_tuple_but_cache_checksums:349) else goto L35
L35:
    r52 = [r51]
    r53 = load_address r52
    r54 = PyObject_Vectorcall(r46, r53, 1, 0)
    dec_ref r46
    if is_error(r54) goto L66 (error at _format_tuple_but_cache_checksums:349) else goto L36
L36:
    dec_ref r51
    CPy_Raise(r54)
    dec_ref r54
    if not 0 goto L40 (error at _format_tuple_but_cache_checksums:349) else goto L67 :: bool
L37:
    unreachable
L38:
    CPy_Reraise()
    if not 0 goto L40 else goto L68 :: bool
L39:
    unreachable
L40:
    CPy_RestoreExcInfo(r40)
    dec_ref r40
    r55 = CPy_KeepPropagating()
    if not r55 goto L45 else goto L41 :: bool
L41:
    unreachable
L42:
    r56 = CPy_NoErrOccurred()
    if not r56 goto L46 (error at _format_tuple_but_cache_checksums:340) else goto L43 :: bool
L43:
    r57 = CPy_NoErrOccurred()
    if not r57 goto L46 (error at _format_tuple_but_cache_checksums:340) else goto L44 :: bool
L44:
    return r0
L45:
    r58 = <error> :: list
    return r58
L46:
    dec_ref r0
    goto L45
L47:
    dec_ref r0
    dec_ref r1 :: int
    goto L3
L48:
    dec_ref r0
    dec_ref r4
    goto L45
L49:
    dec_ref r7
    goto L6
L50:
    dec_ref r0
    dec_ref r8
    goto L45
L51:
    dec_ref r8
    dec_ref r9
    goto L42
L52:
    dec_ref r8
    dec_ref r9
    dec_ref r10
    goto L42
L53:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    dec_ref r10
    goto L30
L54:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    goto L30
L55:
    dec_ref r11
    goto L8
L56:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    dec_ref r10
    goto L18
L57:
    dec_ref r11
    goto L19
L58:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    dec_ref r27
    goto L30
L59:
    dec_ref r11
    goto L8
L60:
    dec_ref r11
    goto L8
L61:
    dec_ref r11
    goto L40
L62:
    dec_ref r11
    goto L38
L63:
    dec_ref r45
    dec_ref r46
    goto L40
L64:
    dec_ref r46
    dec_ref r48
    goto L40
L65:
    dec_ref r46
    goto L40
L66:
    dec_ref r51
    goto L40
L67:
    dec_ref r40
    goto L37
L68:
    dec_ref r40
    goto L39

def _format_array_but_cache_checksums(abi_type, values):
    abi_type :: object
    values :: union[list, tuple]
    r0 :: str
    r1, r2, r3 :: object
    r4 :: int
    r5 :: bit
    r6 :: str
    r7, r8, r9, r10, r11 :: object
    r12 :: union[object, None]
    r13, r14 :: object
    r15 :: bool
    r16 :: object[2]
    r17 :: object_ptr
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: i32
    r24 :: bit
    r25 :: bool
    r26 :: list
    r27, r28 :: object
    r29 :: union[list, tuple]
    r30 :: list
    r31 :: i32
    r32, r33 :: bit
    r34 :: object
    r35 :: bool
    r36 :: i32
    r37 :: bit
    r38 :: bool
    r39 :: str
    r40 :: object
    r41 :: list
    r42, r43 :: object
    r44 :: union[list, tuple]
    r45 :: list
    r46 :: i32
    r47, r48 :: bit
    r49 :: str
    r50 :: object[1]
    r51 :: object_ptr
    r52 :: object
    r53 :: str
    r54 :: list
    r55, r56, r57 :: object
    r58 :: i32
    r59, r60 :: bit
    r61 :: list
L0:
    r0 = 'arrlist'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L48 (error at _format_array_but_cache_checksums:354) else goto L1
L1:
    r2 = object -1
    r3 = PyObject_GetItem(r1, r2)
    dec_ref r1
    if is_error(r3) goto L48 (error at _format_array_but_cache_checksums:354) else goto L2
L2:
    r4 = CPyObject_Size(r3)
    dec_ref r3
    if is_error(r4) goto L48 (error at _format_array_but_cache_checksums:354) else goto L3
L3:
    r5 = r4 != 0
    dec_ref r4 :: int
    if r5 goto L4 else goto L8 :: bool
L4:
    r6 = 'arrlist'
    r7 = CPyObject_GetAttr(abi_type, r6)
    if is_error(r7) goto L48 (error at _format_array_but_cache_checksums:354) else goto L5
L5:
    r8 = object -1
    r9 = PyObject_GetItem(r7, r8)
    dec_ref r7
    if is_error(r9) goto L48 (error at _format_array_but_cache_checksums:354) else goto L6
L6:
    r10 = object 0
    r11 = PyObject_GetItem(r9, r10)
    dec_ref r9
    if is_error(r11) goto L48 (error at _format_array_but_cache_checksums:354) else goto L7
L7:
    r12 = r11
    goto L9
L8:
    r13 = box(None, 1)
    inc_ref r13
    r12 = r13
L9:
    r14 = dank_mids.brownie_patch.call._check_array :: static
    if is_error(r14) goto L49 else goto L12
L10:
    r15 = raise NameError('value for final name "_check_array" was not set')
    if not r15 goto L48 (error at _format_array_but_cache_checksums:354) else goto L11 :: bool
L11:
    unreachable
L12:
    r16 = [values, r12]
    r17 = load_address r16
    r18 = PyObject_Vectorcall(r14, r17, 2, 0)
    if is_error(r18) goto L50 (error at _format_array_but_cache_checksums:354) else goto L51
L13:
    dec_ref r12
    r19 = 'item_type'
    r20 = CPyObject_GetAttr(abi_type, r19)
    if is_error(r20) goto L48 (error at _format_array_but_cache_checksums:355) else goto L14
L14:
    r21 = 'is_array'
    r22 = CPyObject_GetAttr(r20, r21)
    if is_error(r22) goto L52 (error at _format_array_but_cache_checksums:356) else goto L15
L15:
    r23 = PyObject_IsTrue(r22)
    dec_ref r22
    r24 = r23 >= 0 :: signed
    if not r24 goto L52 (error at _format_array_but_cache_checksums:356) else goto L16 :: bool
L16:
    r25 = truncate r23: i32 to builtins.bool
    if r25 goto L17 else goto L25 :: bool
L17:
    r26 = PyList_New(0)
    if is_error(r26) goto L52 (error at _format_array_but_cache_checksums:357) else goto L18
L18:
    r27 = PyObject_GetIter(values)
    if is_error(r27) goto L53 (error at _format_array_but_cache_checksums:357) else goto L19
L19:
    r28 = PyIter_Next(r27)
    if is_error(r28) goto L54 else goto L20
L20:
    r29 = cast(union[list, tuple], r28)
    if is_error(r29) goto L55 (error at _format_array_but_cache_checksums:357) else goto L21
L21:
    r30 = _format_array_but_cache_checksums(r20, r29)
    dec_ref r29
    if is_error(r30) goto L55 (error at _format_array_but_cache_checksums:357) else goto L22
L22:
    r31 = PyList_Append(r26, r30)
    dec_ref r30
    r32 = r31 >= 0 :: signed
    if not r32 goto L55 (error at _format_array_but_cache_checksums:357) else goto L19 :: bool
L23:
    r33 = CPy_NoErrOccurred()
    if not r33 goto L56 (error at _format_array_but_cache_checksums:357) else goto L24 :: bool
L24:
    return r26
L25:
    r34 = dank_mids.brownie_patch.call.TupleType :: static
    if is_error(r34) goto L57 else goto L28
L26:
    r35 = raise NameError('value for final name "TupleType" was not set')
    if not r35 goto L48 (error at _format_array_but_cache_checksums:358) else goto L27 :: bool
L27:
    unreachable
L28:
    r36 = PyObject_IsInstance(r20, r34)
    r37 = r36 >= 0 :: signed
    if not r37 goto L52 (error at _format_array_but_cache_checksums:358) else goto L29 :: bool
L29:
    r38 = truncate r36: i32 to builtins.bool
    if r38 goto L30 else goto L39 :: bool
L30:
    r39 = 'components'
    r40 = CPyObject_GetAttr(r20, r39)
    dec_ref r20
    if is_error(r40) goto L48 (error at _format_array_but_cache_checksums:359) else goto L31
L31:
    r41 = PyList_New(0)
    if is_error(r41) goto L58 (error at _format_array_but_cache_checksums:360) else goto L32
L32:
    r42 = PyObject_GetIter(values)
    if is_error(r42) goto L59 (error at _format_array_but_cache_checksums:360) else goto L33
L33:
    r43 = PyIter_Next(r42)
    if is_error(r43) goto L60 else goto L34
L34:
    r44 = cast(union[list, tuple], r43)
    if is_error(r44) goto L61 (error at _format_array_but_cache_checksums:360) else goto L35
L35:
    r45 = _format_tuple_but_cache_checksums(r40, r44)
    dec_ref r44
    if is_error(r45) goto L61 (error at _format_array_but_cache_checksums:360) else goto L36
L36:
    r46 = PyList_Append(r41, r45)
    dec_ref r45
    r47 = r46 >= 0 :: signed
    if not r47 goto L61 (error at _format_array_but_cache_checksums:360) else goto L33 :: bool
L37:
    r48 = CPy_NoErrOccurred()
    if not r48 goto L62 (error at _format_array_but_cache_checksums:360) else goto L38 :: bool
L38:
    return r41
L39:
    r49 = 'to_type_str'
    r50 = [r20]
    r51 = load_address r50
    r52 = PyObject_VectorcallMethod(r49, r51, 9223372036854775809, 0)
    if is_error(r52) goto L52 (error at _format_array_but_cache_checksums:362) else goto L40
L40:
    dec_ref r20
    r53 = cast(str, r52)
    if is_error(r53) goto L48 (error at _format_array_but_cache_checksums:362) else goto L41
L41:
    r54 = PyList_New(0)
    if is_error(r54) goto L63 (error at _format_array_but_cache_checksums:363) else goto L42
L42:
    r55 = PyObject_GetIter(values)
    if is_error(r55) goto L64 (error at _format_array_but_cache_checksums:363) else goto L43
L43:
    r56 = PyIter_Next(r55)
    if is_error(r56) goto L65 else goto L44
L44:
    r57 = _format_single_but_cache_checksums(r53, r56)
    dec_ref r56
    if is_error(r57) goto L66 (error at _format_array_but_cache_checksums:363) else goto L45
L45:
    r58 = PyList_Append(r54, r57)
    dec_ref r57
    r59 = r58 >= 0 :: signed
    if not r59 goto L66 (error at _format_array_but_cache_checksums:363) else goto L43 :: bool
L46:
    r60 = CPy_NoErrOccurred()
    if not r60 goto L67 (error at _format_array_but_cache_checksums:363) else goto L47 :: bool
L47:
    return r54
L48:
    r61 = <error> :: list
    return r61
L49:
    dec_ref r12
    goto L10
L50:
    dec_ref r12
    goto L48
L51:
    dec_ref r18
    goto L13
L52:
    dec_ref r20
    goto L48
L53:
    dec_ref r20
    dec_ref r26
    goto L48
L54:
    dec_ref r20
    dec_ref r27
    goto L23
L55:
    dec_ref r20
    dec_ref r26
    dec_ref r27
    goto L48
L56:
    dec_ref r26
    goto L48
L57:
    dec_ref r20
    goto L26
L58:
    dec_ref r40
    goto L48
L59:
    dec_ref r40
    dec_ref r41
    goto L48
L60:
    dec_ref r40
    dec_ref r42
    goto L37
L61:
    dec_ref r40
    dec_ref r41
    dec_ref r42
    goto L48
L62:
    dec_ref r41
    goto L48
L63:
    dec_ref r53
    goto L48
L64:
    dec_ref r53
    dec_ref r54
    goto L48
L65:
    dec_ref r53
    dec_ref r55
    goto L46
L66:
    dec_ref r53
    dec_ref r54
    dec_ref r55
    goto L48
L67:
    dec_ref r54
    goto L48

def _format_single_but_cache_checksums(type_str, value):
    type_str :: str
    value :: object
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4 :: object
    r5 :: bool
    r6 :: object[2]
    r7 :: object_ptr
    r8 :: object
    r9 :: str
    r10 :: i32
    r11 :: bit
    r12 :: bool
    r13 :: object
    r14 :: bool
    r15 :: object[2]
    r16 :: object_ptr
    r17 :: object
    r18 :: str
    r19 :: i32
    r20 :: bit
    r21 :: object
    r22, r23, r24 :: bit
    r25 :: object
    r26 :: bool
    r27 :: object[1]
    r28 :: object_ptr
    r29 :: object
    r30 :: str
    r31 :: i32
    r32 :: bit
    r33 :: object
    r34, r35, r36 :: bit
    r37 :: object
    r38 :: bool
    r39 :: object[1]
    r40 :: object_ptr
    r41 :: object
    r42 :: str
    r43 :: i32
    r44 :: bit
    r45 :: object
    r46, r47, r48 :: bit
    r49, r50, r51 :: object
    r52 :: str
    r53, r54, r55 :: object
    r56 :: tuple[object, object, object, object, object]
    r57 :: object
    r58 :: i32
    r59 :: bit
    r60 :: bool
    r61 :: union[str, bytes, object, int]
    r62 :: str
    r63 :: object
    r64 :: bool
    r65 :: object[1]
    r66 :: object_ptr
    r67 :: object
    r68 :: str
    r69 :: i32
    r70 :: bit
    r71 :: bool
    r72 :: object
    r73 :: bool
    r74 :: object[2]
    r75 :: object_ptr
    r76 :: object
    r77 :: str
    r78 :: i32
    r79 :: bit
    r80 :: bool
    r81 :: object
    r82 :: bool
    r83 :: object[1]
    r84 :: object_ptr
    r85 :: object
    r86, r87 :: str
    r88 :: object
    r89 :: str
    r90 :: object
    r91 :: object[1]
    r92 :: object_ptr
    r93, r94 :: object
L0:
    r0 = 'uint'
    r1 = PyUnicode_Contains(type_str, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L66 (error at _format_single_but_cache_checksums:368) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L2 else goto L7 :: bool
L2:
    r4 = dank_mids.brownie_patch.call.to_uint :: static
    if is_error(r4) goto L3 else goto L5
L3:
    r5 = raise NameError('value for final name "to_uint" was not set')
    if not r5 goto L66 (error at _format_single_but_cache_checksums:369) else goto L4 :: bool
L4:
    unreachable
L5:
    r6 = [value, type_str]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r4, r7, 2, 0)
    if is_error(r8) goto L66 (error at _format_single_but_cache_checksums:369) else goto L6
L6:
    return r8
L7:
    r9 = 'int'
    r10 = PyUnicode_Contains(type_str, r9)
    r11 = r10 >= 0 :: signed
    if not r11 goto L66 (error at _format_single_but_cache_checksums:370) else goto L8 :: bool
L8:
    r12 = truncate r10: i32 to builtins.bool
    if r12 goto L9 else goto L14 :: bool
L9:
    r13 = dank_mids.brownie_patch.call.to_int :: static
    if is_error(r13) goto L10 else goto L12
L10:
    r14 = raise NameError('value for final name "to_int" was not set')
    if not r14 goto L66 (error at _format_single_but_cache_checksums:371) else goto L11 :: bool
L11:
    unreachable
L12:
    r15 = [value, type_str]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r13, r16, 2, 0)
    if is_error(r17) goto L66 (error at _format_single_but_cache_checksums:371) else goto L13
L13:
    return r17
L14:
    r18 = 'fixed168x10'
    r19 = PyUnicode_Compare(type_str, r18)
    r20 = r19 == -1
    if r20 goto L15 else goto L17 :: bool
L15:
    r21 = PyErr_Occurred()
    r22 = r21 != 0
    if r22 goto L16 else goto L17 :: bool
L16:
    r23 = CPy_KeepPropagating()
    if not r23 goto L66 (error at _format_single_but_cache_checksums:372) else goto L17 :: bool
L17:
    r24 = r19 == 0
    if r24 goto L18 else goto L23 :: bool
L18:
    r25 = dank_mids.brownie_patch.call.to_decimal :: static
    if is_error(r25) goto L19 else goto L21
L19:
    r26 = raise NameError('value for final name "to_decimal" was not set')
    if not r26 goto L66 (error at _format_single_but_cache_checksums:373) else goto L20 :: bool
L20:
    unreachable
L21:
    r27 = [value]
    r28 = load_address r27
    r29 = PyObject_Vectorcall(r25, r28, 1, 0)
    if is_error(r29) goto L66 (error at _format_single_but_cache_checksums:373) else goto L22
L22:
    return r29
L23:
    r30 = 'bool'
    r31 = PyUnicode_Compare(type_str, r30)
    r32 = r31 == -1
    if r32 goto L24 else goto L26 :: bool
L24:
    r33 = PyErr_Occurred()
    r34 = r33 != 0
    if r34 goto L25 else goto L26 :: bool
L25:
    r35 = CPy_KeepPropagating()
    if not r35 goto L66 (error at _format_single_but_cache_checksums:374) else goto L26 :: bool
L26:
    r36 = r31 == 0
    if r36 goto L27 else goto L32 :: bool
L27:
    r37 = dank_mids.brownie_patch.call.to_bool :: static
    if is_error(r37) goto L28 else goto L30
L28:
    r38 = raise NameError('value for final name "to_bool" was not set')
    if not r38 goto L66 (error at _format_single_but_cache_checksums:375) else goto L29 :: bool
L29:
    unreachable
L30:
    r39 = [value]
    r40 = load_address r39
    r41 = PyObject_Vectorcall(r37, r40, 1, 0)
    if is_error(r41) goto L66 (error at _format_single_but_cache_checksums:375) else goto L31
L31:
    return r41
L32:
    r42 = 'address'
    r43 = PyUnicode_Compare(type_str, r42)
    r44 = r43 == -1
    if r44 goto L33 else goto L35 :: bool
L33:
    r45 = PyErr_Occurred()
    r46 = r45 != 0
    if r46 goto L34 else goto L35 :: bool
L34:
    r47 = CPy_KeepPropagating()
    if not r47 goto L66 (error at _format_single_but_cache_checksums:376) else goto L35 :: bool
L35:
    r48 = r43 == 0
    if r48 goto L36 else goto L47 :: bool
L36:
    r49 = load_address PyUnicode_Type
    r50 = load_address PyBytes_Type
    r51 = builtins :: module
    r52 = 'bytearray'
    r53 = CPyObject_GetAttr(r51, r52)
    if is_error(r53) goto L66 (error at _format_single_but_cache_checksums:379) else goto L37
L37:
    r54 = load_address PyLong_Type
    r55 = load_address PyBool_Type
    inc_ref r49
    inc_ref r50
    inc_ref r54
    inc_ref r55
    r56 = (r49, r50, r53, r54, r55)
    r57 = box(tuple[object, object, object, object, object], r56)
    r58 = PyObject_IsInstance(value, r57)
    dec_ref r57
    r59 = r58 >= 0 :: signed
    if not r59 goto L66 (error at _format_single_but_cache_checksums:379) else goto L38 :: bool
L38:
    r60 = truncate r58: i32 to builtins.bool
    if r60 goto L39 else goto L40 :: bool
L39:
    inc_ref value
    r61 = value
    goto L42
L40:
    r62 = PyObject_Str(value)
    if is_error(r62) goto L66 (error at _format_single_but_cache_checksums:379) else goto L41
L41:
    r61 = r62
L42:
    r63 = dank_mids.brownie_patch.call.to_checksum_address :: static
    if is_error(r63) goto L67 else goto L45
L43:
    r64 = raise NameError('value for final name "to_checksum_address" was not set')
    if not r64 goto L66 (error at _format_single_but_cache_checksums:378) else goto L44 :: bool
L44:
    unreachable
L45:
    r65 = [r61]
    r66 = load_address r65
    r67 = PyObject_Vectorcall(r63, r66, 1, 0)
    if is_error(r67) goto L68 (error at _format_single_but_cache_checksums:378) else goto L46
L46:
    dec_ref r61
    return r67
L47:
    r68 = 'byte'
    r69 = PyUnicode_Contains(type_str, r68)
    r70 = r69 >= 0 :: signed
    if not r70 goto L66 (error at _format_single_but_cache_checksums:381) else goto L48 :: bool
L48:
    r71 = truncate r69: i32 to builtins.bool
    if r71 goto L49 else goto L54 :: bool
L49:
    r72 = dank_mids.brownie_patch.call.HexString :: static
    if is_error(r72) goto L50 else goto L52
L50:
    r73 = raise NameError('value for final name "HexString" was not set')
    if not r73 goto L66 (error at _format_single_but_cache_checksums:382) else goto L51 :: bool
L51:
    unreachable
L52:
    r74 = [value, type_str]
    r75 = load_address r74
    r76 = PyObject_Vectorcall(r72, r75, 2, 0)
    if is_error(r76) goto L66 (error at _format_single_but_cache_checksums:382) else goto L53
L53:
    return r76
L54:
    r77 = 'string'
    r78 = PyUnicode_Contains(type_str, r77)
    r79 = r78 >= 0 :: signed
    if not r79 goto L66 (error at _format_single_but_cache_checksums:383) else goto L55 :: bool
L55:
    r80 = truncate r78: i32 to builtins.bool
    if r80 goto L56 else goto L61 :: bool
L56:
    r81 = dank_mids.brownie_patch.call.to_string :: static
    if is_error(r81) goto L57 else goto L59
L57:
    r82 = raise NameError('value for final name "to_string" was not set')
    if not r82 goto L66 (error at _format_single_but_cache_checksums:384) else goto L58 :: bool
L58:
    unreachable
L59:
    r83 = [value]
    r84 = load_address r83
    r85 = PyObject_Vectorcall(r81, r84, 1, 0)
    if is_error(r85) goto L66 (error at _format_single_but_cache_checksums:384) else goto L60
L60:
    return r85
L61:
    r86 = 'Unknown type: '
    r87 = CPyStr_Build(2, r86, type_str)
    if is_error(r87) goto L66 (error at _format_single_but_cache_checksums:385) else goto L62
L62:
    r88 = builtins :: module
    r89 = 'TypeError'
    r90 = CPyObject_GetAttr(r88, r89)
    if is_error(r90) goto L69 (error at _format_single_but_cache_checksums:385) else goto L63
L63:
    r91 = [r87]
    r92 = load_address r91
    r93 = PyObject_Vectorcall(r90, r92, 1, 0)
    dec_ref r90
    if is_error(r93) goto L69 (error at _format_single_but_cache_checksums:385) else goto L64
L64:
    dec_ref r87
    CPy_Raise(r93)
    dec_ref r93
    if not 0 goto L66 (error at _format_single_but_cache_checksums:385) else goto L65 :: bool
L65:
    unreachable
L66:
    r94 = <error> :: object
    return r94
L67:
    dec_ref r61
    goto L43
L68:
    dec_ref r61
    goto L66
L69:
    dec_ref r87
    goto L66

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: dict
    r30, r31 :: object
    r32 :: str
    r33 :: dict
    r34 :: object
    r35, r36, r37, r38, r39 :: object_ptr
    r40 :: object_ptr[5]
    r41 :: c_ptr
    r42 :: native_int[5]
    r43 :: c_ptr
    r44 :: object
    r45 :: dict
    r46, r47 :: str
    r48 :: bit
    r49 :: object
    r50 :: str
    r51 :: dict
    r52, r53 :: object
    r54 :: str
    r55 :: dict
    r56, r57 :: object
    r58 :: str
    r59 :: dict
    r60, r61 :: object
    r62 :: str
    r63 :: dict
    r64, r65 :: object
    r66 :: str
    r67 :: dict
    r68, r69 :: object
    r70 :: str
    r71 :: dict
    r72, r73 :: object
    r74 :: str
    r75 :: dict
    r76, r77 :: object
    r78 :: str
    r79 :: dict
    r80, r81 :: object
    r82 :: str
    r83 :: dict
    r84, r85 :: object
    r86 :: str
    r87 :: dict
    r88, r89 :: object
    r90 :: str
    r91 :: dict
    r92, r93 :: object
    r94 :: str
    r95 :: dict
    r96, r97 :: object
    r98 :: str
    r99 :: dict
    r100, r101, r102 :: object
    r103 :: str
    r104 :: dict
    r105, r106 :: object
    r107 :: str
    r108 :: dict
    r109, r110 :: object
    r111 :: str
    r112 :: dict
    r113, r114 :: object
    r115 :: str
    r116 :: dict
    r117, r118 :: object
    r119 :: str
    r120 :: dict
    r121, r122 :: object
    r123 :: bool
    r124 :: str
    r125 :: object
    r126 :: bool
    r127 :: dict
    r128 :: str
    r129 :: i32
    r130 :: bit
    r131 :: str
    r132 :: dict
    r133 :: str
    r134 :: object
    r135 :: object[1]
    r136 :: object_ptr
    r137 :: object
    r138 :: dict
    r139 :: str
    r140 :: i32
    r141 :: bit
    r142 :: str
    r143 :: object
    r144 :: dict
    r145 :: str
    r146 :: object
    r147 :: object[2]
    r148 :: object_ptr
    r149 :: object
    r150 :: dict
    r151 :: str
    r152 :: i32
    r153 :: bit
    r154 :: dict
    r155 :: str
    r156 :: object
    r157 :: dict
    r158 :: str
    r159, r160 :: object
    r161 :: dict
    r162 :: str
    r163 :: i32
    r164 :: bit
    r165 :: dict
    r166 :: str
    r167 :: object
    r168 :: dict
    r169 :: str
    r170 :: object
    r171 :: dict
    r172 :: str
    r173, r174 :: object
    r175 :: dict
    r176 :: str
    r177 :: object
    r178 :: dict
    r179 :: str
    r180, r181 :: object
    r182 :: tuple[object, object]
    r183, r184 :: object
    r185 :: tuple[object, object]
    r186, r187 :: object
    r188 :: dict
    r189 :: str
    r190 :: i32
    r191 :: bit
    r192 :: str
    r193 :: dict
    r194 :: str
    r195, r196 :: object
    r197 :: dict
    r198 :: str
    r199 :: object
    r200 :: tuple[object, object]
    r201, r202 :: object
    r203 :: dict
    r204 :: str
    r205 :: object
    r206 :: object[2]
    r207 :: object_ptr
    r208 :: object
    r209 :: dict
    r210 :: str
    r211 :: i32
    r212 :: bit
    r213 :: object
    r214 :: str
    r215 :: object
    r216 :: dict
    r217 :: str
    r218 :: i32
    r219 :: bit
    r220 :: dict
    r221 :: str
    r222 :: object
    r223 :: str
    r224 :: object
    r225 :: dict
    r226 :: str
    r227 :: i32
    r228 :: bit
    r229 :: dict
    r230 :: str
    r231 :: object
    r232 :: str
    r233 :: object
    r234 :: str
    r235 :: object
    r236 :: str
    r237 :: object
    r238 :: dict
    r239 :: str
    r240 :: i32
    r241 :: bit
    r242 :: dict
    r243 :: str
    r244 :: object
    r245 :: str
    r246 :: object
    r247 :: str
    r248 :: object
    r249 :: str
    r250 :: object
    r251 :: dict
    r252 :: str
    r253 :: i32
    r254 :: bit
    r255 :: dict
    r256 :: str
    r257 :: object
    r258 :: str
    r259 :: object
    r260 :: str
    r261 :: object
    r262 :: str
    r263 :: object
    r264 :: dict
    r265 :: str
    r266 :: i32
    r267 :: bit
    r268 :: dict
    r269 :: str
    r270 :: object
    r271 :: str
    r272 :: object
    r273 :: str
    r274 :: object
    r275 :: str
    r276 :: object
    r277 :: dict
    r278 :: str
    r279 :: i32
    r280 :: bit
    r281 :: dict
    r282 :: str
    r283 :: object
    r284 :: str
    r285 :: object
    r286 :: dict
    r287 :: str
    r288 :: i32
    r289 :: bit
    r290 :: dict
    r291 :: str
    r292 :: object
    r293 :: str
    r294 :: object
    r295 :: str
    r296 :: object
    r297 :: str
    r298 :: object
    r299 :: dict
    r300 :: str
    r301 :: i32
    r302 :: bit
    r303 :: dict
    r304 :: str
    r305 :: object
    r306 :: str
    r307 :: object
    r308 :: str
    r309 :: object
    r310 :: str
    r311 :: object
    r312 :: dict
    r313 :: str
    r314 :: i32
    r315 :: bit
    r316 :: dict
    r317 :: str
    r318 :: object
    r319 :: str
    r320 :: object
    r321 :: str
    r322 :: object
    r323 :: str
    r324 :: object
    r325 :: dict
    r326 :: str
    r327 :: i32
    r328 :: bit
    r329 :: dict
    r330 :: str
    r331 :: object
    r332 :: str
    r333 :: object
    r334 :: str
    r335 :: object
    r336 :: str
    r337 :: object
    r338 :: dict
    r339 :: str
    r340 :: i32
    r341 :: bit
    r342 :: dict
    r343 :: str
    r344 :: object
    r345 :: str
    r346 :: object
    r347 :: str
    r348 :: object
    r349 :: str
    r350 :: object
    r351 :: dict
    r352 :: str
    r353 :: i32
    r354 :: bit
    r355 :: dict
    r356 :: str
    r357 :: object
    r358 :: str
    r359 :: object
    r360 :: str
    r361 :: object
    r362 :: str
    r363 :: object
    r364 :: dict
    r365 :: str
    r366 :: i32
    r367 :: bit
    r368 :: dict
    r369 :: str
    r370 :: object
    r371 :: str
    r372 :: object
    r373 :: str
    r374 :: object
    r375 :: str
    r376 :: object
    r377 :: dict
    r378 :: str
    r379 :: i32
    r380 :: bit
    r381 :: dict
    r382 :: str
    r383 :: object
    r384 :: str
    r385 :: object
    r386 :: bool
    r387 :: object[1]
    r388 :: object_ptr
    r389 :: object
    r390 :: dict
    r391 :: str
    r392 :: i32
    r393 :: bit
    r394 :: dank_mids.brownie_patch.call.__mypyc_lambda__0_obj
    r395 :: dict
    r396 :: str
    r397 :: i32
    r398 :: bit
    r399 :: dank_mids.brownie_patch.call.__mypyc_lambda__1_obj
    r400 :: dict
    r401 :: str
    r402 :: i32
    r403 :: bit
    r404 :: dict
    r405 :: str
    r406 :: object
    r407 :: str
    r408 :: object
    r409 :: dict
    r410 :: str
    r411 :: i32
    r412 :: bit
    r413 :: dict
    r414 :: str
    r415 :: object
    r416 :: dict
    r417 :: str
    r418 :: object
    r419 :: object[1]
    r420 :: object_ptr
    r421 :: object
    r422 :: dict
    r423 :: str
    r424 :: i32
    r425 :: bit
    r426 :: dict
    r427 :: str
    r428 :: object
    r429 :: str
    r430 :: bool
    r431 :: dict
    r432 :: str
    r433 :: object
    r434 :: str
    r435, r436 :: object
    r437 :: dict
    r438 :: str
    r439 :: object
    r440 :: str
    r441 :: object
    r442 :: dict
    r443 :: str
    r444 :: i32
    r445 :: bit
    r446 :: dict
    r447 :: str
    r448 :: object
    r449 :: str
    r450 :: bool
    r451 :: dict
    r452 :: str
    r453 :: object
    r454 :: str
    r455, r456 :: object
    r457 :: dict
    r458 :: str
    r459 :: object
    r460 :: str
    r461 :: object
    r462 :: dict
    r463 :: str
    r464 :: i32
    r465 :: bit
    r466 :: str
    r467 :: set
    r468 :: i32
    r469 :: bit
    r470 :: dict
    r471 :: str
    r472 :: i32
    r473 :: bit
    r474 :: dict
    r475 :: str
    r476 :: object
    r477 :: str
    r478 :: object
    r479 :: dict
    r480 :: str
    r481 :: i32
    r482 :: bit
    r483 :: tuple[object, object, object]
    r484 :: object
    r485 :: str
    r486 :: object
    r487 :: bit
    r488 :: dict
    r489 :: str
    r490 :: object
    r491 :: i32
    r492 :: bit
    r493 :: str
    r494 :: dict
    r495 :: str
    r496 :: object
    r497 :: str
    r498 :: i32
    r499 :: bit
    r500, r501 :: bool
    r502 :: bit
    r503 :: dict
    r504 :: str
    r505 :: object
    r506 :: dict
    r507 :: str
    r508 :: object
    r509 :: str
    r510 :: object
    r511 :: object[3]
    r512 :: object_ptr
    r513 :: object
    r514 :: dict
    r515 :: str
    r516 :: i32
    r517 :: bit
    r518 :: i32
    r519 :: bit
    r520 :: bool
    r521 :: dict
    r522 :: str
    r523 :: object
    r524 :: set
    r525 :: dict
    r526 :: str
    r527, r528 :: object
    r529 :: bool
    r530 :: object[1]
    r531 :: object_ptr
    r532 :: object
    r533 :: i32
    r534 :: bit
    r535 :: dict
    r536 :: str
    r537 :: object
    r538 :: dict
    r539 :: str
    r540 :: object
    r541 :: str
    r542 :: object
    r543 :: str
    r544 :: object
    r545 :: str
    r546 :: i32
    r547 :: bit
    r548 :: dict
    r549 :: str
    r550 :: object
    r551 :: dict
    r552 :: str
    r553 :: object
    r554 :: str
    r555 :: object
    r556 :: str
    r557 :: object
    r558 :: str
    r559 :: i32
    r560 :: bit
    r561 :: dict
    r562 :: str
    r563 :: object
    r564 :: dict
    r565 :: str
    r566 :: object
    r567 :: str
    r568 :: object
    r569 :: str
    r570 :: object
    r571 :: str
    r572 :: i32
    r573 :: bit
    r574 :: dict
    r575 :: str
    r576 :: object
    r577 :: dict
    r578 :: str
    r579 :: object
    r580 :: str
    r581 :: object
    r582 :: str
    r583 :: object
    r584 :: str
    r585 :: i32
    r586 :: bit
    r587 :: dict
    r588 :: str
    r589 :: object
    r590 :: dict
    r591 :: str
    r592 :: object
    r593 :: str
    r594 :: object
    r595 :: str
    r596 :: object
    r597 :: str
    r598 :: i32
    r599 :: bit
    r600 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L220 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address decimal :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('decimal', 'decimal', 'decimal'),)
    r11 = dank_mids.brownie_patch.call.globals :: static
    r12 = 'dank_mids\\brownie_patch\\call.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L220 else goto L4 :: bool
L4:
    r15 = ('BrokenProcessPool',)
    r16 = 'concurrent.futures.process'
    r17 = dank_mids.brownie_patch.call.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L220 (error at <module>:2) else goto L5
L5:
    concurrent.futures.process = r18 :: module
    dec_ref r18
    r19 = ('Logger',)
    r20 = 'logging'
    r21 = dank_mids.brownie_patch.call.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L220 (error at <module>:3) else goto L6
L6:
    logging = r22 :: module
    dec_ref r22
    r23 = ('PicklingError',)
    r24 = 'pickle'
    r25 = dank_mids.brownie_patch.call.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L220 (error at <module>:4) else goto L7
L7:
    pickle = r26 :: module
    dec_ref r26
    r27 = ('MethodType',)
    r28 = 'types'
    r29 = dank_mids.brownie_patch.call.globals :: static
    r30 = CPyImport_ImportFromMany(r28, r27, r27, r29)
    if is_error(r30) goto L220 (error at <module>:5) else goto L8
L8:
    types = r30 :: module
    dec_ref r30
    r31 = ('TYPE_CHECKING', 'Any', 'Callable', 'Dict', 'Final', 'List', 'NewType', 'Optional', 'Sequence', 'Tuple', 'TypeVar', 'Union')
    r32 = 'typing'
    r33 = dank_mids.brownie_patch.call.globals :: static
    r34 = CPyImport_ImportFromMany(r32, r31, r31, r33)
    if is_error(r34) goto L220 (error at <module>:6) else goto L9
L9:
    typing = r34 :: module
    dec_ref r34
    r35 = load_address brownie.convert.datatypes :: module
    r36 = load_address brownie.convert.normalize :: module
    r37 = load_address brownie.network.contract :: module
    r38 = load_address eth_abi :: module
    r39 = load_address hexbytes :: module
    r40 = [r35, r36, r37, r38, r39]
    r41 = load_address r40
    r42 = [21, 22, 23, 24, 25]
    r43 = load_address r42
    r44 = (('brownie.convert.datatypes', 'brownie', 'brownie'), ('brownie.convert.normalize', 'brownie', 'brownie'), ('brownie.network.contract', 'brownie', 'brownie'), ('eth_abi', 'eth_abi', 'eth_abi'), ('hexbytes', 'hexbytes', 'hexbytes'))
    r45 = dank_mids.brownie_patch.call.globals :: static
    r46 = 'dank_mids\\brownie_patch\\call.py'
    r47 = '<module>'
    r48 = CPyImport_ImportMany(r44, r41, r45, r46, r47, r43)
    if not r48 goto L220 else goto L10 :: bool
L10:
    r49 = ('AsyncProcessPoolExecutor',)
    r50 = 'a_sync'
    r51 = dank_mids.brownie_patch.call.globals :: static
    r52 = CPyImport_ImportFromMany(r50, r49, r49, r51)
    if is_error(r52) goto L220 (error at <module>:26) else goto L11
L11:
    a_sync = r52 :: module
    dec_ref r52
    r53 = ('chain',)
    r54 = 'brownie'
    r55 = dank_mids.brownie_patch.call.globals :: static
    r56 = CPyImport_ImportFromMany(r54, r53, r53, r55)
    if is_error(r56) goto L220 (error at <module>:27) else goto L12
L12:
    brownie = r56 :: module
    dec_ref r56
    r57 = ('ABIType',)
    r58 = 'brownie.convert.normalize'
    r59 = dank_mids.brownie_patch.call.globals :: static
    r60 = CPyImport_ImportFromMany(r58, r57, r57, r59)
    if is_error(r60) goto L220 (error at <module>:28) else goto L13
L13:
    brownie.convert.normalize = r60 :: module
    dec_ref r60
    r61 = ('get_type_strings',)
    r62 = 'brownie.convert.utils'
    r63 = dank_mids.brownie_patch.call.globals :: static
    r64 = CPyImport_ImportFromMany(r62, r61, r61, r63)
    if is_error(r64) goto L220 (error at <module>:29) else goto L14
L14:
    brownie.convert.utils = r64 :: module
    dec_ref r64
    r65 = ('VirtualMachineError',)
    r66 = 'brownie.exceptions'
    r67 = dank_mids.brownie_patch.call.globals :: static
    r68 = CPyImport_ImportFromMany(r66, r65, r65, r67)
    if is_error(r68) goto L220 (error at <module>:30) else goto L15
L15:
    brownie.exceptions = r68 :: module
    dec_ref r68
    r69 = ('ContractCall',)
    r70 = 'brownie.network.contract'
    r71 = dank_mids.brownie_patch.call.globals :: static
    r72 = CPyImport_ImportFromMany(r70, r69, r69, r71)
    if is_error(r72) goto L220 (error at <module>:31) else goto L16
L16:
    brownie.network.contract = r72 :: module
    dec_ref r72
    r73 = ('SOLIDITY_ERROR_CODES',)
    r74 = 'brownie.project.compiler.solidity'
    r75 = dank_mids.brownie_patch.call.globals :: static
    r76 = CPyImport_ImportFromMany(r74, r73, r73, r75)
    if is_error(r76) goto L220 (error at <module>:32) else goto L17
L17:
    brownie.project.compiler.solidity = r76 :: module
    dec_ref r76
    r77 = ('InsufficientDataBytes',)
    r78 = 'eth_abi.exceptions'
    r79 = dank_mids.brownie_patch.call.globals :: static
    r80 = CPyImport_ImportFromMany(r78, r77, r77, r79)
    if is_error(r80) goto L220 (error at <module>:33) else goto L18
L18:
    eth_abi.exceptions = r80 :: module
    dec_ref r80
    r81 = ('HexStr',)
    r82 = 'eth_typing'
    r83 = dank_mids.brownie_patch.call.globals :: static
    r84 = CPyImport_ImportFromMany(r82, r81, r81, r83)
    if is_error(r84) goto L220 (error at <module>:34) else goto L19
L19:
    eth_typing = r84 :: module
    dec_ref r84
    r85 = ('Address',)
    r86 = 'evmspec.data'
    r87 = dank_mids.brownie_patch.call.globals :: static
    r88 = CPyImport_ImportFromMany(r86, r85, r85, r87)
    if is_error(r88) goto L220 (error at <module>:35) else goto L20
L20:
    evmspec.data = r88 :: module
    dec_ref r88
    r89 = ('BytesLike',)
    r90 = 'hexbytes.main'
    r91 = dank_mids.brownie_patch.call.globals :: static
    r92 = CPyImport_ImportFromMany(r90, r89, r89, r91)
    if is_error(r92) goto L220 (error at <module>:36) else goto L21
L21:
    hexbytes.main = r92 :: module
    dec_ref r92
    r93 = ('MULTICALL2_ADDRESSES',)
    r94 = 'multicall.constants'
    r95 = dank_mids.brownie_patch.call.globals :: static
    r96 = CPyImport_ImportFromMany(r94, r93, r93, r95)
    if is_error(r96) goto L220 (error at <module>:37) else goto L22
L22:
    multicall.constants = r96 :: module
    dec_ref r96
    r97 = ('BlockIdentifier',)
    r98 = 'web3.types'
    r99 = dank_mids.brownie_patch.call.globals :: static
    r100 = CPyImport_ImportFromMany(r98, r97, r97, r99)
    if is_error(r100) goto L220 (error at <module>:38) else goto L23
L23:
    web3.types = r100 :: module
    dec_ref r100
    r101 = ('ENVIRONMENT_VARIABLES',)
    r102 = ('ENVS',)
    r103 = 'dank_mids'
    r104 = dank_mids.brownie_patch.call.globals :: static
    r105 = CPyImport_ImportFromMany(r103, r101, r102, r104)
    if is_error(r105) goto L220 (error at <module>:40) else goto L24
L24:
    dank_mids = r105 :: module
    dec_ref r105
    r106 = ('exceptions',)
    r107 = 'dank_mids'
    r108 = dank_mids.brownie_patch.call.globals :: static
    r109 = CPyImport_ImportFromMany(r107, r106, r106, r108)
    if is_error(r109) goto L220 (error at <module>:41) else goto L25
L25:
    dank_mids = r109 :: module
    dec_ref r109
    r110 = ('getLogger',)
    r111 = 'dank_mids._logging'
    r112 = dank_mids.brownie_patch.call.globals :: static
    r113 = CPyImport_ImportFromMany(r111, r110, r110, r112)
    if is_error(r113) goto L220 (error at <module>:42) else goto L26
L26:
    dank_mids._logging = r113 :: module
    dec_ref r113
    r114 = ('lru_cache_lite_nonull',)
    r115 = 'dank_mids.helpers.lru_cache'
    r116 = dank_mids.brownie_patch.call.globals :: static
    r117 = CPyImport_ImportFromMany(r115, r114, r114, r116)
    if is_error(r117) goto L220 (error at <module>:43) else goto L27
L27:
    dank_mids.helpers.lru_cache = r117 :: module
    dec_ref r117
    r118 = ('DankWeb3',)
    r119 = 'dank_mids.helpers._helpers'
    r120 = dank_mids.brownie_patch.call.globals :: static
    r121 = CPyImport_ImportFromMany(r119, r118, r118, r120)
    if is_error(r121) goto L220 (error at <module>:44) else goto L28
L28:
    dank_mids.helpers._helpers = r121 :: module
    dec_ref r121
    if 0 goto L29 else goto L29 :: bool
L29:
    r122 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r122) goto L30 else goto L32
L30:
    r123 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r123 goto L220 (error at <module>:50) else goto L31 :: bool
L31:
    unreachable
L32:
    r124 = 'application'
    r125 = CPyObject_GetAttr(r122, r124)
    if is_error(r125) goto L220 (error at <module>:50) else goto L33
L33:
    r126 = unbox(bool, r125)
    if is_error(r126) goto L221 (error at <module>:50) else goto L34
L34:
    dank_mids.brownie_patch.call.APPLICATION_MODE = r126 :: static
    r127 = dank_mids.brownie_patch.call.globals :: static
    r128 = 'APPLICATION_MODE'
    r129 = CPyDict_SetItem(r127, r128, r125)
    dec_ref r125
    r130 = r129 >= 0 :: signed
    if not r130 goto L220 (error at <module>:50) else goto L35 :: bool
L35:
    r131 = '_T'
    r132 = dank_mids.brownie_patch.call.globals :: static
    r133 = 'TypeVar'
    r134 = CPyDict_GetItem(r132, r133)
    if is_error(r134) goto L220 (error at <module>:53) else goto L36
L36:
    r135 = [r131]
    r136 = load_address r135
    r137 = PyObject_Vectorcall(r134, r136, 1, 0)
    dec_ref r134
    if is_error(r137) goto L220 (error at <module>:53) else goto L37
L37:
    r138 = dank_mids.brownie_patch.call.globals :: static
    r139 = '_T'
    r140 = CPyDict_SetItem(r138, r139, r137)
    dec_ref r137
    r141 = r140 >= 0 :: signed
    if not r141 goto L220 (error at <module>:53) else goto L38 :: bool
L38:
    r142 = 'TypeStr'
    r143 = load_address PyUnicode_Type
    r144 = dank_mids.brownie_patch.call.globals :: static
    r145 = 'NewType'
    r146 = CPyDict_GetItem(r144, r145)
    if is_error(r146) goto L220 (error at <module>:54) else goto L39
L39:
    r147 = [r142, r143]
    r148 = load_address r147
    r149 = PyObject_Vectorcall(r146, r148, 2, 0)
    dec_ref r146
    if is_error(r149) goto L220 (error at <module>:54) else goto L40
L40:
    r150 = dank_mids.brownie_patch.call.globals :: static
    r151 = 'TypeStr'
    r152 = CPyDict_SetItem(r150, r151, r149)
    dec_ref r149
    r153 = r152 >= 0 :: signed
    if not r153 goto L220 (error at <module>:54) else goto L41 :: bool
L41:
    r154 = dank_mids.brownie_patch.call.globals :: static
    r155 = 'List'
    r156 = CPyDict_GetItem(r154, r155)
    if is_error(r156) goto L220 (error at <module>:55) else goto L42
L42:
    r157 = dank_mids.brownie_patch.call.globals :: static
    r158 = 'TypeStr'
    r159 = CPyDict_GetItem(r157, r158)
    if is_error(r159) goto L222 (error at <module>:55) else goto L43
L43:
    r160 = PyObject_GetItem(r156, r159)
    dec_ref r156
    dec_ref r159
    if is_error(r160) goto L220 (error at <module>:55) else goto L44
L44:
    r161 = dank_mids.brownie_patch.call.globals :: static
    r162 = 'TypeStrs'
    r163 = CPyDict_SetItem(r161, r162, r160)
    dec_ref r160
    r164 = r163 >= 0 :: signed
    if not r164 goto L220 (error at <module>:55) else goto L45 :: bool
L45:
    r165 = dank_mids.brownie_patch.call.globals :: static
    r166 = 'Union'
    r167 = CPyDict_GetItem(r165, r166)
    if is_error(r167) goto L220 (error at <module>:56) else goto L46
L46:
    r168 = dank_mids.brownie_patch.call.globals :: static
    r169 = 'List'
    r170 = CPyDict_GetItem(r168, r169)
    if is_error(r170) goto L223 (error at <module>:56) else goto L47
L47:
    r171 = dank_mids.brownie_patch.call.globals :: static
    r172 = '_T'
    r173 = CPyDict_GetItem(r171, r172)
    if is_error(r173) goto L224 (error at <module>:56) else goto L48
L48:
    r174 = PyObject_GetItem(r170, r173)
    dec_ref r170
    dec_ref r173
    if is_error(r174) goto L223 (error at <module>:56) else goto L49
L49:
    r175 = dank_mids.brownie_patch.call.globals :: static
    r176 = 'Tuple'
    r177 = CPyDict_GetItem(r175, r176)
    if is_error(r177) goto L225 (error at <module>:56) else goto L50
L50:
    r178 = dank_mids.brownie_patch.call.globals :: static
    r179 = '_T'
    r180 = CPyDict_GetItem(r178, r179)
    if is_error(r180) goto L226 (error at <module>:56) else goto L51
L51:
    r181 = load_address _Py_EllipsisObject
    inc_ref r181
    r182 = (r180, r181)
    r183 = box(tuple[object, object], r182)
    r184 = PyObject_GetItem(r177, r183)
    dec_ref r177
    dec_ref r183
    if is_error(r184) goto L225 (error at <module>:56) else goto L52
L52:
    r185 = (r174, r184)
    r186 = box(tuple[object, object], r185)
    r187 = PyObject_GetItem(r167, r186)
    dec_ref r167
    dec_ref r186
    if is_error(r187) goto L220 (error at <module>:56) else goto L53
L53:
    r188 = dank_mids.brownie_patch.call.globals :: static
    r189 = 'ListOrTuple'
    r190 = CPyDict_SetItem(r188, r189, r187)
    dec_ref r187
    r191 = r190 >= 0 :: signed
    if not r191 goto L220 (error at <module>:56) else goto L54 :: bool
L54:
    r192 = 'AbiDict'
    r193 = dank_mids.brownie_patch.call.globals :: static
    r194 = 'Dict'
    r195 = CPyDict_GetItem(r193, r194)
    if is_error(r195) goto L220 (error at <module>:57) else goto L55
L55:
    r196 = load_address PyUnicode_Type
    r197 = dank_mids.brownie_patch.call.globals :: static
    r198 = 'Any'
    r199 = CPyDict_GetItem(r197, r198)
    if is_error(r199) goto L227 (error at <module>:57) else goto L56
L56:
    inc_ref r196
    r200 = (r196, r199)
    r201 = box(tuple[object, object], r200)
    r202 = PyObject_GetItem(r195, r201)
    dec_ref r195
    dec_ref r201
    if is_error(r202) goto L220 (error at <module>:57) else goto L57
L57:
    r203 = dank_mids.brownie_patch.call.globals :: static
    r204 = 'NewType'
    r205 = CPyDict_GetItem(r203, r204)
    if is_error(r205) goto L228 (error at <module>:57) else goto L58
L58:
    r206 = [r192, r202]
    r207 = load_address r206
    r208 = PyObject_Vectorcall(r205, r207, 2, 0)
    dec_ref r205
    if is_error(r208) goto L228 (error at <module>:57) else goto L59
L59:
    dec_ref r202
    r209 = dank_mids.brownie_patch.call.globals :: static
    r210 = 'AbiDict'
    r211 = CPyDict_SetItem(r209, r210, r208)
    dec_ref r208
    r212 = r211 >= 0 :: signed
    if not r212 goto L220 (error at <module>:57) else goto L60 :: bool
L60:
    r213 = decimal :: module
    r214 = 'Decimal'
    r215 = CPyObject_GetAttr(r213, r214)
    if is_error(r215) goto L220 (error at <module>:61) else goto L61
L61:
    dank_mids.brownie_patch.call.Decimal = r215 :: static
    r216 = dank_mids.brownie_patch.call.globals :: static
    r217 = 'Decimal'
    r218 = CPyDict_SetItem(r216, r217, r215)
    dec_ref r215
    r219 = r218 >= 0 :: signed
    if not r219 goto L220 (error at <module>:61) else goto L62 :: bool
L62:
    r220 = dank_mids.brownie_patch.call.globals :: static
    r221 = 'hexbytes'
    r222 = CPyDict_GetItem(r220, r221)
    if is_error(r222) goto L220 (error at <module>:62) else goto L63
L63:
    r223 = 'HexBytes'
    r224 = CPyObject_GetAttr(r222, r223)
    dec_ref r222
    if is_error(r224) goto L220 (error at <module>:62) else goto L64
L64:
    dank_mids.brownie_patch.call.HexBytes = r224 :: static
    r225 = dank_mids.brownie_patch.call.globals :: static
    r226 = 'HexBytes'
    r227 = CPyDict_SetItem(r225, r226, r224)
    dec_ref r224
    r228 = r227 >= 0 :: signed
    if not r228 goto L220 (error at <module>:62) else goto L65 :: bool
L65:
    r229 = dank_mids.brownie_patch.call.globals :: static
    r230 = 'brownie'
    r231 = CPyDict_GetItem(r229, r230)
    if is_error(r231) goto L220 (error at <module>:63) else goto L66
L66:
    r232 = 'network'
    r233 = CPyObject_GetAttr(r231, r232)
    dec_ref r231
    if is_error(r233) goto L220 (error at <module>:63) else goto L67
L67:
    r234 = 'contract'
    r235 = CPyObject_GetAttr(r233, r234)
    dec_ref r233
    if is_error(r235) goto L220 (error at <module>:63) else goto L68
L68:
    r236 = 'Contract'
    r237 = CPyObject_GetAttr(r235, r236)
    dec_ref r235
    if is_error(r237) goto L220 (error at <module>:63) else goto L69
L69:
    dank_mids.brownie_patch.call.Contract = r237 :: static
    r238 = dank_mids.brownie_patch.call.globals :: static
    r239 = 'Contract'
    r240 = CPyDict_SetItem(r238, r239, r237)
    dec_ref r237
    r241 = r240 >= 0 :: signed
    if not r241 goto L220 (error at <module>:63) else goto L70 :: bool
L70:
    r242 = dank_mids.brownie_patch.call.globals :: static
    r243 = 'brownie'
    r244 = CPyDict_GetItem(r242, r243)
    if is_error(r244) goto L220 (error at <module>:64) else goto L71
L71:
    r245 = 'convert'
    r246 = CPyObject_GetAttr(r244, r245)
    dec_ref r244
    if is_error(r246) goto L220 (error at <module>:64) else goto L72
L72:
    r247 = 'datatypes'
    r248 = CPyObject_GetAttr(r246, r247)
    dec_ref r246
    if is_error(r248) goto L220 (error at <module>:64) else goto L73
L73:
    r249 = 'ReturnValue'
    r250 = CPyObject_GetAttr(r248, r249)
    dec_ref r248
    if is_error(r250) goto L220 (error at <module>:64) else goto L74
L74:
    dank_mids.brownie_patch.call.ReturnValue = r250 :: static
    r251 = dank_mids.brownie_patch.call.globals :: static
    r252 = 'ReturnValue'
    r253 = CPyDict_SetItem(r251, r252, r250)
    dec_ref r250
    r254 = r253 >= 0 :: signed
    if not r254 goto L220 (error at <module>:64) else goto L75 :: bool
L75:
    r255 = dank_mids.brownie_patch.call.globals :: static
    r256 = 'brownie'
    r257 = CPyDict_GetItem(r255, r256)
    if is_error(r257) goto L220 (error at <module>:65) else goto L76
L76:
    r258 = 'convert'
    r259 = CPyObject_GetAttr(r257, r258)
    dec_ref r257
    if is_error(r259) goto L220 (error at <module>:65) else goto L77
L77:
    r260 = 'normalize'
    r261 = CPyObject_GetAttr(r259, r260)
    dec_ref r259
    if is_error(r261) goto L220 (error at <module>:65) else goto L78
L78:
    r262 = 'HexString'
    r263 = CPyObject_GetAttr(r261, r262)
    dec_ref r261
    if is_error(r263) goto L220 (error at <module>:65) else goto L79
L79:
    dank_mids.brownie_patch.call.HexString = r263 :: static
    r264 = dank_mids.brownie_patch.call.globals :: static
    r265 = 'HexString'
    r266 = CPyDict_SetItem(r264, r265, r263)
    dec_ref r263
    r267 = r266 >= 0 :: signed
    if not r267 goto L220 (error at <module>:65) else goto L80 :: bool
L80:
    r268 = dank_mids.brownie_patch.call.globals :: static
    r269 = 'brownie'
    r270 = CPyDict_GetItem(r268, r269)
    if is_error(r270) goto L220 (error at <module>:66) else goto L81
L81:
    r271 = 'convert'
    r272 = CPyObject_GetAttr(r270, r271)
    dec_ref r270
    if is_error(r272) goto L220 (error at <module>:66) else goto L82
L82:
    r273 = 'normalize'
    r274 = CPyObject_GetAttr(r272, r273)
    dec_ref r272
    if is_error(r274) goto L220 (error at <module>:66) else goto L83
L83:
    r275 = 'TupleType'
    r276 = CPyObject_GetAttr(r274, r275)
    dec_ref r274
    if is_error(r276) goto L220 (error at <module>:66) else goto L84
L84:
    dank_mids.brownie_patch.call.TupleType = r276 :: static
    r277 = dank_mids.brownie_patch.call.globals :: static
    r278 = 'TupleType'
    r279 = CPyDict_SetItem(r277, r278, r276)
    dec_ref r276
    r280 = r279 >= 0 :: signed
    if not r280 goto L220 (error at <module>:66) else goto L85 :: bool
L85:
    r281 = dank_mids.brownie_patch.call.globals :: static
    r282 = 'exceptions'
    r283 = CPyDict_GetItem(r281, r282)
    if is_error(r283) goto L220 (error at <module>:68) else goto L86
L86:
    r284 = 'Revert'
    r285 = CPyObject_GetAttr(r283, r284)
    dec_ref r283
    if is_error(r285) goto L220 (error at <module>:68) else goto L87
L87:
    dank_mids.brownie_patch.call.Revert = r285 :: static
    r286 = dank_mids.brownie_patch.call.globals :: static
    r287 = 'Revert'
    r288 = CPyDict_SetItem(r286, r287, r285)
    dec_ref r285
    r289 = r288 >= 0 :: signed
    if not r289 goto L220 (error at <module>:68) else goto L88 :: bool
L88:
    r290 = dank_mids.brownie_patch.call.globals :: static
    r291 = 'brownie'
    r292 = CPyDict_GetItem(r290, r291)
    if is_error(r292) goto L220 (error at <module>:70) else goto L89
L89:
    r293 = 'convert'
    r294 = CPyObject_GetAttr(r292, r293)
    dec_ref r292
    if is_error(r294) goto L220 (error at <module>:70) else goto L90
L90:
    r295 = 'normalize'
    r296 = CPyObject_GetAttr(r294, r295)
    dec_ref r294
    if is_error(r296) goto L220 (error at <module>:70) else goto L91
L91:
    r297 = 'to_bool'
    r298 = CPyObject_GetAttr(r296, r297)
    dec_ref r296
    if is_error(r298) goto L220 (error at <module>:70) else goto L92
L92:
    dank_mids.brownie_patch.call.to_bool = r298 :: static
    r299 = dank_mids.brownie_patch.call.globals :: static
    r300 = 'to_bool'
    r301 = CPyDict_SetItem(r299, r300, r298)
    dec_ref r298
    r302 = r301 >= 0 :: signed
    if not r302 goto L220 (error at <module>:70) else goto L93 :: bool
L93:
    r303 = dank_mids.brownie_patch.call.globals :: static
    r304 = 'brownie'
    r305 = CPyDict_GetItem(r303, r304)
    if is_error(r305) goto L220 (error at <module>:71) else goto L94
L94:
    r306 = 'convert'
    r307 = CPyObject_GetAttr(r305, r306)
    dec_ref r305
    if is_error(r307) goto L220 (error at <module>:71) else goto L95
L95:
    r308 = 'normalize'
    r309 = CPyObject_GetAttr(r307, r308)
    dec_ref r307
    if is_error(r309) goto L220 (error at <module>:71) else goto L96
L96:
    r310 = 'to_decimal'
    r311 = CPyObject_GetAttr(r309, r310)
    dec_ref r309
    if is_error(r311) goto L220 (error at <module>:71) else goto L97
L97:
    dank_mids.brownie_patch.call.to_decimal = r311 :: static
    r312 = dank_mids.brownie_patch.call.globals :: static
    r313 = 'to_decimal'
    r314 = CPyDict_SetItem(r312, r313, r311)
    dec_ref r311
    r315 = r314 >= 0 :: signed
    if not r315 goto L220 (error at <module>:71) else goto L98 :: bool
L98:
    r316 = dank_mids.brownie_patch.call.globals :: static
    r317 = 'brownie'
    r318 = CPyDict_GetItem(r316, r317)
    if is_error(r318) goto L220 (error at <module>:72) else goto L99
L99:
    r319 = 'convert'
    r320 = CPyObject_GetAttr(r318, r319)
    dec_ref r318
    if is_error(r320) goto L220 (error at <module>:72) else goto L100
L100:
    r321 = 'normalize'
    r322 = CPyObject_GetAttr(r320, r321)
    dec_ref r320
    if is_error(r322) goto L220 (error at <module>:72) else goto L101
L101:
    r323 = 'to_int'
    r324 = CPyObject_GetAttr(r322, r323)
    dec_ref r322
    if is_error(r324) goto L220 (error at <module>:72) else goto L102
L102:
    dank_mids.brownie_patch.call.to_int = r324 :: static
    r325 = dank_mids.brownie_patch.call.globals :: static
    r326 = 'to_int'
    r327 = CPyDict_SetItem(r325, r326, r324)
    dec_ref r324
    r328 = r327 >= 0 :: signed
    if not r328 goto L220 (error at <module>:72) else goto L103 :: bool
L103:
    r329 = dank_mids.brownie_patch.call.globals :: static
    r330 = 'brownie'
    r331 = CPyDict_GetItem(r329, r330)
    if is_error(r331) goto L220 (error at <module>:73) else goto L104
L104:
    r332 = 'convert'
    r333 = CPyObject_GetAttr(r331, r332)
    dec_ref r331
    if is_error(r333) goto L220 (error at <module>:73) else goto L105
L105:
    r334 = 'normalize'
    r335 = CPyObject_GetAttr(r333, r334)
    dec_ref r333
    if is_error(r335) goto L220 (error at <module>:73) else goto L106
L106:
    r336 = 'to_string'
    r337 = CPyObject_GetAttr(r335, r336)
    dec_ref r335
    if is_error(r337) goto L220 (error at <module>:73) else goto L107
L107:
    dank_mids.brownie_patch.call.to_string = r337 :: static
    r338 = dank_mids.brownie_patch.call.globals :: static
    r339 = 'to_string'
    r340 = CPyDict_SetItem(r338, r339, r337)
    dec_ref r337
    r341 = r340 >= 0 :: signed
    if not r341 goto L220 (error at <module>:73) else goto L108 :: bool
L108:
    r342 = dank_mids.brownie_patch.call.globals :: static
    r343 = 'brownie'
    r344 = CPyDict_GetItem(r342, r343)
    if is_error(r344) goto L220 (error at <module>:74) else goto L109
L109:
    r345 = 'convert'
    r346 = CPyObject_GetAttr(r344, r345)
    dec_ref r344
    if is_error(r346) goto L220 (error at <module>:74) else goto L110
L110:
    r347 = 'normalize'
    r348 = CPyObject_GetAttr(r346, r347)
    dec_ref r346
    if is_error(r348) goto L220 (error at <module>:74) else goto L111
L111:
    r349 = 'to_uint'
    r350 = CPyObject_GetAttr(r348, r349)
    dec_ref r348
    if is_error(r350) goto L220 (error at <module>:74) else goto L112
L112:
    dank_mids.brownie_patch.call.to_uint = r350 :: static
    r351 = dank_mids.brownie_patch.call.globals :: static
    r352 = 'to_uint'
    r353 = CPyDict_SetItem(r351, r352, r350)
    dec_ref r350
    r354 = r353 >= 0 :: signed
    if not r354 goto L220 (error at <module>:74) else goto L113 :: bool
L113:
    r355 = dank_mids.brownie_patch.call.globals :: static
    r356 = 'brownie'
    r357 = CPyDict_GetItem(r355, r356)
    if is_error(r357) goto L220 (error at <module>:75) else goto L114
L114:
    r358 = 'convert'
    r359 = CPyObject_GetAttr(r357, r358)
    dec_ref r357
    if is_error(r359) goto L220 (error at <module>:75) else goto L115
L115:
    r360 = 'normalize'
    r361 = CPyObject_GetAttr(r359, r360)
    dec_ref r359
    if is_error(r361) goto L220 (error at <module>:75) else goto L116
L116:
    r362 = '_check_array'
    r363 = CPyObject_GetAttr(r361, r362)
    dec_ref r361
    if is_error(r363) goto L220 (error at <module>:75) else goto L117
L117:
    dank_mids.brownie_patch.call._check_array = r363 :: static
    r364 = dank_mids.brownie_patch.call.globals :: static
    r365 = '_check_array'
    r366 = CPyDict_SetItem(r364, r365, r363)
    dec_ref r363
    r367 = r366 >= 0 :: signed
    if not r367 goto L220 (error at <module>:75) else goto L118 :: bool
L118:
    r368 = dank_mids.brownie_patch.call.globals :: static
    r369 = 'brownie'
    r370 = CPyDict_GetItem(r368, r369)
    if is_error(r370) goto L220 (error at <module>:76) else goto L119
L119:
    r371 = 'convert'
    r372 = CPyObject_GetAttr(r370, r371)
    dec_ref r370
    if is_error(r372) goto L220 (error at <module>:76) else goto L120
L120:
    r373 = 'normalize'
    r374 = CPyObject_GetAttr(r372, r373)
    dec_ref r372
    if is_error(r374) goto L220 (error at <module>:76) else goto L121
L121:
    r375 = '_get_abi_types'
    r376 = CPyObject_GetAttr(r374, r375)
    dec_ref r374
    if is_error(r376) goto L220 (error at <module>:76) else goto L122
L122:
    dank_mids.brownie_patch.call._get_abi_types = r376 :: static
    r377 = dank_mids.brownie_patch.call.globals :: static
    r378 = '_get_abi_types'
    r379 = CPyDict_SetItem(r377, r378, r376)
    dec_ref r376
    r380 = r379 >= 0 :: signed
    if not r380 goto L220 (error at <module>:76) else goto L123 :: bool
L123:
    r381 = dank_mids.brownie_patch.call.globals :: static
    r382 = '__name__'
    r383 = CPyDict_GetItem(r381, r382)
    if is_error(r383) goto L220 (error at <module>:79) else goto L124
L124:
    r384 = cast(str, r383)
    if is_error(r384) goto L220 (error at <module>:79) else goto L125
L125:
    r385 = dank_mids._logging.getLogger :: static
    if is_error(r385) goto L229 else goto L128
L126:
    r386 = raise NameError('value for final name "getLogger" was not set')
    if not r386 goto L220 (error at <module>:79) else goto L127 :: bool
L127:
    unreachable
L128:
    r387 = [r384]
    r388 = load_address r387
    r389 = PyObject_Vectorcall(r385, r388, 1, 0)
    if is_error(r389) goto L230 (error at <module>:79) else goto L129
L129:
    dec_ref r384
    dank_mids.brownie_patch.call.logger = r389 :: static
    r390 = dank_mids.brownie_patch.call.globals :: static
    r391 = 'logger'
    r392 = CPyDict_SetItem(r390, r391, r389)
    dec_ref r389
    r393 = r392 >= 0 :: signed
    if not r393 goto L220 (error at <module>:79) else goto L130 :: bool
L130:
    r394 = __mypyc_lambda__0_obj()
    if is_error(r394) goto L220 (error at <module>:82) else goto L131
L131:
    dank_mids.brownie_patch.call.encode = r394 :: static
    r395 = dank_mids.brownie_patch.call.globals :: static
    r396 = 'encode'
    r397 = CPyDict_SetItem(r395, r396, r394)
    dec_ref r394
    r398 = r397 >= 0 :: signed
    if not r398 goto L220 (error at <module>:82) else goto L132 :: bool
L132:
    r399 = __mypyc_lambda__1_obj()
    if is_error(r399) goto L220 (error at <module>:101) else goto L133
L133:
    dank_mids.brownie_patch.call.decode = r399 :: static
    r400 = dank_mids.brownie_patch.call.globals :: static
    r401 = 'decode'
    r402 = CPyDict_SetItem(r400, r401, r399)
    dec_ref r399
    r403 = r402 >= 0 :: signed
    if not r403 goto L220 (error at <module>:101) else goto L134 :: bool
L134:
    r404 = dank_mids.brownie_patch.call.globals :: static
    r405 = 'Address'
    r406 = CPyDict_GetItem(r404, r405)
    if is_error(r406) goto L220 (error at <module>:122) else goto L135
L135:
    r407 = 'checksum'
    r408 = CPyObject_GetAttr(r406, r407)
    dec_ref r406
    if is_error(r408) goto L220 (error at <module>:122) else goto L136
L136:
    dank_mids.brownie_patch.call.to_checksum_address = r408 :: static
    r409 = dank_mids.brownie_patch.call.globals :: static
    r410 = 'to_checksum_address'
    r411 = CPyDict_SetItem(r409, r410, r408)
    dec_ref r408
    r412 = r411 >= 0 :: signed
    if not r412 goto L220 (error at <module>:122) else goto L137 :: bool
L137:
    r413 = dank_mids.brownie_patch.call.globals :: static
    r414 = '_get_coroutine_fn'
    r415 = CPyDict_GetItem(r413, r414)
    if is_error(r415) goto L220 (error at <module>:140) else goto L138
L138:
    r416 = dank_mids.brownie_patch.call.globals :: static
    r417 = 'lru_cache_lite_nonull'
    r418 = CPyDict_GetItem(r416, r417)
    if is_error(r418) goto L231 (error at <module>:140) else goto L139
L139:
    r419 = [r415]
    r420 = load_address r419
    r421 = PyObject_Vectorcall(r418, r420, 1, 0)
    dec_ref r418
    if is_error(r421) goto L231 (error at <module>:140) else goto L140
L140:
    dec_ref r415
    r422 = dank_mids.brownie_patch.call.globals :: static
    r423 = '_get_coroutine_fn'
    r424 = CPyDict_SetItem(r422, r423, r421)
    dec_ref r421
    r425 = r424 >= 0 :: signed
    if not r425 goto L220 (error at <module>:140) else goto L141 :: bool
L141:
    r426 = dank_mids.brownie_patch.call.globals :: static
    r427 = 'eth_abi'
    r428 = CPyDict_GetItem(r426, r427)
    if is_error(r428) goto L220 (error at <module>:245) else goto L142
L142:
    r429 = 'encode'
    r430 = PyObject_HasAttr(r428, r429)
    dec_ref r428
    if r430 goto L143 else goto L146 :: bool
L143:
    r431 = dank_mids.brownie_patch.call.globals :: static
    r432 = 'eth_abi'
    r433 = CPyDict_GetItem(r431, r432)
    if is_error(r433) goto L220 (error at <module>:245) else goto L144
L144:
    r434 = 'encode'
    r435 = CPyObject_GetAttr(r433, r434)
    dec_ref r433
    if is_error(r435) goto L220 (error at <module>:245) else goto L145
L145:
    r436 = r435
    goto L149
L146:
    r437 = dank_mids.brownie_patch.call.globals :: static
    r438 = 'eth_abi'
    r439 = CPyDict_GetItem(r437, r438)
    if is_error(r439) goto L220 (error at <module>:245) else goto L147
L147:
    r440 = 'encode_abi'
    r441 = CPyObject_GetAttr(r439, r440)
    dec_ref r439
    if is_error(r441) goto L220 (error at <module>:245) else goto L148
L148:
    r436 = r441
L149:
    dank_mids.brownie_patch.call.__eth_abi_encode = r436 :: static
    r442 = dank_mids.brownie_patch.call.globals :: static
    r443 = '__eth_abi_encode'
    r444 = CPyDict_SetItem(r442, r443, r436)
    dec_ref r436
    r445 = r444 >= 0 :: signed
    if not r445 goto L220 (error at <module>:245) else goto L150 :: bool
L150:
    r446 = dank_mids.brownie_patch.call.globals :: static
    r447 = 'eth_abi'
    r448 = CPyDict_GetItem(r446, r447)
    if is_error(r448) goto L220 (error at <module>:248) else goto L151
L151:
    r449 = 'decode'
    r450 = PyObject_HasAttr(r448, r449)
    dec_ref r448
    if r450 goto L152 else goto L155 :: bool
L152:
    r451 = dank_mids.brownie_patch.call.globals :: static
    r452 = 'eth_abi'
    r453 = CPyDict_GetItem(r451, r452)
    if is_error(r453) goto L220 (error at <module>:248) else goto L153
L153:
    r454 = 'decode'
    r455 = CPyObject_GetAttr(r453, r454)
    dec_ref r453
    if is_error(r455) goto L220 (error at <module>:248) else goto L154
L154:
    r456 = r455
    goto L158
L155:
    r457 = dank_mids.brownie_patch.call.globals :: static
    r458 = 'eth_abi'
    r459 = CPyDict_GetItem(r457, r458)
    if is_error(r459) goto L220 (error at <module>:248) else goto L156
L156:
    r460 = 'decode_abi'
    r461 = CPyObject_GetAttr(r459, r460)
    dec_ref r459
    if is_error(r461) goto L220 (error at <module>:248) else goto L157
L157:
    r456 = r461
L158:
    dank_mids.brownie_patch.call.__eth_abi_decode = r456 :: static
    r462 = dank_mids.brownie_patch.call.globals :: static
    r463 = '__eth_abi_decode'
    r464 = CPyDict_SetItem(r462, r463, r456)
    dec_ref r456
    r465 = r464 >= 0 :: signed
    if not r465 goto L220 (error at <module>:248) else goto L159 :: bool
L159:
    r466 = '0xcA11bde05977b3631167028862bE2a173976CA11'
    r467 = PySet_New(0)
    if is_error(r467) goto L220 (error at <module>:261) else goto L160
L160:
    r468 = PySet_Add(r467, r466)
    r469 = r468 >= 0 :: signed
    if not r469 goto L232 (error at <module>:261) else goto L161 :: bool
L161:
    r470 = dank_mids.brownie_patch.call.globals :: static
    r471 = '_skip_proc_pool'
    r472 = CPyDict_SetItem(r470, r471, r467)
    dec_ref r467
    r473 = r472 >= 0 :: signed
    if not r473 goto L220 (error at <module>:261) else goto L162 :: bool
L162:
    if 1 goto L163 else goto L180 :: bool
L163:
    r474 = dank_mids.brownie_patch.call.globals :: static
    r475 = 'chain'
    r476 = CPyDict_GetItem(r474, r475)
    if is_error(r476) goto L166 (error at <module>:265) else goto L164
L164:
    r477 = 'id'
    r478 = CPyObject_GetAttr(r476, r477)
    dec_ref r476
    if is_error(r478) goto L166 (error at <module>:265) else goto L165
L165:
    r479 = dank_mids.brownie_patch.call.globals :: static
    r480 = 'chainid'
    r481 = CPyDict_SetItem(r479, r480, r478)
    dec_ref r478
    r482 = r481 >= 0 :: signed
    if not r482 goto L166 (error at <module>:265) else goto L180 :: bool
L166:
    r483 = CPy_CatchError()
    r484 = builtins :: module
    r485 = 'Exception'
    r486 = CPyObject_GetAttr(r484, r485)
    if is_error(r486) goto L178 (error at <module>:267) else goto L167
L167:
    r487 = CPy_ExceptionMatches(r486)
    dec_ref r486
    if r487 goto L168 else goto L175 :: bool
L168:
    r488 = dank_mids.brownie_patch.call.globals :: static
    r489 = 'e'
    r490 = CPy_GetExcValue()
    r491 = CPyDict_SetItem(r488, r489, r490)
    dec_ref r490
    r492 = r491 >= 0 :: signed
    if not r492 goto L178 (error at <module>:267) else goto L169 :: bool
L169:
    r493 = '429'
    r494 = dank_mids.brownie_patch.call.globals :: static
    r495 = 'e'
    r496 = CPyDict_GetItem(r494, r495)
    if is_error(r496) goto L178 (error at <module>:268) else goto L170
L170:
    r497 = PyObject_Str(r496)
    dec_ref r496
    if is_error(r497) goto L178 (error at <module>:268) else goto L171
L171:
    r498 = PyUnicode_Contains(r497, r493)
    dec_ref r497
    r499 = r498 >= 0 :: signed
    if not r499 goto L178 (error at <module>:268) else goto L172 :: bool
L172:
    r500 = truncate r498: i32 to builtins.bool
    r501 = r500 ^ 1
    if r501 goto L173 else goto L177 :: bool
L173:
    CPy_Reraise()
    if not 0 goto L178 else goto L233 :: bool
L174:
    unreachable
L175:
    CPy_Reraise()
    if not 0 goto L178 else goto L234 :: bool
L176:
    unreachable
L177:
    CPy_RestoreExcInfo(r483)
    dec_ref r483
    goto L162
L178:
    CPy_RestoreExcInfo(r483)
    dec_ref r483
    r502 = CPy_KeepPropagating()
    if not r502 goto L220 else goto L179 :: bool
L179:
    unreachable
L180:
    r503 = dank_mids.brownie_patch.call.globals :: static
    r504 = 'MULTICALL2_ADDRESSES'
    r505 = CPyDict_GetItem(r503, r504)
    if is_error(r505) goto L220 (error at <module>:270) else goto L181
L181:
    r506 = dank_mids.brownie_patch.call.globals :: static
    r507 = 'chainid'
    r508 = CPyDict_GetItem(r506, r507)
    if is_error(r508) goto L235 (error at <module>:270) else goto L182
L182:
    r509 = 'get'
    r510 = box(None, 1)
    r511 = [r505, r508, r510]
    r512 = load_address r511
    r513 = PyObject_VectorcallMethod(r509, r512, 9223372036854775811, 0)
    if is_error(r513) goto L236 (error at <module>:270) else goto L183
L183:
    dec_ref r505
    dec_ref r508
    r514 = dank_mids.brownie_patch.call.globals :: static
    r515 = 'multicall2'
    r516 = CPyDict_SetItem(r514, r515, r513)
    r517 = r516 >= 0 :: signed
    if not r517 goto L237 (error at <module>:270) else goto L184 :: bool
L184:
    r518 = PyObject_IsTrue(r513)
    dec_ref r513
    r519 = r518 >= 0 :: signed
    if not r519 goto L220 (error at <module>:270) else goto L185 :: bool
L185:
    r520 = truncate r518: i32 to builtins.bool
    if r520 goto L186 else goto L194 :: bool
L186:
    r521 = dank_mids.brownie_patch.call.globals :: static
    r522 = '_skip_proc_pool'
    r523 = CPyDict_GetItem(r521, r522)
    if is_error(r523) goto L220 (error at <module>:271) else goto L187
L187:
    r524 = cast(set, r523)
    if is_error(r524) goto L220 (error at <module>:271) else goto L188
L188:
    r525 = dank_mids.brownie_patch.call.globals :: static
    r526 = 'multicall2'
    r527 = CPyDict_GetItem(r525, r526)
    if is_error(r527) goto L238 (error at <module>:271) else goto L189
L189:
    r528 = dank_mids.brownie_patch.call.to_checksum_address :: static
    if is_error(r528) goto L239 else goto L192
L190:
    r529 = raise NameError('value for final name "to_checksum_address" was not set')
    if not r529 goto L220 (error at <module>:271) else goto L191 :: bool
L191:
    unreachable
L192:
    r530 = [r527]
    r531 = load_address r530
    r532 = PyObject_Vectorcall(r528, r531, 1, 0)
    if is_error(r532) goto L240 (error at <module>:271) else goto L193
L193:
    dec_ref r527
    r533 = PySet_Add(r524, r532)
    dec_ref r524
    dec_ref r532
    r534 = r533 >= 0 :: signed
    if not r534 goto L220 (error at <module>:271) else goto L194 :: bool
L194:
    r535 = dank_mids.brownie_patch.call.globals :: static
    r536 = 'format_input_but_cache_checksums'
    r537 = CPyDict_GetItem(r535, r536)
    if is_error(r537) goto L220 (error at <module>:331) else goto L195
L195:
    r538 = dank_mids.brownie_patch.call.globals :: static
    r539 = 'brownie'
    r540 = CPyDict_GetItem(r538, r539)
    if is_error(r540) goto L241 (error at <module>:331) else goto L196
L196:
    r541 = 'network'
    r542 = CPyObject_GetAttr(r540, r541)
    dec_ref r540
    if is_error(r542) goto L241 (error at <module>:331) else goto L197
L197:
    r543 = 'contract'
    r544 = CPyObject_GetAttr(r542, r543)
    dec_ref r542
    if is_error(r544) goto L241 (error at <module>:331) else goto L198
L198:
    r545 = 'format_input'
    r546 = PyObject_SetAttr(r544, r545, r537)
    dec_ref r544
    dec_ref r537
    r547 = r546 >= 0 :: signed
    if not r547 goto L220 (error at <module>:331) else goto L199 :: bool
L199:
    r548 = dank_mids.brownie_patch.call.globals :: static
    r549 = 'format_output_but_cache_checksums'
    r550 = CPyDict_GetItem(r548, r549)
    if is_error(r550) goto L220 (error at <module>:332) else goto L200
L200:
    r551 = dank_mids.brownie_patch.call.globals :: static
    r552 = 'brownie'
    r553 = CPyDict_GetItem(r551, r552)
    if is_error(r553) goto L242 (error at <module>:332) else goto L201
L201:
    r554 = 'network'
    r555 = CPyObject_GetAttr(r553, r554)
    dec_ref r553
    if is_error(r555) goto L242 (error at <module>:332) else goto L202
L202:
    r556 = 'contract'
    r557 = CPyObject_GetAttr(r555, r556)
    dec_ref r555
    if is_error(r557) goto L242 (error at <module>:332) else goto L203
L203:
    r558 = 'format_output'
    r559 = PyObject_SetAttr(r557, r558, r550)
    dec_ref r557
    dec_ref r550
    r560 = r559 >= 0 :: signed
    if not r560 goto L220 (error at <module>:332) else goto L204 :: bool
L204:
    r561 = dank_mids.brownie_patch.call.globals :: static
    r562 = '_format_array_but_cache_checksums'
    r563 = CPyDict_GetItem(r561, r562)
    if is_error(r563) goto L220 (error at <module>:389) else goto L205
L205:
    r564 = dank_mids.brownie_patch.call.globals :: static
    r565 = 'brownie'
    r566 = CPyDict_GetItem(r564, r565)
    if is_error(r566) goto L243 (error at <module>:389) else goto L206
L206:
    r567 = 'convert'
    r568 = CPyObject_GetAttr(r566, r567)
    dec_ref r566
    if is_error(r568) goto L243 (error at <module>:389) else goto L207
L207:
    r569 = 'normalize'
    r570 = CPyObject_GetAttr(r568, r569)
    dec_ref r568
    if is_error(r570) goto L243 (error at <module>:389) else goto L208
L208:
    r571 = '_format_array'
    r572 = PyObject_SetAttr(r570, r571, r563)
    dec_ref r570
    dec_ref r563
    r573 = r572 >= 0 :: signed
    if not r573 goto L220 (error at <module>:389) else goto L209 :: bool
L209:
    r574 = dank_mids.brownie_patch.call.globals :: static
    r575 = '_format_single_but_cache_checksums'
    r576 = CPyDict_GetItem(r574, r575)
    if is_error(r576) goto L220 (error at <module>:390) else goto L210
L210:
    r577 = dank_mids.brownie_patch.call.globals :: static
    r578 = 'brownie'
    r579 = CPyDict_GetItem(r577, r578)
    if is_error(r579) goto L244 (error at <module>:390) else goto L211
L211:
    r580 = 'convert'
    r581 = CPyObject_GetAttr(r579, r580)
    dec_ref r579
    if is_error(r581) goto L244 (error at <module>:390) else goto L212
L212:
    r582 = 'normalize'
    r583 = CPyObject_GetAttr(r581, r582)
    dec_ref r581
    if is_error(r583) goto L244 (error at <module>:390) else goto L213
L213:
    r584 = '_format_single'
    r585 = PyObject_SetAttr(r583, r584, r576)
    dec_ref r583
    dec_ref r576
    r586 = r585 >= 0 :: signed
    if not r586 goto L220 (error at <module>:390) else goto L214 :: bool
L214:
    r587 = dank_mids.brownie_patch.call.globals :: static
    r588 = '_format_tuple_but_cache_checksums'
    r589 = CPyDict_GetItem(r587, r588)
    if is_error(r589) goto L220 (error at <module>:391) else goto L215
L215:
    r590 = dank_mids.brownie_patch.call.globals :: static
    r591 = 'brownie'
    r592 = CPyDict_GetItem(r590, r591)
    if is_error(r592) goto L245 (error at <module>:391) else goto L216
L216:
    r593 = 'convert'
    r594 = CPyObject_GetAttr(r592, r593)
    dec_ref r592
    if is_error(r594) goto L245 (error at <module>:391) else goto L217
L217:
    r595 = 'normalize'
    r596 = CPyObject_GetAttr(r594, r595)
    dec_ref r594
    if is_error(r596) goto L245 (error at <module>:391) else goto L218
L218:
    r597 = '_format_tuple'
    r598 = PyObject_SetAttr(r596, r597, r589)
    dec_ref r596
    dec_ref r589
    r599 = r598 >= 0 :: signed
    if not r599 goto L220 (error at <module>:391) else goto L219 :: bool
L219:
    return 1
L220:
    r600 = <error> :: None
    return r600
L221:
    dec_ref r125
    goto L220
L222:
    dec_ref r156
    goto L220
L223:
    dec_ref r167
    goto L220
L224:
    dec_ref r167
    dec_ref r170
    goto L220
L225:
    dec_ref r167
    dec_ref r174
    goto L220
L226:
    dec_ref r167
    dec_ref r174
    dec_ref r177
    goto L220
L227:
    dec_ref r195
    goto L220
L228:
    dec_ref r202
    goto L220
L229:
    dec_ref r384
    goto L126
L230:
    dec_ref r384
    goto L220
L231:
    dec_ref r415
    goto L220
L232:
    dec_ref r467
    goto L220
L233:
    dec_ref r483
    goto L174
L234:
    dec_ref r483
    goto L176
L235:
    dec_ref r505
    goto L220
L236:
    dec_ref r505
    dec_ref r508
    goto L220
L237:
    dec_ref r513
    goto L220
L238:
    dec_ref r524
    goto L220
L239:
    dec_ref r524
    dec_ref r527
    goto L190
L240:
    dec_ref r524
    dec_ref r527
    goto L220
L241:
    dec_ref r537
    goto L220
L242:
    dec_ref r550
    goto L220
L243:
    dec_ref r563
    goto L220
L244:
    dec_ref r576
    goto L220
L245:
    dec_ref r589
    goto L220

def get_len(method):
    method, r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: object
    r4, r5, r6 :: bit
    r7 :: set
    r8 :: i32
    r9 :: bit
    r10 :: bool
    r11 :: str
    r12 :: i32
    r13 :: bit
    r14 :: bool
    r15 :: int
L0:
    r0 = 'eth_getTransactionReceipt'
    r1 = PyUnicode_Compare(method, r0)
    r2 = r1 == -1
    if r2 goto L1 else goto L3 :: bool
L1:
    r3 = PyErr_Occurred()
    r4 = r3 != 0
    if r4 goto L2 else goto L3 :: bool
L2:
    r5 = CPy_KeepPropagating()
    if not r5 goto L11 (error at get_len:16) else goto L3 :: bool
L3:
    r6 = r1 == 0
    if r6 goto L4 else goto L5 :: bool
L4:
    return 10
L5:
    r7 = frozenset({'eth_getCode', 'eth_getTransaction'})
    r8 = PySet_Contains(r7, method)
    r9 = r8 >= 0 :: signed
    if not r9 goto L11 (error at get_len:18) else goto L6 :: bool
L6:
    r10 = truncate r8: i32 to builtins.bool
    if r10 goto L9 else goto L7 :: bool
L7:
    r11 = 'eth_getBlockBy'
    r12 = PyUnicode_Contains(method, r11)
    r13 = r12 >= 0 :: signed
    if not r13 goto L11 (error at get_len:18) else goto L8 :: bool
L8:
    r14 = truncate r12: i32 to builtins.bool
    if r14 goto L9 else goto L10 :: bool
L9:
    return 6
L10:
    return 2
L11:
    r15 = <error> :: int
    return r15

def should_batch(method):
    method :: str
    r0 :: bool
    r1 :: tuple[str, str, str, str]
    r2 :: bool
    r3, r4, r5 :: object
    r6 :: str
    r7 :: i32
    r8 :: bit
    r9, r10, r11 :: bool
    r12 :: bit
    r13 :: bool
L0:
    r0 = 1
    r1 = dank_mids.helpers.method.BYPASS_METHODS :: static
    if is_error(r1) goto L1 else goto L3
L1:
    r2 = raise NameError('value for final name "BYPASS_METHODS" was not set')
    if not r2 goto L11 (error at should_batch:25) else goto L2 :: bool
L2:
    unreachable
L3:
    inc_ref r1
    r3 = box(tuple[str, str, str, str], r1)
    r4 = PyObject_GetIter(r3)
    dec_ref r3
    if is_error(r4) goto L11 (error at should_batch:25) else goto L4
L4:
    r5 = PyIter_Next(r4)
    if is_error(r5) goto L12 else goto L5
L5:
    r6 = cast(str, r5)
    if is_error(r6) goto L13 (error at should_batch:25) else goto L6
L6:
    r7 = PyUnicode_Contains(method, r6)
    dec_ref r6
    r8 = r7 >= 0 :: signed
    if not r8 goto L13 (error at should_batch:25) else goto L7 :: bool
L7:
    r9 = truncate r7: i32 to builtins.bool
    r10 = r9 ^ 1
    r11 = r10 ^ 1
    if r11 goto L14 else goto L4 :: bool
L8:
    r0 = 0
    goto L10
L9:
    r12 = CPy_NoErrOccurred()
    if not r12 goto L11 (error at should_batch:25) else goto L10 :: bool
L10:
    return r0
L11:
    r13 = <error> :: bool
    return r13
L12:
    dec_ref r4
    goto L9
L13:
    dec_ref r4
    goto L11
L14:
    dec_ref r4
    goto L8

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13, r14, r15, r16 :: str
    r17 :: tuple[str, str, str, str]
    r18 :: dict
    r19 :: str
    r20 :: object
    r21 :: i32
    r22 :: bit
    r23 :: dict
    r24 :: str
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: object
    r29 :: object[1]
    r30 :: object_ptr
    r31 :: object
    r32 :: dict
    r33 :: str
    r34 :: i32
    r35 :: bit
    r36 :: dict
    r37 :: str
    r38 :: object
    r39 :: dict
    r40 :: str
    r41 :: object
    r42 :: object[1]
    r43 :: object_ptr
    r44 :: object
    r45 :: dict
    r46 :: str
    r47 :: i32
    r48 :: bit
    r49 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L15 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = dank_mids.helpers.method.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L15 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('lru_cache_lite_nonull',)
    r10 = 'dank_mids.helpers.lru_cache'
    r11 = dank_mids.helpers.method.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L15 (error at <module>:3) else goto L5
L5:
    dank_mids.helpers.lru_cache = r12 :: module
    dec_ref r12
    r13 = 'eth_blockNumber'
    r14 = 'eth_getLogs'
    r15 = 'trace_'
    r16 = 'debug_'
    inc_ref r13
    inc_ref r14
    inc_ref r15
    inc_ref r16
    r17 = (r13, r14, r15, r16)
    dank_mids.helpers.method.BYPASS_METHODS = r17 :: static
    r18 = dank_mids.helpers.method.globals :: static
    r19 = 'BYPASS_METHODS'
    r20 = box(tuple[str, str, str, str], r17)
    r21 = CPyDict_SetItem(r18, r19, r20)
    dec_ref r20
    r22 = r21 >= 0 :: signed
    if not r22 goto L15 (error at <module>:6) else goto L6 :: bool
L6:
    r23 = dank_mids.helpers.method.globals :: static
    r24 = 'get_len'
    r25 = CPyDict_GetItem(r23, r24)
    if is_error(r25) goto L15 (error at <module>:13) else goto L7
L7:
    r26 = dank_mids.helpers.method.globals :: static
    r27 = 'lru_cache_lite_nonull'
    r28 = CPyDict_GetItem(r26, r27)
    if is_error(r28) goto L16 (error at <module>:13) else goto L8
L8:
    r29 = [r25]
    r30 = load_address r29
    r31 = PyObject_Vectorcall(r28, r30, 1, 0)
    dec_ref r28
    if is_error(r31) goto L16 (error at <module>:13) else goto L9
L9:
    dec_ref r25
    r32 = dank_mids.helpers.method.globals :: static
    r33 = 'get_len'
    r34 = CPyDict_SetItem(r32, r33, r31)
    dec_ref r31
    r35 = r34 >= 0 :: signed
    if not r35 goto L15 (error at <module>:13) else goto L10 :: bool
L10:
    r36 = dank_mids.helpers.method.globals :: static
    r37 = 'should_batch'
    r38 = CPyDict_GetItem(r36, r37)
    if is_error(r38) goto L15 (error at <module>:23) else goto L11
L11:
    r39 = dank_mids.helpers.method.globals :: static
    r40 = 'lru_cache_lite_nonull'
    r41 = CPyDict_GetItem(r39, r40)
    if is_error(r41) goto L17 (error at <module>:23) else goto L12
L12:
    r42 = [r38]
    r43 = load_address r42
    r44 = PyObject_Vectorcall(r41, r43, 1, 0)
    dec_ref r41
    if is_error(r44) goto L17 (error at <module>:23) else goto L13
L13:
    dec_ref r38
    r45 = dank_mids.helpers.method.globals :: static
    r46 = 'should_batch'
    r47 = CPyDict_SetItem(r45, r46, r44)
    dec_ref r44
    r48 = r47 >= 0 :: signed
    if not r48 goto L15 (error at <module>:23) else goto L14 :: bool
L14:
    return 1
L15:
    r49 = <error> :: None
    return r49
L16:
    dec_ref r25
    goto L15
L17:
    dec_ref r38
    goto L15

def _create_named_task(awaitable):
    awaitable, r0 :: object
    r1 :: str
    r2 :: object
    r3, r4, r5 :: str
    r6 :: object
    r7 :: bool
    r8 :: object[2]
    r9 :: object_ptr
    r10, r11, r12 :: object
L0:
    r0 = PyObject_Type(awaitable)
    r1 = '__name__'
    r2 = CPyObject_GetAttr(r0, r1)
    dec_ref r0
    if is_error(r2) goto L8 (error at _create_named_task:35) else goto L1
L1:
    r3 = cast(str, r2)
    if is_error(r3) goto L8 (error at _create_named_task:35) else goto L2
L2:
    r4 = ' via DankBatch'
    r5 = CPyStr_Build(2, r3, r4)
    dec_ref r3
    if is_error(r5) goto L8 (error at _create_named_task:35) else goto L3
L3:
    r6 = dank_mids._batch.create_task :: static
    if is_error(r6) goto L9 else goto L6
L4:
    r7 = raise NameError('value for final name "create_task" was not set')
    if not r7 goto L8 (error at _create_named_task:35) else goto L5 :: bool
L5:
    unreachable
L6:
    r8 = [awaitable, r5]
    r9 = load_address r8
    r10 = ('name',)
    r11 = PyObject_Vectorcall(r6, r9, 1, r10)
    if is_error(r11) goto L10 (error at _create_named_task:35) else goto L7
L7:
    dec_ref r5
    return r11
L8:
    r12 = <error> :: object
    return r12
L9:
    dec_ref r5
    goto L4
L10:
    dec_ref r5
    goto L8

def DankBatch.__init__(self, controller, multicalls, rpc_calls):
    self :: dank_mids._batch.DankBatch
    controller :: object
    multicalls :: dict
    rpc_calls :: object
    r0 :: str
    r1 :: object
    r2 :: str
    r3, r4, r5 :: object
    r6 :: i32
    r7 :: bit
    r8 :: bool
    r9, r10 :: object
    r11 :: None
L0:
    inc_ref controller
    self.controller = controller
    inc_ref multicalls
    self.multicalls = multicalls
    inc_ref rpc_calls
    self.rpc_calls = rpc_calls
    self._awaited = 0
    r0 = 'batcher'
    r1 = CPyObject_GetAttr(controller, r0)
    if is_error(r1) goto L8 (error at __init__:74) else goto L1
L1:
    r2 = 'step'
    r3 = CPyObject_GetAttr(r1, r2)
    dec_ref r1
    if is_error(r3) goto L8 (error at __init__:74) else goto L2
L2:
    r4 = object 0
    r5 = PyObject_RichCompare(r3, r4, 0)
    if is_error(r5) goto L9 (error at __init__:74) else goto L3
L3:
    r6 = PyObject_IsTrue(r5)
    dec_ref r5
    r7 = r6 >= 0 :: signed
    if not r7 goto L9 (error at __init__:74) else goto L4 :: bool
L4:
    r8 = truncate r6: i32 to builtins.bool
    if r8 goto L5 else goto L10 :: bool
L5:
    r9 = r3
    goto L7
L6:
    r10 = object 0
    inc_ref r10
    r9 = r10
L7:
    self._check_len = r9
    return 1
L8:
    r11 = <error> :: None
    return r11
L9:
    dec_ref r3
    goto L8
L10:
    dec_ref r3
    goto L6

def DankBatch.__repr__(self):
    self :: dank_mids._batch.DankBatch
    r0 :: str
    r1 :: int
    r2 :: object
    r3 :: str
    r4, r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8 :: object
    r9, r10, r11, r12 :: str
L0:
    r0 = '<dank_mids.DankBatch object at '
    r1 = CPyTagged_Id(self)
    r2 = builtins :: module
    r3 = 'hex'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L6 (error at __repr__:77) else goto L1
L1:
    r5 = box(int, r1)
    r6 = [r5]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r4, r7, 1, 0)
    dec_ref r4
    if is_error(r8) goto L7 (error at __repr__:77) else goto L2
L2:
    dec_ref r5
    r9 = cast(str, r8)
    if is_error(r9) goto L5 (error at __repr__:77) else goto L3
L3:
    r10 = '>'
    r11 = CPyStr_Build(3, r0, r9, r10)
    dec_ref r9
    if is_error(r11) goto L5 (error at __repr__:77) else goto L4
L4:
    return r11
L5:
    r12 = <error> :: str
    return r12
L6:
    dec_ref r1 :: int
    goto L5
L7:
    dec_ref r5
    goto L5

def DankBatch.__await__(self):
    self :: dank_mids._batch.DankBatch
    r0 :: bool
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8 :: bool
    r9 :: dict
    r10 :: short_int
    r11 :: native_int
    r12 :: short_int
    r13 :: object
    r14 :: tuple[bool, short_int, object]
    r15 :: short_int
    r16 :: bool
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[3]
    r21 :: object_ptr
    r22, r23 :: object
    r24, r25 :: bit
    r26, r27, r28 :: object
    r29 :: str
    r30 :: i32
    r31, r32 :: bit
    r33 :: object
    r34 :: str
    r35 :: object[1]
    r36 :: object_ptr
    r37, r38 :: object
L0:
    r0 = self._awaited
    if r0 goto L1 else goto L5 :: bool
L1:
    r1 = 'The batch has already been awaited'
    r2 = builtins :: module
    r3 = 'RuntimeError'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L18 (error at __await__:94) else goto L2
L2:
    r5 = [r1]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r4, r6, 1, 0)
    dec_ref r4
    if is_error(r7) goto L18 (error at __await__:94) else goto L3
L3:
    CPy_Raise(r7)
    dec_ref r7
    if not 0 goto L18 (error at __await__:94) else goto L4 :: bool
L4:
    unreachable
L5:
    self._awaited = 1
    r9 = self.multicalls
    r10 = 0
    r11 = PyDict_Size(r9)
    r12 = r11 << 1
    r13 = CPyDict_GetValuesIter(r9)
    if is_error(r13) goto L19 (error at __await__:96) else goto L6
L6:
    r14 = CPyDict_NextValue(r13, r10)
    r15 = r14[1]
    r10 = r15
    r16 = r14[0]
    if r16 goto L7 else goto L20 :: bool
L7:
    r17 = r14[2]
    dec_ref r14
    r18 = 'start'
    r19 = box(bool, 0)
    r20 = [r17, self, r19]
    r21 = load_address r20
    r22 = ('cleanup',)
    r23 = PyObject_VectorcallMethod(r18, r21, 9223372036854775810, r22)
    if is_error(r23) goto L21 (error at __await__:97) else goto L22
L8:
    dec_ref r17
L9:
    r24 = CPyDict_CheckSize(r9, r12)
    if not r24 goto L23 (error at __await__:96) else goto L6 :: bool
L10:
    r25 = CPy_NoErrOccurred()
    if not r25 goto L18 (error at __await__:96) else goto L11 :: bool
L11:
    r26 = self.rpc_calls
    r27 = PyObject_GetIter(r26)
    dec_ref r26
    if is_error(r27) goto L18 (error at __await__:98) else goto L12
L12:
    r28 = PyIter_Next(r27)
    if is_error(r28) goto L24 else goto L13
L13:
    r29 = '_batch'
    r30 = PyObject_SetAttr(r28, r29, self)
    dec_ref r28
    r31 = r30 >= 0 :: signed
    if not r31 goto L25 (error at __await__:99) else goto L12 :: bool
L14:
    r32 = CPy_NoErrOccurred()
    if not r32 goto L18 (error at __await__:98) else goto L15 :: bool
L15:
    r33 = self._await()
    if is_error(r33) goto L18 (error at __await__:100) else goto L16
L16:
    r34 = '__await__'
    r35 = [r33]
    r36 = load_address r35
    r37 = PyObject_VectorcallMethod(r34, r36, 9223372036854775809, 0)
    if is_error(r37) goto L26 (error at __await__:100) else goto L17
L17:
    dec_ref r33
    return r37
L18:
    r38 = <error> :: object
    return r38
L19:
    dec_ref r9
    goto L18
L20:
    dec_ref r9
    dec_ref r13
    dec_ref r14
    goto L10
L21:
    dec_ref r9
    dec_ref r13
    dec_ref r17
    goto L18
L22:
    dec_ref r23
    goto L8
L23:
    dec_ref r9
    dec_ref r13
    goto L18
L24:
    dec_ref r27
    goto L14
L25:
    dec_ref r27
    goto L18
L26:
    dec_ref r33
    goto L18

def _await_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    type, value, traceback, arg, r0, r1, r2, r3 :: object
    r4 :: dank_mids._batch._await_DankBatch_env
    r5 :: int
    r6 :: object
    r7 :: bit
    r8 :: dank_mids._batch.DankBatch
    r9 :: object
    r10 :: list
    r11 :: bool
    r12 :: object
    r13 :: bool
    r14 :: list
    r15, r16 :: bool
    r17 :: list
    r18 :: ptr
    r19 :: native_int
    r20 :: list
    r21, r22 :: bool
    r23 :: list
    r24 :: ptr
    r25 :: native_int
    r26, r27 :: short_int
    r28 :: bit
    r29 :: list
    r30 :: short_int
    r31 :: native_int
    r32, r33 :: ptr
    r34 :: native_int
    r35 :: ptr
    r36 :: object
    r37 :: bool
    r38 :: short_int
    r39, r40 :: object
    r41 :: bit
    r42, r43 :: short_int
    r44, r45, r46 :: bool
    r47 :: list
    r48 :: ptr
    r49 :: native_int
    r50, r51 :: short_int
    r52 :: bit
    r53 :: list
    r54 :: ptr
    r55 :: native_int
    r56, r57 :: short_int
    r58 :: bit
    r59 :: list
    r60 :: short_int
    r61 :: native_int
    r62, r63 :: ptr
    r64 :: native_int
    r65 :: ptr
    r66 :: object
    r67 :: bool
    r68 :: list
    r69 :: short_int
    r70 :: native_int
    r71, r72 :: ptr
    r73 :: native_int
    r74 :: ptr
    r75 :: object
    r76 :: bool
    r77, r78 :: object
    r79 :: bool
    r80, r81, r82, r83, r84 :: object
    r85 :: bool
    r86 :: object
    r87 :: bit
    r88 :: tuple[object, object, object]
    r89 :: bool
    r90 :: object_ptr
    r91 :: object
    r92 :: bool
    r93, r94, r95 :: tuple[object, object, object]
    r96 :: bit
    r97, r98, r99 :: object
    r100 :: tuple[object, object, object]
    r101 :: bool
    r102 :: object
    r103 :: str
    r104 :: object
    r105 :: bit
    r106 :: object
    r107 :: bool
    r108, r109 :: object
    r110 :: ptr
    r111 :: object
    r112 :: bit
    r113 :: object
    r114 :: bool
    r115, r116 :: object
    r117 :: None
    r118 :: object
    r119 :: bool
    r120, r121 :: tuple[object, object, object]
    r122 :: bit
    r123, r124 :: short_int
    r125 :: bool
    r126, r127 :: short_int
    r128 :: bool
    r129 :: union[object, None]
    r130 :: object
    r131 :: bit
    r132 :: union[object, None]
    r133 :: object
    r134 :: bool
    r135, r136, r137, r138, r139 :: object
    r140 :: bool
    r141 :: object
    r142 :: bit
    r143 :: tuple[object, object, object]
    r144 :: bool
    r145 :: object_ptr
    r146 :: object
    r147 :: bool
    r148, r149, r150 :: tuple[object, object, object]
    r151 :: bit
    r152, r153, r154, r155 :: object
    r156 :: bool
    r157, r158, r159 :: bit
    r160 :: bool
    r161 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = __mypyc_self__.__mypyc_env__
    if is_error(r4) goto L139 (error at _await:102) else goto L1
L1:
    r5 = r4.__mypyc_next_label__
    if is_error(r5) goto L140 (error at _await:102) else goto L133
L2:
    r6 = load_address _Py_NoneStruct
    r7 = type != r6
    if r7 goto L141 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L138 (error at _await:102) else goto L4 :: bool
L4:
    unreachable
L5:
    r8 = r4.self
    if is_error(r8) goto L140 (error at _await:114) else goto L6
L6:
    r9 = r8.coroutines
    dec_ref r8
    if is_error(r9) goto L140 (error at _await:114) else goto L7
L7:
    r10 = PySequence_List(r9)
    dec_ref r9
    if is_error(r10) goto L140 (error at _await:114) else goto L8
L8:
    r4.batches = r10; r11 = is_error
    if not r11 goto L140 (error at _await:114) else goto L9 :: bool
L9:
    r12 = box(None, 1)
    inc_ref r12
    r4.last_failure = r12; r13 = is_error
    if not r13 goto L140 (error at _await:116) else goto L10 :: bool
L10:
    r14 = r4.batches
    if is_error(r14) goto L140 (error at _await:117) else goto L11
L11:
    r4.__mypyc_temp__0 = r14; r15 = is_error
    if not r15 goto L140 (error at _await:-1) else goto L12 :: bool
L12:
    r4.__mypyc_temp__1 = 0; r16 = is_error
    if not r16 goto L140 (error at _await:-1) else goto L13 :: bool
L13:
    r17 = r4.batches
    if is_error(r17) goto L140 (error at _await:117) else goto L14
L14:
    r18 = get_element_ptr r17 ob_size :: PyVarObject
    r19 = load_mem r18 :: native_int*
    r20 = PyList_New(r19)
    if is_error(r20) goto L142 (error at _await:117) else goto L15
L15:
    r4.__mypyc_temp__2 = r17; r21 = is_error
    if not r21 goto L143 (error at _await:-1) else goto L16 :: bool
L16:
    r4.__mypyc_temp__3 = 0; r22 = is_error
    if not r22 goto L143 (error at _await:-1) else goto L17 :: bool
L17:
    r23 = r4.__mypyc_temp__2
    if is_error(r23) goto L143 (error at _await:117) else goto L18
L18:
    r24 = get_element_ptr r23 ob_size :: PyVarObject
    r25 = load_mem r24 :: native_int*
    dec_ref r23
    r26 = r25 << 1
    r27 = r4.__mypyc_temp__3
    if is_error(r27) goto L143 (error at _await:117) else goto L19
L19:
    r28 = r27 < r26 :: signed
    if r28 goto L20 else goto L29 :: bool
L20:
    r29 = r4.__mypyc_temp__2
    if is_error(r29) goto L143 (error at _await:117) else goto L21
L21:
    r30 = r4.__mypyc_temp__3
    if is_error(r30) goto L144 (error at _await:117) else goto L22
L22:
    r31 = r30 >> 1
    r32 = get_element_ptr r29 ob_item :: PyListObject
    r33 = load_mem r32 :: ptr*
    r34 = r31 * 8
    r35 = r33 + r34
    r36 = load_mem r35 :: builtins.object*
    inc_ref r36
    dec_ref r29
    r4.coro = r36; r37 = is_error
    if not r37 goto L143 (error at _await:117) else goto L23 :: bool
L23:
    r38 = r4.__mypyc_temp__3
    if is_error(r38) goto L143 (error at _await:-1) else goto L24
L24:
    r39 = r4.coro
    if is_error(r39) goto L143 (error at _await:117) else goto L25
L25:
    r40 = _create_named_task(r39)
    dec_ref r39
    if is_error(r40) goto L143 (error at _await:117) else goto L26
L26:
    r41 = CPyList_SetItemUnsafe(r20, r38, r40)
    if not r41 goto L143 (error at _await:117) else goto L27 :: bool
L27:
    r42 = r4.__mypyc_temp__3
    if is_error(r42) goto L143 (error at _await:117) else goto L28
L28:
    r43 = r42 + 2
    r4.__mypyc_temp__3 = r43; r44 = is_error
    if not r44 goto L143 (error at _await:117) else goto L17 :: bool
L29:
    r4.__mypyc_temp__4 = r20; r45 = is_error
    if not r45 goto L140 (error at _await:-1) else goto L30 :: bool
L30:
    r4.__mypyc_temp__5 = 0; r46 = is_error
    if not r46 goto L140 (error at _await:-1) else goto L31 :: bool
L31:
    r47 = r4.__mypyc_temp__0
    if is_error(r47) goto L140 (error at _await:117) else goto L32
L32:
    r48 = get_element_ptr r47 ob_size :: PyVarObject
    r49 = load_mem r48 :: native_int*
    dec_ref r47
    r50 = r49 << 1
    r51 = r4.__mypyc_temp__1
    if is_error(r51) goto L140 (error at _await:117) else goto L33
L33:
    r52 = r51 < r50 :: signed
    if r52 goto L34 else goto L145 :: bool
L34:
    r53 = r4.__mypyc_temp__4
    if is_error(r53) goto L140 (error at _await:117) else goto L35
L35:
    r54 = get_element_ptr r53 ob_size :: PyVarObject
    r55 = load_mem r54 :: native_int*
    dec_ref r53
    r56 = r55 << 1
    r57 = r4.__mypyc_temp__5
    if is_error(r57) goto L140 (error at _await:117) else goto L36
L36:
    r58 = r57 < r56 :: signed
    if r58 goto L37 else goto L145 :: bool
L37:
    r59 = r4.__mypyc_temp__0
    if is_error(r59) goto L140 (error at _await:117) else goto L38
L38:
    r60 = r4.__mypyc_temp__1
    if is_error(r60) goto L146 (error at _await:117) else goto L39
L39:
    r61 = r60 >> 1
    r62 = get_element_ptr r59 ob_item :: PyListObject
    r63 = load_mem r62 :: ptr*
    r64 = r61 * 8
    r65 = r63 + r64
    r66 = load_mem r65 :: builtins.object*
    inc_ref r66
    dec_ref r59
    r4.batch = r66; r67 = is_error
    if not r67 goto L140 (error at _await:117) else goto L40 :: bool
L40:
    r68 = r4.__mypyc_temp__4
    if is_error(r68) goto L140 (error at _await:117) else goto L41
L41:
    r69 = r4.__mypyc_temp__5
    if is_error(r69) goto L147 (error at _await:117) else goto L42
L42:
    r70 = r69 >> 1
    r71 = get_element_ptr r68 ob_item :: PyListObject
    r72 = load_mem r71 :: ptr*
    r73 = r70 * 8
    r74 = r72 + r73
    r75 = load_mem r74 :: builtins.object*
    inc_ref r75
    dec_ref r68
    r4.task = r75; r76 = is_error
    if not r76 goto L140 (error at _await:117) else goto L43 :: bool
L43:
    r77 = r4.task
    if is_error(r77) goto L73 (error at _await:119) else goto L44
L44:
    r78 = CPy_GetCoro(r77)
    dec_ref r77
    if is_error(r78) goto L73 (error at _await:119) else goto L45
L45:
    r4.__mypyc_temp__6 = r78; r79 = is_error
    if not r79 goto L73 (error at _await:-1) else goto L46 :: bool
L46:
    r80 = r4.__mypyc_temp__6
    if is_error(r80) goto L73 (error at _await:-1) else goto L47
L47:
    r81 = CPyIter_Next(r80)
    dec_ref r80
    if is_error(r81) goto L48 else goto L50
L48:
    r82 = CPy_FetchStopIterationValue()
    if is_error(r82) goto L73 (error at _await:119) else goto L49
L49:
    r83 = r82
    dec_ref r83
    goto L94
L50:
    r84 = r81
L51:
    r4.__mypyc_next_label__ = 2; r85 = is_error
    if not r85 goto L148 (error at _await:119) else goto L149 :: bool
L52:
    return r84
L53:
    r86 = load_address _Py_NoneStruct
    r87 = type != r86
    if r87 goto L54 else goto L56 :: bool
L54:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L57 (error at _await:119) else goto L150 :: bool
L55:
    unreachable
L56:
    inc_ref arg
    goto L68
L57:
    r88 = CPy_CatchError()
    r4.__mypyc_temp__7 = r88; r89 = is_error
    if not r89 goto L65 (error at _await:-1) else goto L58 :: bool
L58:
    r90 = load_address r1
    r91 = r4.__mypyc_temp__6
    if is_error(r91) goto L65 (error at _await:-1) else goto L59
L59:
    r92 = CPy_YieldFromErrorHandle(r91, r90)
    dec_ref r91
    if is_error(r92) goto L65 (error at _await:119) else goto L60
L60:
    if r92 goto L63 else goto L61 :: bool
L61:
    inc_ref r1
    r84 = r1
    r93 = r4.__mypyc_temp__7
    if is_error(r93) goto L151 (error at _await:-1) else goto L62
L62:
    CPy_RestoreExcInfo(r93)
    dec_ref r93
    goto L51
L63:
    inc_ref r1
    r83 = r1
    dec_ref r83
    r94 = r4.__mypyc_temp__7
    if is_error(r94) goto L65 (error at _await:-1) else goto L64
L64:
    CPy_RestoreExcInfo(r94)
    dec_ref r94
    goto L94
L65:
    r95 = r4.__mypyc_temp__7
    if is_error(r95) goto L73 (error at _await:-1) else goto L66
L66:
    CPy_RestoreExcInfo(r95)
    dec_ref r95
    r96 = CPy_KeepPropagating()
    if not r96 goto L73 else goto L152 :: bool
L67:
    unreachable
L68:
    r97 = r4.__mypyc_temp__6
    if is_error(r97) goto L153 (error at _await:-1) else goto L69
L69:
    r98 = CPyIter_Send(r97, arg)
    dec_ref r97
    dec_ref arg
    if is_error(r98) goto L71 else goto L70
L70:
    r84 = r98
    goto L51
L71:
    r99 = CPy_FetchStopIterationValue()
    if is_error(r99) goto L73 (error at _await:119) else goto L72
L72:
    r83 = r99
    dec_ref r83
    goto L94
L73:
    r100 = CPy_CatchError()
    r4.__mypyc_temp__8 = r100; r101 = is_error
    if not r101 goto L154 (error at _await:-1) else goto L74 :: bool
L74:
    r102 = builtins :: module
    r103 = 'Exception'
    r104 = CPyObject_GetAttr(r102, r103)
    if is_error(r104) goto L154 (error at _await:120) else goto L75
L75:
    r105 = CPy_ExceptionMatches(r104)
    dec_ref r104
    if r105 goto L76 else goto L155 :: bool
L76:
    r106 = CPy_GetExcValue()
    r4.e = r106; r107 = is_error
    if not r107 goto L154 (error at _await:120) else goto L77 :: bool
L77:
    r108 = r4.e
    if is_error(r108) goto L154 (error at _await:122) else goto L78
L78:
    r109 = dank_mids._exceptions.DankMidsInternalError :: type
    r110 = get_element_ptr r108 ob_type :: PyObject
    r111 = load_mem r110 :: builtins.object*
    dec_ref r108
    r112 = r111 == r109
    if r112 goto L85 else goto L79 :: bool
L79:
    r113 = dank_mids._batch.logger :: static
    if is_error(r113) goto L156 else goto L82
L80:
    r114 = raise NameError('value for final name "logger" was not set')
    if not r114 goto L91 (error at _await:123) else goto L157 :: bool
L81:
    unreachable
L82:
    r115 = r4.batch
    if is_error(r115) goto L154 (error at _await:123) else goto L83
L83:
    r116 = r4.e
    if is_error(r116) goto L158 (error at _await:123) else goto L84
L84:
    r117 = log_internal_error(r113, r115, r116)
    dec_ref r115
    dec_ref r116
    if is_error(r117) goto L154 (error at _await:123) else goto L85
L85:
    r118 = r4.task
    if is_error(r118) goto L154 (error at _await:124) else goto L86
L86:
    r4.last_failure = r118; r119 = is_error
    if not r119 goto L154 (error at _await:124) else goto L89 :: bool
L87:
    CPy_Reraise()
    if not 0 goto L91 else goto L159 :: bool
L88:
    unreachable
L89:
    r120 = r4.__mypyc_temp__8
    if is_error(r120) goto L140 (error at _await:-1) else goto L90
L90:
    CPy_RestoreExcInfo(r120)
    dec_ref r120
    goto L94
L91:
    r121 = r4.__mypyc_temp__8
    dec_ref r4
    if is_error(r121) goto L138 (error at _await:-1) else goto L92
L92:
    CPy_RestoreExcInfo(r121)
    dec_ref r121
    r122 = CPy_KeepPropagating()
    if not r122 goto L138 else goto L93 :: bool
L93:
    unreachable
L94:
    r123 = r4.__mypyc_temp__1
    if is_error(r123) goto L140 (error at _await:117) else goto L95
L95:
    r124 = r123 + 2
    r4.__mypyc_temp__1 = r124; r125 = is_error
    if not r125 goto L140 (error at _await:117) else goto L96 :: bool
L96:
    r126 = r4.__mypyc_temp__5
    if is_error(r126) goto L140 (error at _await:117) else goto L97
L97:
    r127 = r126 + 2
    r4.__mypyc_temp__5 = r127; r128 = is_error
    if not r128 goto L140 (error at _await:117) else goto L31 :: bool
L98:
    r129 = r4.last_failure
    if is_error(r129) goto L160 (error at _await:126) else goto L99
L99:
    r130 = load_address _Py_NoneStruct
    r131 = r129 != r130
    dec_ref r129
    if r131 goto L100 else goto L161 :: bool
L100:
    r132 = r4.last_failure
    if is_error(r132) goto L160 (error at _await:128) else goto L101
L101:
    r133 = CPy_GetCoro(r132)
    dec_ref r132
    if is_error(r133) goto L160 (error at _await:128) else goto L102
L102:
    r4.__mypyc_temp__9 = r133; r134 = is_error
    if not r134 goto L160 (error at _await:-1) else goto L103 :: bool
L103:
    r135 = r4.__mypyc_temp__9
    if is_error(r135) goto L160 (error at _await:-1) else goto L104
L104:
    r136 = CPyIter_Next(r135)
    dec_ref r135
    if is_error(r136) goto L162 else goto L107
L105:
    r137 = CPy_FetchStopIterationValue()
    if is_error(r137) goto L163 (error at _await:128) else goto L106
L106:
    r138 = r137
    dec_ref r138
    goto L130
L107:
    r139 = r136
L108:
    r4.__mypyc_next_label__ = 4; r140 = is_error
    if not r140 goto L164 (error at _await:128) else goto L165 :: bool
L109:
    return r139
L110:
    r141 = load_address _Py_NoneStruct
    r142 = type != r141
    if r142 goto L111 else goto L113 :: bool
L111:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L114 (error at _await:128) else goto L166 :: bool
L112:
    unreachable
L113:
    inc_ref arg
    goto L125
L114:
    r143 = CPy_CatchError()
    r4.__mypyc_temp__10 = r143; r144 = is_error
    if not r144 goto L167 (error at _await:-1) else goto L115 :: bool
L115:
    r145 = load_address r3
    r146 = r4.__mypyc_temp__9
    if is_error(r146) goto L167 (error at _await:-1) else goto L116
L116:
    r147 = CPy_YieldFromErrorHandle(r146, r145)
    dec_ref r146
    if is_error(r147) goto L167 (error at _await:128) else goto L117
L117:
    if r147 goto L120 else goto L118 :: bool
L118:
    inc_ref r3
    r139 = r3
    r148 = r4.__mypyc_temp__10
    if is_error(r148) goto L168 (error at _await:-1) else goto L119
L119:
    CPy_RestoreExcInfo(r148)
    dec_ref r148
    goto L108
L120:
    r138 = r3
    dec_ref r138
    r149 = r4.__mypyc_temp__10
    if is_error(r149) goto L122 (error at _await:-1) else goto L121
L121:
    CPy_RestoreExcInfo(r149)
    dec_ref r149
    goto L130
L122:
    r150 = r4.__mypyc_temp__10
    dec_ref r4
    if is_error(r150) goto L138 (error at _await:-1) else goto L123
L123:
    CPy_RestoreExcInfo(r150)
    dec_ref r150
    r151 = CPy_KeepPropagating()
    if not r151 goto L138 else goto L124 :: bool
L124:
    unreachable
L125:
    r152 = r4.__mypyc_temp__9
    if is_error(r152) goto L169 (error at _await:-1) else goto L126
L126:
    r153 = CPyIter_Send(r152, arg)
    dec_ref r152
    dec_ref arg
    if is_error(r153) goto L170 else goto L127
L127:
    r139 = r153
    goto L108
L128:
    r154 = CPy_FetchStopIterationValue()
    if is_error(r154) goto L163 (error at _await:128) else goto L129
L129:
    r138 = r154
    dec_ref r138
L130:
    r155 = box(None, 1)
    r4.__mypyc_next_label__ = -2; r156 = is_error
    dec_ref r4
    if not r156 goto L138 (error at _await:102) else goto L131 :: bool
L131:
    CPyGen_SetStopIterationValue(r155)
    if not 0 goto L138 else goto L132 :: bool
L132:
    unreachable
L133:
    r157 = r5 == 0
    if r157 goto L171 else goto L134 :: bool
L134:
    r158 = r5 == 2
    if r158 goto L172 else goto L173 :: bool
L135:
    r159 = r5 == 4
    dec_ref r5 :: int
    if r159 goto L110 else goto L174 :: bool
L136:
    r160 = raise StopIteration
    if not r160 goto L138 (error at _await:102) else goto L137 :: bool
L137:
    unreachable
L138:
    r161 = <error> :: object
    return r161
L139:
    xdec_ref r1
    xdec_ref r3
    goto L138
L140:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L138
L141:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L3
L142:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r17
    goto L138
L143:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r20
    goto L138
L144:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r20
    dec_ref r29
    goto L138
L145:
    xdec_ref r1
    goto L98
L146:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r59
    goto L138
L147:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r68
    goto L138
L148:
    dec_ref r84
    goto L57
L149:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L52
L150:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L55
L151:
    dec_ref r84
    goto L65
L152:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L67
L153:
    dec_ref arg
    goto L73
L154:
    xdec_ref r1
    xdec_ref r3
    goto L91
L155:
    xdec_ref r1
    xdec_ref r3
    goto L87
L156:
    xdec_ref r1
    xdec_ref r3
    goto L80
L157:
    dec_ref r4
    goto L81
L158:
    xdec_ref r1
    xdec_ref r3
    dec_ref r115
    goto L91
L159:
    dec_ref r4
    goto L88
L160:
    xdec_ref r3
    dec_ref r4
    goto L138
L161:
    xdec_ref r3
    goto L130
L162:
    xdec_ref r3
    goto L105
L163:
    dec_ref r4
    goto L138
L164:
    dec_ref r139
    goto L114
L165:
    xdec_ref r3
    dec_ref r4
    goto L109
L166:
    xdec_ref r3
    dec_ref r4
    goto L112
L167:
    xdec_ref r3
    goto L122
L168:
    xdec_ref r3
    dec_ref r139
    goto L122
L169:
    xdec_ref r3
    dec_ref r4
    dec_ref arg
    goto L138
L170:
    xdec_ref r3
    goto L128
L171:
    dec_ref r5 :: int
    goto L2
L172:
    dec_ref r5 :: int
    goto L53
L173:
    xdec_ref r1
    goto L135
L174:
    xdec_ref r3
    dec_ref r4
    goto L136

def _await_DankBatch_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _await_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _await_DankBatch_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _await_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _await_DankBatch_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _await_DankBatch_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = _await_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def _await_DankBatch_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def _await_DankBatch_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def DankBatch._await(self):
    self :: dank_mids._batch.DankBatch
    r0 :: dank_mids._batch._await_DankBatch_env
    r1 :: bool
    r2 :: dank_mids._batch._await_DankBatch_gen
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = _await_DankBatch_env()
    if is_error(r0) goto L6 (error at _await:102) else goto L1
L1:
    inc_ref self
    r0.self = self; r1 = is_error
    if not r1 goto L7 (error at _await:102) else goto L2 :: bool
L2:
    r2 = _await_DankBatch_gen()
    if is_error(r2) goto L7 (error at _await:102) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L8 (error at _await:102) else goto L4 :: bool
L4:
    r0.__mypyc_next_label__ = 0; r4 = is_error
    dec_ref r0
    if not r4 goto L9 (error at _await:102) else goto L5 :: bool
L5:
    return r2
L6:
    r5 = <error> :: object
    return r5
L7:
    dec_ref r0
    goto L6
L8:
    dec_ref r0
    dec_ref r2
    goto L6
L9:
    dec_ref r2
    goto L6

def coroutines_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    type, value, traceback, arg :: object
    r0 :: dank_mids._batch.coroutines_DankBatch_env
    r1 :: int
    r2 :: object
    r3 :: bit
    r4 :: dank_mids._batch.DankBatch
    r5 :: object
    r6 :: bool
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: bool
    r11 :: dank_mids._batch.DankBatch
    r12 :: object
    r13 :: bool
    r14 :: dank_mids._batch.DankBatch
    r15 :: dict
    r16, r17 :: bool
    r18 :: dict
    r19 :: native_int
    r20 :: short_int
    r21 :: bool
    r22 :: object
    r23 :: bool
    r24 :: object
    r25 :: short_int
    r26 :: tuple[bool, short_int, object]
    r27 :: short_int
    r28, r29 :: bool
    r30 :: object
    r31 :: bool
    r32 :: object
    r33 :: int
    r34, r35, r36 :: object
    r37 :: i32
    r38 :: bit
    r39 :: bool
    r40, r41, r42 :: object
    r43 :: object[2]
    r44 :: object_ptr
    r45, r46, r47, r48 :: object
    r49 :: str
    r50 :: object
    r51 :: object[3]
    r52 :: object_ptr
    r53, r54, r55 :: object
    r56 :: str
    r57 :: object
    r58 :: bool
    r59 :: object
    r60 :: bool
    r61 :: object
    r62 :: bit
    r63 :: dank_mids._batch.DankBatch
    r64 :: object
    r65 :: dict
    r66 :: str
    r67 :: object
    r68 :: object[1]
    r69 :: object_ptr
    r70 :: object
    r71 :: bool
    r72 :: object
    r73 :: str
    r74 :: object
    r75 :: bool
    r76 :: dict
    r77 :: short_int
    r78, r79 :: bit
    r80 :: object
    r81 :: i32
    r82 :: bit
    r83 :: bool
    r84 :: object
    r85 :: int
    r86 :: bit
    r87, r88, r89 :: object
    r90 :: str
    r91 :: object
    r92 :: object[1]
    r93 :: object_ptr
    r94 :: object
    r95 :: bool
    r96 :: object
    r97 :: str
    r98 :: object
    r99 :: str
    r100 :: object[1]
    r101 :: object_ptr
    r102, r103, r104 :: object
    r105 :: dict
    r106 :: str
    r107 :: object
    r108 :: bit
    r109, r110, r111 :: object
    r112 :: str
    r113 :: object[1]
    r114 :: object_ptr
    r115 :: object
    r116 :: bool
    r117 :: object
    r118 :: bit
    r119 :: object
    r120 :: bool
    r121 :: object
    r122 :: bit
    r123 :: object
    r124 :: bool
    r125, r126, r127, r128 :: bit
    r129 :: bool
    r130 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L101 (error at coroutines:131) else goto L1
L1:
    r1 = r0.__mypyc_next_label__
    if is_error(r1) goto L102 (error at coroutines:131) else goto L95
L2:
    r2 = load_address _Py_NoneStruct
    r3 = type != r2
    if r3 goto L103 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L101 (error at coroutines:131) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = r0.self
    if is_error(r4) goto L102 (error at coroutines:145) else goto L6
L6:
    r5 = r4.rpc_calls
    dec_ref r4
    r0.working_batch = r5; r6 = is_error
    if not r6 goto L102 (error at coroutines:145) else goto L7 :: bool
L7:
    r7 = r0.working_batch
    if is_error(r7) goto L102 (error at coroutines:148) else goto L8
L8:
    r8 = 'append'
    r9 = CPyObject_GetAttr(r7, r8)
    dec_ref r7
    if is_error(r9) goto L102 (error at coroutines:148) else goto L9
L9:
    r0.batch_append = r9; r10 = is_error
    if not r10 goto L102 (error at coroutines:148) else goto L10 :: bool
L10:
    r11 = r0.self
    if is_error(r11) goto L102 (error at coroutines:151) else goto L11
L11:
    r12 = r11._check_len
    dec_ref r11
    r0.check_len = r12; r13 = is_error
    if not r13 goto L102 (error at coroutines:151) else goto L12 :: bool
L12:
    r14 = r0.self
    if is_error(r14) goto L102 (error at coroutines:152) else goto L13
L13:
    r15 = r14.multicalls
    dec_ref r14
    inc_ref r15
    r0.__mypyc_temp__11 = r15; r16 = is_error
    if not r16 goto L104 (error at coroutines:-1) else goto L14 :: bool
L14:
    r0.__mypyc_temp__12 = 0; r17 = is_error
    if not r17 goto L104 (error at coroutines:-1) else goto L15 :: bool
L15:
    r18 = r0.__mypyc_temp__11
    if is_error(r18) goto L104 (error at coroutines:152) else goto L16
L16:
    r19 = PyDict_Size(r18)
    dec_ref r18
    r20 = r19 << 1
    r0.__mypyc_temp__13 = r20; r21 = is_error
    if not r21 goto L104 (error at coroutines:-1) else goto L17 :: bool
L17:
    r22 = CPyDict_GetValuesIter(r15)
    dec_ref r15
    if is_error(r22) goto L102 (error at coroutines:152) else goto L18
L18:
    r0.__mypyc_temp__14 = r22; r23 = is_error
    if not r23 goto L102 (error at coroutines:-1) else goto L19 :: bool
L19:
    r24 = r0.__mypyc_temp__14
    if is_error(r24) goto L102 (error at coroutines:152) else goto L20
L20:
    r25 = r0.__mypyc_temp__12
    if is_error(r25) goto L105 (error at coroutines:152) else goto L21
L21:
    r26 = CPyDict_NextValue(r24, r25)
    dec_ref r24
    r27 = r26[1]
    r0.__mypyc_temp__12 = r27; r28 = is_error
    if not r28 goto L106 (error at coroutines:152) else goto L22 :: bool
L22:
    r29 = r26[0]
    if r29 goto L23 else goto L107 :: bool
L23:
    r30 = r26[2]
    dec_ref r26
    r0.mcall = r30; r31 = is_error
    if not r31 goto L102 (error at coroutines:152) else goto L24 :: bool
L24:
    r32 = r0.mcall
    if is_error(r32) goto L102 (error at coroutines:153) else goto L25
L25:
    r33 = CPyObject_Size(r32)
    dec_ref r32
    if is_error(r33) goto L102 (error at coroutines:153) else goto L26
L26:
    r34 = r0.check_len
    if is_error(r34) goto L108 (error at coroutines:153) else goto L27
L27:
    r35 = box(int, r33)
    r36 = PyObject_RichCompare(r35, r34, 5)
    dec_ref r35
    dec_ref r34
    if is_error(r36) goto L102 (error at coroutines:153) else goto L28
L28:
    r37 = PyObject_IsTrue(r36)
    dec_ref r36
    r38 = r37 >= 0 :: signed
    if not r38 goto L102 (error at coroutines:153) else goto L29 :: bool
L29:
    r39 = truncate r37: i32 to builtins.bool
    if r39 goto L30 else goto L34 :: bool
L30:
    r40 = r0.mcall
    if is_error(r40) goto L102 (error at coroutines:154) else goto L31
L31:
    r41 = r0.batch_append
    if is_error(r41) goto L109 (error at coroutines:154) else goto L32
L32:
    r42 = box(bool, 1)
    r43 = [r40, r42]
    r44 = load_address r43
    r45 = ('skip_check',)
    r46 = PyObject_Vectorcall(r41, r44, 1, r45)
    dec_ref r41
    if is_error(r46) goto L109 (error at coroutines:154) else goto L110
L33:
    dec_ref r40
    goto L38
L34:
    r47 = r0.working_batch
    if is_error(r47) goto L102 (error at coroutines:158) else goto L35
L35:
    r48 = r0.mcall
    if is_error(r48) goto L111 (error at coroutines:158) else goto L36
L36:
    r49 = 'extend'
    r50 = box(bool, 1)
    r51 = [r47, r48, r50]
    r52 = load_address r51
    r53 = ('skip_check',)
    r54 = PyObject_VectorcallMethod(r49, r52, 9223372036854775810, r53)
    if is_error(r54) goto L112 (error at coroutines:158) else goto L113
L37:
    dec_ref r47
    dec_ref r48
L38:
    r55 = r0.working_batch
    if is_error(r55) goto L102 (error at coroutines:159) else goto L39
L39:
    r56 = 'is_full'
    r57 = CPyObject_GetAttr(r55, r56)
    dec_ref r55
    if is_error(r57) goto L102 (error at coroutines:159) else goto L40
L40:
    r58 = unbox(bool, r57)
    dec_ref r57
    if is_error(r58) goto L102 (error at coroutines:159) else goto L41
L41:
    if r58 goto L42 else goto L55 :: bool
L42:
    r59 = r0.working_batch
    if is_error(r59) goto L102 (error at coroutines:160) else goto L43
L43:
    r0.__mypyc_next_label__ = 2; r60 = is_error
    dec_ref r0
    if not r60 goto L114 (error at coroutines:160) else goto L44 :: bool
L44:
    return r59
L45:
    r61 = load_address _Py_NoneStruct
    r62 = type != r61
    if r62 goto L115 else goto L48 :: bool
L46:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L101 (error at coroutines:160) else goto L47 :: bool
L47:
    unreachable
L48:
    r63 = r0.self
    if is_error(r63) goto L102 (error at coroutines:161) else goto L49
L49:
    r64 = r63.controller
    dec_ref r63
    r65 = dank_mids._batch.globals :: static
    r66 = 'JSONRPCBatch'
    r67 = CPyDict_GetItem(r65, r66)
    if is_error(r67) goto L116 (error at coroutines:161) else goto L50
L50:
    r68 = [r64]
    r69 = load_address r68
    r70 = PyObject_Vectorcall(r67, r69, 1, 0)
    dec_ref r67
    if is_error(r70) goto L116 (error at coroutines:161) else goto L51
L51:
    dec_ref r64
    r0.working_batch = r70; r71 = is_error
    if not r71 goto L102 (error at coroutines:161) else goto L52 :: bool
L52:
    r72 = r0.working_batch
    if is_error(r72) goto L102 (error at coroutines:162) else goto L53
L53:
    r73 = 'append'
    r74 = CPyObject_GetAttr(r72, r73)
    dec_ref r72
    if is_error(r74) goto L102 (error at coroutines:162) else goto L54
L54:
    r0.batch_append = r74; r75 = is_error
    if not r75 goto L102 (error at coroutines:162) else goto L55 :: bool
L55:
    r76 = r0.__mypyc_temp__11
    if is_error(r76) goto L102 (error at coroutines:152) else goto L56
L56:
    r77 = r0.__mypyc_temp__13
    if is_error(r77) goto L117 (error at coroutines:152) else goto L57
L57:
    r78 = CPyDict_CheckSize(r76, r77)
    dec_ref r76
    if not r78 goto L102 (error at coroutines:152) else goto L19 :: bool
L58:
    r79 = CPy_NoErrOccurred()
    if not r79 goto L102 (error at coroutines:152) else goto L59 :: bool
L59:
    r80 = r0.working_batch
    if is_error(r80) goto L102 (error at coroutines:164) else goto L60
L60:
    r81 = PyObject_IsTrue(r80)
    dec_ref r80
    r82 = r81 >= 0 :: signed
    if not r82 goto L102 (error at coroutines:164) else goto L61 :: bool
L61:
    r83 = truncate r81: i32 to builtins.bool
    if r83 goto L62 else goto L92 :: bool
L62:
    r84 = r0.working_batch
    if is_error(r84) goto L102 (error at coroutines:165) else goto L63
L63:
    r85 = CPyObject_Size(r84)
    dec_ref r84
    if is_error(r85) goto L102 (error at coroutines:165) else goto L64
L64:
    r86 = r85 == 2
    dec_ref r85 :: int
    if r86 goto L65 else goto L86 :: bool
L65:
    r87 = r0.working_batch
    if is_error(r87) goto L102 (error at coroutines:166) else goto L66
L66:
    r88 = PyObject_GetIter(r87)
    dec_ref r87
    if is_error(r88) goto L102 (error at coroutines:166) else goto L67
L67:
    r89 = builtins :: module
    r90 = 'next'
    r91 = CPyObject_GetAttr(r89, r90)
    if is_error(r91) goto L118 (error at coroutines:166) else goto L68
L68:
    r92 = [r88]
    r93 = load_address r92
    r94 = PyObject_Vectorcall(r91, r93, 1, 0)
    dec_ref r91
    if is_error(r94) goto L118 (error at coroutines:166) else goto L69
L69:
    dec_ref r88
    r0.call = r94; r95 = is_error
    if not r95 goto L102 (error at coroutines:166) else goto L70 :: bool
L70:
    r96 = r0.working_batch
    if is_error(r96) goto L102 (error at coroutines:168) else goto L71
L71:
    r97 = '_done'
    r98 = CPyObject_GetAttr(r96, r97)
    dec_ref r96
    if is_error(r98) goto L102 (error at coroutines:168) else goto L72
L72:
    r99 = 'set'
    r100 = [r98]
    r101 = load_address r100
    r102 = PyObject_VectorcallMethod(r99, r101, 9223372036854775809, 0)
    if is_error(r102) goto L119 (error at coroutines:168) else goto L120
L73:
    dec_ref r98
    r103 = r0.call
    if is_error(r103) goto L102 (error at coroutines:169) else goto L74
L74:
    r104 = PyObject_Type(r103)
    dec_ref r103
    r105 = dank_mids._batch.globals :: static
    r106 = 'Multicall'
    r107 = CPyDict_GetItem(r105, r106)
    if is_error(r107) goto L121 (error at coroutines:169) else goto L75
L75:
    r108 = r104 == r107
    dec_ref r104
    dec_ref r107
    if r108 goto L76 else goto L78 :: bool
L76:
    r109 = r0.call
    if is_error(r109) goto L102 (error at coroutines:169) else goto L77
L77:
    r110 = r109
    goto L81
L78:
    r111 = r0.call
    if is_error(r111) goto L102 (error at coroutines:169) else goto L79
L79:
    r112 = 'make_request'
    r113 = [r111]
    r114 = load_address r113
    r115 = PyObject_VectorcallMethod(r112, r114, 9223372036854775809, 0)
    if is_error(r115) goto L122 (error at coroutines:169) else goto L80
L80:
    dec_ref r111
    r110 = r115
L81:
    r0.__mypyc_next_label__ = 4; r116 = is_error
    dec_ref r0
    if not r116 goto L123 (error at coroutines:169) else goto L82 :: bool
L82:
    return r110
L83:
    r117 = load_address _Py_NoneStruct
    r118 = type != r117
    if r118 goto L124 else goto L92 :: bool
L84:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L101 (error at coroutines:169) else goto L85 :: bool
L85:
    unreachable
L86:
    r119 = r0.working_batch
    if is_error(r119) goto L102 (error at coroutines:171) else goto L87
L87:
    r0.__mypyc_next_label__ = 6; r120 = is_error
    dec_ref r0
    if not r120 goto L125 (error at coroutines:171) else goto L88 :: bool
L88:
    return r119
L89:
    r121 = load_address _Py_NoneStruct
    r122 = type != r121
    if r122 goto L126 else goto L92 :: bool
L90:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L101 (error at coroutines:171) else goto L91 :: bool
L91:
    unreachable
L92:
    r123 = box(None, 1)
    r0.__mypyc_next_label__ = -2; r124 = is_error
    dec_ref r0
    if not r124 goto L101 (error at coroutines:131) else goto L93 :: bool
L93:
    CPyGen_SetStopIterationValue(r123)
    if not 0 goto L101 else goto L94 :: bool
L94:
    unreachable
L95:
    r125 = r1 == 0
    if r125 goto L127 else goto L96 :: bool
L96:
    r126 = r1 == 2
    if r126 goto L128 else goto L97 :: bool
L97:
    r127 = r1 == 4
    if r127 goto L129 else goto L98 :: bool
L98:
    r128 = r1 == 6
    dec_ref r1 :: int
    if r128 goto L89 else goto L130 :: bool
L99:
    r129 = raise StopIteration
    if not r129 goto L101 (error at coroutines:131) else goto L100 :: bool
L100:
    unreachable
L101:
    r130 = <error> :: object
    return r130
L102:
    dec_ref r0
    goto L101
L103:
    dec_ref r0
    goto L3
L104:
    dec_ref r0
    dec_ref r15
    goto L101
L105:
    dec_ref r0
    dec_ref r24
    goto L101
L106:
    dec_ref r0
    dec_ref r26
    goto L101
L107:
    dec_ref r26
    goto L58
L108:
    dec_ref r0
    dec_ref r33 :: int
    goto L101
L109:
    dec_ref r0
    dec_ref r40
    goto L101
L110:
    dec_ref r46
    goto L33
L111:
    dec_ref r0
    dec_ref r47
    goto L101
L112:
    dec_ref r0
    dec_ref r47
    dec_ref r48
    goto L101
L113:
    dec_ref r54
    goto L37
L114:
    dec_ref r59
    goto L101
L115:
    dec_ref r0
    goto L46
L116:
    dec_ref r0
    dec_ref r64
    goto L101
L117:
    dec_ref r0
    dec_ref r76
    goto L101
L118:
    dec_ref r0
    dec_ref r88
    goto L101
L119:
    dec_ref r0
    dec_ref r98
    goto L101
L120:
    dec_ref r102
    goto L73
L121:
    dec_ref r0
    dec_ref r104
    goto L101
L122:
    dec_ref r0
    dec_ref r111
    goto L101
L123:
    dec_ref r110
    goto L101
L124:
    dec_ref r0
    goto L84
L125:
    dec_ref r119
    goto L101
L126:
    dec_ref r0
    goto L90
L127:
    dec_ref r1 :: int
    goto L2
L128:
    dec_ref r1 :: int
    goto L45
L129:
    dec_ref r1 :: int
    goto L83
L130:
    dec_ref r0
    goto L99

def coroutines_DankBatch_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutines_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutines_DankBatch_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutines_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutines_DankBatch_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutines_DankBatch_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutines_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutines_DankBatch_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def DankBatch.coroutines(self):
    self :: dank_mids._batch.DankBatch
    r0 :: dank_mids._batch.coroutines_DankBatch_env
    r1 :: bool
    r2 :: dank_mids._batch.coroutines_DankBatch_gen
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = coroutines_DankBatch_env()
    if is_error(r0) goto L6 (error at coroutines:131) else goto L1
L1:
    inc_ref self
    r0.self = self; r1 = is_error
    if not r1 goto L7 (error at coroutines:131) else goto L2 :: bool
L2:
    r2 = coroutines_DankBatch_gen()
    if is_error(r2) goto L7 (error at coroutines:131) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L8 (error at coroutines:131) else goto L4 :: bool
L4:
    r0.__mypyc_next_label__ = 0; r4 = is_error
    dec_ref r0
    if not r4 goto L9 (error at coroutines:131) else goto L5 :: bool
L5:
    return r2
L6:
    r5 = <error> :: object
    return r5
L7:
    dec_ref r0
    goto L6
L8:
    dec_ref r0
    dec_ref r2
    goto L6
L9:
    dec_ref r2
    goto L6

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13 :: object_ptr
    r14 :: object_ptr[1]
    r15 :: c_ptr
    r16 :: native_int[1]
    r17 :: c_ptr
    r18 :: object
    r19 :: dict
    r20, r21 :: str
    r22 :: bit
    r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: dict
    r30, r31 :: object
    r32 :: str
    r33 :: dict
    r34, r35 :: object
    r36 :: str
    r37 :: dict
    r38, r39 :: object
    r40 :: str
    r41 :: dict
    r42, r43 :: object
    r44 :: str
    r45 :: dict
    r46 :: object
    r47 :: str
    r48 :: dict
    r49 :: str
    r50 :: object
    r51 :: object[1]
    r52 :: object_ptr
    r53 :: object
    r54 :: dict
    r55 :: str
    r56 :: i32
    r57 :: bit
    r58 :: dict
    r59 :: str
    r60 :: object
    r61 :: dict
    r62 :: str
    r63 :: object
    r64 :: dict
    r65 :: str
    r66 :: object
    r67 :: dict
    r68 :: str
    r69, r70, r71 :: object
    r72 :: tuple[object, object, object]
    r73, r74 :: object
    r75 :: dict
    r76 :: str
    r77 :: i32
    r78 :: bit
    r79 :: dict
    r80 :: str
    r81 :: object
    r82 :: i32
    r83 :: bit
    r84 :: dict
    r85 :: str
    r86 :: object
    r87 :: i32
    r88 :: bit
    r89 :: dict
    r90 :: str
    r91 :: object
    r92 :: str
    r93 :: object
    r94 :: bool
    r95 :: object[1]
    r96 :: object_ptr
    r97 :: object
    r98 :: dict
    r99 :: str
    r100 :: i32
    r101 :: bit
    r102 :: dict
    r103 :: str
    r104 :: object
    r105 :: str
    r106 :: object
    r107 :: dict
    r108 :: str
    r109 :: i32
    r110 :: bit
    r111 :: object
    r112 :: str
    r113, r114 :: object
    r115 :: bool
    r116, r117, r118, r119, r120, r121 :: str
    r122 :: tuple
    r123 :: i32
    r124 :: bit
    r125 :: dict
    r126 :: str
    r127 :: i32
    r128 :: bit
    r129 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L41 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Task',)
    r6 = 'asyncio'
    r7 = dank_mids._batch.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L41 (error at <module>:1) else goto L4
L4:
    asyncio = r8 :: module
    dec_ref r8
    r9 = ('TYPE_CHECKING', 'Any', 'Awaitable', 'Final', 'Generator', 'TypeVar', 'Union', 'final')
    r10 = 'typing'
    r11 = dank_mids._batch.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L41 (error at <module>:2) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = load_address a_sync :: module
    r14 = [r13]
    r15 = load_address r14
    r16 = [4]
    r17 = load_address r16
    r18 = (('a_sync', 'a_sync', 'a_sync'),)
    r19 = dank_mids._batch.globals :: static
    r20 = 'dank_mids\\_batch.py'
    r21 = '<module>'
    r22 = CPyImport_ImportMany(r18, r15, r19, r20, r21, r17)
    if not r22 goto L41 else goto L6 :: bool
L6:
    r23 = ('DankMidsInternalError',)
    r24 = 'dank_mids._exceptions'
    r25 = dank_mids._batch.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L41 (error at <module>:6) else goto L7
L7:
    dank_mids._exceptions = r26 :: module
    dec_ref r26
    r27 = ('getLogger',)
    r28 = 'dank_mids._logging'
    r29 = dank_mids._batch.globals :: static
    r30 = CPyImport_ImportFromMany(r28, r27, r27, r29)
    if is_error(r30) goto L41 (error at <module>:7) else goto L8
L8:
    dank_mids._logging = r30 :: module
    dec_ref r30
    r31 = ('JSONRPCBatch', 'Multicall')
    r32 = 'dank_mids._requests'
    r33 = dank_mids._batch.globals :: static
    r34 = CPyImport_ImportFromMany(r32, r31, r31, r33)
    if is_error(r34) goto L41 (error at <module>:8) else goto L9
L9:
    dank_mids._requests = r34 :: module
    dec_ref r34
    r35 = ('RawResponse',)
    r36 = 'dank_mids.helpers._codec'
    r37 = dank_mids._batch.globals :: static
    r38 = CPyImport_ImportFromMany(r36, r35, r35, r37)
    if is_error(r38) goto L41 (error at <module>:9) else goto L10
L10:
    dank_mids.helpers._codec = r38 :: module
    dec_ref r38
    r39 = ('log_internal_error',)
    r40 = 'dank_mids.helpers._errors'
    r41 = dank_mids._batch.globals :: static
    r42 = CPyImport_ImportFromMany(r40, r39, r39, r41)
    if is_error(r42) goto L41 (error at <module>:10) else goto L11
L11:
    dank_mids.helpers._errors = r42 :: module
    dec_ref r42
    r43 = ('Multicalls',)
    r44 = 'dank_mids.types'
    r45 = dank_mids._batch.globals :: static
    r46 = CPyImport_ImportFromMany(r44, r43, r43, r45)
    if is_error(r46) goto L41 (error at <module>:11) else goto L12
L12:
    dank_mids.types = r46 :: module
    dec_ref r46
    if 0 goto L13 else goto L13 :: bool
L13:
    r47 = '__T'
    r48 = dank_mids._batch.globals :: static
    r49 = 'TypeVar'
    r50 = CPyDict_GetItem(r48, r49)
    if is_error(r50) goto L41 (error at <module>:17) else goto L14
L14:
    r51 = [r47]
    r52 = load_address r51
    r53 = PyObject_Vectorcall(r50, r52, 1, 0)
    dec_ref r50
    if is_error(r53) goto L41 (error at <module>:17) else goto L15
L15:
    r54 = dank_mids._batch.globals :: static
    r55 = '__T'
    r56 = CPyDict_SetItem(r54, r55, r53)
    dec_ref r53
    r57 = r56 >= 0 :: signed
    if not r57 goto L41 (error at <module>:17) else goto L16 :: bool
L16:
    r58 = dank_mids._batch.globals :: static
    r59 = 'Union'
    r60 = CPyDict_GetItem(r58, r59)
    if is_error(r60) goto L41 (error at <module>:19) else goto L17
L17:
    r61 = dank_mids._batch.globals :: static
    r62 = 'Multicall'
    r63 = CPyDict_GetItem(r61, r62)
    if is_error(r63) goto L42 (error at <module>:19) else goto L18
L18:
    r64 = dank_mids._batch.globals :: static
    r65 = 'JSONRPCBatch'
    r66 = CPyDict_GetItem(r64, r65)
    if is_error(r66) goto L43 (error at <module>:19) else goto L19
L19:
    r67 = dank_mids._batch.globals :: static
    r68 = 'Awaitable'
    r69 = CPyDict_GetItem(r67, r68)
    if is_error(r69) goto L44 (error at <module>:19) else goto L20
L20:
    r70 = dank_mids.helpers._codec.RawResponse :: type
    r71 = PyObject_GetItem(r69, r70)
    dec_ref r69
    if is_error(r71) goto L44 (error at <module>:19) else goto L21
L21:
    r72 = (r63, r66, r71)
    r73 = box(tuple[object, object, object], r72)
    r74 = PyObject_GetItem(r60, r73)
    dec_ref r60
    dec_ref r73
    if is_error(r74) goto L41 (error at <module>:19) else goto L22
L22:
    r75 = dank_mids._batch.globals :: static
    r76 = 'Coro'
    r77 = CPyDict_SetItem(r75, r76, r74)
    dec_ref r74
    r78 = r77 >= 0 :: signed
    if not r78 goto L41 (error at <module>:19) else goto L23 :: bool
L23:
    r79 = dank_mids._batch.globals :: static
    r80 = 'MIN_SIZE'
    r81 = object 1
    r82 = CPyDict_SetItem(r79, r80, r81)
    r83 = r82 >= 0 :: signed
    if not r83 goto L41 (error at <module>:22) else goto L24 :: bool
L24:
    r84 = dank_mids._batch.globals :: static
    r85 = 'CHECK'
    r86 = object 0
    r87 = CPyDict_SetItem(r84, r85, r86)
    r88 = r87 >= 0 :: signed
    if not r88 goto L41 (error at <module>:25) else goto L25 :: bool
L25:
    r89 = dank_mids._batch.globals :: static
    r90 = '__name__'
    r91 = CPyDict_GetItem(r89, r90)
    if is_error(r91) goto L41 (error at <module>:29) else goto L26
L26:
    r92 = cast(str, r91)
    if is_error(r92) goto L41 (error at <module>:29) else goto L27
L27:
    r93 = dank_mids._logging.getLogger :: static
    if is_error(r93) goto L45 else goto L30
L28:
    r94 = raise NameError('value for final name "getLogger" was not set')
    if not r94 goto L41 (error at <module>:29) else goto L29 :: bool
L29:
    unreachable
L30:
    r95 = [r92]
    r96 = load_address r95
    r97 = PyObject_Vectorcall(r93, r96, 1, 0)
    if is_error(r97) goto L46 (error at <module>:29) else goto L31
L31:
    dec_ref r92
    dank_mids._batch.logger = r97 :: static
    r98 = dank_mids._batch.globals :: static
    r99 = 'logger'
    r100 = CPyDict_SetItem(r98, r99, r97)
    dec_ref r97
    r101 = r100 >= 0 :: signed
    if not r101 goto L41 (error at <module>:29) else goto L32 :: bool
L32:
    r102 = dank_mids._batch.globals :: static
    r103 = 'a_sync'
    r104 = CPyDict_GetItem(r102, r103)
    if is_error(r104) goto L41 (error at <module>:31) else goto L33
L33:
    r105 = 'create_task'
    r106 = CPyObject_GetAttr(r104, r105)
    dec_ref r104
    if is_error(r106) goto L41 (error at <module>:31) else goto L34
L34:
    dank_mids._batch.create_task = r106 :: static
    r107 = dank_mids._batch.globals :: static
    r108 = 'create_task'
    r109 = CPyDict_SetItem(r107, r108, r106)
    dec_ref r106
    r110 = r109 >= 0 :: signed
    if not r110 goto L41 (error at <module>:31) else goto L35 :: bool
L35:
    r111 = <error> :: object
    r112 = 'dank_mids._batch'
    r113 = dank_mids._batch.DankBatch_template :: type
    r114 = CPyType_FromTemplate(r113, r111, r112)
    if is_error(r114) goto L41 (error at <module>:39) else goto L36
L36:
    r115 = DankBatch_trait_vtable_setup()
    if is_error(r115) goto L47 (error at <module>:-1) else goto L37
L37:
    r116 = '__mypyc_attrs__'
    r117 = 'controller'
    r118 = 'multicalls'
    r119 = 'rpc_calls'
    r120 = '_awaited'
    r121 = '_check_len'
    r122 = PyTuple_Pack(5, r117, r118, r119, r120, r121)
    if is_error(r122) goto L47 (error at <module>:39) else goto L38
L38:
    r123 = PyObject_SetAttr(r114, r116, r122)
    dec_ref r122
    r124 = r123 >= 0 :: signed
    if not r124 goto L47 (error at <module>:39) else goto L39 :: bool
L39:
    dank_mids._batch.DankBatch = r114 :: type
    r125 = dank_mids._batch.globals :: static
    r126 = 'DankBatch'
    r127 = CPyDict_SetItem(r125, r126, r114)
    dec_ref r114
    r128 = r127 >= 0 :: signed
    if not r128 goto L41 (error at <module>:39) else goto L40 :: bool
L40:
    return 1
L41:
    r129 = <error> :: None
    return r129
L42:
    dec_ref r60
    goto L41
L43:
    dec_ref r60
    dec_ref r63
    goto L41
L44:
    dec_ref r60
    dec_ref r63
    dec_ref r66
    goto L41
L45:
    dec_ref r92
    goto L28
L46:
    dec_ref r92
    goto L41
L47:
    dec_ref r114
    goto L41

def FunctionABI.__init__(self, abi):
    self :: dank_mids.brownie_patch._abi.FunctionABI
    abi :: dict
    r0 :: bool
    r1 :: str
    r2 :: bool
    r3 :: str
    r4 :: bool
    r5 :: None
L0:
    inc_ref abi
    self.abi = abi; r0 = is_error
    if not r0 goto L6 (error at __init__:44) else goto L1 :: bool
L1:
    r1 = build_function_signature(abi)
    if is_error(r1) goto L6 (error at __init__:50) else goto L2
L2:
    inc_ref r1
    self.input_sig = r1; r2 = is_error
    if not r2 goto L7 (error at __init__:51) else goto L3 :: bool
L3:
    r3 = build_function_selector(r1)
    dec_ref r1
    if is_error(r3) goto L6 (error at __init__:57) else goto L4
L4:
    self.signature = r3; r4 = is_error
    if not r4 goto L6 (error at __init__:57) else goto L5 :: bool
L5:
    return 1
L6:
    r5 = <error> :: None
    return r5
L7:
    dec_ref r1
    goto L6

def FunctionABI.singleton(abi):
    abi :: dict
    r0 :: list
    r1 :: ptr
    r2 :: native_int
    r3 :: tuple
    r4 :: short_int
    r5 :: ptr
    r6 :: native_int
    r7 :: short_int
    r8 :: bit
    r9 :: native_int
    r10, r11 :: ptr
    r12 :: native_int
    r13 :: ptr
    r14 :: object
    r15 :: str
    r16, r17 :: object
    r18 :: bool
    r19 :: object[1]
    r20 :: object_ptr
    r21 :: object
    r22 :: tuple[str, object]
    r23 :: object
    r24 :: bit
    r25 :: short_int
    r26 :: object
    r27 :: bool
    r28 :: object
    r29 :: dank_mids.brownie_patch._abi.FunctionABI
    r30 :: tuple[object, object, object]
    r31 :: object
    r32 :: str
    r33 :: object
    r34 :: bit
    r35 :: object
    r36 :: dict
    r37 :: i32
    r38 :: bit
    r39 :: tuple
    r40 :: object
    r41 :: dank_mids.brownie_patch._abi.FunctionABI
    r42 :: object
    r43 :: bool
    r44 :: i32
    r45 :: bit
    r46 :: object
    r47 :: str
    r48 :: object
    r49 :: bit
    r50 :: object
    r51 :: str
    r52 :: object
    r53 :: str
    r54 :: object
    r55 :: object[2]
    r56 :: object_ptr
    r57 :: object
    r58 :: bit
    r59 :: dank_mids.brownie_patch._abi.FunctionABI
L0:
    r0 = CPySequence_Sort(abi)
    if is_error(r0) goto L42 (error at singleton:71) else goto L1
L1:
    r1 = get_element_ptr r0 ob_size :: PyVarObject
    r2 = load_mem r1 :: native_int*
    r3 = PyTuple_New(r2)
    if is_error(r3) goto L43 (error at singleton:71) else goto L2
L2:
    r4 = 0
L3:
    r5 = get_element_ptr r0 ob_size :: PyVarObject
    r6 = load_mem r5 :: native_int*
    r7 = r6 << 1
    r8 = r4 < r7 :: signed
    if r8 goto L4 else goto L44 :: bool
L4:
    r9 = r4 >> 1
    r10 = get_element_ptr r0 ob_item :: PyListObject
    r11 = load_mem r10 :: ptr*
    r12 = r9 * 8
    r13 = r11 + r12
    r14 = load_mem r13 :: builtins.object*
    inc_ref r14
    r15 = cast(str, r14)
    if is_error(r15) goto L45 (error at singleton:71) else goto L5
L5:
    r16 = CPyDict_GetItem(abi, r15)
    if is_error(r16) goto L46 (error at singleton:71) else goto L6
L6:
    r17 = dank_mids.brownie_patch._abi._make_hashable :: static
    if is_error(r17) goto L47 else goto L9
L7:
    r18 = raise NameError('value for final name "_make_hashable" was not set')
    if not r18 goto L42 (error at singleton:71) else goto L8 :: bool
L8:
    unreachable
L9:
    r19 = [r16]
    r20 = load_address r19
    r21 = PyObject_Vectorcall(r17, r20, 1, 0)
    if is_error(r21) goto L48 (error at singleton:71) else goto L10
L10:
    dec_ref r16
    r22 = (r15, r21)
    r23 = box(tuple[str, object], r22)
    r24 = CPySequenceTuple_SetItemUnsafe(r3, r4, r23)
    if not r24 goto L45 (error at singleton:71) else goto L11 :: bool
L11:
    r25 = r4 + 2
    r4 = r25
    goto L3
L12:
L13:
    r26 = dank_mids.brownie_patch._abi._singletons :: static
    if is_error(r26) goto L14 else goto L16
L14:
    r27 = raise NameError('value for final name "_singletons" was not set')
    if not r27 goto L19 (error at singleton:73) else goto L49 :: bool
L15:
    unreachable
L16:
    r28 = PyObject_GetItem(r26, r3)
    if is_error(r28) goto L19 (error at singleton:73) else goto L17
L17:
    r29 = cast(dank_mids.brownie_patch._abi.FunctionABI, r28)
    if is_error(r29) goto L19 (error at singleton:73) else goto L50
L18:
    return r29
L19:
    r30 = CPy_CatchError()
    r31 = builtins :: module
    r32 = 'KeyError'
    r33 = CPyObject_GetAttr(r31, r32)
    if is_error(r33) goto L51 (error at singleton:74) else goto L20
L20:
    r34 = CPy_ExceptionMatches(r33)
    dec_ref r33
    if r34 goto L21 else goto L31 :: bool
L21:
    r35 = dank_mids.brownie_patch._abi.FunctionABI :: type
    r36 = PyDict_New()
    if is_error(r36) goto L51 (error at singleton:75) else goto L22
L22:
    r37 = CPyDict_UpdateInDisplay(r36, abi)
    r38 = r37 >= 0 :: signed
    if not r38 goto L52 (error at singleton:75) else goto L23 :: bool
L23:
    r39 = PyTuple_Pack(0)
    if is_error(r39) goto L52 (error at singleton:75) else goto L24
L24:
    r40 = PyObject_Call(r35, r39, r36)
    dec_ref r39
    dec_ref r36
    if is_error(r40) goto L51 (error at singleton:75) else goto L25
L25:
    r41 = cast(dank_mids.brownie_patch._abi.FunctionABI, r40)
    if is_error(r41) goto L51 (error at singleton:75) else goto L26
L26:
    inc_ref r41
    r42 = dank_mids.brownie_patch._abi._singletons :: static
    if is_error(r42) goto L53 else goto L29
L27:
    r43 = raise NameError('value for final name "_singletons" was not set')
    if not r43 goto L40 (error at singleton:75) else goto L54 :: bool
L28:
    unreachable
L29:
    r44 = PyObject_SetItem(r42, r3, r41)
    dec_ref r3
    dec_ref r41
    r45 = r44 >= 0 :: signed
    if not r45 goto L55 (error at singleton:75) else goto L30 :: bool
L30:
    CPy_RestoreExcInfo(r30)
    dec_ref r30
    return r41
L31:
    r46 = builtins :: module
    r47 = 'AttributeError'
    r48 = CPyObject_GetAttr(r46, r47)
    if is_error(r48) goto L51 (error at singleton:77) else goto L32
L32:
    r49 = CPy_ExceptionMatches(r48)
    dec_ref r48
    if r49 goto L33 else goto L56 :: bool
L33:
    r50 = CPy_GetExcValue()
    r51 = PyObject_Str(r50)
    dec_ref r50
    if is_error(r51) goto L51 (error at singleton:78) else goto L34
L34:
    r52 = builtins :: module
    r53 = 'AttributeError'
    r54 = CPyObject_GetAttr(r52, r53)
    if is_error(r54) goto L57 (error at singleton:78) else goto L35
L35:
    r55 = [r51, r3]
    r56 = load_address r55
    r57 = PyObject_Vectorcall(r54, r56, 2, 0)
    dec_ref r54
    if is_error(r57) goto L57 (error at singleton:78) else goto L36
L36:
    dec_ref r51
    dec_ref r3
    CPy_Raise(r57)
    dec_ref r57
    if not 0 goto L40 (error at singleton:78) else goto L58 :: bool
L37:
    unreachable
L38:
    CPy_Reraise()
    if not 0 goto L40 else goto L59 :: bool
L39:
    unreachable
L40:
    CPy_RestoreExcInfo(r30)
    dec_ref r30
    r58 = CPy_KeepPropagating()
    if not r58 goto L42 else goto L41 :: bool
L41:
    unreachable
L42:
    r59 = <error> :: dank_mids.brownie_patch._abi.FunctionABI
    return r59
L43:
    dec_ref r0
    goto L42
L44:
    dec_ref r0
    goto L12
L45:
    dec_ref r0
    dec_ref r3
    goto L42
L46:
    dec_ref r0
    dec_ref r3
    dec_ref r15
    goto L42
L47:
    dec_ref r0
    dec_ref r3
    dec_ref r15
    dec_ref r16
    goto L7
L48:
    dec_ref r0
    dec_ref r3
    dec_ref r15
    dec_ref r16
    goto L42
L49:
    dec_ref r3
    goto L15
L50:
    dec_ref r3
    goto L18
L51:
    dec_ref r3
    goto L40
L52:
    dec_ref r3
    dec_ref r36
    goto L40
L53:
    dec_ref r3
    dec_ref r41
    dec_ref r41
    goto L27
L54:
    dec_ref r30
    goto L28
L55:
    dec_ref r41
    goto L40
L56:
    dec_ref r3
    goto L38
L57:
    dec_ref r3
    dec_ref r51
    goto L40
L58:
    dec_ref r30
    goto L37
L59:
    dec_ref r30
    goto L39

def get_type_strings(abi_params, substitutions):
    abi_params :: list
    substitutions :: union[dict, None]
    r0 :: object
    r1 :: list
    r2 :: object
    r3 :: bit
    r4 :: dict
    r5 :: short_int
    r6 :: ptr
    r7 :: native_int
    r8 :: short_int
    r9 :: bit
    r10 :: native_int
    r11, r12 :: ptr
    r13 :: native_int
    r14 :: ptr
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: object
    r19, type_str, r20 :: str
    r21 :: i32
    r22 :: bool
    r23 :: str
    r24 :: object
    r25 :: dict
    r26, r27 :: list
    r28 :: object
    r29, r30, r31, r32, r33, r34 :: str
    r35 :: i32
    r36 :: bit
    r37 :: dict
    r38 :: short_int
    r39 :: native_int
    r40 :: short_int
    r41 :: object
    r42 :: tuple[bool, short_int, object, object]
    r43 :: short_int
    r44 :: bool
    r45, r46 :: object
    r47 :: str
    r48 :: i32
    r49 :: bool
    r50 :: str
    r51 :: object[3]
    r52 :: object_ptr
    r53 :: object
    r54 :: str
    r55, r56 :: bit
    r57 :: i32
    r58 :: bit
    r59 :: short_int
    r60 :: list
L0:
    if is_error(substitutions) goto L1 else goto L35
L1:
    r0 = box(None, 1)
    inc_ref r0
    substitutions = r0
L2:
    r1 = PyList_New(0)
    if is_error(r1) goto L36 (error at get_type_strings:86) else goto L3
L3:
    r2 = load_address _Py_NoneStruct
    r3 = substitutions == r2
    if r3 goto L37 else goto L6 :: bool
L4:
    r4 = PyDict_New()
    if is_error(r4) goto L38 (error at get_type_strings:88) else goto L5
L5:
    substitutions = r4
L6:
    r5 = 0
L7:
    r6 = get_element_ptr abi_params ob_size :: PyVarObject
    r7 = load_mem r6 :: native_int*
    r8 = r7 << 1
    r9 = r5 < r8 :: signed
    if r9 goto L8 else goto L39 :: bool
L8:
    r10 = r5 >> 1
    r11 = get_element_ptr abi_params ob_item :: PyListObject
    r12 = load_mem r11 :: ptr*
    r13 = r10 * 8
    r14 = r12 + r13
    r15 = load_mem r14 :: builtins.object*
    inc_ref r15
    r16 = cast(dict, r15)
    if is_error(r16) goto L40 (error at get_type_strings:90) else goto L9
L9:
    r17 = 'type'
    r18 = CPyDict_GetItem(r16, r17)
    if is_error(r18) goto L41 (error at get_type_strings:91) else goto L10
L10:
    r19 = cast(str, r18)
    if is_error(r19) goto L41 (error at get_type_strings:91) else goto L11
L11:
    type_str = r19
    r20 = 'tuple'
    r21 = CPyStr_Startswith(type_str, r20)
    r22 = truncate r21: i32 to builtins.bool
    if r22 goto L12 else goto L42 :: bool
L12:
    r23 = 'components'
    r24 = CPyDict_GetItem(r16, r23)
    dec_ref r16
    if is_error(r24) goto L43 (error at get_type_strings:93) else goto L13
L13:
    inc_ref substitutions
    r25 = cast(dict, substitutions)
    if is_error(r25) goto L44 (error at get_type_strings:93) else goto L14
L14:
    r26 = cast(list, r24)
    if is_error(r26) goto L45 (error at get_type_strings:93) else goto L15
L15:
    r27 = get_type_strings(r26, r25)
    dec_ref r26
    dec_ref r25
    if is_error(r27) goto L43 (error at get_type_strings:93) else goto L16
L16:
    r28 = CPyStr_GetSlice(type_str, 10, 9223372036854775806)
    dec_ref type_str
    if is_error(r28) goto L46 (error at get_type_strings:94) else goto L17
L17:
    r29 = cast(str, r28)
    if is_error(r29) goto L46 (error at get_type_strings:94) else goto L18
L18:
    r30 = '('
    r31 = ','
    r32 = PyUnicode_Join(r31, r27)
    dec_ref r27
    if is_error(r32) goto L47 (error at get_type_strings:95) else goto L19
L19:
    r33 = ')'
    r34 = CPyStr_Build(4, r30, r32, r33, r29)
    dec_ref r32
    dec_ref r29
    if is_error(r34) goto L40 (error at get_type_strings:95) else goto L20
L20:
    r35 = PyList_Append(r1, r34)
    dec_ref r34
    r36 = r35 >= 0 :: signed
    if not r36 goto L40 (error at get_type_strings:95) else goto L32 :: bool
L21:
    inc_ref substitutions
    r37 = cast(dict, substitutions)
    if is_error(r37) goto L43 (error at get_type_strings:97) else goto L22
L22:
    r38 = 0
    r39 = PyDict_Size(r37)
    r40 = r39 << 1
    r41 = CPyDict_GetItemsIter(r37)
    if is_error(r41) goto L48 (error at get_type_strings:97) else goto L23
L23:
    r42 = CPyDict_NextItem(r41, r38)
    r43 = r42[1]
    r38 = r43
    r44 = r42[0]
    if r44 goto L24 else goto L49 :: bool
L24:
    r45 = r42[2]
    r46 = r42[3]
    dec_ref r42
    r47 = cast(str, r45)
    if is_error(r47) goto L50 (error at get_type_strings:97) else goto L25
L25:
    r48 = CPyStr_Startswith(type_str, r47)
    r49 = truncate r48: i32 to builtins.bool
    if r49 goto L26 else goto L51 :: bool
L26:
    r50 = 'replace'
    r51 = [type_str, r47, r46]
    r52 = load_address r51
    r53 = PyObject_VectorcallMethod(r50, r52, 9223372036854775811, 0)
    if is_error(r53) goto L52 (error at get_type_strings:99) else goto L27
L27:
    dec_ref type_str
    dec_ref r47
    dec_ref r46
    r54 = cast(str, r53)
    if is_error(r54) goto L53 (error at get_type_strings:99) else goto L28
L28:
    type_str = r54
L29:
    r55 = CPyDict_CheckSize(r37, r40)
    if not r55 goto L54 (error at get_type_strings:97) else goto L23 :: bool
L30:
    r56 = CPy_NoErrOccurred()
    if not r56 goto L43 (error at get_type_strings:97) else goto L31 :: bool
L31:
    r57 = PyList_Append(r1, type_str)
    dec_ref type_str
    r58 = r57 >= 0 :: signed
    if not r58 goto L40 (error at get_type_strings:100) else goto L32 :: bool
L32:
    r59 = r5 + 2
    r5 = r59
    goto L7
L33:
    return r1
L34:
    r60 = <error> :: list
    return r60
L35:
    inc_ref substitutions
    goto L2
L36:
    dec_ref substitutions
    goto L34
L37:
    dec_ref substitutions
    goto L4
L38:
    dec_ref r1
    goto L34
L39:
    dec_ref substitutions
    goto L33
L40:
    dec_ref substitutions
    dec_ref r1
    goto L34
L41:
    dec_ref substitutions
    dec_ref r1
    dec_ref r16
    goto L34
L42:
    dec_ref r16
    goto L21
L43:
    dec_ref substitutions
    dec_ref r1
    dec_ref type_str
    goto L34
L44:
    dec_ref substitutions
    dec_ref r1
    dec_ref type_str
    dec_ref r24
    goto L34
L45:
    dec_ref substitutions
    dec_ref r1
    dec_ref type_str
    dec_ref r25
    goto L34
L46:
    dec_ref substitutions
    dec_ref r1
    dec_ref r27
    goto L34
L47:
    dec_ref substitutions
    dec_ref r1
    dec_ref r29
    goto L34
L48:
    dec_ref substitutions
    dec_ref r1
    dec_ref type_str
    dec_ref r37
    goto L34
L49:
    dec_ref r37
    dec_ref r41
    dec_ref r42
    goto L30
L50:
    dec_ref substitutions
    dec_ref r1
    dec_ref type_str
    dec_ref r37
    dec_ref r41
    dec_ref r46
    goto L34
L51:
    dec_ref r47
    dec_ref r46
    goto L29
L52:
    dec_ref substitutions
    dec_ref r1
    dec_ref type_str
    dec_ref r37
    dec_ref r41
    dec_ref r47
    dec_ref r46
    goto L34
L53:
    dec_ref substitutions
    dec_ref r1
    dec_ref r37
    dec_ref r41
    goto L34
L54:
    dec_ref substitutions
    dec_ref r1
    dec_ref type_str
    dec_ref r37
    dec_ref r41
    goto L34

def build_function_signature(abi):
    abi :: dict
    r0 :: str
    r1 :: object
    r2 :: list
    r3 :: union[dict, None]
    r4 :: list
    r5 :: str
    r6 :: object
    r7, r8, r9, r10, r11, r12, r13 :: str
L0:
    r0 = 'inputs'
    r1 = CPyDict_GetItem(abi, r0)
    if is_error(r1) goto L8 (error at build_function_signature:106) else goto L1
L1:
    r2 = cast(list, r1)
    if is_error(r2) goto L8 (error at build_function_signature:106) else goto L2
L2:
    r3 = <error> :: union[dict, None]
    r4 = get_type_strings(r2, r3)
    dec_ref r2
    if is_error(r4) goto L8 (error at build_function_signature:106) else goto L3
L3:
    r5 = 'name'
    r6 = CPyDict_GetItem(abi, r5)
    if is_error(r6) goto L9 (error at build_function_signature:107) else goto L4
L4:
    r7 = PyObject_Str(r6)
    dec_ref r6
    if is_error(r7) goto L9 (error at build_function_signature:107) else goto L5
L5:
    r8 = '('
    r9 = ','
    r10 = PyUnicode_Join(r9, r4)
    dec_ref r4
    if is_error(r10) goto L10 (error at build_function_signature:107) else goto L6
L6:
    r11 = ')'
    r12 = CPyStr_Build(4, r7, r8, r10, r11)
    dec_ref r7
    dec_ref r10
    if is_error(r12) goto L8 (error at build_function_signature:107) else goto L7
L7:
    return r12
L8:
    r13 = <error> :: str
    return r13
L9:
    dec_ref r4
    goto L8
L10:
    dec_ref r7
    goto L8

def build_function_selector(input_signature):
    input_signature, r0 :: str
    r1 :: bytes
    r2 :: object
    r3 :: bool
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: str
    r8 :: object[1]
    r9 :: object_ptr
    r10, r11, r12, r13, r14, r15 :: object
    r16, r17, r18 :: str
L0:
    r0 = '0x'
    r1 = PyUnicode_AsUTF8String(input_signature)
    if is_error(r1) goto L11 (error at build_function_selector:111) else goto L1
L1:
    r2 = dank_mids.brownie_patch._abi.keccak :: static
    if is_error(r2) goto L12 else goto L4
L2:
    r3 = raise NameError('value for final name "keccak" was not set')
    if not r3 goto L11 (error at build_function_selector:111) else goto L3 :: bool
L3:
    unreachable
L4:
    r4 = [r1]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r2, r5, 1, 0)
    if is_error(r6) goto L13 (error at build_function_selector:111) else goto L5
L5:
    dec_ref r1
    r7 = 'hex'
    r8 = [r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775809, 0)
    if is_error(r10) goto L14 (error at build_function_selector:111) else goto L6
L6:
    dec_ref r6
    r11 = load_address _Py_NoneStruct
    r12 = load_address _Py_NoneStruct
    r13 = object 8
    r14 = PySlice_New(r11, r13, r12)
    if is_error(r14) goto L15 (error at build_function_selector:111) else goto L7
L7:
    r15 = PyObject_GetItem(r10, r14)
    dec_ref r10
    dec_ref r14
    if is_error(r15) goto L11 (error at build_function_selector:111) else goto L8
L8:
    r16 = PyObject_Str(r15)
    dec_ref r15
    if is_error(r16) goto L11 (error at build_function_selector:111) else goto L9
L9:
    r17 = CPyStr_Build(2, r0, r16)
    dec_ref r16
    if is_error(r17) goto L11 (error at build_function_selector:111) else goto L10
L10:
    return r17
L11:
    r18 = <error> :: str
    return r18
L12:
    dec_ref r1
    goto L2
L13:
    dec_ref r1
    goto L11
L14:
    dec_ref r6
    goto L11
L15:
    dec_ref r10
    goto L11

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24 :: object
    r25 :: dict
    r26 :: str
    r27 :: object
    r28 :: dict
    r29 :: str
    r30, r31 :: object
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: tuple[object, object]
    r36, r37, r38 :: object
    r39 :: tuple[object, object]
    r40, r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: dict
    r47 :: str
    r48, r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: dict
    r55 :: str
    r56 :: object
    r57 :: str
    r58 :: object
    r59 :: dict
    r60 :: str
    r61 :: i32
    r62 :: bit
    r63 :: dict
    r64 :: str
    r65 :: object
    r66 :: str
    r67 :: object
    r68 :: dict
    r69 :: str
    r70 :: i32
    r71 :: bit
    r72 :: dict
    r73 :: str
    r74 :: object
    r75 :: str
    r76 :: object
    r77 :: tuple
    r78 :: str
    r79, r80 :: object
    r81 :: bool
    r82, r83, r84, r85, r86 :: str
    r87 :: tuple
    r88 :: i32
    r89 :: bit
    r90 :: dict
    r91 :: str
    r92 :: i32
    r93 :: bit
    r94 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L32 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Dict', 'Final', 'List', 'Optional', 'Tuple', 'final')
    r6 = 'typing'
    r7 = dank_mids.brownie_patch._abi.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L32 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('WeakValueDictionary',)
    r10 = 'weakref'
    r11 = dank_mids.brownie_patch._abi.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L32 (error at <module>:2) else goto L5
L5:
    weakref = r12 :: module
    dec_ref r12
    r13 = ('auto',)
    r14 = 'eth_hash'
    r15 = dank_mids.brownie_patch._abi.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L32 (error at <module>:4) else goto L6
L6:
    eth_hash = r16 :: module
    dec_ref r16
    r17 = ('_nocompile',)
    r18 = 'dank_mids.brownie_patch'
    r19 = dank_mids.brownie_patch._abi.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L32 (error at <module>:6) else goto L7
L7:
    dank_mids.brownie_patch = r20 :: module
    dec_ref r20
    r21 = ('_helpers',)
    r22 = 'dank_mids.helpers'
    r23 = dank_mids.brownie_patch._abi.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L32 (error at <module>:7) else goto L8
L8:
    dank_mids.helpers = r24 :: module
    dec_ref r24
    r25 = dank_mids.brownie_patch._abi.globals :: static
    r26 = 'Tuple'
    r27 = CPyDict_GetItem(r25, r26)
    if is_error(r27) goto L32 (error at <module>:10) else goto L9
L9:
    r28 = dank_mids.brownie_patch._abi.globals :: static
    r29 = 'Tuple'
    r30 = CPyDict_GetItem(r28, r29)
    if is_error(r30) goto L33 (error at <module>:10) else goto L10
L10:
    r31 = load_address PyUnicode_Type
    r32 = dank_mids.brownie_patch._abi.globals :: static
    r33 = 'Any'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L34 (error at <module>:10) else goto L11
L11:
    inc_ref r31
    r35 = (r31, r34)
    r36 = box(tuple[object, object], r35)
    r37 = PyObject_GetItem(r30, r36)
    dec_ref r30
    dec_ref r36
    if is_error(r37) goto L33 (error at <module>:10) else goto L12
L12:
    r38 = load_address _Py_EllipsisObject
    inc_ref r38
    r39 = (r37, r38)
    r40 = box(tuple[object, object], r39)
    r41 = PyObject_GetItem(r27, r40)
    dec_ref r27
    dec_ref r40
    if is_error(r41) goto L32 (error at <module>:10) else goto L13
L13:
    r42 = dank_mids.brownie_patch._abi.globals :: static
    r43 = 'SingletonKey'
    r44 = CPyDict_SetItem(r42, r43, r41)
    dec_ref r41
    r45 = r44 >= 0 :: signed
    if not r45 goto L32 (error at <module>:10) else goto L14 :: bool
L14:
    r46 = dank_mids.brownie_patch._abi.globals :: static
    r47 = 'WeakValueDictionary'
    r48 = CPyDict_GetItem(r46, r47)
    if is_error(r48) goto L32 (error at <module>:12) else goto L15
L15:
    r49 = PyObject_Vectorcall(r48, 0, 0, 0)
    dec_ref r48
    if is_error(r49) goto L32 (error at <module>:12) else goto L16
L16:
    dank_mids.brownie_patch._abi._singletons = r49 :: static
    r50 = dank_mids.brownie_patch._abi.globals :: static
    r51 = '_singletons'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L32 (error at <module>:12) else goto L17 :: bool
L17:
    r54 = dank_mids.brownie_patch._abi.globals :: static
    r55 = 'auto'
    r56 = CPyDict_GetItem(r54, r55)
    if is_error(r56) goto L32 (error at <module>:15) else goto L18
L18:
    r57 = 'keccak'
    r58 = CPyObject_GetAttr(r56, r57)
    dec_ref r56
    if is_error(r58) goto L32 (error at <module>:15) else goto L19
L19:
    dank_mids.brownie_patch._abi.keccak = r58 :: static
    r59 = dank_mids.brownie_patch._abi.globals :: static
    r60 = 'keccak'
    r61 = CPyDict_SetItem(r59, r60, r58)
    dec_ref r58
    r62 = r61 >= 0 :: signed
    if not r62 goto L32 (error at <module>:15) else goto L20 :: bool
L20:
    r63 = dank_mids.brownie_patch._abi.globals :: static
    r64 = '_helpers'
    r65 = CPyDict_GetItem(r63, r64)
    if is_error(r65) goto L32 (error at <module>:17) else goto L21
L21:
    r66 = '_make_hashable'
    r67 = CPyObject_GetAttr(r65, r66)
    dec_ref r65
    if is_error(r67) goto L32 (error at <module>:17) else goto L22
L22:
    dank_mids.brownie_patch._abi._make_hashable = r67 :: static
    r68 = dank_mids.brownie_patch._abi.globals :: static
    r69 = '_make_hashable'
    r70 = CPyDict_SetItem(r68, r69, r67)
    dec_ref r67
    r71 = r70 >= 0 :: signed
    if not r71 goto L32 (error at <module>:17) else goto L23 :: bool
L23:
    r72 = dank_mids.brownie_patch._abi.globals :: static
    r73 = '_nocompile'
    r74 = CPyDict_GetItem(r72, r73)
    if is_error(r74) goto L32 (error at <module>:28) else goto L24
L24:
    r75 = '_FunctionABI'
    r76 = CPyObject_GetAttr(r74, r75)
    dec_ref r74
    if is_error(r76) goto L32 (error at <module>:28) else goto L25
L25:
    r77 = PyTuple_Pack(1, r76)
    dec_ref r76
    if is_error(r77) goto L32 (error at <module>:28) else goto L26
L26:
    r78 = 'dank_mids.brownie_patch._abi'
    r79 = dank_mids.brownie_patch._abi.FunctionABI_template :: type
    r80 = CPyType_FromTemplate(r79, r77, r78)
    dec_ref r77
    if is_error(r80) goto L32 (error at <module>:28) else goto L27
L27:
    r81 = FunctionABI_trait_vtable_setup()
    if is_error(r81) goto L35 (error at <module>:-1) else goto L28
L28:
    r82 = '__mypyc_attrs__'
    r83 = 'abi'
    r84 = 'input_sig'
    r85 = 'signature'
    r86 = '__dict__'
    r87 = PyTuple_Pack(4, r83, r84, r85, r86)
    if is_error(r87) goto L35 (error at <module>:28) else goto L29
L29:
    r88 = PyObject_SetAttr(r80, r82, r87)
    dec_ref r87
    r89 = r88 >= 0 :: signed
    if not r89 goto L35 (error at <module>:28) else goto L30 :: bool
L30:
    dank_mids.brownie_patch._abi.FunctionABI = r80 :: type
    r90 = dank_mids.brownie_patch._abi.globals :: static
    r91 = 'FunctionABI'
    r92 = CPyDict_SetItem(r90, r91, r80)
    dec_ref r80
    r93 = r92 >= 0 :: signed
    if not r93 goto L32 (error at <module>:28) else goto L31 :: bool
L31:
    return 1
L32:
    r94 = <error> :: None
    return r94
L33:
    dec_ref r27
    goto L32
L34:
    dec_ref r27
    dec_ref r30
    goto L32
L35:
    dec_ref r80
    goto L32

def Formatter.__init__(self, normalizers, types):
    self :: dank_mids._web3.abi.Formatter
    normalizers, types :: tuple
    r0 :: ptr
    r1 :: native_int
    r2 :: tuple
    r3 :: short_int
    r4 :: ptr
    r5 :: native_int
    r6 :: short_int
    r7 :: bit
    r8 :: object
    r9 :: dank_mids._web3.abi.map_to_typed_data
    r10 :: bit
    r11 :: short_int
    r12 :: ptr
    r13 :: native_int
    r14 :: list
    r15 :: short_int
    r16 :: ptr
    r17 :: native_int
    r18 :: short_int
    r19 :: bit
    r20 :: object
    r21 :: dict
    r22 :: str
    r23 :: object
    r24 :: i32
    r25 :: bit
    r26 :: bool
    r27 :: dict
    r28 :: str
    r29 :: object
    r30 :: object[1]
    r31 :: object_ptr
    r32, r33 :: object
    r34 :: bit
    r35 :: short_int
    r36 :: None
L0:
    r0 = get_element_ptr normalizers ob_size :: PyVarObject
    r1 = load_mem r0 :: native_int*
    r2 = PyTuple_New(r1)
    if is_error(r2) goto L21 (error at __init__:34) else goto L1
L1:
    r3 = 0
L2:
    r4 = get_element_ptr normalizers ob_size :: PyVarObject
    r5 = load_mem r4 :: native_int*
    r6 = r5 << 1
    r7 = r3 < r6 :: signed
    if r7 goto L3 else goto L7 :: bool
L3:
    r8 = CPySequenceTuple_GetItem(normalizers, r3)
    if is_error(r8) goto L22 (error at __init__:34) else goto L4
L4:
    r9 = get_data_tree_map(r8)
    dec_ref r8
    if is_error(r9) goto L22 (error at __init__:34) else goto L5
L5:
    r10 = CPySequenceTuple_SetItemUnsafe(r2, r3, r9)
    if not r10 goto L22 (error at __init__:34) else goto L6 :: bool
L6:
    r11 = r3 + 2
    r3 = r11
    goto L2
L7:
    self.normalizers = r2
    r12 = get_element_ptr types ob_size :: PyVarObject
    r13 = load_mem r12 :: native_int*
    r14 = PyList_New(r13)
    if is_error(r14) goto L21 (error at __init__:35) else goto L8
L8:
    r15 = 0
L9:
    r16 = get_element_ptr types ob_size :: PyVarObject
    r17 = load_mem r16 :: native_int*
    r18 = r17 << 1
    r19 = r15 < r18 :: signed
    if r19 goto L10 else goto L20 :: bool
L10:
    r20 = CPySequenceTuple_GetItem(types, r15)
    if is_error(r20) goto L23 (error at __init__:35) else goto L11
L11:
    r21 = dank_mids._web3.abi.globals :: static
    r22 = 'TypeStr'
    r23 = CPyDict_GetItem(r21, r22)
    if is_error(r23) goto L24 (error at __init__:35) else goto L12
L12:
    r24 = PyObject_IsInstance(r20, r23)
    dec_ref r23
    r25 = r24 >= 0 :: signed
    if not r25 goto L24 (error at __init__:35) else goto L13 :: bool
L13:
    r26 = truncate r24: i32 to builtins.bool
    if r26 goto L14 else goto L17 :: bool
L14:
    r27 = dank_mids._web3.abi.globals :: static
    r28 = 'parse'
    r29 = CPyDict_GetItem(r27, r28)
    if is_error(r29) goto L24 (error at __init__:35) else goto L15
L15:
    r30 = [r20]
    r31 = load_address r30
    r32 = PyObject_Vectorcall(r29, r31, 1, 0)
    dec_ref r29
    if is_error(r32) goto L24 (error at __init__:35) else goto L16
L16:
    dec_ref r20
    r33 = r32
    goto L18
L17:
    r33 = r20
L18:
    r34 = CPyList_SetItemUnsafe(r14, r15, r33)
    if not r34 goto L23 (error at __init__:35) else goto L19 :: bool
L19:
    r35 = r15 + 2
    r15 = r35
    goto L9
L20:
    self.types = r14
    return 1
L21:
    r36 = <error> :: None
    return r36
L22:
    dec_ref r2
    goto L21
L23:
    dec_ref r14
    goto L21
L24:
    dec_ref r14
    dec_ref r20
    goto L21

def Formatter.__call__(self, data):
    self :: dank_mids._web3.abi.Formatter
    data, r0 :: object
    r1 :: bool
    r2 :: list
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: object[3]
    r7 :: object_ptr
    r8 :: object
    r9 :: tuple
    r10 :: short_int
    r11 :: ptr
    r12 :: native_int
    r13 :: short_int
    r14 :: bit
    r15 :: object
    r16 :: dank_mids._web3.abi.map_to_typed_data
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20 :: short_int
    r21 :: object
    r22, r23 :: list
L0:
    r0 = dank_mids._web3.abi.abi_sub_tree :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "abi_sub_tree" was not set')
    if not r1 goto L15 (error at __call__:40) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = self.types
    r3 = builtins :: module
    r4 = 'map'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L16 (error at __call__:40) else goto L4
L4:
    r6 = [r0, r2, data]
    r7 = load_address r6
    r8 = PyObject_Vectorcall(r5, r7, 3, 0)
    dec_ref r5
    if is_error(r8) goto L16 (error at __call__:40) else goto L5
L5:
    dec_ref r2
    data = r8
    r9 = self.normalizers
    r10 = 0
L6:
    r11 = get_element_ptr r9 ob_size :: PyVarObject
    r12 = load_mem r11 :: native_int*
    r13 = r12 << 1
    r14 = r10 < r13 :: signed
    if r14 goto L7 else goto L17 :: bool
L7:
    r15 = CPySequenceTuple_GetItem(r9, r10)
    if is_error(r15) goto L18 (error at __call__:42) else goto L8
L8:
    r16 = cast(dank_mids._web3.abi.map_to_typed_data, r15)
    if is_error(r16) goto L18 (error at __call__:42) else goto L9
L9:
    r17 = [data]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r16, r18, 1, 0)
    dec_ref r16
    if is_error(r19) goto L18 (error at __call__:43) else goto L10
L10:
    dec_ref data
    data = r19
L11:
    r20 = r10 + 2
    r10 = r20
    goto L6
L12:
    r21 = strip_abi_types(data)
    dec_ref data
    if is_error(r21) goto L15 (error at __call__:45) else goto L13
L13:
    r22 = PySequence_List(r21)
    dec_ref r21
    if is_error(r22) goto L15 (error at __call__:45) else goto L14
L14:
    return r22
L15:
    r23 = <error> :: list
    return r23
L16:
    dec_ref r2
    goto L15
L17:
    dec_ref r9
    goto L12
L18:
    dec_ref data
    dec_ref r9
    goto L15

def get_formatter(normalizers, types):
    normalizers, types :: tuple
    r0 :: dict
    r1 :: bool
    r2 :: tuple[tuple, tuple]
    r3, r4 :: object
    r5, mapper :: union[dank_mids._web3.abi.Formatter, None]
    r6 :: object
    r7 :: bit
    r8 :: dank_mids._web3.abi.Formatter
    r9 :: dict
    r10 :: bool
    r11 :: tuple[tuple, tuple]
    r12 :: object
    r13 :: i32
    r14 :: bit
    r15, r16 :: dank_mids._web3.abi.Formatter
L0:
    r0 = dank_mids._web3.abi._formatters :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_formatters" was not set')
    if not r1 goto L13 (error at get_formatter:56) else goto L2 :: bool
L2:
    unreachable
L3:
    inc_ref normalizers
    inc_ref types
    r2 = (normalizers, types)
    r3 = box(tuple[tuple, tuple], r2)
    r4 = CPyDict_GetWithNone(r0, r3)
    dec_ref r3
    if is_error(r4) goto L13 (error at get_formatter:56) else goto L4
L4:
    r5 = cast(union[dank_mids._web3.abi.Formatter, None], r4)
    if is_error(r5) goto L13 (error at get_formatter:56) else goto L5
L5:
    mapper = r5
    r6 = load_address _Py_NoneStruct
    r7 = mapper == r6
    if r7 goto L14 else goto L11 :: bool
L6:
    r8 = Formatter(normalizers, types)
    if is_error(r8) goto L13 (error at get_formatter:58) else goto L7
L7:
    inc_ref r8
    mapper = r8
    r9 = dank_mids._web3.abi._formatters :: static
    if is_error(r9) goto L15 else goto L10
L8:
    r10 = raise NameError('value for final name "_formatters" was not set')
    if not r10 goto L13 (error at get_formatter:58) else goto L9 :: bool
L9:
    unreachable
L10:
    inc_ref normalizers
    inc_ref types
    r11 = (normalizers, types)
    r12 = box(tuple[tuple, tuple], r11)
    r13 = CPyDict_SetItem(r9, r12, r8)
    dec_ref r12
    dec_ref r8
    r14 = r13 >= 0 :: signed
    if not r14 goto L16 (error at get_formatter:58) else goto L11 :: bool
L11:
    r15 = cast(dank_mids._web3.abi.Formatter, mapper)
    if is_error(r15) goto L13 (error at get_formatter:59) else goto L12
L12:
    return r15
L13:
    r16 = <error> :: dank_mids._web3.abi.Formatter
    return r16
L14:
    dec_ref mapper
    goto L6
L15:
    dec_ref mapper
    dec_ref r8
    goto L8
L16:
    dec_ref mapper
    goto L13

def get_data_tree_map(func):
    func :: object
    r0 :: dict
    r1 :: bool
    r2 :: object
    r3, f :: union[dank_mids._web3.abi.map_to_typed_data, None]
    r4 :: object
    r5 :: bit
    r6 :: dank_mids._web3.abi.map_to_typed_data
    r7 :: dict
    r8 :: bool
    r9 :: i32
    r10 :: bit
    r11, r12 :: dank_mids._web3.abi.map_to_typed_data
L0:
    r0 = dank_mids._web3.abi._data_tree_maps :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_data_tree_maps" was not set')
    if not r1 goto L13 (error at get_data_tree_map:68) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = CPyDict_GetWithNone(r0, func)
    if is_error(r2) goto L13 (error at get_data_tree_map:68) else goto L4
L4:
    r3 = cast(union[dank_mids._web3.abi.map_to_typed_data, None], r2)
    if is_error(r3) goto L13 (error at get_data_tree_map:68) else goto L5
L5:
    f = r3
    r4 = load_address _Py_NoneStruct
    r5 = f == r4
    if r5 goto L14 else goto L11 :: bool
L6:
    r6 = map_to_typed_data(func)
    if is_error(r6) goto L13 (error at get_data_tree_map:70) else goto L7
L7:
    inc_ref r6
    f = r6
    r7 = dank_mids._web3.abi._data_tree_maps :: static
    if is_error(r7) goto L15 else goto L10
L8:
    r8 = raise NameError('value for final name "_data_tree_maps" was not set')
    if not r8 goto L13 (error at get_data_tree_map:70) else goto L9 :: bool
L9:
    unreachable
L10:
    r9 = CPyDict_SetItem(r7, func, r6)
    dec_ref r6
    r10 = r9 >= 0 :: signed
    if not r10 goto L16 (error at get_data_tree_map:70) else goto L11 :: bool
L11:
    r11 = cast(dank_mids._web3.abi.map_to_typed_data, f)
    if is_error(r11) goto L13 (error at get_data_tree_map:71) else goto L12
L12:
    return r11
L13:
    r12 = <error> :: dank_mids._web3.abi.map_to_typed_data
    return r12
L14:
    dec_ref f
    goto L6
L15:
    dec_ref f
    dec_ref r6
    goto L8
L16:
    dec_ref f
    goto L13

def map_to_typed_data.__init__(self, func):
    self :: dank_mids._web3.abi.map_to_typed_data
    func :: object
L0:
    inc_ref func
    self.func = func
    return 1

def map_to_typed_data.__call__(self, elements):
    self :: dank_mids._web3.abi.map_to_typed_data
    elements, r0, r1 :: object
    r2 :: bit
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: bit
    r7 :: list
    r8, r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: i32
    r14, r15 :: bit
    r16 :: object
    r17 :: bit
    r18 :: list
    r19, r20 :: object
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: i32
    r25, r26 :: bit
    r27 :: tuple
    r28 :: object
    r29 :: bool
    r30 :: i32
    r31 :: bit
    r32 :: bool
    r33 :: list
    r34 :: str
    r35 :: object[1]
    r36 :: object_ptr
    r37, r38, r39 :: object
    r40 :: tuple[object, object]
    r41, r42 :: object
    r43 :: object[1]
    r44 :: object_ptr
    r45 :: object
    r46 :: tuple[object, object]
    r47 :: object
    r48 :: i32
    r49, r50 :: bit
    r51 :: object
    r52 :: object[1]
    r53 :: object_ptr
    r54, r55, r56, r57 :: object
    r58 :: str
    r59 :: object
    r60 :: tuple[object, object, object]
    r61 :: object
    r62 :: i32
    r63 :: bit
    r64 :: bool
    r65 :: object
    r66 :: bool
    r67 :: i32
    r68 :: bit
    r69 :: bool
    r70 :: object
    r71 :: str
    r72 :: object
    r73 :: object[2]
    r74 :: object_ptr
    r75 :: object
    r76 :: object[1]
    r77 :: object_ptr
    r78, r79 :: object
    r80 :: bool
    r81 :: i32
    r82 :: bit
    r83 :: bool
    r84 :: str
    r85, r86 :: object
    r87 :: bit
    r88 :: str
    r89 :: object
    r90 :: list
    r91 :: object
    r92 :: tuple
    r93 :: dict
    r94 :: object
    r95 :: tuple[object, object]
    r96 :: object
    r97 :: bool
    r98 :: object
    r99 :: object[1]
    r100 :: object_ptr
    r101, r102 :: object
L0:
    r0 = PyObject_Type(elements)
    r1 = load_address PyList_Type
    r2 = r0 == r1
    if r2 goto L68 else goto L1 :: bool
L1:
    r3 = builtins :: module
    r4 = 'map'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L69 (error at __call__:81) else goto L2
L2:
    r6 = r0 == r5
    dec_ref r5
    if r6 goto L68 else goto L10 :: bool
L3:
    r7 = PyList_New(0)
    if is_error(r7) goto L67 (error at __call__:82) else goto L4
L4:
    r8 = PyObject_GetIter(elements)
    if is_error(r8) goto L70 (error at __call__:82) else goto L5
L5:
    r9 = PyIter_Next(r8)
    if is_error(r9) goto L71 else goto L6
L6:
    r10 = [r9]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(self, r11, 1, 0)
    if is_error(r12) goto L72 (error at __call__:82) else goto L7
L7:
    dec_ref r9
    r13 = PyList_Append(r7, r12)
    dec_ref r12
    r14 = r13 >= 0 :: signed
    if not r14 goto L73 (error at __call__:82) else goto L5 :: bool
L8:
    r15 = CPy_NoErrOccurred()
    if not r15 goto L70 (error at __call__:82) else goto L9 :: bool
L9:
    return r7
L10:
    r16 = load_address PyTuple_Type
    r17 = r0 == r16
    if r17 goto L74 else goto L19 :: bool
L11:
    r18 = PyList_New(0)
    if is_error(r18) goto L67 (error at __call__:84) else goto L12
L12:
    r19 = PyObject_GetIter(elements)
    if is_error(r19) goto L75 (error at __call__:84) else goto L13
L13:
    r20 = PyIter_Next(r19)
    if is_error(r20) goto L76 else goto L14
L14:
    r21 = [r20]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(self, r22, 1, 0)
    if is_error(r23) goto L77 (error at __call__:84) else goto L15
L15:
    dec_ref r20
    r24 = PyList_Append(r18, r23)
    dec_ref r23
    r25 = r24 >= 0 :: signed
    if not r25 goto L78 (error at __call__:84) else goto L13 :: bool
L16:
    r26 = CPy_NoErrOccurred()
    if not r26 goto L75 (error at __call__:84) else goto L17 :: bool
L17:
    r27 = PyList_AsTuple(r18)
    dec_ref r18
    if is_error(r27) goto L67 (error at __call__:84) else goto L18
L18:
    return r27
L19:
    r28 = dank_mids._web3.abi.Mapping :: static
    if is_error(r28) goto L79 else goto L22
L20:
    r29 = raise NameError('value for final name "Mapping" was not set')
    if not r29 goto L67 (error at __call__:85) else goto L21 :: bool
L21:
    unreachable
L22:
    r30 = PyObject_IsInstance(elements, r28)
    r31 = r30 >= 0 :: signed
    if not r31 goto L69 (error at __call__:85) else goto L23 :: bool
L23:
    r32 = truncate r30: i32 to builtins.bool
    if r32 goto L24 else goto L35 :: bool
L24:
    r33 = PyList_New(0)
    if is_error(r33) goto L69 (error at __call__:86) else goto L25
L25:
    r34 = 'items'
    r35 = [elements]
    r36 = load_address r35
    r37 = PyObject_VectorcallMethod(r34, r36, 9223372036854775809, 0)
    if is_error(r37) goto L80 (error at __call__:86) else goto L26
L26:
    r38 = PyObject_GetIter(r37)
    dec_ref r37
    if is_error(r38) goto L80 (error at __call__:86) else goto L27
L27:
    r39 = PyIter_Next(r38)
    if is_error(r39) goto L81 else goto L28
L28:
    r40 = unbox(tuple[object, object], r39)
    dec_ref r39
    if is_error(r40) goto L82 (error at __call__:86) else goto L29
L29:
    r41 = r40[0]
    r42 = r40[1]
    dec_ref r40
    r43 = [r42]
    r44 = load_address r43
    r45 = PyObject_Vectorcall(self, r44, 1, 0)
    if is_error(r45) goto L83 (error at __call__:86) else goto L30
L30:
    dec_ref r42
    r46 = (r41, r45)
    r47 = box(tuple[object, object], r46)
    r48 = PyList_Append(r33, r47)
    dec_ref r47
    r49 = r48 >= 0 :: signed
    if not r49 goto L82 (error at __call__:86) else goto L27 :: bool
L31:
    r50 = CPy_NoErrOccurred()
    if not r50 goto L80 (error at __call__:86) else goto L32 :: bool
L32:
    r51 = PyObject_GetIter(r33)
    dec_ref r33
    if is_error(r51) goto L69 (error at __call__:86) else goto L33
L33:
    r52 = [r51]
    r53 = load_address r52
    r54 = PyObject_Vectorcall(r0, r53, 1, 0)
    dec_ref r0
    if is_error(r54) goto L84 (error at __call__:86) else goto L34
L34:
    dec_ref r51
    return r54
L35:
    r55 = load_address PyBytes_Type
    r56 = load_address PyUnicode_Type
    r57 = builtins :: module
    r58 = 'bytearray'
    r59 = CPyObject_GetAttr(r57, r58)
    if is_error(r59) goto L69 (error at __call__:87) else goto L36
L36:
    inc_ref r55
    inc_ref r56
    r60 = (r55, r56, r59)
    r61 = box(tuple[object, object, object], r60)
    r62 = PyObject_IsInstance(elements, r61)
    dec_ref r61
    r63 = r62 >= 0 :: signed
    if not r63 goto L69 (error at __call__:87) else goto L37 :: bool
L37:
    r64 = truncate r62: i32 to builtins.bool
    if r64 goto L85 else goto L38 :: bool
L38:
    r65 = dank_mids._web3.abi.Iterable :: static
    if is_error(r65) goto L86 else goto L41
L39:
    r66 = raise NameError('value for final name "Iterable" was not set')
    if not r66 goto L67 (error at __call__:87) else goto L40 :: bool
L40:
    unreachable
L41:
    r67 = PyObject_IsInstance(elements, r65)
    r68 = r67 >= 0 :: signed
    if not r68 goto L69 (error at __call__:87) else goto L42 :: bool
L42:
    r69 = truncate r67: i32 to builtins.bool
    if r69 goto L43 else goto L85 :: bool
L43:
    r70 = builtins :: module
    r71 = 'map'
    r72 = CPyObject_GetAttr(r70, r71)
    if is_error(r72) goto L69 (error at __call__:88) else goto L44
L44:
    r73 = [self, elements]
    r74 = load_address r73
    r75 = PyObject_Vectorcall(r72, r74, 2, 0)
    dec_ref r72
    if is_error(r75) goto L69 (error at __call__:88) else goto L45
L45:
    r76 = [r75]
    r77 = load_address r76
    r78 = PyObject_Vectorcall(r0, r77, 1, 0)
    dec_ref r0
    if is_error(r78) goto L87 (error at __call__:88) else goto L46
L46:
    dec_ref r75
    return r78
L47:
    r79 = dank_mids._web3.abi.ABITypedData :: static
    if is_error(r79) goto L48 else goto L50
L48:
    r80 = raise NameError('value for final name "ABITypedData" was not set')
    if not r80 goto L67 (error at __call__:89) else goto L49 :: bool
L49:
    unreachable
L50:
    r81 = PyObject_IsInstance(elements, r79)
    r82 = r81 >= 0 :: signed
    if not r82 goto L67 (error at __call__:89) else goto L51 :: bool
L51:
    r83 = truncate r81: i32 to builtins.bool
    if r83 goto L52 else goto L66 :: bool
L52:
    r84 = 'abi_type'
    r85 = CPyObject_GetAttr(elements, r84)
    if is_error(r85) goto L67 (error at __call__:89) else goto L53
L53:
    r86 = load_address _Py_NoneStruct
    r87 = r85 != r86
    dec_ref r85
    if r87 goto L54 else goto L66 :: bool
L54:
    r88 = 'func'
    r89 = CPyObject_GetAttr(self, r88)
    if is_error(r89) goto L67 (error at __call__:90) else goto L55
L55:
    r90 = PyList_New(0)
    if is_error(r90) goto L88 (error at __call__:90) else goto L56
L56:
    r91 = CPyList_Extend(r90, elements)
    if is_error(r91) goto L89 (error at __call__:90) else goto L90
L57:
    r92 = PyList_AsTuple(r90)
    dec_ref r90
    if is_error(r92) goto L88 (error at __call__:90) else goto L58
L58:
    r93 = PyDict_New()
    if is_error(r93) goto L91 (error at __call__:90) else goto L59
L59:
    r94 = PyObject_Call(r89, r92, r93)
    dec_ref r89
    dec_ref r92
    dec_ref r93
    if is_error(r94) goto L67 (error at __call__:90) else goto L60
L60:
    r95 = unbox(tuple[object, object], r94)
    dec_ref r94
    if is_error(r95) goto L67 (error at __call__:90) else goto L61
L61:
    r96 = dank_mids._web3.abi.ABITypedData :: static
    if is_error(r96) goto L92 else goto L64
L62:
    r97 = raise NameError('value for final name "ABITypedData" was not set')
    if not r97 goto L67 (error at __call__:90) else goto L63 :: bool
L63:
    unreachable
L64:
    r98 = box(tuple[object, object], r95)
    r99 = [r98]
    r100 = load_address r99
    r101 = PyObject_Vectorcall(r96, r100, 1, 0)
    if is_error(r101) goto L93 (error at __call__:90) else goto L65
L65:
    dec_ref r98
    return r101
L66:
    inc_ref elements
    return elements
L67:
    r102 = <error> :: object
    return r102
L68:
    dec_ref r0
    goto L3
L69:
    dec_ref r0
    goto L67
L70:
    dec_ref r7
    goto L67
L71:
    dec_ref r8
    goto L8
L72:
    dec_ref r7
    dec_ref r8
    dec_ref r9
    goto L67
L73:
    dec_ref r7
    dec_ref r8
    goto L67
L74:
    dec_ref r0
    goto L11
L75:
    dec_ref r18
    goto L67
L76:
    dec_ref r19
    goto L16
L77:
    dec_ref r18
    dec_ref r19
    dec_ref r20
    goto L67
L78:
    dec_ref r18
    dec_ref r19
    goto L67
L79:
    dec_ref r0
    goto L20
L80:
    dec_ref r0
    dec_ref r33
    goto L67
L81:
    dec_ref r38
    goto L31
L82:
    dec_ref r0
    dec_ref r33
    dec_ref r38
    goto L67
L83:
    dec_ref r0
    dec_ref r33
    dec_ref r38
    dec_ref r41
    dec_ref r42
    goto L67
L84:
    dec_ref r51
    goto L67
L85:
    dec_ref r0
    goto L47
L86:
    dec_ref r0
    goto L39
L87:
    dec_ref r75
    goto L67
L88:
    dec_ref r89
    goto L67
L89:
    dec_ref r89
    dec_ref r90
    goto L67
L90:
    dec_ref r91
    goto L57
L91:
    dec_ref r89
    dec_ref r92
    goto L67
L92:
    dec_ref r95
    goto L62
L93:
    dec_ref r98
    goto L67

def strip_abi_types(data):
    data, r0, r1 :: object
    r2 :: bit
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: bit
    r7 :: list
    r8, r9, r10 :: object
    r11 :: i32
    r12, r13 :: bit
    r14 :: object
    r15 :: bit
    r16 :: list
    r17, r18, r19 :: object
    r20 :: i32
    r21, r22 :: bit
    r23 :: tuple
    r24 :: object
    r25 :: bool
    r26 :: i32
    r27 :: bit
    r28 :: bool
    r29 :: list
    r30 :: str
    r31 :: object[1]
    r32 :: object_ptr
    r33, r34, r35 :: object
    r36 :: tuple[object, object]
    r37, r38, r39 :: object
    r40 :: tuple[object, object]
    r41 :: object
    r42 :: i32
    r43, r44 :: bit
    r45 :: object
    r46 :: object[1]
    r47 :: object_ptr
    r48, r49, r50, r51 :: object
    r52 :: str
    r53 :: object
    r54 :: tuple[object, object, object]
    r55 :: object
    r56 :: i32
    r57 :: bit
    r58 :: bool
    r59 :: object
    r60 :: bool
    r61 :: i32
    r62 :: bit
    r63 :: bool
    r64 :: dict
    r65 :: str
    r66, r67 :: object
    r68 :: str
    r69 :: object
    r70 :: object[2]
    r71 :: object_ptr
    r72 :: object
    r73 :: object[1]
    r74 :: object_ptr
    r75, r76 :: object
    r77 :: bool
    r78 :: i32
    r79 :: bit
    r80 :: bool
    r81 :: str
    r82, r83 :: object
L0:
    r0 = PyObject_Type(data)
    r1 = load_address PyList_Type
    r2 = r0 == r1
    if r2 goto L57 else goto L1 :: bool
L1:
    r3 = builtins :: module
    r4 = 'map'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L58 (error at strip_abi_types:97) else goto L2
L2:
    r6 = r0 == r5
    dec_ref r5
    if r6 goto L57 else goto L10 :: bool
L3:
    r7 = PyList_New(0)
    if is_error(r7) goto L56 (error at strip_abi_types:98) else goto L4
L4:
    r8 = PyObject_GetIter(data)
    if is_error(r8) goto L59 (error at strip_abi_types:98) else goto L5
L5:
    r9 = PyIter_Next(r8)
    if is_error(r9) goto L60 else goto L6
L6:
    r10 = strip_abi_types(r9)
    dec_ref r9
    if is_error(r10) goto L61 (error at strip_abi_types:98) else goto L7
L7:
    r11 = PyList_Append(r7, r10)
    dec_ref r10
    r12 = r11 >= 0 :: signed
    if not r12 goto L61 (error at strip_abi_types:98) else goto L5 :: bool
L8:
    r13 = CPy_NoErrOccurred()
    if not r13 goto L59 (error at strip_abi_types:98) else goto L9 :: bool
L9:
    return r7
L10:
    r14 = load_address PyTuple_Type
    r15 = r0 == r14
    if r15 goto L62 else goto L19 :: bool
L11:
    r16 = PyList_New(0)
    if is_error(r16) goto L56 (error at strip_abi_types:100) else goto L12
L12:
    r17 = PyObject_GetIter(data)
    if is_error(r17) goto L63 (error at strip_abi_types:100) else goto L13
L13:
    r18 = PyIter_Next(r17)
    if is_error(r18) goto L64 else goto L14
L14:
    r19 = strip_abi_types(r18)
    dec_ref r18
    if is_error(r19) goto L65 (error at strip_abi_types:100) else goto L15
L15:
    r20 = PyList_Append(r16, r19)
    dec_ref r19
    r21 = r20 >= 0 :: signed
    if not r21 goto L65 (error at strip_abi_types:100) else goto L13 :: bool
L16:
    r22 = CPy_NoErrOccurred()
    if not r22 goto L63 (error at strip_abi_types:100) else goto L17 :: bool
L17:
    r23 = PyList_AsTuple(r16)
    dec_ref r16
    if is_error(r23) goto L56 (error at strip_abi_types:100) else goto L18
L18:
    return r23
L19:
    r24 = dank_mids._web3.abi.Mapping :: static
    if is_error(r24) goto L66 else goto L22
L20:
    r25 = raise NameError('value for final name "Mapping" was not set')
    if not r25 goto L56 (error at strip_abi_types:101) else goto L21 :: bool
L21:
    unreachable
L22:
    r26 = PyObject_IsInstance(data, r24)
    r27 = r26 >= 0 :: signed
    if not r27 goto L58 (error at strip_abi_types:101) else goto L23 :: bool
L23:
    r28 = truncate r26: i32 to builtins.bool
    if r28 goto L24 else goto L35 :: bool
L24:
    r29 = PyList_New(0)
    if is_error(r29) goto L58 (error at strip_abi_types:102) else goto L25
L25:
    r30 = 'items'
    r31 = [data]
    r32 = load_address r31
    r33 = PyObject_VectorcallMethod(r30, r32, 9223372036854775809, 0)
    if is_error(r33) goto L67 (error at strip_abi_types:102) else goto L26
L26:
    r34 = PyObject_GetIter(r33)
    dec_ref r33
    if is_error(r34) goto L67 (error at strip_abi_types:102) else goto L27
L27:
    r35 = PyIter_Next(r34)
    if is_error(r35) goto L68 else goto L28
L28:
    r36 = unbox(tuple[object, object], r35)
    dec_ref r35
    if is_error(r36) goto L69 (error at strip_abi_types:102) else goto L29
L29:
    r37 = r36[0]
    r38 = r36[1]
    dec_ref r36
    r39 = strip_abi_types(r38)
    dec_ref r38
    if is_error(r39) goto L70 (error at strip_abi_types:102) else goto L30
L30:
    r40 = (r37, r39)
    r41 = box(tuple[object, object], r40)
    r42 = PyList_Append(r29, r41)
    dec_ref r41
    r43 = r42 >= 0 :: signed
    if not r43 goto L69 (error at strip_abi_types:102) else goto L27 :: bool
L31:
    r44 = CPy_NoErrOccurred()
    if not r44 goto L67 (error at strip_abi_types:102) else goto L32 :: bool
L32:
    r45 = PyObject_GetIter(r29)
    dec_ref r29
    if is_error(r45) goto L58 (error at strip_abi_types:102) else goto L33
L33:
    r46 = [r45]
    r47 = load_address r46
    r48 = PyObject_Vectorcall(r0, r47, 1, 0)
    dec_ref r0
    if is_error(r48) goto L71 (error at strip_abi_types:102) else goto L34
L34:
    dec_ref r45
    return r48
L35:
    r49 = load_address PyBytes_Type
    r50 = load_address PyUnicode_Type
    r51 = builtins :: module
    r52 = 'bytearray'
    r53 = CPyObject_GetAttr(r51, r52)
    if is_error(r53) goto L58 (error at strip_abi_types:103) else goto L36
L36:
    inc_ref r49
    inc_ref r50
    r54 = (r49, r50, r53)
    r55 = box(tuple[object, object, object], r54)
    r56 = PyObject_IsInstance(data, r55)
    dec_ref r55
    r57 = r56 >= 0 :: signed
    if not r57 goto L58 (error at strip_abi_types:103) else goto L37 :: bool
L37:
    r58 = truncate r56: i32 to builtins.bool
    if r58 goto L72 else goto L38 :: bool
L38:
    r59 = dank_mids._web3.abi.Iterable :: static
    if is_error(r59) goto L73 else goto L41
L39:
    r60 = raise NameError('value for final name "Iterable" was not set')
    if not r60 goto L56 (error at strip_abi_types:103) else goto L40 :: bool
L40:
    unreachable
L41:
    r61 = PyObject_IsInstance(data, r59)
    r62 = r61 >= 0 :: signed
    if not r62 goto L58 (error at strip_abi_types:103) else goto L42 :: bool
L42:
    r63 = truncate r61: i32 to builtins.bool
    if r63 goto L43 else goto L72 :: bool
L43:
    r64 = dank_mids._web3.abi.globals :: static
    r65 = 'strip_abi_types'
    r66 = CPyDict_GetItem(r64, r65)
    if is_error(r66) goto L58 (error at strip_abi_types:104) else goto L44
L44:
    r67 = builtins :: module
    r68 = 'map'
    r69 = CPyObject_GetAttr(r67, r68)
    if is_error(r69) goto L74 (error at strip_abi_types:104) else goto L45
L45:
    r70 = [r66, data]
    r71 = load_address r70
    r72 = PyObject_Vectorcall(r69, r71, 2, 0)
    dec_ref r69
    if is_error(r72) goto L74 (error at strip_abi_types:104) else goto L46
L46:
    dec_ref r66
    r73 = [r72]
    r74 = load_address r73
    r75 = PyObject_Vectorcall(r0, r74, 1, 0)
    dec_ref r0
    if is_error(r75) goto L75 (error at strip_abi_types:104) else goto L47
L47:
    dec_ref r72
    return r75
L48:
    r76 = dank_mids._web3.abi.ABITypedData :: static
    if is_error(r76) goto L49 else goto L51
L49:
    r77 = raise NameError('value for final name "ABITypedData" was not set')
    if not r77 goto L56 (error at strip_abi_types:105) else goto L50 :: bool
L50:
    unreachable
L51:
    r78 = PyObject_IsInstance(data, r76)
    r79 = r78 >= 0 :: signed
    if not r79 goto L56 (error at strip_abi_types:105) else goto L52 :: bool
L52:
    r80 = truncate r78: i32 to builtins.bool
    if r80 goto L53 else goto L55 :: bool
L53:
    r81 = 'data'
    r82 = CPyObject_GetAttr(data, r81)
    if is_error(r82) goto L56 (error at strip_abi_types:106) else goto L54
L54:
    return r82
L55:
    inc_ref data
    return data
L56:
    r83 = <error> :: object
    return r83
L57:
    dec_ref r0
    goto L3
L58:
    dec_ref r0
    goto L56
L59:
    dec_ref r7
    goto L56
L60:
    dec_ref r8
    goto L8
L61:
    dec_ref r7
    dec_ref r8
    goto L56
L62:
    dec_ref r0
    goto L11
L63:
    dec_ref r16
    goto L56
L64:
    dec_ref r17
    goto L16
L65:
    dec_ref r16
    dec_ref r17
    goto L56
L66:
    dec_ref r0
    goto L20
L67:
    dec_ref r0
    dec_ref r29
    goto L56
L68:
    dec_ref r34
    goto L31
L69:
    dec_ref r0
    dec_ref r29
    dec_ref r34
    goto L56
L70:
    dec_ref r0
    dec_ref r29
    dec_ref r34
    dec_ref r37
    goto L56
L71:
    dec_ref r45
    goto L56
L72:
    dec_ref r0
    goto L48
L73:
    dec_ref r0
    goto L39
L74:
    dec_ref r0
    dec_ref r66
    goto L56
L75:
    dec_ref r72
    goto L56

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: dict
    r30 :: object
    r31 :: str
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: object[1]
    r36 :: object_ptr
    r37 :: object
    r38 :: dict
    r39 :: str
    r40 :: i32
    r41 :: bit
    r42 :: dict
    r43 :: str
    r44 :: object
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: dict
    r49 :: str
    r50 :: object
    r51 :: list
    r52, r53, r54 :: ptr
    r55 :: dict
    r56 :: str
    r57 :: object
    r58 :: dict
    r59 :: str
    r60 :: object
    r61 :: dict
    r62 :: str
    r63 :: object
    r64 :: tuple[object, object]
    r65, r66 :: object
    r67 :: tuple[list, object]
    r68, r69 :: object
    r70 :: dict
    r71 :: str
    r72 :: i32
    r73 :: bit
    r74 :: dict
    r75 :: str
    r76 :: object
    r77 :: dict
    r78 :: str
    r79 :: object
    r80 :: dict
    r81 :: str
    r82, r83 :: object
    r84 :: tuple[object, object]
    r85, r86 :: object
    r87 :: dict
    r88 :: str
    r89 :: object
    r90 :: dict
    r91 :: str
    r92, r93 :: object
    r94 :: tuple[object, object]
    r95, r96 :: object
    r97 :: tuple[object, object]
    r98, r99 :: object
    r100 :: dict
    r101 :: str
    r102 :: i32
    r103 :: bit
    r104 :: dict
    r105 :: str
    r106 :: object
    r107 :: dict
    r108 :: str
    r109 :: object
    r110 :: dict
    r111 :: str
    r112 :: object
    r113 :: list
    r114, r115, r116 :: ptr
    r117 :: dict
    r118 :: str
    r119 :: object
    r120 :: dict
    r121 :: str
    r122 :: object
    r123 :: dict
    r124 :: str
    r125 :: object
    r126 :: tuple[object, object]
    r127, r128 :: object
    r129 :: tuple[list, object]
    r130, r131 :: object
    r132 :: dict
    r133 :: str
    r134 :: i32
    r135 :: bit
    r136 :: object
    r137 :: str
    r138 :: object
    r139 :: dict
    r140 :: str
    r141 :: i32
    r142 :: bit
    r143 :: object
    r144 :: str
    r145 :: object
    r146 :: dict
    r147 :: str
    r148 :: i32
    r149 :: bit
    r150 :: dict
    r151 :: str
    r152 :: object
    r153 :: str
    r154 :: object
    r155 :: dict
    r156 :: str
    r157 :: i32
    r158 :: bit
    r159 :: dict
    r160 :: str
    r161 :: object
    r162 :: str
    r163 :: object
    r164 :: dict
    r165 :: str
    r166 :: i32
    r167 :: bit
    r168 :: object
    r169 :: str
    r170, r171 :: object
    r172 :: bool
    r173, r174, r175 :: str
    r176 :: tuple
    r177 :: i32
    r178 :: bit
    r179 :: dict
    r180 :: str
    r181 :: i32
    r182 :: bit
    r183, r184 :: dict
    r185 :: str
    r186 :: i32
    r187 :: bit
    r188, r189 :: dict
    r190 :: str
    r191 :: i32
    r192 :: bit
    r193 :: object
    r194 :: str
    r195, r196 :: object
    r197 :: bool
    r198, r199 :: str
    r200 :: tuple
    r201 :: i32
    r202 :: bit
    r203 :: dict
    r204 :: str
    r205 :: i32
    r206 :: bit
    r207 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L65 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address typing :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('typing', 'typing', 'typing'),)
    r11 = dank_mids._web3.abi.globals :: static
    r12 = 'dank_mids\\_web3\\abi.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L65 else goto L4 :: bool
L4:
    r15 = ('Any', 'Callable', 'Dict', 'Final', 'Iterator', 'List', 'Tuple', 'TypeVar', 'final')
    r16 = 'typing'
    r17 = dank_mids._web3.abi.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L65 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = ('parse',)
    r20 = 'eth_abi.grammar'
    r21 = dank_mids._web3.abi.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L65 (error at <module>:4) else goto L6
L6:
    eth_abi.grammar = r22 :: module
    dec_ref r22
    r23 = ('TypeStr',)
    r24 = 'eth_typing'
    r25 = dank_mids._web3.abi.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L65 (error at <module>:5) else goto L7
L7:
    eth_typing = r26 :: module
    dec_ref r26
    r27 = ('abi',)
    r28 = 'web3._utils'
    r29 = dank_mids._web3.abi.globals :: static
    r30 = CPyImport_ImportFromMany(r28, r27, r27, r29)
    if is_error(r30) goto L65 (error at <module>:6) else goto L8
L8:
    web3._utils = r30 :: module
    dec_ref r30
    r31 = '_T'
    r32 = dank_mids._web3.abi.globals :: static
    r33 = 'TypeVar'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L65 (error at <module>:9) else goto L9
L9:
    r35 = [r31]
    r36 = load_address r35
    r37 = PyObject_Vectorcall(r34, r36, 1, 0)
    dec_ref r34
    if is_error(r37) goto L65 (error at <module>:9) else goto L10
L10:
    r38 = dank_mids._web3.abi.globals :: static
    r39 = '_T'
    r40 = CPyDict_SetItem(r38, r39, r37)
    dec_ref r37
    r41 = r40 >= 0 :: signed
    if not r41 goto L65 (error at <module>:9) else goto L11 :: bool
L11:
    r42 = dank_mids._web3.abi.globals :: static
    r43 = 'Callable'
    r44 = CPyDict_GetItem(r42, r43)
    if is_error(r44) goto L65 (error at <module>:12) else goto L12
L12:
    r45 = dank_mids._web3.abi.globals :: static
    r46 = 'TypeStr'
    r47 = CPyDict_GetItem(r45, r46)
    if is_error(r47) goto L66 (error at <module>:12) else goto L13
L13:
    r48 = dank_mids._web3.abi.globals :: static
    r49 = 'Any'
    r50 = CPyDict_GetItem(r48, r49)
    if is_error(r50) goto L67 (error at <module>:12) else goto L14
L14:
    r51 = PyList_New(2)
    if is_error(r51) goto L68 (error at <module>:12) else goto L15
L15:
    r52 = get_element_ptr r51 ob_item :: PyListObject
    r53 = load_mem r52 :: ptr*
    set_mem r53, r47 :: builtins.object*
    r54 = r53 + 8
    set_mem r54, r50 :: builtins.object*
    r55 = dank_mids._web3.abi.globals :: static
    r56 = 'Tuple'
    r57 = CPyDict_GetItem(r55, r56)
    if is_error(r57) goto L69 (error at <module>:12) else goto L16
L16:
    r58 = dank_mids._web3.abi.globals :: static
    r59 = 'TypeStr'
    r60 = CPyDict_GetItem(r58, r59)
    if is_error(r60) goto L70 (error at <module>:12) else goto L17
L17:
    r61 = dank_mids._web3.abi.globals :: static
    r62 = 'Any'
    r63 = CPyDict_GetItem(r61, r62)
    if is_error(r63) goto L71 (error at <module>:12) else goto L18
L18:
    r64 = (r60, r63)
    r65 = box(tuple[object, object], r64)
    r66 = PyObject_GetItem(r57, r65)
    dec_ref r57
    dec_ref r65
    if is_error(r66) goto L69 (error at <module>:12) else goto L19
L19:
    r67 = (r51, r66)
    r68 = box(tuple[list, object], r67)
    r69 = PyObject_GetItem(r44, r68)
    dec_ref r44
    dec_ref r68
    if is_error(r69) goto L65 (error at <module>:12) else goto L20
L20:
    r70 = dank_mids._web3.abi.globals :: static
    r71 = 'Normalizer'
    r72 = CPyDict_SetItem(r70, r71, r69)
    dec_ref r69
    r73 = r72 >= 0 :: signed
    if not r73 goto L65 (error at <module>:12) else goto L21 :: bool
L21:
    r74 = dank_mids._web3.abi.globals :: static
    r75 = 'Tuple'
    r76 = CPyDict_GetItem(r74, r75)
    if is_error(r76) goto L65 (error at <module>:13) else goto L22
L22:
    r77 = dank_mids._web3.abi.globals :: static
    r78 = 'Tuple'
    r79 = CPyDict_GetItem(r77, r78)
    if is_error(r79) goto L72 (error at <module>:13) else goto L23
L23:
    r80 = dank_mids._web3.abi.globals :: static
    r81 = 'Normalizer'
    r82 = CPyDict_GetItem(r80, r81)
    if is_error(r82) goto L73 (error at <module>:13) else goto L24
L24:
    r83 = load_address _Py_EllipsisObject
    inc_ref r83
    r84 = (r82, r83)
    r85 = box(tuple[object, object], r84)
    r86 = PyObject_GetItem(r79, r85)
    dec_ref r79
    dec_ref r85
    if is_error(r86) goto L72 (error at <module>:13) else goto L25
L25:
    r87 = dank_mids._web3.abi.globals :: static
    r88 = 'Tuple'
    r89 = CPyDict_GetItem(r87, r88)
    if is_error(r89) goto L74 (error at <module>:13) else goto L26
L26:
    r90 = dank_mids._web3.abi.globals :: static
    r91 = 'TypeStr'
    r92 = CPyDict_GetItem(r90, r91)
    if is_error(r92) goto L75 (error at <module>:13) else goto L27
L27:
    r93 = load_address _Py_EllipsisObject
    inc_ref r93
    r94 = (r92, r93)
    r95 = box(tuple[object, object], r94)
    r96 = PyObject_GetItem(r89, r95)
    dec_ref r89
    dec_ref r95
    if is_error(r96) goto L74 (error at <module>:13) else goto L28
L28:
    r97 = (r86, r96)
    r98 = box(tuple[object, object], r97)
    r99 = PyObject_GetItem(r76, r98)
    dec_ref r76
    dec_ref r98
    if is_error(r99) goto L65 (error at <module>:13) else goto L29
L29:
    r100 = dank_mids._web3.abi.globals :: static
    r101 = 'MapperKey'
    r102 = CPyDict_SetItem(r100, r101, r99)
    dec_ref r99
    r103 = r102 >= 0 :: signed
    if not r103 goto L65 (error at <module>:13) else goto L30 :: bool
L30:
    r104 = dank_mids._web3.abi.globals :: static
    r105 = 'Callable'
    r106 = CPyDict_GetItem(r104, r105)
    if is_error(r106) goto L65 (error at <module>:14) else goto L31
L31:
    r107 = dank_mids._web3.abi.globals :: static
    r108 = 'TypeStr'
    r109 = CPyDict_GetItem(r107, r108)
    if is_error(r109) goto L76 (error at <module>:14) else goto L32
L32:
    r110 = dank_mids._web3.abi.globals :: static
    r111 = 'Any'
    r112 = CPyDict_GetItem(r110, r111)
    if is_error(r112) goto L77 (error at <module>:14) else goto L33
L33:
    r113 = PyList_New(2)
    if is_error(r113) goto L78 (error at <module>:14) else goto L34
L34:
    r114 = get_element_ptr r113 ob_item :: PyListObject
    r115 = load_mem r114 :: ptr*
    set_mem r115, r109 :: builtins.object*
    r116 = r115 + 8
    set_mem r116, r112 :: builtins.object*
    r117 = dank_mids._web3.abi.globals :: static
    r118 = 'Tuple'
    r119 = CPyDict_GetItem(r117, r118)
    if is_error(r119) goto L79 (error at <module>:14) else goto L35
L35:
    r120 = dank_mids._web3.abi.globals :: static
    r121 = 'TypeStr'
    r122 = CPyDict_GetItem(r120, r121)
    if is_error(r122) goto L80 (error at <module>:14) else goto L36
L36:
    r123 = dank_mids._web3.abi.globals :: static
    r124 = 'Any'
    r125 = CPyDict_GetItem(r123, r124)
    if is_error(r125) goto L81 (error at <module>:14) else goto L37
L37:
    r126 = (r122, r125)
    r127 = box(tuple[object, object], r126)
    r128 = PyObject_GetItem(r119, r127)
    dec_ref r119
    dec_ref r127
    if is_error(r128) goto L79 (error at <module>:14) else goto L38
L38:
    r129 = (r113, r128)
    r130 = box(tuple[list, object], r129)
    r131 = PyObject_GetItem(r106, r130)
    dec_ref r106
    dec_ref r130
    if is_error(r131) goto L65 (error at <module>:14) else goto L39
L39:
    r132 = dank_mids._web3.abi.globals :: static
    r133 = 'DataTreeFunc'
    r134 = CPyDict_SetItem(r132, r133, r131)
    dec_ref r131
    r135 = r134 >= 0 :: signed
    if not r135 goto L65 (error at <module>:14) else goto L40 :: bool
L40:
    r136 = typing :: module
    r137 = 'Iterable'
    r138 = CPyObject_GetAttr(r136, r137)
    if is_error(r138) goto L65 (error at <module>:18) else goto L41
L41:
    dank_mids._web3.abi.Iterable = r138 :: static
    r139 = dank_mids._web3.abi.globals :: static
    r140 = 'Iterable'
    r141 = CPyDict_SetItem(r139, r140, r138)
    dec_ref r138
    r142 = r141 >= 0 :: signed
    if not r142 goto L65 (error at <module>:18) else goto L42 :: bool
L42:
    r143 = typing :: module
    r144 = 'Mapping'
    r145 = CPyObject_GetAttr(r143, r144)
    if is_error(r145) goto L65 (error at <module>:19) else goto L43
L43:
    dank_mids._web3.abi.Mapping = r145 :: static
    r146 = dank_mids._web3.abi.globals :: static
    r147 = 'Mapping'
    r148 = CPyDict_SetItem(r146, r147, r145)
    dec_ref r145
    r149 = r148 >= 0 :: signed
    if not r149 goto L65 (error at <module>:19) else goto L44 :: bool
L44:
    r150 = dank_mids._web3.abi.globals :: static
    r151 = 'abi'
    r152 = CPyDict_GetItem(r150, r151)
    if is_error(r152) goto L65 (error at <module>:22) else goto L45
L45:
    r153 = 'ABITypedData'
    r154 = CPyObject_GetAttr(r152, r153)
    dec_ref r152
    if is_error(r154) goto L65 (error at <module>:22) else goto L46
L46:
    dank_mids._web3.abi.ABITypedData = r154 :: static
    r155 = dank_mids._web3.abi.globals :: static
    r156 = 'ABITypedData'
    r157 = CPyDict_SetItem(r155, r156, r154)
    dec_ref r154
    r158 = r157 >= 0 :: signed
    if not r158 goto L65 (error at <module>:22) else goto L47 :: bool
L47:
    r159 = dank_mids._web3.abi.globals :: static
    r160 = 'abi'
    r161 = CPyDict_GetItem(r159, r160)
    if is_error(r161) goto L65 (error at <module>:23) else goto L48
L48:
    r162 = 'abi_sub_tree'
    r163 = CPyObject_GetAttr(r161, r162)
    dec_ref r161
    if is_error(r163) goto L65 (error at <module>:23) else goto L49
L49:
    dank_mids._web3.abi.abi_sub_tree = r163 :: static
    r164 = dank_mids._web3.abi.globals :: static
    r165 = 'abi_sub_tree'
    r166 = CPyDict_SetItem(r164, r165, r163)
    dec_ref r163
    r167 = r166 >= 0 :: signed
    if not r167 goto L65 (error at <module>:23) else goto L50 :: bool
L50:
    r168 = <error> :: object
    r169 = 'dank_mids._web3.abi'
    r170 = dank_mids._web3.abi.Formatter_template :: type
    r171 = CPyType_FromTemplate(r170, r168, r169)
    if is_error(r171) goto L65 (error at <module>:27) else goto L51
L51:
    r172 = Formatter_trait_vtable_setup()
    if is_error(r172) goto L82 (error at <module>:-1) else goto L52
L52:
    r173 = '__mypyc_attrs__'
    r174 = 'normalizers'
    r175 = 'types'
    r176 = PyTuple_Pack(2, r174, r175)
    if is_error(r176) goto L82 (error at <module>:27) else goto L53
L53:
    r177 = PyObject_SetAttr(r171, r173, r176)
    dec_ref r176
    r178 = r177 >= 0 :: signed
    if not r178 goto L82 (error at <module>:27) else goto L54 :: bool
L54:
    dank_mids._web3.abi.Formatter = r171 :: type
    r179 = dank_mids._web3.abi.globals :: static
    r180 = 'Formatter'
    r181 = CPyDict_SetItem(r179, r180, r171)
    dec_ref r171
    r182 = r181 >= 0 :: signed
    if not r182 goto L65 (error at <module>:27) else goto L55 :: bool
L55:
    r183 = PyDict_New()
    if is_error(r183) goto L65 (error at <module>:48) else goto L56
L56:
    dank_mids._web3.abi._formatters = r183 :: static
    r184 = dank_mids._web3.abi.globals :: static
    r185 = '_formatters'
    r186 = CPyDict_SetItem(r184, r185, r183)
    dec_ref r183
    r187 = r186 >= 0 :: signed
    if not r187 goto L65 (error at <module>:48) else goto L57 :: bool
L57:
    r188 = PyDict_New()
    if is_error(r188) goto L65 (error at <module>:62) else goto L58
L58:
    dank_mids._web3.abi._data_tree_maps = r188 :: static
    r189 = dank_mids._web3.abi.globals :: static
    r190 = '_data_tree_maps'
    r191 = CPyDict_SetItem(r189, r190, r188)
    dec_ref r188
    r192 = r191 >= 0 :: signed
    if not r192 goto L65 (error at <module>:62) else goto L59 :: bool
L59:
    r193 = <error> :: object
    r194 = 'dank_mids._web3.abi'
    r195 = dank_mids._web3.abi.map_to_typed_data_template :: type
    r196 = CPyType_FromTemplate(r195, r193, r194)
    if is_error(r196) goto L65 (error at <module>:75) else goto L60
L60:
    r197 = map_to_typed_data_trait_vtable_setup()
    if is_error(r197) goto L83 (error at <module>:-1) else goto L61
L61:
    r198 = '__mypyc_attrs__'
    r199 = 'func'
    r200 = PyTuple_Pack(1, r199)
    if is_error(r200) goto L83 (error at <module>:75) else goto L62
L62:
    r201 = PyObject_SetAttr(r196, r198, r200)
    dec_ref r200
    r202 = r201 >= 0 :: signed
    if not r202 goto L83 (error at <module>:75) else goto L63 :: bool
L63:
    dank_mids._web3.abi.map_to_typed_data = r196 :: type
    r203 = dank_mids._web3.abi.globals :: static
    r204 = 'map_to_typed_data'
    r205 = CPyDict_SetItem(r203, r204, r196)
    dec_ref r196
    r206 = r205 >= 0 :: signed
    if not r206 goto L65 (error at <module>:75) else goto L64 :: bool
L64:
    return 1
L65:
    r207 = <error> :: None
    return r207
L66:
    dec_ref r44
    goto L65
L67:
    dec_ref r44
    dec_ref r47
    goto L65
L68:
    dec_ref r44
    dec_ref r47
    dec_ref r50
    goto L65
L69:
    dec_ref r44
    dec_ref r51
    goto L65
L70:
    dec_ref r44
    dec_ref r51
    dec_ref r57
    goto L65
L71:
    dec_ref r44
    dec_ref r51
    dec_ref r57
    dec_ref r60
    goto L65
L72:
    dec_ref r76
    goto L65
L73:
    dec_ref r76
    dec_ref r79
    goto L65
L74:
    dec_ref r76
    dec_ref r86
    goto L65
L75:
    dec_ref r76
    dec_ref r86
    dec_ref r89
    goto L65
L76:
    dec_ref r106
    goto L65
L77:
    dec_ref r106
    dec_ref r109
    goto L65
L78:
    dec_ref r106
    dec_ref r109
    dec_ref r112
    goto L65
L79:
    dec_ref r106
    dec_ref r113
    goto L65
L80:
    dec_ref r106
    dec_ref r113
    dec_ref r119
    goto L65
L81:
    dec_ref r106
    dec_ref r113
    dec_ref r119
    dec_ref r122
    goto L65
L82:
    dec_ref r171
    goto L65
L83:
    dec_ref r196
    goto L65

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: object_ptr
    r10 :: object_ptr[1]
    r11 :: c_ptr
    r12 :: native_int[1]
    r13 :: c_ptr
    r14 :: object
    r15 :: dict
    r16, r17 :: str
    r18 :: bit
    r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26 :: object
    r27, r28, r29, r30 :: str
    r31 :: set
    r32 :: i32
    r33 :: bit
    r34 :: i32
    r35 :: bit
    r36 :: i32
    r37 :: bit
    r38 :: i32
    r39 :: bit
    r40 :: dict
    r41 :: str
    r42 :: i32
    r43 :: bit
    r44, r45, r46, r47, r48, r49 :: str
    r50 :: set
    r51 :: i32
    r52 :: bit
    r53 :: i32
    r54 :: bit
    r55 :: i32
    r56 :: bit
    r57 :: i32
    r58 :: bit
    r59 :: i32
    r60 :: bit
    r61 :: i32
    r62 :: bit
    r63 :: dict
    r64 :: str
    r65 :: i32
    r66 :: bit
    r67 :: dict
    r68 :: str
    r69 :: object
    r70 :: str
    r71 :: object
    r72 :: str
    r73 :: object
    r74 :: dict
    r75 :: str
    r76 :: i32
    r77 :: bit
    r78 :: dict
    r79 :: str
    r80 :: object
    r81 :: str
    r82 :: object
    r83 :: str
    r84 :: object
    r85 :: dict
    r86 :: str
    r87 :: i32
    r88 :: bit
    r89 :: dict
    r90 :: str
    r91 :: object
    r92 :: str
    r93 :: object
    r94 :: str
    r95 :: object
    r96 :: dict
    r97 :: str
    r98 :: i32
    r99 :: bit
    r100 :: tuple[object, object, object]
    r101 :: object
    r102 :: str
    r103 :: object
    r104 :: bit
    r105 :: dict
    r106 :: str
    r107 :: object
    r108 :: str
    r109 :: object
    r110 :: str
    r111 :: object
    r112 :: dict
    r113 :: str
    r114 :: i32
    r115, r116 :: bit
    r117, r118, r119 :: tuple[object, object, object]
    r120 :: dict
    r121 :: str
    r122 :: object
    r123 :: dict
    r124 :: str
    r125 :: i32
    r126, r127 :: bit
    r128 :: dict
    r129 :: str
    r130 :: object
    r131 :: str
    r132 :: object
    r133 :: dict
    r134 :: str
    r135 :: object
    r136 :: str
    r137 :: object
    r138 :: dict
    r139 :: str
    r140 :: object
    r141 :: str
    r142 :: object
    r143 :: dict
    r144 :: str
    r145 :: object
    r146 :: str
    r147, r148, r149, r150, r151 :: object
    r152, r153 :: dict
    r154 :: str
    r155 :: i32
    r156 :: bit
    r157 :: dict
    r158 :: str
    r159 :: object
    r160 :: str
    r161 :: object
    r162 :: dict
    r163 :: str
    r164 :: object
    r165 :: str
    r166 :: object
    r167 :: dict
    r168 :: str
    r169 :: object
    r170 :: str
    r171 :: object
    r172 :: dict
    r173 :: str
    r174 :: object
    r175 :: str
    r176 :: object
    r177 :: dict
    r178 :: str
    r179 :: object
    r180 :: str
    r181, r182, r183, r184, r185, r186 :: object
    r187, r188 :: dict
    r189 :: str
    r190 :: i32
    r191 :: bit
    r192, r193, r194, r195, r196, r197, r198, r199, r200, r201 :: str
    r202 :: tuple[str, str, str, str, str, str, str, str, str, str]
    r203 :: dict
    r204 :: str
    r205 :: object
    r206 :: i32
    r207 :: bit
    r208, r209 :: bytes
    r210 :: tuple[bytes, bytes]
    r211 :: dict
    r212 :: str
    r213 :: object
    r214 :: i32
    r215 :: bit
    r216 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L80 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Dict', 'Final')
    r6 = 'typing'
    r7 = dank_mids.constants.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L80 (error at <module>:2) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address multicall.constants :: module
    r10 = [r9]
    r11 = load_address r10
    r12 = [4]
    r13 = load_address r12
    r14 = (('multicall.constants', 'multicall', 'multicall'),)
    r15 = dank_mids.constants.globals :: static
    r16 = 'dank_mids\\constants.py'
    r17 = '<module>'
    r18 = CPyImport_ImportMany(r14, r11, r15, r16, r17, r13)
    if not r18 goto L80 else goto L5 :: bool
L5:
    r19 = ('BlockNumber',)
    r20 = 'eth_typing'
    r21 = dank_mids.constants.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L80 (error at <module>:5) else goto L6
L6:
    eth_typing = r22 :: module
    dec_ref r22
    r23 = ('Network',)
    r24 = 'multicall.constants'
    r25 = dank_mids.constants.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L80 (error at <module>:6) else goto L7
L7:
    multicall.constants = r26 :: module
    dec_ref r26
    r27 = 'payload too large'
    r28 = 'content length too large'
    r29 = 'request entity too large'
    r30 = 'batch limit exceeded'
    r31 = PySet_New(0)
    if is_error(r31) goto L80 (error at <module>:8) else goto L8
L8:
    r32 = PySet_Add(r31, r27)
    r33 = r32 >= 0 :: signed
    if not r33 goto L81 (error at <module>:8) else goto L9 :: bool
L9:
    r34 = PySet_Add(r31, r28)
    r35 = r34 >= 0 :: signed
    if not r35 goto L81 (error at <module>:8) else goto L10 :: bool
L10:
    r36 = PySet_Add(r31, r29)
    r37 = r36 >= 0 :: signed
    if not r37 goto L81 (error at <module>:8) else goto L11 :: bool
L11:
    r38 = PySet_Add(r31, r30)
    r39 = r38 >= 0 :: signed
    if not r39 goto L81 (error at <module>:8) else goto L12 :: bool
L12:
    dank_mids.constants.TOO_MUCH_DATA_ERRS = r31 :: static
    r40 = dank_mids.constants.globals :: static
    r41 = 'TOO_MUCH_DATA_ERRS'
    r42 = CPyDict_SetItem(r40, r41, r31)
    dec_ref r31
    r43 = r42 >= 0 :: signed
    if not r43 goto L80 (error at <module>:8) else goto L13 :: bool
L13:
    r44 = 'connection reset by peer'
    r45 = 'server disconnected'
    r46 = 'execution aborted (timeout ='
    r47 = 'batch limit exceeded'
    r48 = 'request timed out'
    r49 = 'evm timeout'
    r50 = PySet_New(0)
    if is_error(r50) goto L80 (error at <module>:19) else goto L14
L14:
    r51 = PySet_Add(r50, r44)
    r52 = r51 >= 0 :: signed
    if not r52 goto L82 (error at <module>:19) else goto L15 :: bool
L15:
    r53 = PySet_Add(r50, r45)
    r54 = r53 >= 0 :: signed
    if not r54 goto L82 (error at <module>:19) else goto L16 :: bool
L16:
    r55 = PySet_Add(r50, r46)
    r56 = r55 >= 0 :: signed
    if not r56 goto L82 (error at <module>:19) else goto L17 :: bool
L17:
    r57 = PySet_Add(r50, r47)
    r58 = r57 >= 0 :: signed
    if not r58 goto L82 (error at <module>:19) else goto L18 :: bool
L18:
    r59 = PySet_Add(r50, r48)
    r60 = r59 >= 0 :: signed
    if not r60 goto L82 (error at <module>:19) else goto L19 :: bool
L19:
    r61 = PySet_Add(r50, r49)
    r62 = r61 >= 0 :: signed
    if not r62 goto L82 (error at <module>:19) else goto L20 :: bool
L20:
    dank_mids.constants.RETRY_ERRS = r50 :: static
    r63 = dank_mids.constants.globals :: static
    r64 = 'RETRY_ERRS'
    r65 = CPyDict_SetItem(r63, r64, r50)
    dec_ref r50
    r66 = r65 >= 0 :: signed
    if not r66 goto L80 (error at <module>:19) else goto L21 :: bool
L21:
    r67 = dank_mids.constants.globals :: static
    r68 = 'multicall'
    r69 = CPyDict_GetItem(r67, r68)
    if is_error(r69) goto L80 (error at <module>:32) else goto L22
L22:
    r70 = 'constants'
    r71 = CPyObject_GetAttr(r69, r70)
    dec_ref r69
    if is_error(r71) goto L80 (error at <module>:32) else goto L23
L23:
    r72 = 'GAS_LIMIT'
    r73 = CPyObject_GetAttr(r71, r72)
    dec_ref r71
    if is_error(r73) goto L80 (error at <module>:32) else goto L24
L24:
    dank_mids.constants.GAS_LIMIT = r73 :: static
    r74 = dank_mids.constants.globals :: static
    r75 = 'GAS_LIMIT'
    r76 = CPyDict_SetItem(r74, r75, r73)
    dec_ref r73
    r77 = r76 >= 0 :: signed
    if not r77 goto L80 (error at <module>:32) else goto L25 :: bool
L25:
    r78 = dank_mids.constants.globals :: static
    r79 = 'multicall'
    r80 = CPyDict_GetItem(r78, r79)
    if is_error(r80) goto L80 (error at <module>:38) else goto L26
L26:
    r81 = 'constants'
    r82 = CPyObject_GetAttr(r80, r81)
    dec_ref r80
    if is_error(r82) goto L80 (error at <module>:38) else goto L27
L27:
    r83 = 'MULTICALL2_BYTECODE'
    r84 = CPyObject_GetAttr(r82, r83)
    dec_ref r82
    if is_error(r84) goto L80 (error at <module>:38) else goto L28
L28:
    dank_mids.constants.MULTICALL2_OVERRIDE_CODE = r84 :: static
    r85 = dank_mids.constants.globals :: static
    r86 = 'MULTICALL2_OVERRIDE_CODE'
    r87 = CPyDict_SetItem(r85, r86, r84)
    dec_ref r84
    r88 = r87 >= 0 :: signed
    if not r88 goto L80 (error at <module>:38) else goto L29 :: bool
L29:
    r89 = dank_mids.constants.globals :: static
    r90 = 'multicall'
    r91 = CPyDict_GetItem(r89, r90)
    if is_error(r91) goto L33 (error at <module>:45) else goto L30
L30:
    r92 = 'constants'
    r93 = CPyObject_GetAttr(r91, r92)
    dec_ref r91
    if is_error(r93) goto L33 (error at <module>:45) else goto L31
L31:
    r94 = 'MULTICALL3_BYTECODE'
    r95 = CPyObject_GetAttr(r93, r94)
    dec_ref r93
    if is_error(r95) goto L33 (error at <module>:45) else goto L32
L32:
    r96 = dank_mids.constants.globals :: static
    r97 = '__MULTICALL3_OVERRIDE_CODE'
    r98 = CPyDict_SetItem(r96, r97, r95)
    dec_ref r95
    r99 = r98 >= 0 :: signed
    if not r99 goto L33 (error at <module>:45) else goto L44 :: bool
L33:
    r100 = CPy_CatchError()
    r101 = builtins :: module
    r102 = 'AttributeError'
    r103 = CPyObject_GetAttr(r101, r102)
    if is_error(r103) goto L42 (error at <module>:50) else goto L34
L34:
    r104 = CPy_ExceptionMatches(r103)
    dec_ref r103
    if r104 goto L35 else goto L39 :: bool
L35:
    r105 = dank_mids.constants.globals :: static
    r106 = 'multicall'
    r107 = CPyDict_GetItem(r105, r106)
    if is_error(r107) goto L42 (error at <module>:51) else goto L36
L36:
    r108 = 'constants'
    r109 = CPyObject_GetAttr(r107, r108)
    dec_ref r107
    if is_error(r109) goto L42 (error at <module>:51) else goto L37
L37:
    r110 = 'MULTICALL2_BYTECODE'
    r111 = CPyObject_GetAttr(r109, r110)
    dec_ref r109
    if is_error(r111) goto L42 (error at <module>:51) else goto L38
L38:
    r112 = dank_mids.constants.globals :: static
    r113 = '__MULTICALL3_OVERRIDE_CODE'
    r114 = CPyDict_SetItem(r112, r113, r111)
    dec_ref r111
    r115 = r114 >= 0 :: signed
    if not r115 goto L42 (error at <module>:51) else goto L41 :: bool
L39:
    CPy_Reraise()
    if not 0 goto L42 else goto L83 :: bool
L40:
    unreachable
L41:
    CPy_RestoreExcInfo(r100)
    dec_ref r100
    goto L44
L42:
    CPy_RestoreExcInfo(r100)
    dec_ref r100
    r116 = CPy_KeepPropagating()
    if not r116 goto L45 else goto L43 :: bool
L43:
    unreachable
L44:
    r117 = <error> :: tuple[object, object, object]
    r118 = r117
    goto L46
L45:
    r119 = CPy_CatchError()
    r118 = r119
L46:
    r120 = dank_mids.constants.globals :: static
    r121 = '__MULTICALL3_OVERRIDE_CODE'
    r122 = CPyDict_GetItem(r120, r121)
    if is_error(r122) goto L51 (error at <module>:53) else goto L47
L47:
    dank_mids.constants.MULTICALL3_OVERRIDE_CODE = r122 :: static
    r123 = dank_mids.constants.globals :: static
    r124 = 'MULTICALL3_OVERRIDE_CODE'
    r125 = CPyDict_SetItem(r123, r124, r122)
    dec_ref r122
    r126 = r125 >= 0 :: signed
    if not r126 goto L51 (error at <module>:53) else goto L48 :: bool
L48:
    if is_error(r118) goto L55 else goto L49
L49:
    CPy_Reraise()
    if not 0 goto L51 else goto L84 :: bool
L50:
    unreachable
L51:
    if is_error(r118) goto L53 else goto L52
L52:
    CPy_RestoreExcInfo(r118)
    xdec_ref r118
L53:
    r127 = CPy_KeepPropagating()
    if not r127 goto L80 else goto L54 :: bool
L54:
    unreachable
L55:
    r128 = dank_mids.constants.globals :: static
    r129 = 'Network'
    r130 = CPyDict_GetItem(r128, r129)
    if is_error(r130) goto L80 (error at <module>:56) else goto L56
L56:
    r131 = 'Mainnet'
    r132 = CPyObject_GetAttr(r130, r131)
    dec_ref r130
    if is_error(r132) goto L80 (error at <module>:56) else goto L57
L57:
    r133 = dank_mids.constants.globals :: static
    r134 = 'Network'
    r135 = CPyDict_GetItem(r133, r134)
    if is_error(r135) goto L85 (error at <module>:57) else goto L58
L58:
    r136 = 'Fantom'
    r137 = CPyObject_GetAttr(r135, r136)
    dec_ref r135
    if is_error(r137) goto L85 (error at <module>:57) else goto L59
L59:
    r138 = dank_mids.constants.globals :: static
    r139 = 'Network'
    r140 = CPyDict_GetItem(r138, r139)
    if is_error(r140) goto L86 (error at <module>:58) else goto L60
L60:
    r141 = 'Arbitrum'
    r142 = CPyObject_GetAttr(r140, r141)
    dec_ref r140
    if is_error(r142) goto L86 (error at <module>:58) else goto L61
L61:
    r143 = dank_mids.constants.globals :: static
    r144 = 'Network'
    r145 = CPyDict_GetItem(r143, r144)
    if is_error(r145) goto L87 (error at <module>:59) else goto L62
L62:
    r146 = 'Optimism'
    r147 = CPyObject_GetAttr(r145, r146)
    dec_ref r145
    if is_error(r147) goto L87 (error at <module>:59) else goto L63
L63:
    r148 = object 12336033
    r149 = object 16572242
    r150 = object 821923
    r151 = object 722566
    r152 = CPyDict_Build(4, r132, r148, r137, r149, r142, r150, r147, r151)
    dec_ref r132
    dec_ref r137
    dec_ref r142
    dec_ref r147
    if is_error(r152) goto L80 (error at <module>:55) else goto L64
L64:
    dank_mids.constants.MULTICALL2_DEPLOY_BLOCKS = r152 :: static
    r153 = dank_mids.constants.globals :: static
    r154 = 'MULTICALL2_DEPLOY_BLOCKS'
    r155 = CPyDict_SetItem(r153, r154, r152)
    dec_ref r152
    r156 = r155 >= 0 :: signed
    if not r156 goto L80 (error at <module>:55) else goto L65 :: bool
L65:
    r157 = dank_mids.constants.globals :: static
    r158 = 'Network'
    r159 = CPyDict_GetItem(r157, r158)
    if is_error(r159) goto L80 (error at <module>:64) else goto L66
L66:
    r160 = 'Mainnet'
    r161 = CPyObject_GetAttr(r159, r160)
    dec_ref r159
    if is_error(r161) goto L80 (error at <module>:64) else goto L67
L67:
    r162 = dank_mids.constants.globals :: static
    r163 = 'Network'
    r164 = CPyDict_GetItem(r162, r163)
    if is_error(r164) goto L88 (error at <module>:65) else goto L68
L68:
    r165 = 'Fantom'
    r166 = CPyObject_GetAttr(r164, r165)
    dec_ref r164
    if is_error(r166) goto L88 (error at <module>:65) else goto L69
L69:
    r167 = dank_mids.constants.globals :: static
    r168 = 'Network'
    r169 = CPyDict_GetItem(r167, r168)
    if is_error(r169) goto L89 (error at <module>:66) else goto L70
L70:
    r170 = 'Arbitrum'
    r171 = CPyObject_GetAttr(r169, r170)
    dec_ref r169
    if is_error(r171) goto L89 (error at <module>:66) else goto L71
L71:
    r172 = dank_mids.constants.globals :: static
    r173 = 'Network'
    r174 = CPyDict_GetItem(r172, r173)
    if is_error(r174) goto L90 (error at <module>:67) else goto L72
L72:
    r175 = 'Optimism'
    r176 = CPyObject_GetAttr(r174, r175)
    dec_ref r174
    if is_error(r176) goto L90 (error at <module>:67) else goto L73
L73:
    r177 = dank_mids.constants.globals :: static
    r178 = 'Network'
    r179 = CPyDict_GetItem(r177, r178)
    if is_error(r179) goto L91 (error at <module>:68) else goto L74
L74:
    r180 = 'Base'
    r181 = CPyObject_GetAttr(r179, r180)
    dec_ref r179
    if is_error(r181) goto L91 (error at <module>:68) else goto L75
L75:
    r182 = object 14353601
    r183 = object 33001987
    r184 = object 7654707
    r185 = object 4286263
    r186 = object 5022
    r187 = CPyDict_Build(5, r161, r182, r166, r183, r171, r184, r176, r185, r181, r186)
    dec_ref r161
    dec_ref r166
    dec_ref r171
    dec_ref r176
    dec_ref r181
    if is_error(r187) goto L80 (error at <module>:63) else goto L76
L76:
    dank_mids.constants.MULTICALL3_DEPLOY_BLOCKS = r187 :: static
    r188 = dank_mids.constants.globals :: static
    r189 = 'MULTICALL3_DEPLOY_BLOCKS'
    r190 = CPyDict_SetItem(r188, r189, r187)
    dec_ref r187
    r191 = r190 >= 0 :: signed
    if not r191 goto L80 (error at <module>:63) else goto L77 :: bool
L77:
    r192 = '0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000094e6f206163636573730000000000000000000000000000000000000000000000'
    r193 = '0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e6d696e7420697320706175736564000000000000000000000000000000000000'
    r194 = '0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000016496e76616c6964206574686572207472616e7366657200000000000000000000'
    r195 = '0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e4e4f4e5f454d5054595f44415441000000000000000000000000000000000000'
    r196 = '0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000246d73672e736967206973206e6f742061737369676e656420746f207375626d6f64756c6500000000000000000000000000000000000000000000000000000000'
    r197 = '0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000346f6e6c792077726170706564206e617469766520636f6e747261637420636f756c642073656e64206e617469766520746f6b656e000000000000000000000000'
    r198 = '0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000013434f4e54524f4c4c45525f52454a454354454400000000000000000000000000'
    r199 = '0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000204469616d6f6e643a2046756e6374696f6e20646f6573206e6f74206578697374'
    r200 = '0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001a66756e6374696f6e2073686f756c6420626520616c6c6f776564000000000000'
    r201 = '0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001846756e6374696f6e20646f6573206e6f742065786973742e0000000000000000'
    inc_ref r192
    inc_ref r193
    inc_ref r194
    inc_ref r195
    inc_ref r196
    inc_ref r197
    inc_ref r198
    inc_ref r199
    inc_ref r200
    inc_ref r201
    r202 = (r192, r193, r194, r195, r196, r197, r198, r199, r200, r201)
    dank_mids.constants.BAD_HEXES = r202 :: static
    r203 = dank_mids.constants.globals :: static
    r204 = 'BAD_HEXES'
    r205 = box(tuple[str, str, str, str, str, str, str, str, str, str], r202)
    r206 = CPyDict_SetItem(r203, r204, r205)
    dec_ref r205
    r207 = r206 >= 0 :: signed
    if not r207 goto L80 (error at <module>:75) else goto L78 :: bool
L78:
    r208 = b'\x08\xc3y\xa0'
    r209 = b'4e487b71'
    inc_ref r208
    inc_ref r209
    r210 = (r208, r209)
    dank_mids.constants.REVERT_SELECTORS = r210 :: static
    r211 = dank_mids.constants.globals :: static
    r212 = 'REVERT_SELECTORS'
    r213 = box(tuple[bytes, bytes], r210)
    r214 = CPyDict_SetItem(r211, r212, r213)
    dec_ref r213
    r215 = r214 >= 0 :: signed
    if not r215 goto L80 (error at <module>:101) else goto L79 :: bool
L79:
    return 1
L80:
    r216 = <error> :: None
    return r216
L81:
    dec_ref r31
    goto L80
L82:
    dec_ref r50
    goto L80
L83:
    dec_ref r100
    goto L40
L84:
    xdec_ref r118
    goto L50
L85:
    dec_ref r132
    goto L80
L86:
    dec_ref r132
    dec_ref r137
    goto L80
L87:
    dec_ref r132
    dec_ref r137
    dec_ref r142
    goto L80
L88:
    dec_ref r161
    goto L80
L89:
    dec_ref r161
    dec_ref r166
    goto L80
L90:
    dec_ref r161
    dec_ref r166
    dec_ref r171
    goto L80
L91:
    dec_ref r161
    dec_ref r166
    dec_ref r171
    dec_ref r176
    goto L80

def lru_cache_lite_wrap_lru_cache_lite_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def lru_cache_lite_wrap_lru_cache_lite_obj.__call__(__mypyc_self__, args):
    __mypyc_self__ :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_obj
    args :: tuple
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_env
    r1 :: dict
    r2, r3, retval, r4 :: object
    r5 :: bit
    r6 :: object
    r7 :: list
    r8 :: object
    r9 :: tuple
    r10 :: dict
    r11 :: object
    r12 :: dict
    r13 :: i32
    r14 :: bit
    r15 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L15 (error at lru_cache_lite_wrap:41) else goto L1
L1:
    r1 = r0.cache
    if is_error(r1) goto L16 (error at lru_cache_lite_wrap:42) else goto L2
L2:
    r2 = r0.cache_miss
    if is_error(r2) goto L17 (error at lru_cache_lite_wrap:42) else goto L3
L3:
    r3 = CPyDict_Get(r1, args, r2)
    dec_ref r1
    dec_ref r2
    if is_error(r3) goto L16 (error at lru_cache_lite_wrap:42) else goto L4
L4:
    retval = r3
    r4 = r0.cache_miss
    if is_error(r4) goto L18 (error at lru_cache_lite_wrap:43) else goto L5
L5:
    r5 = retval == r4
    dec_ref r4
    if r5 goto L19 else goto L20 :: bool
L6:
    r6 = r0.func
    if is_error(r6) goto L16 (error at lru_cache_lite_wrap:44) else goto L7
L7:
    r7 = PyList_New(0)
    if is_error(r7) goto L21 (error at lru_cache_lite_wrap:44) else goto L8
L8:
    r8 = CPyList_Extend(r7, args)
    if is_error(r8) goto L22 (error at lru_cache_lite_wrap:44) else goto L23
L9:
    r9 = PyList_AsTuple(r7)
    dec_ref r7
    if is_error(r9) goto L21 (error at lru_cache_lite_wrap:44) else goto L10
L10:
    r10 = PyDict_New()
    if is_error(r10) goto L24 (error at lru_cache_lite_wrap:44) else goto L11
L11:
    r11 = PyObject_Call(r6, r9, r10)
    dec_ref r6
    dec_ref r9
    dec_ref r10
    if is_error(r11) goto L16 (error at lru_cache_lite_wrap:44) else goto L12
L12:
    retval = r11
    r12 = r0.cache
    dec_ref r0
    if is_error(r12) goto L25 (error at lru_cache_lite_wrap:45) else goto L13
L13:
    r13 = CPyDict_SetItem(r12, args, retval)
    dec_ref r12
    r14 = r13 >= 0 :: signed
    if not r14 goto L25 (error at lru_cache_lite_wrap:45) else goto L14 :: bool
L14:
    return retval
L15:
    r15 = <error> :: object
    return r15
L16:
    dec_ref r0
    goto L15
L17:
    dec_ref r0
    dec_ref r1
    goto L15
L18:
    dec_ref r0
    dec_ref retval
    goto L15
L19:
    dec_ref retval
    goto L6
L20:
    dec_ref r0
    goto L14
L21:
    dec_ref r0
    dec_ref r6
    goto L15
L22:
    dec_ref r0
    dec_ref r6
    dec_ref r7
    goto L15
L23:
    dec_ref r8
    goto L9
L24:
    dec_ref r0
    dec_ref r6
    dec_ref r9
    goto L15
L25:
    dec_ref retval
    goto L15

def lru_cache_lite(func):
    func :: object
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_env
    r1 :: bool
    r2 :: dict
    r3 :: bool
    r4 :: object
    r5 :: str
    r6, r7 :: object
    r8 :: bool
    r9 :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_obj
    r10 :: bool
    r11 :: object
    r12 :: dict
    r13 :: str
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: object[1]
    r19 :: object_ptr
    r20 :: object
    r21 :: dict
    r22 :: str
    r23 :: i32
    r24 :: bit
    r25 :: dict
    r26 :: str
    r27 :: i32
    r28 :: bit
    r29 :: object
L0:
    r0 = lru_cache_lite_env()
    if is_error(r0) goto L17 (error at lru_cache_lite:11) else goto L1
L1:
    inc_ref func
    r0.func = func; r1 = is_error
    if not r1 goto L18 (error at lru_cache_lite:11) else goto L2 :: bool
L2:
    r2 = PyDict_New()
    if is_error(r2) goto L18 (error at lru_cache_lite:37) else goto L3
L3:
    r0.cache = r2; r3 = is_error
    if not r3 goto L18 (error at lru_cache_lite:37) else goto L4 :: bool
L4:
    r4 = builtins :: module
    r5 = 'object'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L18 (error at lru_cache_lite:38) else goto L5
L5:
    r7 = PyObject_Vectorcall(r6, 0, 0, 0)
    dec_ref r6
    if is_error(r7) goto L18 (error at lru_cache_lite:38) else goto L6
L6:
    r0.cache_miss = r7; r8 = is_error
    if not r8 goto L18 (error at lru_cache_lite:38) else goto L7 :: bool
L7:
    r9 = lru_cache_lite_wrap_lru_cache_lite_obj()
    if is_error(r9) goto L18 (error at lru_cache_lite:41) else goto L8
L8:
    inc_ref r0
    r9.__mypyc_env__ = r0; r10 = is_error
    if not r10 goto L19 (error at lru_cache_lite:41) else goto L9 :: bool
L9:
    r11 = r0.func
    if is_error(r11) goto L19 (error at lru_cache_lite:40) else goto L10
L10:
    r12 = dank_mids.helpers.lru_cache.globals :: static
    r13 = 'wraps'
    r14 = CPyDict_GetItem(r12, r13)
    if is_error(r14) goto L20 (error at lru_cache_lite:40) else goto L11
L11:
    r15 = [r11]
    r16 = load_address r15
    r17 = PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L20 (error at lru_cache_lite:40) else goto L12
L12:
    dec_ref r11
    r18 = [r9]
    r19 = load_address r18
    r20 = PyObject_Vectorcall(r17, r19, 1, 0)
    dec_ref r17
    if is_error(r20) goto L19 (error at lru_cache_lite:41) else goto L13
L13:
    dec_ref r9
    inc_ref r20
    r21 = dank_mids.helpers.lru_cache.globals :: static
    r22 = 'lru_cache_lite_wrap'
    r23 = CPyDict_SetItem(r21, r22, r20)
    dec_ref r20
    r24 = r23 >= 0 :: signed
    if not r24 goto L21 (error at lru_cache_lite:41) else goto L14 :: bool
L14:
    r25 = r0.cache
    dec_ref r0
    if is_error(r25) goto L22 (error at lru_cache_lite:48) else goto L15
L15:
    r26 = 'cache'
    r27 = PyObject_SetAttr(r20, r26, r25)
    dec_ref r25
    r28 = r27 >= 0 :: signed
    if not r28 goto L22 (error at lru_cache_lite:48) else goto L16 :: bool
L16:
    return r20
L17:
    r29 = <error> :: object
    return r29
L18:
    dec_ref r0
    goto L17
L19:
    dec_ref r0
    dec_ref r9
    goto L17
L20:
    dec_ref r0
    dec_ref r9
    dec_ref r11
    goto L17
L21:
    dec_ref r0
    dec_ref r20
    goto L17
L22:
    dec_ref r20
    goto L17

def lru_cache_lite_wrap_lru_cache_lite_nonull_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def lru_cache_lite_wrap_lru_cache_lite_nonull_obj.__call__(__mypyc_self__, args):
    __mypyc_self__ :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_nonull_obj
    args :: tuple
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_nonull_env
    r1 :: dict
    r2 :: object
    retval :: union[object, None]
    r3 :: object
    r4 :: bit
    r5 :: object
    r6 :: list
    r7 :: object
    r8 :: tuple
    r9 :: dict
    r10 :: object
    r11 :: dict
    r12 :: i32
    r13 :: bit
    r14 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L13 (error at lru_cache_lite_wrap:89) else goto L1
L1:
    r1 = r0.cache
    if is_error(r1) goto L14 (error at lru_cache_lite_wrap:90) else goto L2
L2:
    r2 = CPyDict_GetWithNone(r1, args)
    dec_ref r1
    if is_error(r2) goto L14 (error at lru_cache_lite_wrap:90) else goto L3
L3:
    retval = r2
    r3 = load_address _Py_NoneStruct
    r4 = retval == r3
    if r4 goto L15 else goto L16 :: bool
L4:
    r5 = r0.func
    if is_error(r5) goto L14 (error at lru_cache_lite_wrap:92) else goto L5
L5:
    r6 = PyList_New(0)
    if is_error(r6) goto L17 (error at lru_cache_lite_wrap:92) else goto L6
L6:
    r7 = CPyList_Extend(r6, args)
    if is_error(r7) goto L18 (error at lru_cache_lite_wrap:92) else goto L19
L7:
    r8 = PyList_AsTuple(r6)
    dec_ref r6
    if is_error(r8) goto L17 (error at lru_cache_lite_wrap:92) else goto L8
L8:
    r9 = PyDict_New()
    if is_error(r9) goto L20 (error at lru_cache_lite_wrap:92) else goto L9
L9:
    r10 = PyObject_Call(r5, r8, r9)
    dec_ref r5
    dec_ref r8
    dec_ref r9
    if is_error(r10) goto L14 (error at lru_cache_lite_wrap:92) else goto L10
L10:
    retval = r10
    r11 = r0.cache
    dec_ref r0
    if is_error(r11) goto L21 (error at lru_cache_lite_wrap:93) else goto L11
L11:
    r12 = CPyDict_SetItem(r11, args, retval)
    dec_ref r11
    r13 = r12 >= 0 :: signed
    if not r13 goto L21 (error at lru_cache_lite_wrap:93) else goto L12 :: bool
L12:
    return retval
L13:
    r14 = <error> :: object
    return r14
L14:
    dec_ref r0
    goto L13
L15:
    dec_ref retval
    goto L4
L16:
    dec_ref r0
    goto L12
L17:
    dec_ref r0
    dec_ref r5
    goto L13
L18:
    dec_ref r0
    dec_ref r5
    dec_ref r6
    goto L13
L19:
    dec_ref r7
    goto L7
L20:
    dec_ref r0
    dec_ref r5
    dec_ref r8
    goto L13
L21:
    dec_ref retval
    goto L13

def lru_cache_lite_nonull(func):
    func :: object
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_nonull_env
    r1 :: bool
    r2 :: dict
    r3 :: bool
    r4 :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_nonull_obj
    r5 :: bool
    r6 :: object
    r7 :: dict
    r8 :: str
    r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: i32
    r19 :: bit
    r20 :: dict
    r21 :: str
    r22 :: i32
    r23 :: bit
    r24 :: object
L0:
    r0 = lru_cache_lite_nonull_env()
    if is_error(r0) goto L14 (error at lru_cache_lite_nonull:52) else goto L1
L1:
    inc_ref func
    r0.func = func; r1 = is_error
    if not r1 goto L15 (error at lru_cache_lite_nonull:52) else goto L2 :: bool
L2:
    r2 = PyDict_New()
    if is_error(r2) goto L15 (error at lru_cache_lite_nonull:86) else goto L3
L3:
    r0.cache = r2; r3 = is_error
    if not r3 goto L15 (error at lru_cache_lite_nonull:86) else goto L4 :: bool
L4:
    r4 = lru_cache_lite_wrap_lru_cache_lite_nonull_obj()
    if is_error(r4) goto L15 (error at lru_cache_lite_nonull:89) else goto L5
L5:
    inc_ref r0
    r4.__mypyc_env__ = r0; r5 = is_error
    if not r5 goto L16 (error at lru_cache_lite_nonull:89) else goto L6 :: bool
L6:
    r6 = r0.func
    if is_error(r6) goto L16 (error at lru_cache_lite_nonull:88) else goto L7
L7:
    r7 = dank_mids.helpers.lru_cache.globals :: static
    r8 = 'wraps'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L17 (error at lru_cache_lite_nonull:88) else goto L8
L8:
    r10 = [r6]
    r11 = load_address r10
    r12 = PyObject_Vectorcall(r9, r11, 1, 0)
    dec_ref r9
    if is_error(r12) goto L17 (error at lru_cache_lite_nonull:88) else goto L9
L9:
    dec_ref r6
    r13 = [r4]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L16 (error at lru_cache_lite_nonull:89) else goto L10
L10:
    dec_ref r4
    inc_ref r15
    r16 = dank_mids.helpers.lru_cache.globals :: static
    r17 = 'lru_cache_lite_wrap'
    r18 = CPyDict_SetItem(r16, r17, r15)
    dec_ref r15
    r19 = r18 >= 0 :: signed
    if not r19 goto L18 (error at lru_cache_lite_nonull:89) else goto L11 :: bool
L11:
    r20 = r0.cache
    dec_ref r0
    if is_error(r20) goto L19 (error at lru_cache_lite_nonull:96) else goto L12
L12:
    r21 = 'cache'
    r22 = PyObject_SetAttr(r15, r21, r20)
    dec_ref r20
    r23 = r22 >= 0 :: signed
    if not r23 goto L19 (error at lru_cache_lite_nonull:96) else goto L13 :: bool
L13:
    return r15
L14:
    r24 = <error> :: object
    return r24
L15:
    dec_ref r0
    goto L14
L16:
    dec_ref r0
    dec_ref r4
    goto L14
L17:
    dec_ref r0
    dec_ref r4
    dec_ref r6
    goto L14
L18:
    dec_ref r0
    dec_ref r15
    goto L14
L19:
    dec_ref r15
    goto L14

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: str
    r18 :: dict
    r19 :: str
    r20 :: object
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: dict
    r25 :: str
    r26 :: i32
    r27 :: bit
    r28 :: str
    r29 :: dict
    r30 :: str
    r31 :: object
    r32 :: object[1]
    r33 :: object_ptr
    r34 :: object
    r35 :: dict
    r36 :: str
    r37 :: i32
    r38 :: bit
    r39, r40 :: str
    r41 :: list
    r42, r43, r44 :: ptr
    r45 :: dict
    r46 :: str
    r47 :: i32
    r48 :: bit
    r49 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L15 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('wraps',)
    r6 = 'functools'
    r7 = dank_mids.helpers.lru_cache.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L15 (error at <module>:1) else goto L4
L4:
    functools = r8 :: module
    dec_ref r8
    r9 = ('Callable', 'Dict', 'TypeVar')
    r10 = 'typing'
    r11 = dank_mids.helpers.lru_cache.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L15 (error at <module>:2) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = ('ParamSpec',)
    r14 = 'typing_extensions'
    r15 = dank_mids.helpers.lru_cache.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L15 (error at <module>:4) else goto L6
L6:
    typing_extensions = r16 :: module
    dec_ref r16
    r17 = '__P'
    r18 = dank_mids.helpers.lru_cache.globals :: static
    r19 = 'ParamSpec'
    r20 = CPyDict_GetItem(r18, r19)
    if is_error(r20) goto L15 (error at <module>:7) else goto L7
L7:
    r21 = [r17]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(r20, r22, 1, 0)
    dec_ref r20
    if is_error(r23) goto L15 (error at <module>:7) else goto L8
L8:
    r24 = dank_mids.helpers.lru_cache.globals :: static
    r25 = '__P'
    r26 = CPyDict_SetItem(r24, r25, r23)
    dec_ref r23
    r27 = r26 >= 0 :: signed
    if not r27 goto L15 (error at <module>:7) else goto L9 :: bool
L9:
    r28 = '__T'
    r29 = dank_mids.helpers.lru_cache.globals :: static
    r30 = 'TypeVar'
    r31 = CPyDict_GetItem(r29, r30)
    if is_error(r31) goto L15 (error at <module>:8) else goto L10
L10:
    r32 = [r28]
    r33 = load_address r32
    r34 = PyObject_Vectorcall(r31, r33, 1, 0)
    dec_ref r31
    if is_error(r34) goto L15 (error at <module>:8) else goto L11
L11:
    r35 = dank_mids.helpers.lru_cache.globals :: static
    r36 = '__T'
    r37 = CPyDict_SetItem(r35, r36, r34)
    dec_ref r34
    r38 = r37 >= 0 :: signed
    if not r38 goto L15 (error at <module>:8) else goto L12 :: bool
L12:
    r39 = 'lru_cache_lite'
    r40 = 'lru_cache_lite_nonull'
    r41 = PyList_New(2)
    if is_error(r41) goto L15 (error at <module>:100) else goto L13
L13:
    r42 = get_element_ptr r41 ob_item :: PyListObject
    r43 = load_mem r42 :: ptr*
    inc_ref r39
    set_mem r43, r39 :: builtins.object*
    inc_ref r40
    r44 = r43 + 8
    set_mem r44, r40 :: builtins.object*
    r45 = dank_mids.helpers.lru_cache.globals :: static
    r46 = '__all__'
    r47 = CPyDict_SetItem(r45, r46, r41)
    dec_ref r41
    r48 = r47 >= 0 :: signed
    if not r48 goto L15 (error at <module>:100) else goto L14 :: bool
L14:
    return 1
L15:
    r49 = <error> :: None
    return r49

def gatherish_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    type, value, traceback, arg, r0, r1, r2, r3, r4, r5, r6, r7 :: object
    r8 :: dank_mids.helpers._gather.gatherish_env
    r9 :: int
    r10 :: object
    r11 :: bit
    r12 :: object
    r13 :: bool
    r14 :: object
    r15 :: bool
    r16 :: list
    r17 :: bool
    r18, r19 :: object
    r20, r21 :: bool
    r22, r23 :: object
    r24 :: bool
    r25, r26 :: object
    r27 :: union[str, None]
    r28 :: object
    r29 :: bool
    r30 :: object[3]
    r31 :: object_ptr
    r32, r33 :: object
    r34 :: list
    r35 :: i32
    r36, r37 :: bit
    r38 :: list
    r39 :: object
    r40 :: bool
    r41 :: object
    r42 :: bool
    r43, r44 :: object
    r45 :: bool
    r46, r47, r48, r49, r50 :: object
    r51 :: bool
    r52 :: object
    r53 :: bit
    r54 :: tuple[object, object, object]
    r55 :: bool
    r56 :: object_ptr
    r57 :: object
    r58 :: bool
    r59, r60, r61 :: tuple[object, object, object]
    r62 :: bit
    r63, r64, r65, r66 :: object
    r67 :: bool
    r68, r69 :: object
    r70 :: bool
    r71, r72, r73, r74, r75 :: object
    r76 :: bool
    r77 :: object
    r78 :: bit
    r79 :: tuple[object, object, object]
    r80 :: bool
    r81 :: object_ptr
    r82 :: object
    r83 :: bool
    r84, r85, r86 :: tuple[object, object, object]
    r87 :: bit
    r88, r89, r90, r91, r92 :: object
    r93, r94 :: bool
    r95, r96 :: object
    r97 :: bool
    r98, r99 :: object
    r100 :: bool
    r101, r102, r103, r104, r105 :: object
    r106 :: bool
    r107 :: object
    r108 :: bit
    r109 :: tuple[object, object, object]
    r110 :: bool
    r111 :: object_ptr
    r112 :: object
    r113 :: bool
    r114, r115, r116 :: tuple[object, object, object]
    r117 :: bit
    r118, r119, r120 :: object
    r121 :: tuple[object, object, object]
    r122 :: bool
    r123 :: object
    r124 :: str
    r125 :: object
    r126 :: bit
    r127, r128 :: object
    r129, r130 :: bool
    r131, r132 :: object
    r133 :: bool
    r134, r135 :: object
    r136 :: bool
    r137, r138, r139, r140, r141 :: object
    r142 :: bool
    r143 :: object
    r144 :: bit
    r145 :: tuple[object, object, object]
    r146 :: bool
    r147 :: object_ptr
    r148 :: object
    r149 :: bool
    r150, r151, r152 :: tuple[object, object, object]
    r153 :: bit
    r154, r155, r156 :: object
    r157 :: tuple[object, object, object]
    r158 :: bool
    r159 :: object
    r160 :: str
    r161 :: object
    r162 :: bit
    r163, r164 :: tuple[object, object, object]
    r165, r166 :: bit
    r167 :: tuple[object, object, object]
    r168, r169 :: bit
    r170 :: object
    r171 :: bool
    r172, r173, r174, r175, r176 :: bit
    r177 :: bool
    r178 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = <error> :: object
    r5 = r4
    r6 = <error> :: object
    r7 = r6
    r8 = __mypyc_self__.__mypyc_env__
    if is_error(r8) goto L205 (error at gatherish:33) else goto L1
L1:
    r9 = r8.__mypyc_next_label__
    if is_error(r9) goto L206 (error at gatherish:33) else goto L197
L2:
    r10 = load_address _Py_NoneStruct
    r11 = type != r10
    if r11 goto L207 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L204 (error at gatherish:33) else goto L4 :: bool
L4:
    unreachable
L5:
    r12 = dank_mids.helpers._gather.get_running_loop :: static
    if is_error(r12) goto L208 else goto L8
L6:
    r13 = raise NameError('value for final name "get_running_loop" was not set')
    if not r13 goto L204 (error at gatherish:41) else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = PyObject_Vectorcall(r12, 0, 0, 0)
    if is_error(r14) goto L206 (error at gatherish:41) else goto L9
L9:
    r8.loop = r14; r15 = is_error
    if not r15 goto L206 (error at gatherish:41) else goto L10 :: bool
L10:
    r16 = PyList_New(0)
    if is_error(r16) goto L206 (error at gatherish:44) else goto L11
L11:
    r8.__mypyc_temp__0 = r16; r17 = is_error
    if not r17 goto L206 (error at gatherish:-1) else goto L12 :: bool
L12:
    r18 = r8.coros
    if is_error(r18) goto L206 (error at gatherish:44) else goto L13
L13:
    r19 = PyObject_GetIter(r18)
    if is_error(r19) goto L209 (error at gatherish:44) else goto L14
L14:
    r8.__mypyc_temp__1 = r18; r20 = is_error
    if not r20 goto L210 (error at gatherish:-1) else goto L15 :: bool
L15:
    r8.__mypyc_temp__2 = r19; r21 = is_error
    if not r21 goto L206 (error at gatherish:-1) else goto L16 :: bool
L16:
    r22 = r8.__mypyc_temp__2
    if is_error(r22) goto L206 (error at gatherish:44) else goto L17
L17:
    r23 = PyIter_Next(r22)
    dec_ref r22
    if is_error(r23) goto L28 else goto L18
L18:
    r8.coro = r23; r24 = is_error
    if not r24 goto L206 (error at gatherish:44) else goto L19 :: bool
L19:
    r25 = r8.coro
    if is_error(r25) goto L206 (error at gatherish:44) else goto L20
L20:
    r26 = r8.loop
    if is_error(r26) goto L211 (error at gatherish:44) else goto L21
L21:
    r27 = r8.name
    if is_error(r27) goto L212 (error at gatherish:44) else goto L22
L22:
    r28 = dank_mids.helpers._gather.Task :: static
    if is_error(r28) goto L213 else goto L25
L23:
    r29 = raise NameError('value for final name "Task" was not set')
    if not r29 goto L204 (error at gatherish:44) else goto L24 :: bool
L24:
    unreachable
L25:
    r30 = [r25, r26, r27]
    r31 = load_address r30
    r32 = ('loop', 'name')
    r33 = PyObject_Vectorcall(r28, r31, 1, r32)
    if is_error(r33) goto L214 (error at gatherish:44) else goto L26
L26:
    dec_ref r25
    dec_ref r26
    dec_ref r27
    r34 = r8.__mypyc_temp__0
    if is_error(r34) goto L215 (error at gatherish:-1) else goto L27
L27:
    r35 = PyList_Append(r34, r33)
    dec_ref r34
    dec_ref r33
    r36 = r35 >= 0 :: signed
    if not r36 goto L206 (error at gatherish:44) else goto L16 :: bool
L28:
    r37 = CPy_NoErrOccurred()
    if not r37 goto L206 (error at gatherish:44) else goto L29 :: bool
L29:
    r38 = r8.__mypyc_temp__0
    if is_error(r38) goto L206 (error at gatherish:-1) else goto L30
L30:
    r39 = PyObject_GetIter(r38)
    dec_ref r38
    if is_error(r39) goto L206 (error at gatherish:44) else goto L31
L31:
    r8.tasks = r39; r40 = is_error
    if not r40 goto L206 (error at gatherish:44) else goto L32 :: bool
L32:
    r41 = dank_mids.helpers._gather.yield_to_loop :: static
    if is_error(r41) goto L216 else goto L35
L33:
    r42 = raise NameError('value for final name "yield_to_loop" was not set')
    if not r42 goto L204 (error at gatherish:49) else goto L34 :: bool
L34:
    unreachable
L35:
    r43 = PyObject_Vectorcall(r41, 0, 0, 0)
    if is_error(r43) goto L206 (error at gatherish:49) else goto L36
L36:
    r44 = CPy_GetCoro(r43)
    dec_ref r43
    if is_error(r44) goto L206 (error at gatherish:49) else goto L37
L37:
    r8.__mypyc_temp__3 = r44; r45 = is_error
    if not r45 goto L206 (error at gatherish:-1) else goto L38 :: bool
L38:
    r46 = r8.__mypyc_temp__3
    if is_error(r46) goto L206 (error at gatherish:-1) else goto L39
L39:
    r47 = CPyIter_Next(r46)
    dec_ref r46
    if is_error(r47) goto L217 else goto L42
L40:
    r48 = CPy_FetchStopIterationValue()
    if is_error(r48) goto L218 (error at gatherish:49) else goto L41
L41:
    r49 = r48
    dec_ref r49
    goto L65
L42:
    r50 = r47
L43:
    r8.__mypyc_next_label__ = 2; r51 = is_error
    if not r51 goto L219 (error at gatherish:49) else goto L220 :: bool
L44:
    return r50
L45:
    r52 = load_address _Py_NoneStruct
    r53 = type != r52
    if r53 goto L46 else goto L48 :: bool
L46:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L49 (error at gatherish:49) else goto L221 :: bool
L47:
    unreachable
L48:
    inc_ref arg
    goto L60
L49:
    r54 = CPy_CatchError()
    r8.__mypyc_temp__4 = r54; r55 = is_error
    if not r55 goto L222 (error at gatherish:-1) else goto L50 :: bool
L50:
    r56 = load_address r1
    r57 = r8.__mypyc_temp__3
    if is_error(r57) goto L222 (error at gatherish:-1) else goto L51
L51:
    r58 = CPy_YieldFromErrorHandle(r57, r56)
    dec_ref r57
    if is_error(r58) goto L222 (error at gatherish:49) else goto L52
L52:
    if r58 goto L55 else goto L53 :: bool
L53:
    inc_ref r1
    r50 = r1
    r59 = r8.__mypyc_temp__4
    if is_error(r59) goto L223 (error at gatherish:-1) else goto L54
L54:
    CPy_RestoreExcInfo(r59)
    dec_ref r59
    goto L43
L55:
    r49 = r1
    dec_ref r49
    r60 = r8.__mypyc_temp__4
    if is_error(r60) goto L224 (error at gatherish:-1) else goto L56
L56:
    CPy_RestoreExcInfo(r60)
    dec_ref r60
    goto L65
L57:
    r61 = r8.__mypyc_temp__4
    dec_ref r8
    if is_error(r61) goto L204 (error at gatherish:-1) else goto L58
L58:
    CPy_RestoreExcInfo(r61)
    dec_ref r61
    r62 = CPy_KeepPropagating()
    if not r62 goto L204 else goto L59 :: bool
L59:
    unreachable
L60:
    r63 = r8.__mypyc_temp__3
    if is_error(r63) goto L225 (error at gatherish:-1) else goto L61
L61:
    r64 = CPyIter_Send(r63, arg)
    dec_ref r63
    dec_ref arg
    if is_error(r64) goto L226 else goto L62
L62:
    r50 = r64
    goto L43
L63:
    r65 = CPy_FetchStopIterationValue()
    if is_error(r65) goto L218 (error at gatherish:49) else goto L64
L64:
    r49 = r65
    dec_ref r49
L65:
    r66 = dank_mids.helpers._gather.yield_to_loop :: static
    if is_error(r66) goto L227 else goto L68
L66:
    r67 = raise NameError('value for final name "yield_to_loop" was not set')
    if not r67 goto L204 (error at gatherish:50) else goto L67 :: bool
L67:
    unreachable
L68:
    r68 = PyObject_Vectorcall(r66, 0, 0, 0)
    if is_error(r68) goto L218 (error at gatherish:50) else goto L69
L69:
    r69 = CPy_GetCoro(r68)
    dec_ref r68
    if is_error(r69) goto L218 (error at gatherish:50) else goto L70
L70:
    r8.__mypyc_temp__5 = r69; r70 = is_error
    if not r70 goto L218 (error at gatherish:-1) else goto L71 :: bool
L71:
    r71 = r8.__mypyc_temp__5
    if is_error(r71) goto L218 (error at gatherish:-1) else goto L72
L72:
    r72 = CPyIter_Next(r71)
    dec_ref r71
    if is_error(r72) goto L228 else goto L75
L73:
    r73 = CPy_FetchStopIterationValue()
    if is_error(r73) goto L229 (error at gatherish:50) else goto L74
L74:
    r74 = r73
    dec_ref r74
    goto L98
L75:
    r75 = r72
L76:
    r8.__mypyc_next_label__ = 4; r76 = is_error
    if not r76 goto L230 (error at gatherish:50) else goto L231 :: bool
L77:
    return r75
L78:
    r77 = load_address _Py_NoneStruct
    r78 = type != r77
    if r78 goto L79 else goto L81 :: bool
L79:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L82 (error at gatherish:50) else goto L232 :: bool
L80:
    unreachable
L81:
    inc_ref arg
    goto L93
L82:
    r79 = CPy_CatchError()
    r8.__mypyc_temp__6 = r79; r80 = is_error
    if not r80 goto L233 (error at gatherish:-1) else goto L83 :: bool
L83:
    r81 = load_address r3
    r82 = r8.__mypyc_temp__5
    if is_error(r82) goto L233 (error at gatherish:-1) else goto L84
L84:
    r83 = CPy_YieldFromErrorHandle(r82, r81)
    dec_ref r82
    if is_error(r83) goto L233 (error at gatherish:50) else goto L85
L85:
    if r83 goto L88 else goto L86 :: bool
L86:
    inc_ref r3
    r75 = r3
    r84 = r8.__mypyc_temp__6
    if is_error(r84) goto L234 (error at gatherish:-1) else goto L87
L87:
    CPy_RestoreExcInfo(r84)
    dec_ref r84
    goto L76
L88:
    r74 = r3
    dec_ref r74
    r85 = r8.__mypyc_temp__6
    if is_error(r85) goto L235 (error at gatherish:-1) else goto L89
L89:
    CPy_RestoreExcInfo(r85)
    dec_ref r85
    goto L98
L90:
    r86 = r8.__mypyc_temp__6
    dec_ref r8
    if is_error(r86) goto L204 (error at gatherish:-1) else goto L91
L91:
    CPy_RestoreExcInfo(r86)
    dec_ref r86
    r87 = CPy_KeepPropagating()
    if not r87 goto L204 else goto L92 :: bool
L92:
    unreachable
L93:
    r88 = r8.__mypyc_temp__5
    if is_error(r88) goto L236 (error at gatherish:-1) else goto L94
L94:
    r89 = CPyIter_Send(r88, arg)
    dec_ref r88
    dec_ref arg
    if is_error(r89) goto L237 else goto L95
L95:
    r75 = r89
    goto L76
L96:
    r90 = CPy_FetchStopIterationValue()
    if is_error(r90) goto L229 (error at gatherish:50) else goto L97
L97:
    r74 = r90
    dec_ref r74
L98:
    r91 = r8.tasks
    if is_error(r91) goto L229 (error at gatherish:51) else goto L99
L99:
    r92 = PyObject_GetIter(r91)
    if is_error(r92) goto L238 (error at gatherish:51) else goto L100
L100:
    r8.__mypyc_temp__7 = r91; r93 = is_error
    if not r93 goto L239 (error at gatherish:-1) else goto L101 :: bool
L101:
    r8.__mypyc_temp__8 = r92; r94 = is_error
    if not r94 goto L229 (error at gatherish:-1) else goto L102 :: bool
L102:
    r95 = r8.__mypyc_temp__8
    if is_error(r95) goto L229 (error at gatherish:51) else goto L103
L103:
    r96 = PyIter_Next(r95)
    dec_ref r95
    if is_error(r96) goto L240 else goto L104
L104:
    r8.task = r96; r97 = is_error
    if not r97 goto L229 (error at gatherish:51) else goto L105 :: bool
L105:
    r98 = r8.task
    if is_error(r98) goto L241 (error at gatherish:53) else goto L106
L106:
    r99 = CPy_GetCoro(r98)
    dec_ref r98
    if is_error(r99) goto L241 (error at gatherish:53) else goto L107
L107:
    r8.__mypyc_temp__9 = r99; r100 = is_error
    if not r100 goto L241 (error at gatherish:-1) else goto L108 :: bool
L108:
    r101 = r8.__mypyc_temp__9
    if is_error(r101) goto L241 (error at gatherish:-1) else goto L109
L109:
    r102 = CPyIter_Next(r101)
    dec_ref r101
    if is_error(r102) goto L110 else goto L112
L110:
    r103 = CPy_FetchStopIterationValue()
    if is_error(r103) goto L241 (error at gatherish:53) else goto L111
L111:
    r104 = r103
    dec_ref r104
    goto L102
L112:
    r105 = r102
L113:
    r8.__mypyc_next_label__ = 6; r106 = is_error
    if not r106 goto L242 (error at gatherish:53) else goto L243 :: bool
L114:
    return r105
L115:
    r107 = load_address _Py_NoneStruct
    r108 = type != r107
    if r108 goto L116 else goto L118 :: bool
L116:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L119 (error at gatherish:53) else goto L244 :: bool
L117:
    unreachable
L118:
    inc_ref arg
    goto L130
L119:
    r109 = CPy_CatchError()
    r8.__mypyc_temp__10 = r109; r110 = is_error
    if not r110 goto L245 (error at gatherish:-1) else goto L120 :: bool
L120:
    r111 = load_address r5
    r112 = r8.__mypyc_temp__9
    if is_error(r112) goto L245 (error at gatherish:-1) else goto L121
L121:
    r113 = CPy_YieldFromErrorHandle(r112, r111)
    dec_ref r112
    if is_error(r113) goto L245 (error at gatherish:53) else goto L122
L122:
    if r113 goto L125 else goto L123 :: bool
L123:
    inc_ref r5
    r105 = r5
    r114 = r8.__mypyc_temp__10
    if is_error(r114) goto L246 (error at gatherish:-1) else goto L124
L124:
    CPy_RestoreExcInfo(r114)
    dec_ref r114
    goto L113
L125:
    inc_ref r5
    r104 = r5
    dec_ref r104
    r115 = r8.__mypyc_temp__10
    if is_error(r115) goto L245 (error at gatherish:-1) else goto L126
L126:
    CPy_RestoreExcInfo(r115)
    dec_ref r115
    goto L102
L127:
    r116 = r8.__mypyc_temp__10
    if is_error(r116) goto L135 (error at gatherish:-1) else goto L128
L128:
    CPy_RestoreExcInfo(r116)
    dec_ref r116
    r117 = CPy_KeepPropagating()
    if not r117 goto L135 else goto L247 :: bool
L129:
    unreachable
L130:
    r118 = r8.__mypyc_temp__9
    if is_error(r118) goto L248 (error at gatherish:-1) else goto L131
L131:
    r119 = CPyIter_Send(r118, arg)
    dec_ref r118
    dec_ref arg
    if is_error(r119) goto L133 else goto L132
L132:
    r105 = r119
    goto L113
L133:
    r120 = CPy_FetchStopIterationValue()
    if is_error(r120) goto L241 (error at gatherish:53) else goto L134
L134:
    r104 = r120
    dec_ref r104
    goto L102
L135:
    r121 = CPy_CatchError()
    r8.__mypyc_temp__11 = r121; r122 = is_error
    if not r122 goto L249 (error at gatherish:-1) else goto L136 :: bool
L136:
    r123 = builtins :: module
    r124 = 'Exception'
    r125 = CPyObject_GetAttr(r123, r124)
    if is_error(r125) goto L249 (error at gatherish:54) else goto L137
L137:
    r126 = CPy_ExceptionMatches(r125)
    dec_ref r125
    if r126 goto L138 else goto L250 :: bool
L138:
    r127 = r8.tasks
    if is_error(r127) goto L249 (error at gatherish:57) else goto L139
L139:
    r128 = PyObject_GetIter(r127)
    if is_error(r128) goto L251 (error at gatherish:57) else goto L140
L140:
    r8.__mypyc_temp__12 = r127; r129 = is_error
    if not r129 goto L252 (error at gatherish:-1) else goto L141 :: bool
L141:
    r8.__mypyc_temp__13 = r128; r130 = is_error
    if not r130 goto L249 (error at gatherish:-1) else goto L142 :: bool
L142:
    r131 = r8.__mypyc_temp__13
    if is_error(r131) goto L249 (error at gatherish:57) else goto L143
L143:
    r132 = PyIter_Next(r131)
    dec_ref r131
    if is_error(r132) goto L253 else goto L144
L144:
    r8.task = r132; r133 = is_error
    if not r133 goto L249 (error at gatherish:57) else goto L145 :: bool
L145:
    r134 = r8.task
    if is_error(r134) goto L175 (error at gatherish:60) else goto L146
L146:
    r135 = CPy_GetCoro(r134)
    dec_ref r134
    if is_error(r135) goto L175 (error at gatherish:60) else goto L147
L147:
    r8.__mypyc_temp__14 = r135; r136 = is_error
    if not r136 goto L175 (error at gatherish:-1) else goto L148 :: bool
L148:
    r137 = r8.__mypyc_temp__14
    if is_error(r137) goto L175 (error at gatherish:-1) else goto L149
L149:
    r138 = CPyIter_Next(r137)
    dec_ref r137
    if is_error(r138) goto L150 else goto L152
L150:
    r139 = CPy_FetchStopIterationValue()
    if is_error(r139) goto L175 (error at gatherish:60) else goto L151
L151:
    r140 = r139
    dec_ref r140
    goto L142
L152:
    r141 = r138
L153:
    r8.__mypyc_next_label__ = 8; r142 = is_error
    if not r142 goto L254 (error at gatherish:60) else goto L255 :: bool
L154:
    return r141
L155:
    r143 = load_address _Py_NoneStruct
    r144 = type != r143
    if r144 goto L156 else goto L158 :: bool
L156:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L159 (error at gatherish:60) else goto L256 :: bool
L157:
    unreachable
L158:
    inc_ref arg
    goto L170
L159:
    r145 = CPy_CatchError()
    r8.__mypyc_temp__15 = r145; r146 = is_error
    if not r146 goto L167 (error at gatherish:-1) else goto L160 :: bool
L160:
    r147 = load_address r7
    r148 = r8.__mypyc_temp__14
    if is_error(r148) goto L167 (error at gatherish:-1) else goto L161
L161:
    r149 = CPy_YieldFromErrorHandle(r148, r147)
    dec_ref r148
    if is_error(r149) goto L167 (error at gatherish:60) else goto L162
L162:
    if r149 goto L165 else goto L163 :: bool
L163:
    inc_ref r7
    r141 = r7
    r150 = r8.__mypyc_temp__15
    if is_error(r150) goto L257 (error at gatherish:-1) else goto L164
L164:
    CPy_RestoreExcInfo(r150)
    dec_ref r150
    goto L153
L165:
    inc_ref r7
    r140 = r7
    dec_ref r140
    r151 = r8.__mypyc_temp__15
    if is_error(r151) goto L167 (error at gatherish:-1) else goto L166
L166:
    CPy_RestoreExcInfo(r151)
    dec_ref r151
    goto L142
L167:
    r152 = r8.__mypyc_temp__15
    if is_error(r152) goto L175 (error at gatherish:-1) else goto L168
L168:
    CPy_RestoreExcInfo(r152)
    dec_ref r152
    r153 = CPy_KeepPropagating()
    if not r153 goto L175 else goto L258 :: bool
L169:
    unreachable
L170:
    r154 = r8.__mypyc_temp__14
    if is_error(r154) goto L259 (error at gatherish:-1) else goto L171
L171:
    r155 = CPyIter_Send(r154, arg)
    dec_ref r154
    dec_ref arg
    if is_error(r155) goto L173 else goto L172
L172:
    r141 = r155
    goto L153
L173:
    r156 = CPy_FetchStopIterationValue()
    if is_error(r156) goto L175 (error at gatherish:60) else goto L174
L174:
    r140 = r156
    dec_ref r140
    goto L142
L175:
    r157 = CPy_CatchError()
    r8.__mypyc_temp__16 = r157; r158 = is_error
    if not r158 goto L260 (error at gatherish:-1) else goto L176 :: bool
L176:
    r159 = builtins :: module
    r160 = 'Exception'
    r161 = CPyObject_GetAttr(r159, r160)
    if is_error(r161) goto L260 (error at gatherish:61) else goto L177
L177:
    r162 = CPy_ExceptionMatches(r161)
    dec_ref r161
    if r162 goto L180 else goto L261 :: bool
L178:
    CPy_Reraise()
    if not 0 goto L182 else goto L262 :: bool
L179:
    unreachable
L180:
    r163 = r8.__mypyc_temp__16
    if is_error(r163) goto L249 (error at gatherish:-1) else goto L181
L181:
    CPy_RestoreExcInfo(r163)
    dec_ref r163
    goto L142
L182:
    r164 = r8.__mypyc_temp__16
    if is_error(r164) goto L190 (error at gatherish:-1) else goto L183
L183:
    CPy_RestoreExcInfo(r164)
    dec_ref r164
    r165 = CPy_KeepPropagating()
    if not r165 goto L190 else goto L263 :: bool
L184:
    unreachable
L185:
    r166 = CPy_NoErrOccurred()
    if not r166 goto L190 (error at gatherish:57) else goto L186 :: bool
L186:
    CPy_Reraise()
    if not 0 goto L190 else goto L264 :: bool
L187:
    unreachable
L188:
    CPy_Reraise()
    if not 0 goto L190 else goto L265 :: bool
L189:
    unreachable
L190:
    r167 = r8.__mypyc_temp__11
    dec_ref r8
    if is_error(r167) goto L204 (error at gatherish:-1) else goto L191
L191:
    CPy_RestoreExcInfo(r167)
    dec_ref r167
    r168 = CPy_KeepPropagating()
    if not r168 goto L204 else goto L192 :: bool
L192:
    unreachable
L193:
    r169 = CPy_NoErrOccurred()
    if not r169 goto L266 (error at gatherish:51) else goto L194 :: bool
L194:
    r170 = box(None, 1)
    r8.__mypyc_next_label__ = -2; r171 = is_error
    dec_ref r8
    if not r171 goto L204 (error at gatherish:33) else goto L195 :: bool
L195:
    CPyGen_SetStopIterationValue(r170)
    if not 0 goto L204 else goto L196 :: bool
L196:
    unreachable
L197:
    r172 = r9 == 0
    if r172 goto L267 else goto L198 :: bool
L198:
    r173 = r9 == 2
    if r173 goto L268 else goto L269 :: bool
L199:
    r174 = r9 == 4
    if r174 goto L270 else goto L271 :: bool
L200:
    r175 = r9 == 6
    if r175 goto L272 else goto L273 :: bool
L201:
    r176 = r9 == 8
    dec_ref r9 :: int
    if r176 goto L155 else goto L274 :: bool
L202:
    r177 = raise StopIteration
    if not r177 goto L204 (error at gatherish:33) else goto L203 :: bool
L203:
    unreachable
L204:
    r178 = <error> :: object
    return r178
L205:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    goto L204
L206:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L204
L207:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L3
L208:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L6
L209:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r18
    goto L204
L210:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r19
    goto L204
L211:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r25
    goto L204
L212:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r25
    dec_ref r26
    goto L204
L213:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r25
    dec_ref r26
    dec_ref r27
    goto L23
L214:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r25
    dec_ref r26
    dec_ref r27
    goto L204
L215:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r33
    goto L204
L216:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L33
L217:
    xdec_ref r1
    goto L40
L218:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L204
L219:
    dec_ref r50
    goto L49
L220:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L44
L221:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L47
L222:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    goto L57
L223:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r50
    goto L57
L224:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    goto L57
L225:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref arg
    goto L204
L226:
    xdec_ref r1
    goto L63
L227:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L66
L228:
    xdec_ref r3
    goto L73
L229:
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L204
L230:
    dec_ref r75
    goto L82
L231:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L77
L232:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L80
L233:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    goto L90
L234:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r75
    goto L90
L235:
    xdec_ref r5
    xdec_ref r7
    goto L90
L236:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref arg
    goto L204
L237:
    xdec_ref r3
    goto L96
L238:
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r91
    goto L204
L239:
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r92
    goto L204
L240:
    xdec_ref r5
    xdec_ref r7
    goto L193
L241:
    xdec_ref r5
    goto L135
L242:
    dec_ref r105
    goto L119
L243:
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L114
L244:
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L117
L245:
    xdec_ref r5
    goto L127
L246:
    xdec_ref r5
    dec_ref r105
    goto L127
L247:
    xdec_ref r7
    dec_ref r8
    goto L129
L248:
    xdec_ref r5
    dec_ref arg
    goto L135
L249:
    xdec_ref r7
    goto L190
L250:
    xdec_ref r7
    goto L188
L251:
    xdec_ref r7
    dec_ref r127
    goto L190
L252:
    xdec_ref r7
    dec_ref r128
    goto L190
L253:
    xdec_ref r7
    goto L185
L254:
    dec_ref r141
    goto L159
L255:
    xdec_ref r7
    dec_ref r8
    goto L154
L256:
    xdec_ref r7
    dec_ref r8
    goto L157
L257:
    dec_ref r141
    goto L167
L258:
    xdec_ref r7
    dec_ref r8
    goto L169
L259:
    dec_ref arg
    goto L175
L260:
    xdec_ref r7
    goto L182
L261:
    xdec_ref r7
    goto L178
L262:
    dec_ref r8
    goto L179
L263:
    dec_ref r8
    goto L184
L264:
    dec_ref r8
    goto L187
L265:
    dec_ref r8
    goto L189
L266:
    dec_ref r8
    goto L204
L267:
    dec_ref r9 :: int
    goto L2
L268:
    dec_ref r9 :: int
    goto L45
L269:
    xdec_ref r1
    goto L199
L270:
    dec_ref r9 :: int
    goto L78
L271:
    xdec_ref r3
    goto L200
L272:
    dec_ref r9 :: int
    goto L115
L273:
    xdec_ref r5
    goto L201
L274:
    xdec_ref r7
    dec_ref r8
    goto L202

def gatherish_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = gatherish_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def gatherish_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = gatherish_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def gatherish_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def gatherish_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = gatherish_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def gatherish_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def gatherish_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def gatherish(coros, name):
    coros :: object
    name :: union[str, None]
    r0 :: object
    r1 :: dank_mids.helpers._gather.gatherish_env
    r2, r3 :: bool
    r4 :: dank_mids.helpers._gather.gatherish_gen
    r5, r6 :: bool
    r7 :: object
L0:
    if is_error(name) goto L1 else goto L10
L1:
    r0 = box(None, 1)
    inc_ref r0
    name = r0
L2:
    r1 = gatherish_env()
    if is_error(r1) goto L11 (error at gatherish:33) else goto L3
L3:
    inc_ref coros
    r1.coros = coros; r2 = is_error
    if not r2 goto L12 (error at gatherish:33) else goto L4 :: bool
L4:
    r1.name = name; r3 = is_error
    if not r3 goto L13 (error at gatherish:33) else goto L5 :: bool
L5:
    r4 = gatherish_gen()
    if is_error(r4) goto L13 (error at gatherish:33) else goto L6
L6:
    inc_ref r1
    r4.__mypyc_env__ = r1; r5 = is_error
    if not r5 goto L14 (error at gatherish:33) else goto L7 :: bool
L7:
    r1.__mypyc_next_label__ = 0; r6 = is_error
    dec_ref r1
    if not r6 goto L15 (error at gatherish:33) else goto L8 :: bool
L8:
    return r4
L9:
    r7 = <error> :: object
    return r7
L10:
    inc_ref name
    goto L2
L11:
    dec_ref name
    goto L9
L12:
    dec_ref name
    dec_ref r1
    goto L9
L13:
    dec_ref r1
    goto L9
L14:
    dec_ref r1
    dec_ref r4
    goto L9
L15:
    dec_ref r4
    goto L9

def first_completed_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    type, value, traceback, arg, r0, r1, r2, r3 :: object
    r4 :: dank_mids.helpers._gather.first_completed_env
    r5 :: int
    r6 :: object
    r7 :: bit
    r8 :: bool
    r9 :: tuple
    r10 :: str
    r11 :: object
    r12 :: bool
    r13 :: object[2]
    r14 :: object_ptr
    r15, r16, r17 :: object
    r18 :: bool
    r19, r20, r21, r22, r23 :: object
    r24 :: bool
    r25 :: object
    r26 :: bit
    r27 :: tuple[object, object, object]
    r28 :: bool
    r29 :: object_ptr
    r30 :: object
    r31 :: bool
    r32, r33, r34 :: tuple[object, object, object]
    r35 :: bit
    r36, r37, r38 :: object
    r39 :: tuple[set, set]
    r40 :: object
    r41 :: bool
    r42 :: tuple
    r43 :: str
    r44 :: object
    r45 :: bool
    r46 :: object[2]
    r47 :: object_ptr
    r48, r49, r50 :: object
    r51 :: bool
    r52, r53, r54, r55, r56 :: object
    r57 :: bool
    r58 :: object
    r59 :: bit
    r60 :: tuple[object, object, object]
    r61 :: bool
    r62 :: object_ptr
    r63 :: object
    r64 :: bool
    r65, r66, r67 :: tuple[object, object, object]
    r68 :: bit
    r69, r70, r71 :: object
    r72 :: tuple[set, set]
    r73, r74, r75 :: set
    r76 :: bool
    r77 :: set
    r78 :: bool
    r79 :: set
    r80 :: object
    r81, r82 :: bool
    r83, r84 :: object
    r85 :: bool
    r86 :: object
    r87 :: str
    r88 :: object[1]
    r89 :: object_ptr
    r90 :: object
    r91 :: bit
    r92 :: set
    r93 :: bool
    r94, r95, r96 :: bit
    r97 :: bool
    r98 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = __mypyc_self__.__mypyc_env__
    if is_error(r4) goto L103 (error at first_completed:74) else goto L1
L1:
    r5 = r4.__mypyc_next_label__
    if is_error(r5) goto L104 (error at first_completed:74) else goto L97
L2:
    r6 = load_address _Py_NoneStruct
    r7 = type != r6
    if r7 goto L105 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L102 (error at first_completed:74) else goto L4 :: bool
L4:
    unreachable
L5:
    r8 = r4.cancel
    if is_error(r8) goto L104 (error at first_completed:77) else goto L6
L6:
    if r8 goto L106 else goto L107 :: bool
L7:
    r9 = r4.fs
    if is_error(r9) goto L108 (error at first_completed:78) else goto L8
L8:
    r10 = 'FIRST_COMPLETED'
    r11 = dank_mids.helpers._gather.wait :: static
    if is_error(r11) goto L109 else goto L11
L9:
    r12 = raise NameError('value for final name "wait" was not set')
    if not r12 goto L102 (error at first_completed:78) else goto L10 :: bool
L10:
    unreachable
L11:
    r13 = [r9, r10]
    r14 = load_address r13
    r15 = ('return_when',)
    r16 = PyObject_Vectorcall(r11, r14, 1, r15)
    if is_error(r16) goto L110 (error at first_completed:78) else goto L12
L12:
    dec_ref r9
    r17 = CPy_GetCoro(r16)
    dec_ref r16
    if is_error(r17) goto L108 (error at first_completed:78) else goto L13
L13:
    r4.__mypyc_temp__17 = r17; r18 = is_error
    if not r18 goto L108 (error at first_completed:-1) else goto L14 :: bool
L14:
    r19 = r4.__mypyc_temp__17
    if is_error(r19) goto L108 (error at first_completed:-1) else goto L15
L15:
    r20 = CPyIter_Next(r19)
    dec_ref r19
    if is_error(r20) goto L111 else goto L18
L16:
    r21 = CPy_FetchStopIterationValue()
    if is_error(r21) goto L112 (error at first_completed:78) else goto L17
L17:
    r22 = r21
    goto L41
L18:
    r23 = r20
L19:
    r4.__mypyc_next_label__ = 2; r24 = is_error
    if not r24 goto L113 (error at first_completed:78) else goto L114 :: bool
L20:
    return r23
L21:
    r25 = load_address _Py_NoneStruct
    r26 = type != r25
    if r26 goto L22 else goto L24 :: bool
L22:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L25 (error at first_completed:78) else goto L115 :: bool
L23:
    unreachable
L24:
    inc_ref arg
    goto L36
L25:
    r27 = CPy_CatchError()
    r4.__mypyc_temp__18 = r27; r28 = is_error
    if not r28 goto L116 (error at first_completed:-1) else goto L26 :: bool
L26:
    r29 = load_address r1
    r30 = r4.__mypyc_temp__17
    if is_error(r30) goto L116 (error at first_completed:-1) else goto L27
L27:
    r31 = CPy_YieldFromErrorHandle(r30, r29)
    dec_ref r30
    if is_error(r31) goto L116 (error at first_completed:78) else goto L28
L28:
    if r31 goto L31 else goto L29 :: bool
L29:
    inc_ref r1
    r23 = r1
    r32 = r4.__mypyc_temp__18
    if is_error(r32) goto L117 (error at first_completed:-1) else goto L30
L30:
    CPy_RestoreExcInfo(r32)
    dec_ref r32
    goto L19
L31:
    r22 = r1
    r33 = r4.__mypyc_temp__18
    if is_error(r33) goto L118 (error at first_completed:-1) else goto L32
L32:
    CPy_RestoreExcInfo(r33)
    dec_ref r33
    goto L41
L33:
    r34 = r4.__mypyc_temp__18
    dec_ref r4
    if is_error(r34) goto L102 (error at first_completed:-1) else goto L34
L34:
    CPy_RestoreExcInfo(r34)
    dec_ref r34
    r35 = CPy_KeepPropagating()
    if not r35 goto L102 else goto L35 :: bool
L35:
    unreachable
L36:
    r36 = r4.__mypyc_temp__17
    if is_error(r36) goto L119 (error at first_completed:-1) else goto L37
L37:
    r37 = CPyIter_Send(r36, arg)
    dec_ref r36
    dec_ref arg
    if is_error(r37) goto L120 else goto L38
L38:
    r23 = r37
    goto L19
L39:
    r38 = CPy_FetchStopIterationValue()
    if is_error(r38) goto L112 (error at first_completed:78) else goto L40
L40:
    r22 = r38
L41:
    r39 = unbox(tuple[set, set], r22)
    dec_ref r22
    if is_error(r39) goto L112 (error at first_completed:78) else goto L42
L42:
    r40 = box(tuple[set, set], r39)
    r4.__mypyc_next_label__ = -2; r41 = is_error
    dec_ref r4
    if not r41 goto L121 (error at first_completed:78) else goto L43 :: bool
L43:
    CPyGen_SetStopIterationValue(r40)
    dec_ref r40
    if not 0 goto L102 else goto L44 :: bool
L44:
    unreachable
L45:
    r42 = r4.fs
    if is_error(r42) goto L122 (error at first_completed:79) else goto L46
L46:
    r43 = 'FIRST_COMPLETED'
    r44 = dank_mids.helpers._gather.wait :: static
    if is_error(r44) goto L123 else goto L49
L47:
    r45 = raise NameError('value for final name "wait" was not set')
    if not r45 goto L102 (error at first_completed:79) else goto L48 :: bool
L48:
    unreachable
L49:
    r46 = [r42, r43]
    r47 = load_address r46
    r48 = ('return_when',)
    r49 = PyObject_Vectorcall(r44, r47, 1, r48)
    if is_error(r49) goto L124 (error at first_completed:79) else goto L50
L50:
    dec_ref r42
    r50 = CPy_GetCoro(r49)
    dec_ref r49
    if is_error(r50) goto L122 (error at first_completed:79) else goto L51
L51:
    r4.__mypyc_temp__19 = r50; r51 = is_error
    if not r51 goto L122 (error at first_completed:-1) else goto L52 :: bool
L52:
    r52 = r4.__mypyc_temp__19
    if is_error(r52) goto L122 (error at first_completed:-1) else goto L53
L53:
    r53 = CPyIter_Next(r52)
    dec_ref r52
    if is_error(r53) goto L125 else goto L56
L54:
    r54 = CPy_FetchStopIterationValue()
    if is_error(r54) goto L112 (error at first_completed:79) else goto L55
L55:
    r55 = r54
    goto L79
L56:
    r56 = r53
L57:
    r4.__mypyc_next_label__ = 4; r57 = is_error
    if not r57 goto L126 (error at first_completed:79) else goto L127 :: bool
L58:
    return r56
L59:
    r58 = load_address _Py_NoneStruct
    r59 = type != r58
    if r59 goto L60 else goto L62 :: bool
L60:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L63 (error at first_completed:79) else goto L128 :: bool
L61:
    unreachable
L62:
    inc_ref arg
    goto L74
L63:
    r60 = CPy_CatchError()
    r4.__mypyc_temp__20 = r60; r61 = is_error
    if not r61 goto L129 (error at first_completed:-1) else goto L64 :: bool
L64:
    r62 = load_address r3
    r63 = r4.__mypyc_temp__19
    if is_error(r63) goto L129 (error at first_completed:-1) else goto L65
L65:
    r64 = CPy_YieldFromErrorHandle(r63, r62)
    dec_ref r63
    if is_error(r64) goto L129 (error at first_completed:79) else goto L66
L66:
    if r64 goto L69 else goto L67 :: bool
L67:
    inc_ref r3
    r56 = r3
    r65 = r4.__mypyc_temp__20
    if is_error(r65) goto L130 (error at first_completed:-1) else goto L68
L68:
    CPy_RestoreExcInfo(r65)
    dec_ref r65
    goto L57
L69:
    r55 = r3
    r66 = r4.__mypyc_temp__20
    if is_error(r66) goto L131 (error at first_completed:-1) else goto L70
L70:
    CPy_RestoreExcInfo(r66)
    dec_ref r66
    goto L79
L71:
    r67 = r4.__mypyc_temp__20
    dec_ref r4
    if is_error(r67) goto L102 (error at first_completed:-1) else goto L72
L72:
    CPy_RestoreExcInfo(r67)
    dec_ref r67
    r68 = CPy_KeepPropagating()
    if not r68 goto L102 else goto L73 :: bool
L73:
    unreachable
L74:
    r69 = r4.__mypyc_temp__19
    if is_error(r69) goto L132 (error at first_completed:-1) else goto L75
L75:
    r70 = CPyIter_Send(r69, arg)
    dec_ref r69
    dec_ref arg
    if is_error(r70) goto L133 else goto L76
L76:
    r56 = r70
    goto L57
L77:
    r71 = CPy_FetchStopIterationValue()
    if is_error(r71) goto L112 (error at first_completed:79) else goto L78
L78:
    r55 = r71
L79:
    r72 = unbox(tuple[set, set], r55)
    dec_ref r55
    if is_error(r72) goto L112 (error at first_completed:79) else goto L80
L80:
    r73 = borrow r72[0]
    r74 = borrow r72[1]
    r75 = unborrow r73
    r4.done = r75; r76 = is_error
    if not r76 goto L112 (error at first_completed:79) else goto L81 :: bool
L81:
    r77 = unborrow r74
    r4.pending = r77; r78 = is_error
    if not r78 goto L112 (error at first_completed:79) else goto L82 :: bool
L82:
    r79 = r4.pending
    if is_error(r79) goto L112 (error at first_completed:80) else goto L83
L83:
    r80 = PyObject_GetIter(r79)
    if is_error(r80) goto L134 (error at first_completed:80) else goto L84
L84:
    r4.__mypyc_temp__21 = r79; r81 = is_error
    if not r81 goto L135 (error at first_completed:-1) else goto L85 :: bool
L85:
    r4.__mypyc_temp__22 = r80; r82 = is_error
    if not r82 goto L112 (error at first_completed:-1) else goto L86 :: bool
L86:
    r83 = r4.__mypyc_temp__22
    if is_error(r83) goto L112 (error at first_completed:80) else goto L87
L87:
    r84 = PyIter_Next(r83)
    dec_ref r83
    if is_error(r84) goto L92 else goto L88
L88:
    r4.p = r84; r85 = is_error
    if not r85 goto L112 (error at first_completed:80) else goto L89 :: bool
L89:
    r86 = r4.p
    if is_error(r86) goto L112 (error at first_completed:81) else goto L90
L90:
    r87 = 'cancel'
    r88 = [r86]
    r89 = load_address r88
    r90 = PyObject_VectorcallMethod(r87, r89, 9223372036854775809, 0)
    if is_error(r90) goto L136 (error at first_completed:81) else goto L137
L91:
    dec_ref r86
    goto L86
L92:
    r91 = CPy_NoErrOccurred()
    if not r91 goto L112 (error at first_completed:80) else goto L93 :: bool
L93:
    r92 = r4.done
    if is_error(r92) goto L112 (error at first_completed:82) else goto L94
L94:
    r4.__mypyc_next_label__ = -2; r93 = is_error
    dec_ref r4
    if not r93 goto L138 (error at first_completed:82) else goto L95 :: bool
L95:
    CPyGen_SetStopIterationValue(r92)
    dec_ref r92
    if not 0 goto L102 else goto L96 :: bool
L96:
    unreachable
L97:
    r94 = r5 == 0
    if r94 goto L139 else goto L98 :: bool
L98:
    r95 = r5 == 2
    if r95 goto L140 else goto L141 :: bool
L99:
    r96 = r5 == 4
    dec_ref r5 :: int
    if r96 goto L59 else goto L142 :: bool
L100:
    r97 = raise StopIteration
    if not r97 goto L102 (error at first_completed:74) else goto L101 :: bool
L101:
    unreachable
L102:
    r98 = <error> :: object
    return r98
L103:
    xdec_ref r1
    xdec_ref r3
    goto L102
L104:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L102
L105:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L3
L106:
    xdec_ref r1
    goto L45
L107:
    xdec_ref r3
    goto L7
L108:
    xdec_ref r1
    dec_ref r4
    goto L102
L109:
    xdec_ref r1
    dec_ref r4
    dec_ref r9
    goto L9
L110:
    xdec_ref r1
    dec_ref r4
    dec_ref r9
    goto L102
L111:
    xdec_ref r1
    goto L16
L112:
    dec_ref r4
    goto L102
L113:
    dec_ref r23
    goto L25
L114:
    xdec_ref r1
    dec_ref r4
    goto L20
L115:
    xdec_ref r1
    dec_ref r4
    goto L23
L116:
    xdec_ref r1
    goto L33
L117:
    xdec_ref r1
    dec_ref r23
    goto L33
L118:
    dec_ref r22
    goto L33
L119:
    xdec_ref r1
    dec_ref r4
    dec_ref arg
    goto L102
L120:
    xdec_ref r1
    goto L39
L121:
    dec_ref r40
    goto L102
L122:
    xdec_ref r3
    dec_ref r4
    goto L102
L123:
    xdec_ref r3
    dec_ref r4
    dec_ref r42
    goto L47
L124:
    xdec_ref r3
    dec_ref r4
    dec_ref r42
    goto L102
L125:
    xdec_ref r3
    goto L54
L126:
    dec_ref r56
    goto L63
L127:
    xdec_ref r3
    dec_ref r4
    goto L58
L128:
    xdec_ref r3
    dec_ref r4
    goto L61
L129:
    xdec_ref r3
    goto L71
L130:
    xdec_ref r3
    dec_ref r56
    goto L71
L131:
    dec_ref r55
    goto L71
L132:
    xdec_ref r3
    dec_ref r4
    dec_ref arg
    goto L102
L133:
    xdec_ref r3
    goto L77
L134:
    dec_ref r4
    dec_ref r79
    goto L102
L135:
    dec_ref r4
    dec_ref r80
    goto L102
L136:
    dec_ref r4
    dec_ref r86
    goto L102
L137:
    dec_ref r90
    goto L91
L138:
    dec_ref r92
    goto L102
L139:
    dec_ref r5 :: int
    goto L2
L140:
    xdec_ref r3
    dec_ref r5 :: int
    goto L21
L141:
    xdec_ref r1
    goto L99
L142:
    xdec_ref r3
    dec_ref r4
    goto L100

def first_completed_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = first_completed_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def first_completed_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = first_completed_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def first_completed_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def first_completed_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = first_completed_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def first_completed_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def first_completed_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def first_completed(fs, cancel):
    fs :: tuple
    cancel :: bool
    r0 :: dank_mids.helpers._gather.first_completed_env
    r1, r2 :: bool
    r3 :: dank_mids.helpers._gather.first_completed_gen
    r4, r5 :: bool
    r6 :: object
L0:
    if is_error(cancel) goto L1 else goto L2
L1:
    cancel = 0
L2:
    r0 = first_completed_env()
    if is_error(r0) goto L9 (error at first_completed:74) else goto L3
L3:
    inc_ref fs
    r0.fs = fs; r1 = is_error
    if not r1 goto L10 (error at first_completed:74) else goto L4 :: bool
L4:
    r0.cancel = cancel; r2 = is_error
    if not r2 goto L10 (error at first_completed:74) else goto L5 :: bool
L5:
    r3 = first_completed_gen()
    if is_error(r3) goto L10 (error at first_completed:74) else goto L6
L6:
    inc_ref r0
    r3.__mypyc_env__ = r0; r4 = is_error
    if not r4 goto L11 (error at first_completed:74) else goto L7 :: bool
L7:
    r0.__mypyc_next_label__ = 0; r5 = is_error
    dec_ref r0
    if not r5 goto L12 (error at first_completed:74) else goto L8 :: bool
L8:
    return r3
L9:
    r6 = <error> :: object
    return r6
L10:
    dec_ref r0
    goto L9
L11:
    dec_ref r0
    dec_ref r3
    goto L9
L12:
    dec_ref r3
    goto L9

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18 :: object
    r19 :: object_ptr
    r20 :: object_ptr[1]
    r21 :: c_ptr
    r22 :: native_int[1]
    r23 :: c_ptr
    r24 :: object
    r25 :: dict
    r26, r27 :: str
    r28 :: bit
    r29 :: str
    r30 :: dict
    r31 :: str
    r32 :: object
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36 :: dict
    r37 :: str
    r38 :: i32
    r39 :: bit
    r40 :: dict
    r41 :: str
    r42 :: object
    r43 :: str
    r44 :: object
    r45 :: dict
    r46 :: str
    r47 :: i32
    r48 :: bit
    r49 :: dict
    r50 :: str
    r51 :: object
    r52 :: str
    r53 :: object
    r54 :: dict
    r55 :: str
    r56 :: i32
    r57 :: bit
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: dict
    r62 :: str
    r63 :: i32
    r64 :: bit
    r65 :: object
    r66 :: str
    r67 :: object
    r68 :: dict
    r69 :: str
    r70 :: i32
    r71 :: bit
    r72 :: object
    r73 :: str
    r74 :: object
    r75 :: dict
    r76 :: str
    r77 :: i32
    r78 :: bit
    r79 :: dict
    r80 :: str
    r81 :: object
    r82 :: str
    r83 :: object
    r84 :: str
    r85 :: object
    r86 :: dict
    r87 :: str
    r88 :: i32
    r89 :: bit
    r90 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L26 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address asyncio :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('asyncio', 'asyncio', 'asyncio'),)
    r11 = dank_mids.helpers._gather.globals :: static
    r12 = 'dank_mids\\helpers\\_gather.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L26 else goto L4 :: bool
L4:
    r15 = ('Coroutine', 'Final', 'Iterable', 'Literal', 'Optional', 'Set', 'Tuple', 'TypeVar', 'Union', 'overload')
    r16 = 'typing'
    r17 = dank_mids.helpers._gather.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L26 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = load_address a_sync.asyncio :: module
    r20 = [r19]
    r21 = load_address r20
    r22 = [15]
    r23 = load_address r22
    r24 = (('a_sync.asyncio', 'a_sync', 'a_sync'),)
    r25 = dank_mids.helpers._gather.globals :: static
    r26 = 'dank_mids\\helpers\\_gather.py'
    r27 = '<module>'
    r28 = CPyImport_ImportMany(r24, r21, r25, r26, r27, r23)
    if not r28 goto L26 else goto L6 :: bool
L6:
    r29 = '__T'
    r30 = dank_mids.helpers._gather.globals :: static
    r31 = 'TypeVar'
    r32 = CPyDict_GetItem(r30, r31)
    if is_error(r32) goto L26 (error at <module>:18) else goto L7
L7:
    r33 = [r29]
    r34 = load_address r33
    r35 = PyObject_Vectorcall(r32, r34, 1, 0)
    dec_ref r32
    if is_error(r35) goto L26 (error at <module>:18) else goto L8
L8:
    r36 = dank_mids.helpers._gather.globals :: static
    r37 = '__T'
    r38 = CPyDict_SetItem(r36, r37, r35)
    dec_ref r35
    r39 = r38 >= 0 :: signed
    if not r39 goto L26 (error at <module>:18) else goto L9 :: bool
L9:
    r40 = dank_mids.helpers._gather.globals :: static
    r41 = 'Set'
    r42 = CPyDict_GetItem(r40, r41)
    if is_error(r42) goto L26 (error at <module>:20) else goto L10
L10:
    r43 = 'asyncio.Future[__T]'
    r44 = PyObject_GetItem(r42, r43)
    dec_ref r42
    if is_error(r44) goto L26 (error at <module>:20) else goto L11
L11:
    r45 = dank_mids.helpers._gather.globals :: static
    r46 = 'FinishedTasks'
    r47 = CPyDict_SetItem(r45, r46, r44)
    dec_ref r44
    r48 = r47 >= 0 :: signed
    if not r48 goto L26 (error at <module>:20) else goto L12 :: bool
L12:
    r49 = dank_mids.helpers._gather.globals :: static
    r50 = 'Set'
    r51 = CPyDict_GetItem(r49, r50)
    if is_error(r51) goto L26 (error at <module>:21) else goto L13
L13:
    r52 = 'asyncio.Future[__T]'
    r53 = PyObject_GetItem(r51, r52)
    dec_ref r51
    if is_error(r53) goto L26 (error at <module>:21) else goto L14
L14:
    r54 = dank_mids.helpers._gather.globals :: static
    r55 = 'PendingTasks'
    r56 = CPyDict_SetItem(r54, r55, r53)
    dec_ref r53
    r57 = r56 >= 0 :: signed
    if not r57 goto L26 (error at <module>:21) else goto L15 :: bool
L15:
    r58 = asyncio :: module
    r59 = 'Task'
    r60 = CPyObject_GetAttr(r58, r59)
    if is_error(r60) goto L26 (error at <module>:25) else goto L16
L16:
    dank_mids.helpers._gather.Task = r60 :: static
    r61 = dank_mids.helpers._gather.globals :: static
    r62 = 'Task'
    r63 = CPyDict_SetItem(r61, r62, r60)
    dec_ref r60
    r64 = r63 >= 0 :: signed
    if not r64 goto L26 (error at <module>:25) else goto L17 :: bool
L17:
    r65 = asyncio :: module
    r66 = 'get_running_loop'
    r67 = CPyObject_GetAttr(r65, r66)
    if is_error(r67) goto L26 (error at <module>:26) else goto L18
L18:
    dank_mids.helpers._gather.get_running_loop = r67 :: static
    r68 = dank_mids.helpers._gather.globals :: static
    r69 = 'get_running_loop'
    r70 = CPyDict_SetItem(r68, r69, r67)
    dec_ref r67
    r71 = r70 >= 0 :: signed
    if not r71 goto L26 (error at <module>:26) else goto L19 :: bool
L19:
    r72 = asyncio :: module
    r73 = 'wait'
    r74 = CPyObject_GetAttr(r72, r73)
    if is_error(r74) goto L26 (error at <module>:27) else goto L20
L20:
    dank_mids.helpers._gather.wait = r74 :: static
    r75 = dank_mids.helpers._gather.globals :: static
    r76 = 'wait'
    r77 = CPyDict_SetItem(r75, r76, r74)
    dec_ref r74
    r78 = r77 >= 0 :: signed
    if not r78 goto L26 (error at <module>:27) else goto L21 :: bool
L21:
    r79 = dank_mids.helpers._gather.globals :: static
    r80 = 'a_sync'
    r81 = CPyDict_GetItem(r79, r80)
    if is_error(r81) goto L26 (error at <module>:30) else goto L22
L22:
    r82 = 'asyncio'
    r83 = CPyObject_GetAttr(r81, r82)
    dec_ref r81
    if is_error(r83) goto L26 (error at <module>:30) else goto L23
L23:
    r84 = 'sleep0'
    r85 = CPyObject_GetAttr(r83, r84)
    dec_ref r83
    if is_error(r85) goto L26 (error at <module>:30) else goto L24
L24:
    dank_mids.helpers._gather.yield_to_loop = r85 :: static
    r86 = dank_mids.helpers._gather.globals :: static
    r87 = 'yield_to_loop'
    r88 = CPyDict_SetItem(r86, r87, r85)
    dec_ref r85
    r89 = r88 >= 0 :: signed
    if not r89 goto L26 (error at <module>:30) else goto L25 :: bool
L25:
    return 1
L26:
    r90 = <error> :: None
    return r90

def return_as_is(x):
    x :: object
L0:
    inc_ref x
    return x

def abi_request_formatters_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    type, value, traceback, arg :: object
    r0 :: dank_mids._web3.formatters.abi_request_formatters_env
    r1 :: int
    r2 :: object
    r3 :: bit
    r4 :: dict
    r5, r6 :: bool
    r7 :: dict
    r8 :: native_int
    r9 :: short_int
    r10 :: bool
    r11 :: object
    r12 :: bool
    r13 :: object
    r14 :: short_int
    r15 :: tuple[bool, short_int, object, object]
    r16 :: short_int
    r17, r18 :: bool
    r19, r20 :: object
    r21 :: union[list, dict]
    r22, r23 :: bool
    r24 :: union[list, dict]
    r25 :: object
    r26 :: i32
    r27 :: bit
    r28 :: bool
    r29, r30 :: object
    r31 :: tuple
    r32 :: union[list, dict]
    r33 :: list
    r34 :: tuple
    r35 :: dank_mids._web3.abi.Formatter
    r36 :: tuple[object, dank_mids._web3.abi.Formatter]
    r37 :: object
    r38 :: bool
    r39 :: object
    r40 :: bit
    r41 :: union[list, dict]
    r42 :: object
    r43 :: i32
    r44 :: bit
    r45 :: bool
    r46 :: object
    r47 :: union[list, dict]
    r48, r49 :: dict
    r50 :: str
    r51 :: object
    r52 :: object[2]
    r53 :: object_ptr
    r54 :: object
    r55 :: bool
    r56, r57 :: object
    r58 :: dict
    r59 :: str
    r60, r61 :: object
    r62 :: object[2]
    r63 :: object_ptr
    r64 :: object
    r65 :: tuple[object, object]
    r66 :: object
    r67 :: bool
    r68 :: object
    r69 :: bit
    r70, r71, r72 :: str
    r73 :: union[list, dict]
    r74, r75 :: str
    r76 :: object[3]
    r77 :: object_ptr
    r78 :: object
    r79 :: list
    r80, r81, r82 :: ptr
    r83 :: str
    r84 :: object
    r85 :: str
    r86 :: object
    r87 :: object[1]
    r88 :: object_ptr
    r89 :: object
    r90 :: dict
    r91 :: short_int
    r92, r93 :: bit
    r94 :: object
    r95 :: bool
    r96, r97, r98 :: bit
    r99 :: bool
    r100 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L72 (error at abi_request_formatters:27) else goto L1
L1:
    r1 = r0.__mypyc_next_label__
    if is_error(r1) goto L73 (error at abi_request_formatters:27) else goto L67
L2:
    r2 = load_address _Py_NoneStruct
    r3 = type != r2
    if r3 goto L74 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L72 (error at abi_request_formatters:27) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = r0.abis
    if is_error(r4) goto L73 (error at abi_request_formatters:31) else goto L6
L6:
    inc_ref r4
    r0.__mypyc_temp__0 = r4; r5 = is_error
    if not r5 goto L75 (error at abi_request_formatters:-1) else goto L7 :: bool
L7:
    r0.__mypyc_temp__1 = 0; r6 = is_error
    if not r6 goto L75 (error at abi_request_formatters:-1) else goto L8 :: bool
L8:
    r7 = r0.__mypyc_temp__0
    if is_error(r7) goto L75 (error at abi_request_formatters:31) else goto L9
L9:
    r8 = PyDict_Size(r7)
    dec_ref r7
    r9 = r8 << 1
    r0.__mypyc_temp__2 = r9; r10 = is_error
    if not r10 goto L75 (error at abi_request_formatters:-1) else goto L10 :: bool
L10:
    r11 = CPyDict_GetItemsIter(r4)
    dec_ref r4
    if is_error(r11) goto L73 (error at abi_request_formatters:31) else goto L11
L11:
    r0.__mypyc_temp__3 = r11; r12 = is_error
    if not r12 goto L73 (error at abi_request_formatters:-1) else goto L12 :: bool
L12:
    r13 = r0.__mypyc_temp__3
    if is_error(r13) goto L73 (error at abi_request_formatters:31) else goto L13
L13:
    r14 = r0.__mypyc_temp__1
    if is_error(r14) goto L76 (error at abi_request_formatters:31) else goto L14
L14:
    r15 = CPyDict_NextItem(r13, r14)
    dec_ref r13
    r16 = r15[1]
    r0.__mypyc_temp__1 = r16; r17 = is_error
    if not r17 goto L77 (error at abi_request_formatters:31) else goto L15 :: bool
L15:
    r18 = r15[0]
    if r18 goto L16 else goto L78 :: bool
L16:
    r19 = r15[2]
    r20 = r15[3]
    dec_ref r15
    r21 = cast(union[list, dict], r20)
    if is_error(r21) goto L79 (error at abi_request_formatters:31) else goto L17
L17:
    r0.method = r19; r22 = is_error
    if not r22 goto L80 (error at abi_request_formatters:31) else goto L18 :: bool
L18:
    r0.abi_types = r21; r23 = is_error
    if not r23 goto L73 (error at abi_request_formatters:31) else goto L19 :: bool
L19:
    r24 = r0.abi_types
    if is_error(r24) goto L73 (error at abi_request_formatters:32) else goto L20
L20:
    r25 = load_address PyList_Type
    r26 = PyObject_IsInstance(r24, r25)
    dec_ref r24
    r27 = r26 >= 0 :: signed
    if not r27 goto L73 (error at abi_request_formatters:32) else goto L21 :: bool
L21:
    r28 = truncate r26: i32 to builtins.bool
    if r28 goto L22 else goto L34 :: bool
L22:
    r29 = r0.method
    if is_error(r29) goto L73 (error at abi_request_formatters:33) else goto L23
L23:
    r30 = r0.normalizers
    if is_error(r30) goto L81 (error at abi_request_formatters:33) else goto L24
L24:
    r31 = PySequence_Tuple(r30)
    dec_ref r30
    if is_error(r31) goto L81 (error at abi_request_formatters:33) else goto L25
L25:
    r32 = r0.abi_types
    if is_error(r32) goto L82 (error at abi_request_formatters:33) else goto L26
L26:
    r33 = cast(list, r32)
    if is_error(r33) goto L82 (error at abi_request_formatters:33) else goto L27
L27:
    r34 = PyList_AsTuple(r33)
    dec_ref r33
    if is_error(r34) goto L82 (error at abi_request_formatters:33) else goto L28
L28:
    r35 = get_formatter(r31, r34)
    dec_ref r31
    dec_ref r34
    if is_error(r35) goto L81 (error at abi_request_formatters:33) else goto L29
L29:
    r36 = (r29, r35)
    r37 = box(tuple[object, dank_mids._web3.abi.Formatter], r36)
    r0.__mypyc_next_label__ = 2; r38 = is_error
    dec_ref r0
    if not r38 goto L83 (error at abi_request_formatters:33) else goto L30 :: bool
L30:
    return r37
L31:
    r39 = load_address _Py_NoneStruct
    r40 = type != r39
    if r40 goto L84 else goto L60 :: bool
L32:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L72 (error at abi_request_formatters:33) else goto L33 :: bool
L33:
    unreachable
L34:
    r41 = r0.abi_types
    if is_error(r41) goto L73 (error at abi_request_formatters:34) else goto L35
L35:
    r42 = load_address PyDict_Type
    r43 = PyObject_IsInstance(r41, r42)
    dec_ref r41
    r44 = r43 >= 0 :: signed
    if not r44 goto L73 (error at abi_request_formatters:34) else goto L36 :: bool
L36:
    r45 = truncate r43: i32 to builtins.bool
    if r45 goto L37 else goto L52 :: bool
L37:
    r46 = r0.normalizers
    if is_error(r46) goto L73 (error at abi_request_formatters:35) else goto L38
L38:
    r47 = r0.abi_types
    if is_error(r47) goto L85 (error at abi_request_formatters:35) else goto L39
L39:
    r48 = cast(dict, r47)
    if is_error(r48) goto L85 (error at abi_request_formatters:35) else goto L40
L40:
    r49 = dank_mids._web3.formatters.globals :: static
    r50 = 'apply_abi_formatters_to_dict'
    r51 = CPyDict_GetItem(r49, r50)
    if is_error(r51) goto L86 (error at abi_request_formatters:35) else goto L41
L41:
    r52 = [r46, r48]
    r53 = load_address r52
    r54 = PyObject_Vectorcall(r51, r53, 2, 0)
    dec_ref r51
    if is_error(r54) goto L86 (error at abi_request_formatters:35) else goto L42
L42:
    dec_ref r46
    dec_ref r48
    r0.single_dict_formatter = r54; r55 = is_error
    if not r55 goto L73 (error at abi_request_formatters:35) else goto L43 :: bool
L43:
    r56 = r0.method
    if is_error(r56) goto L73 (error at abi_request_formatters:36) else goto L44
L44:
    r57 = r0.single_dict_formatter
    if is_error(r57) goto L87 (error at abi_request_formatters:36) else goto L45
L45:
    r58 = dank_mids._web3.formatters.globals :: static
    r59 = 'apply_formatter_at_index'
    r60 = CPyDict_GetItem(r58, r59)
    if is_error(r60) goto L88 (error at abi_request_formatters:36) else goto L46
L46:
    r61 = object 0
    r62 = [r57, r61]
    r63 = load_address r62
    r64 = PyObject_Vectorcall(r60, r63, 2, 0)
    dec_ref r60
    if is_error(r64) goto L88 (error at abi_request_formatters:36) else goto L47
L47:
    dec_ref r57
    r65 = (r56, r64)
    r66 = box(tuple[object, object], r65)
    r0.__mypyc_next_label__ = 4; r67 = is_error
    dec_ref r0
    if not r67 goto L89 (error at abi_request_formatters:36) else goto L48 :: bool
L48:
    return r66
L49:
    r68 = load_address _Py_NoneStruct
    r69 = type != r68
    if r69 goto L90 else goto L60 :: bool
L50:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L72 (error at abi_request_formatters:36) else goto L51 :: bool
L51:
    unreachable
L52:
    r70 = ''
    r71 = 'ABI definitions must be a list or dictionary, got '
    r72 = '{!r:{}}'
    r73 = r0.abi_types
    dec_ref r0
    if is_error(r73) goto L72 (error at abi_request_formatters:38) else goto L53
L53:
    r74 = ''
    r75 = 'format'
    r76 = [r72, r73, r74]
    r77 = load_address r76
    r78 = PyObject_VectorcallMethod(r75, r77, 9223372036854775811, 0)
    if is_error(r78) goto L91 (error at abi_request_formatters:38) else goto L54
L54:
    dec_ref r73
    r79 = PyList_New(2)
    if is_error(r79) goto L92 (error at abi_request_formatters:38) else goto L55
L55:
    r80 = get_element_ptr r79 ob_item :: PyListObject
    r81 = load_mem r80 :: ptr*
    inc_ref r71
    set_mem r81, r71 :: builtins.object*
    r82 = r81 + 8
    set_mem r82, r78 :: builtins.object*
    r83 = PyUnicode_Join(r70, r79)
    dec_ref r79
    if is_error(r83) goto L72 (error at abi_request_formatters:38) else goto L56
L56:
    r84 = builtins :: module
    r85 = 'TypeError'
    r86 = CPyObject_GetAttr(r84, r85)
    if is_error(r86) goto L93 (error at abi_request_formatters:38) else goto L57
L57:
    r87 = [r83]
    r88 = load_address r87
    r89 = PyObject_Vectorcall(r86, r88, 1, 0)
    dec_ref r86
    if is_error(r89) goto L93 (error at abi_request_formatters:38) else goto L58
L58:
    dec_ref r83
    CPy_Raise(r89)
    dec_ref r89
    if not 0 goto L72 (error at abi_request_formatters:38) else goto L59 :: bool
L59:
    unreachable
L60:
    r90 = r0.__mypyc_temp__0
    if is_error(r90) goto L73 (error at abi_request_formatters:31) else goto L61
L61:
    r91 = r0.__mypyc_temp__2
    if is_error(r91) goto L94 (error at abi_request_formatters:31) else goto L62
L62:
    r92 = CPyDict_CheckSize(r90, r91)
    dec_ref r90
    if not r92 goto L73 (error at abi_request_formatters:31) else goto L12 :: bool
L63:
    r93 = CPy_NoErrOccurred()
    if not r93 goto L73 (error at abi_request_formatters:31) else goto L64 :: bool
L64:
    r94 = box(None, 1)
    r0.__mypyc_next_label__ = -2; r95 = is_error
    dec_ref r0
    if not r95 goto L72 (error at abi_request_formatters:27) else goto L65 :: bool
L65:
    CPyGen_SetStopIterationValue(r94)
    if not 0 goto L72 else goto L66 :: bool
L66:
    unreachable
L67:
    r96 = r1 == 0
    if r96 goto L95 else goto L68 :: bool
L68:
    r97 = r1 == 2
    if r97 goto L96 else goto L69 :: bool
L69:
    r98 = r1 == 4
    dec_ref r1 :: int
    if r98 goto L49 else goto L97 :: bool
L70:
    r99 = raise StopIteration
    if not r99 goto L72 (error at abi_request_formatters:27) else goto L71 :: bool
L71:
    unreachable
L72:
    r100 = <error> :: object
    return r100
L73:
    dec_ref r0
    goto L72
L74:
    dec_ref r0
    goto L3
L75:
    dec_ref r0
    dec_ref r4
    goto L72
L76:
    dec_ref r0
    dec_ref r13
    goto L72
L77:
    dec_ref r0
    dec_ref r15
    goto L72
L78:
    dec_ref r15
    goto L63
L79:
    dec_ref r0
    dec_ref r19
    goto L72
L80:
    dec_ref r0
    dec_ref r21
    goto L72
L81:
    dec_ref r0
    dec_ref r29
    goto L72
L82:
    dec_ref r0
    dec_ref r29
    dec_ref r31
    goto L72
L83:
    dec_ref r37
    goto L72
L84:
    dec_ref r0
    goto L32
L85:
    dec_ref r0
    dec_ref r46
    goto L72
L86:
    dec_ref r0
    dec_ref r46
    dec_ref r48
    goto L72
L87:
    dec_ref r0
    dec_ref r56
    goto L72
L88:
    dec_ref r0
    dec_ref r56
    dec_ref r57
    goto L72
L89:
    dec_ref r66
    goto L72
L90:
    dec_ref r0
    goto L50
L91:
    dec_ref r73
    goto L72
L92:
    dec_ref r78
    goto L72
L93:
    dec_ref r83
    goto L72
L94:
    dec_ref r0
    dec_ref r90
    goto L72
L95:
    dec_ref r1 :: int
    goto L2
L96:
    dec_ref r1 :: int
    goto L31
L97:
    dec_ref r0
    goto L70

def abi_request_formatters_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = abi_request_formatters_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def abi_request_formatters_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = abi_request_formatters_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def abi_request_formatters_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def abi_request_formatters_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = abi_request_formatters_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def abi_request_formatters_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def abi_request_formatters(normalizers, abis):
    normalizers :: object
    abis :: dict
    r0 :: dank_mids._web3.formatters.abi_request_formatters_env
    r1, r2 :: bool
    r3 :: dank_mids._web3.formatters.abi_request_formatters_gen
    r4, r5 :: bool
    r6 :: object
L0:
    r0 = abi_request_formatters_env()
    if is_error(r0) goto L7 (error at abi_request_formatters:27) else goto L1
L1:
    inc_ref normalizers
    r0.normalizers = normalizers; r1 = is_error
    if not r1 goto L8 (error at abi_request_formatters:27) else goto L2 :: bool
L2:
    inc_ref abis
    r0.abis = abis; r2 = is_error
    if not r2 goto L8 (error at abi_request_formatters:27) else goto L3 :: bool
L3:
    r3 = abi_request_formatters_gen()
    if is_error(r3) goto L8 (error at abi_request_formatters:27) else goto L4
L4:
    inc_ref r0
    r3.__mypyc_env__ = r0; r4 = is_error
    if not r4 goto L9 (error at abi_request_formatters:27) else goto L5 :: bool
L5:
    r0.__mypyc_next_label__ = 0; r5 = is_error
    dec_ref r0
    if not r5 goto L10 (error at abi_request_formatters:27) else goto L6 :: bool
L6:
    return r3
L7:
    r6 = <error> :: object
    return r6
L8:
    dec_ref r0
    goto L7
L9:
    dec_ref r0
    dec_ref r3
    goto L7
L10:
    dec_ref r3
    goto L7

def get_request_formatters(method_name):
    method_name, r0 :: object
    r1 :: bool
    r2 :: str
    r3 :: object[2]
    r4 :: object_ptr
    r5, formatters, r6 :: object
    r7 :: bit
    r8 :: list
    r9 :: tuple[object, object, object]
    r10 :: bool
    r11, r12, r13 :: object
    r14 :: str
    r15 :: object[2]
    r16 :: object_ptr
    r17 :: object
    r18 :: i32
    r19, r20 :: bit
    r21 :: object
    r22 :: list
    r23, r24, r25 :: object
    r26 :: bit
    r27 :: i32
    r28, r29 :: bit
    r30 :: ptr
    r31 :: native_int
    r32 :: short_int
    r33 :: bit
    r34 :: dict
    r35 :: str
    r36 :: object
    r37 :: ptr
    r38 :: native_int
    r39 :: short_int
    r40 :: bit
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: object
    r45 :: list
    r46 :: object
    r47 :: tuple
    r48 :: dict
    r49, r50 :: object
    r51 :: bool
    r52 :: i32
    r53 :: bit
    r54 :: object
L0:
    r0 = dank_mids._web3.formatters._request_formatters :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_request_formatters" was not set')
    if not r1 goto L39 (error at get_request_formatters:59) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = 'get'
    r3 = [r0, method_name]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r2, r4, 9223372036854775810, 0)
    if is_error(r5) goto L39 (error at get_request_formatters:59) else goto L4
L4:
    formatters = r5
    r6 = load_address _Py_NoneStruct
    r7 = formatters == r6
    if r7 goto L40 else goto L38 :: bool
L5:
    r8 = PyList_New(0)
    if is_error(r8) goto L39 (error at get_request_formatters:61) else goto L6
L6:
    r9 = dank_mids._web3.formatters.REQUEST_FORMATTER_MAPS :: static
    if is_error(r9) goto L41 else goto L9
L7:
    r10 = raise NameError('value for final name "REQUEST_FORMATTER_MAPS" was not set')
    if not r10 goto L39 (error at get_request_formatters:61) else goto L8 :: bool
L8:
    unreachable
L9:
    inc_ref r9
    r11 = box(tuple[object, object, object], r9)
    r12 = PyObject_GetIter(r11)
    dec_ref r11
    if is_error(r12) goto L42 (error at get_request_formatters:61) else goto L10
L10:
    r13 = PyIter_Next(r12)
    if is_error(r13) goto L43 else goto L11
L11:
    r14 = 'get'
    r15 = [r13, method_name]
    r16 = load_address r15
    r17 = PyObject_VectorcallMethod(r14, r16, 9223372036854775810, 0)
    if is_error(r17) goto L44 (error at get_request_formatters:61) else goto L12
L12:
    dec_ref r13
    r18 = PyList_Append(r8, r17)
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L45 (error at get_request_formatters:61) else goto L10 :: bool
L13:
    r20 = CPy_NoErrOccurred()
    if not r20 goto L42 (error at get_request_formatters:61) else goto L14 :: bool
L14:
    r21 = PyObject_GetIter(r8)
    dec_ref r8
    if is_error(r21) goto L39 (error at get_request_formatters:61) else goto L15
L15:
    r22 = PyList_New(0)
    if is_error(r22) goto L46 (error at get_request_formatters:62) else goto L16
L16:
    r23 = PyObject_GetIter(r21)
    if is_error(r23) goto L47 (error at get_request_formatters:62) else goto L17
L17:
    r24 = PyIter_Next(r23)
    if is_error(r24) goto L48 else goto L18
L18:
    r25 = load_address _Py_NoneStruct
    r26 = r24 != r25
    if r26 goto L19 else goto L49 :: bool
L19:
    r27 = PyList_Append(r22, r24)
    dec_ref r24
    r28 = r27 >= 0 :: signed
    if not r28 goto L50 (error at get_request_formatters:62) else goto L17 :: bool
L20:
    r29 = CPy_NoErrOccurred()
    if not r29 goto L47 (error at get_request_formatters:62) else goto L21 :: bool
L21:
    r30 = get_element_ptr r22 ob_size :: PyVarObject
    r31 = load_mem r30 :: native_int*
    r32 = r31 << 1
    r33 = r32 != 0
    if r33 goto L24 else goto L51 :: bool
L22:
    r34 = dank_mids._web3.formatters.globals :: static
    r35 = 'return_as_is'
    r36 = CPyDict_GetItem(r34, r35)
    if is_error(r36) goto L39 (error at get_request_formatters:64) else goto L23
L23:
    formatters = r36
    goto L34
L24:
    r37 = get_element_ptr r22 ob_size :: PyVarObject
    r38 = load_mem r37 :: native_int*
    r39 = r38 << 1
    r40 = r39 == 2
    if r40 goto L52 else goto L53 :: bool
L25:
    r41 = CPyList_GetItemShort(r22, 0)
    dec_ref r22
    if is_error(r41) goto L39 (error at get_request_formatters:66) else goto L26
L26:
    formatters = r41
    goto L34
L27:
    r42 = dank_mids._web3.formatters.globals :: static
    r43 = 'compose'
    r44 = CPyDict_GetItem(r42, r43)
    if is_error(r44) goto L46 (error at get_request_formatters:70) else goto L28
L28:
    r45 = PyList_New(0)
    if is_error(r45) goto L54 (error at get_request_formatters:70) else goto L29
L29:
    r46 = CPyList_Extend(r45, r21)
    dec_ref r21
    if is_error(r46) goto L55 (error at get_request_formatters:70) else goto L56
L30:
    r47 = PyList_AsTuple(r45)
    dec_ref r45
    if is_error(r47) goto L57 (error at get_request_formatters:70) else goto L31
L31:
    r48 = PyDict_New()
    if is_error(r48) goto L58 (error at get_request_formatters:70) else goto L32
L32:
    r49 = PyObject_Call(r44, r47, r48)
    dec_ref r44
    dec_ref r47
    dec_ref r48
    if is_error(r49) goto L39 (error at get_request_formatters:70) else goto L33
L33:
    formatters = r49
L34:
    r50 = dank_mids._web3.formatters._request_formatters :: static
    if is_error(r50) goto L59 else goto L37
L35:
    r51 = raise NameError('value for final name "_request_formatters" was not set')
    if not r51 goto L39 (error at get_request_formatters:71) else goto L36 :: bool
L36:
    unreachable
L37:
    r52 = PyObject_SetItem(r50, method_name, formatters)
    r53 = r52 >= 0 :: signed
    if not r53 goto L60 (error at get_request_formatters:71) else goto L38 :: bool
L38:
    return formatters
L39:
    r54 = <error> :: object
    return r54
L40:
    dec_ref formatters
    goto L5
L41:
    dec_ref r8
    goto L7
L42:
    dec_ref r8
    goto L39
L43:
    dec_ref r12
    goto L13
L44:
    dec_ref r8
    dec_ref r12
    dec_ref r13
    goto L39
L45:
    dec_ref r8
    dec_ref r12
    goto L39
L46:
    dec_ref r21
    goto L39
L47:
    dec_ref r21
    dec_ref r22
    goto L39
L48:
    dec_ref r23
    goto L20
L49:
    dec_ref r24
    goto L17
L50:
    dec_ref r21
    dec_ref r22
    dec_ref r23
    goto L39
L51:
    dec_ref r21
    dec_ref r22
    goto L22
L52:
    dec_ref r21
    goto L25
L53:
    dec_ref r22
    goto L27
L54:
    dec_ref r21
    dec_ref r44
    goto L39
L55:
    dec_ref r44
    dec_ref r45
    goto L39
L56:
    dec_ref r46
    goto L30
L57:
    dec_ref r44
    goto L39
L58:
    dec_ref r44
    dec_ref r47
    goto L39
L59:
    dec_ref formatters
    goto L35
L60:
    dec_ref formatters
    goto L39

def _get_response_formatters(method):
    method :: object
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: dict
    r4 :: str
    r5 :: object
    r6 :: dict
    r7 :: str
    r8 :: object
    r9 :: str
    r10 :: object[3]
    r11 :: object_ptr
    r12 :: object
    r13 :: dict
    r14 :: str
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: object
    r19 :: str
    r20 :: object[3]
    r21 :: object_ptr
    r22 :: object
    r23 :: tuple[object, object, object]
    r24 :: dict
    r25 :: bool
    r26 :: object
    r27 :: i32
    r28 :: bit
    r29 :: tuple[object, object, object]
L0:
    r0 = dank_mids._web3.formatters.globals :: static
    r1 = 'return_as_is'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L12 (error at _get_response_formatters:86) else goto L1
L1:
    r3 = dank_mids._web3.formatters.globals :: static
    r4 = 'ERROR_FORMATTERS'
    r5 = CPyDict_GetItem(r3, r4)
    if is_error(r5) goto L13 (error at _get_response_formatters:87) else goto L2
L2:
    r6 = dank_mids._web3.formatters.globals :: static
    r7 = 'return_as_is'
    r8 = CPyDict_GetItem(r6, r7)
    if is_error(r8) goto L14 (error at _get_response_formatters:87) else goto L3
L3:
    r9 = 'get'
    r10 = [r5, method, r8]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775811, 0)
    if is_error(r12) goto L15 (error at _get_response_formatters:87) else goto L4
L4:
    dec_ref r5
    dec_ref r8
    r13 = dank_mids._web3.formatters.globals :: static
    r14 = 'NULL_RESULT_FORMATTERS'
    r15 = CPyDict_GetItem(r13, r14)
    if is_error(r15) goto L16 (error at _get_response_formatters:88) else goto L5
L5:
    r16 = dank_mids._web3.formatters.globals :: static
    r17 = 'return_as_is'
    r18 = CPyDict_GetItem(r16, r17)
    if is_error(r18) goto L17 (error at _get_response_formatters:88) else goto L6
L6:
    r19 = 'get'
    r20 = [r15, method, r18]
    r21 = load_address r20
    r22 = PyObject_VectorcallMethod(r19, r21, 9223372036854775811, 0)
    if is_error(r22) goto L18 (error at _get_response_formatters:88) else goto L7
L7:
    dec_ref r15
    dec_ref r18
    r23 = (r2, r12, r22)
    inc_ref r23
    r24 = dank_mids._web3.formatters._response_formatters :: static
    if is_error(r24) goto L19 else goto L10
L8:
    r25 = raise NameError('value for final name "_response_formatters" was not set')
    if not r25 goto L12 (error at _get_response_formatters:85) else goto L9 :: bool
L9:
    unreachable
L10:
    r26 = box(tuple[object, object, object], r23)
    r27 = CPyDict_SetItem(r24, method, r26)
    dec_ref r26
    r28 = r27 >= 0 :: signed
    if not r28 goto L20 (error at _get_response_formatters:85) else goto L11 :: bool
L11:
    return r23
L12:
    r29 = <error> :: tuple[object, object, object]
    return r29
L13:
    dec_ref r2
    goto L12
L14:
    dec_ref r2
    dec_ref r5
    goto L12
L15:
    dec_ref r2
    dec_ref r5
    dec_ref r8
    goto L12
L16:
    dec_ref r2
    dec_ref r12
    goto L12
L17:
    dec_ref r2
    dec_ref r12
    dec_ref r15
    goto L12
L18:
    dec_ref r2
    dec_ref r12
    dec_ref r15
    dec_ref r18
    goto L12
L19:
    dec_ref r23
    dec_ref r23
    goto L8
L20:
    dec_ref r23
    goto L12

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24, r25 :: object
    r26 :: str
    r27 :: dict
    r28, r29 :: object
    r30 :: str
    r31 :: dict
    r32, r33 :: object
    r34 :: str
    r35 :: dict
    r36 :: object
    r37 :: str
    r38 :: dict
    r39 :: str
    r40 :: object
    r41 :: object[1]
    r42 :: object_ptr
    r43 :: object
    r44 :: dict
    r45 :: str
    r46 :: i32
    r47 :: bit
    r48 :: dict
    r49 :: str
    r50 :: object
    r51 :: dict
    r52 :: str
    r53 :: object
    r54 :: dict
    r55 :: object
    r56, r57 :: dict
    r58 :: str
    r59 :: i32
    r60 :: bit
    r61 :: object
    r62 :: bool
    r63 :: dict
    r64 :: str
    r65 :: object
    r66 :: dict
    r67 :: str
    r68 :: object
    r69 :: tuple[object, object, object]
    r70 :: dict
    r71 :: str
    r72 :: object
    r73 :: i32
    r74 :: bit
    r75, r76 :: dict
    r77 :: str
    r78 :: i32
    r79 :: bit
    r80 :: dict
    r81 :: str
    r82 :: object
    r83 :: dict
    r84 :: str
    r85 :: object
    r86 :: list
    r87, r88 :: ptr
    r89 :: dict
    r90 :: str
    r91 :: object
    r92 :: tuple[list, object]
    r93, r94 :: object
    r95 :: dict
    r96 :: str
    r97 :: i32
    r98 :: bit
    r99 :: dict
    r100 :: str
    r101 :: object
    r102 :: dict
    r103 :: str
    r104 :: object
    r105 :: list
    r106, r107 :: ptr
    r108 :: dict
    r109 :: str
    r110 :: object
    r111 :: tuple[list, object]
    r112, r113 :: object
    r114 :: dict
    r115 :: str
    r116 :: i32
    r117 :: bit
    r118 :: dict
    r119 :: str
    r120 :: object
    r121 :: dict
    r122 :: str
    r123 :: object
    r124 :: list
    r125, r126 :: ptr
    r127 :: dict
    r128 :: str
    r129 :: object
    r130 :: tuple[list, object]
    r131, r132 :: object
    r133 :: dict
    r134 :: str
    r135 :: i32
    r136 :: bit
    r137 :: dict
    r138 :: str
    r139 :: object
    r140 :: dict
    r141 :: str
    r142 :: object
    r143 :: dict
    r144 :: str
    r145 :: object
    r146 :: dict
    r147 :: str
    r148 :: object
    r149 :: tuple[object, object, object]
    r150, r151 :: object
    r152 :: dict
    r153 :: str
    r154 :: i32
    r155 :: bit
    r156, r157 :: dict
    r158 :: str
    r159 :: i32
    r160 :: bit
    r161 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L55 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Callable', 'Dict', 'Final', 'Iterator', 'List', 'Sequence', 'Tuple', 'TypeVar', 'Union')
    r6 = 'typing'
    r7 = dank_mids._web3.formatters.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L55 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('TypeStr',)
    r10 = 'eth_typing'
    r11 = dank_mids._web3.formatters.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L55 (error at <module>:3) else goto L5
L5:
    eth_typing = r12 :: module
    dec_ref r12
    r13 = ('apply_formatter_at_index',)
    r14 = 'faster_eth_utils.curried'
    r15 = dank_mids._web3.formatters.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L55 (error at <module>:4) else goto L6
L6:
    faster_eth_utils.curried = r16 :: module
    dec_ref r16
    r17 = ('compose',)
    r18 = 'faster_eth_utils.toolz'
    r19 = dank_mids._web3.formatters.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L55 (error at <module>:5) else goto L7
L7:
    faster_eth_utils.toolz = r20 :: module
    dec_ref r20
    r21 = ('ERROR_FORMATTERS', 'METHOD_NORMALIZERS', 'NULL_RESULT_FORMATTERS', 'PYTHONIC_REQUEST_FORMATTERS', 'STANDARD_NORMALIZERS')
    r22 = 'web3._utils.method_formatters'
    r23 = dank_mids._web3.formatters.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L55 (error at <module>:6) else goto L8
L8:
    web3._utils.method_formatters = r24 :: module
    dec_ref r24
    r25 = ('RPC_ABIS', 'apply_abi_formatters_to_dict')
    r26 = 'web3._utils.rpc_abi'
    r27 = dank_mids._web3.formatters.globals :: static
    r28 = CPyImport_ImportFromMany(r26, r25, r25, r27)
    if is_error(r28) goto L55 (error at <module>:13) else goto L9
L9:
    web3._utils.rpc_abi = r28 :: module
    dec_ref r28
    r29 = ('Formatters', 'RPCEndpoint', 'RPCResponse')
    r30 = 'web3.types'
    r31 = dank_mids._web3.formatters.globals :: static
    r32 = CPyImport_ImportFromMany(r30, r29, r29, r31)
    if is_error(r32) goto L55 (error at <module>:14) else goto L10
L10:
    web3.types = r32 :: module
    dec_ref r32
    r33 = ('get_formatter',)
    r34 = 'dank_mids._web3.abi'
    r35 = dank_mids._web3.formatters.globals :: static
    r36 = CPyImport_ImportFromMany(r34, r33, r33, r35)
    if is_error(r36) goto L55 (error at <module>:17) else goto L11
L11:
    dank_mids._web3.abi = r36 :: module
    dec_ref r36
    r37 = '_T'
    r38 = dank_mids._web3.formatters.globals :: static
    r39 = 'TypeVar'
    r40 = CPyDict_GetItem(r38, r39)
    if is_error(r40) goto L55 (error at <module>:20) else goto L12
L12:
    r41 = [r37]
    r42 = load_address r41
    r43 = PyObject_Vectorcall(r40, r42, 1, 0)
    dec_ref r40
    if is_error(r43) goto L55 (error at <module>:20) else goto L13
L13:
    r44 = dank_mids._web3.formatters.globals :: static
    r45 = '_T'
    r46 = CPyDict_SetItem(r44, r45, r43)
    dec_ref r43
    r47 = r46 >= 0 :: signed
    if not r47 goto L55 (error at <module>:20) else goto L14 :: bool
L14:
    r48 = dank_mids._web3.formatters.globals :: static
    r49 = 'STANDARD_NORMALIZERS'
    r50 = CPyDict_GetItem(r48, r49)
    if is_error(r50) goto L55 (error at <module>:42) else goto L15
L15:
    r51 = dank_mids._web3.formatters.globals :: static
    r52 = 'RPC_ABIS'
    r53 = CPyDict_GetItem(r51, r52)
    if is_error(r53) goto L56 (error at <module>:42) else goto L16
L16:
    r54 = cast(dict, r53)
    if is_error(r54) goto L56 (error at <module>:42) else goto L17
L17:
    r55 = abi_request_formatters(r50, r54)
    dec_ref r50
    dec_ref r54
    if is_error(r55) goto L55 (error at <module>:42) else goto L18
L18:
    r56 = CPyDict_FromAny(r55)
    dec_ref r55
    if is_error(r56) goto L55 (error at <module>:41) else goto L19
L19:
    dank_mids._web3.formatters.ABI_REQUEST_FORMATTERS = r56 :: static
    r57 = dank_mids._web3.formatters.globals :: static
    r58 = 'ABI_REQUEST_FORMATTERS'
    r59 = CPyDict_SetItem(r57, r58, r56)
    dec_ref r56
    r60 = r59 >= 0 :: signed
    if not r60 goto L55 (error at <module>:41) else goto L20 :: bool
L20:
    r61 = dank_mids._web3.formatters.ABI_REQUEST_FORMATTERS :: static
    if is_error(r61) goto L21 else goto L23
L21:
    r62 = raise NameError('value for final name "ABI_REQUEST_FORMATTERS" was not set')
    if not r62 goto L55 (error at <module>:46) else goto L22 :: bool
L22:
    unreachable
L23:
    r63 = dank_mids._web3.formatters.globals :: static
    r64 = 'METHOD_NORMALIZERS'
    r65 = CPyDict_GetItem(r63, r64)
    if is_error(r65) goto L55 (error at <module>:51) else goto L24
L24:
    r66 = dank_mids._web3.formatters.globals :: static
    r67 = 'PYTHONIC_REQUEST_FORMATTERS'
    r68 = CPyDict_GetItem(r66, r67)
    if is_error(r68) goto L57 (error at <module>:52) else goto L25
L25:
    inc_ref r61
    r69 = (r61, r65, r68)
    dank_mids._web3.formatters.REQUEST_FORMATTER_MAPS = r69 :: static
    r70 = dank_mids._web3.formatters.globals :: static
    r71 = 'REQUEST_FORMATTER_MAPS'
    r72 = box(tuple[object, object, object], r69)
    r73 = CPyDict_SetItem(r70, r71, r72)
    dec_ref r72
    r74 = r73 >= 0 :: signed
    if not r74 goto L55 (error at <module>:45) else goto L26 :: bool
L26:
    r75 = PyDict_New()
    if is_error(r75) goto L55 (error at <module>:55) else goto L27
L27:
    dank_mids._web3.formatters._request_formatters = r75 :: static
    r76 = dank_mids._web3.formatters.globals :: static
    r77 = '_request_formatters'
    r78 = CPyDict_SetItem(r76, r77, r75)
    dec_ref r75
    r79 = r78 >= 0 :: signed
    if not r79 goto L55 (error at <module>:55) else goto L28 :: bool
L28:
    r80 = dank_mids._web3.formatters.globals :: static
    r81 = 'Callable'
    r82 = CPyDict_GetItem(r80, r81)
    if is_error(r82) goto L55 (error at <module>:75) else goto L29
L29:
    r83 = dank_mids._web3.formatters.globals :: static
    r84 = 'RPCResponse'
    r85 = CPyDict_GetItem(r83, r84)
    if is_error(r85) goto L58 (error at <module>:75) else goto L30
L30:
    r86 = PyList_New(1)
    if is_error(r86) goto L59 (error at <module>:75) else goto L31
L31:
    r87 = get_element_ptr r86 ob_item :: PyListObject
    r88 = load_mem r87 :: ptr*
    set_mem r88, r85 :: builtins.object*
    r89 = dank_mids._web3.formatters.globals :: static
    r90 = 'Any'
    r91 = CPyDict_GetItem(r89, r90)
    if is_error(r91) goto L60 (error at <module>:75) else goto L32
L32:
    r92 = (r86, r91)
    r93 = box(tuple[list, object], r92)
    r94 = PyObject_GetItem(r82, r93)
    dec_ref r82
    dec_ref r93
    if is_error(r94) goto L55 (error at <module>:75) else goto L33
L33:
    r95 = dank_mids._web3.formatters.globals :: static
    r96 = 'SuccessFormatter'
    r97 = CPyDict_SetItem(r95, r96, r94)
    dec_ref r94
    r98 = r97 >= 0 :: signed
    if not r98 goto L55 (error at <module>:75) else goto L34 :: bool
L34:
    r99 = dank_mids._web3.formatters.globals :: static
    r100 = 'Callable'
    r101 = CPyDict_GetItem(r99, r100)
    if is_error(r101) goto L55 (error at <module>:76) else goto L35
L35:
    r102 = dank_mids._web3.formatters.globals :: static
    r103 = 'RPCResponse'
    r104 = CPyDict_GetItem(r102, r103)
    if is_error(r104) goto L61 (error at <module>:76) else goto L36
L36:
    r105 = PyList_New(1)
    if is_error(r105) goto L62 (error at <module>:76) else goto L37
L37:
    r106 = get_element_ptr r105 ob_item :: PyListObject
    r107 = load_mem r106 :: ptr*
    set_mem r107, r104 :: builtins.object*
    r108 = dank_mids._web3.formatters.globals :: static
    r109 = 'Any'
    r110 = CPyDict_GetItem(r108, r109)
    if is_error(r110) goto L63 (error at <module>:76) else goto L38
L38:
    r111 = (r105, r110)
    r112 = box(tuple[list, object], r111)
    r113 = PyObject_GetItem(r101, r112)
    dec_ref r101
    dec_ref r112
    if is_error(r113) goto L55 (error at <module>:76) else goto L39
L39:
    r114 = dank_mids._web3.formatters.globals :: static
    r115 = 'ErrorFormatter'
    r116 = CPyDict_SetItem(r114, r115, r113)
    dec_ref r113
    r117 = r116 >= 0 :: signed
    if not r117 goto L55 (error at <module>:76) else goto L40 :: bool
L40:
    r118 = dank_mids._web3.formatters.globals :: static
    r119 = 'Callable'
    r120 = CPyDict_GetItem(r118, r119)
    if is_error(r120) goto L55 (error at <module>:77) else goto L41
L41:
    r121 = dank_mids._web3.formatters.globals :: static
    r122 = 'RPCResponse'
    r123 = CPyDict_GetItem(r121, r122)
    if is_error(r123) goto L64 (error at <module>:77) else goto L42
L42:
    r124 = PyList_New(1)
    if is_error(r124) goto L65 (error at <module>:77) else goto L43
L43:
    r125 = get_element_ptr r124 ob_item :: PyListObject
    r126 = load_mem r125 :: ptr*
    set_mem r126, r123 :: builtins.object*
    r127 = dank_mids._web3.formatters.globals :: static
    r128 = 'Any'
    r129 = CPyDict_GetItem(r127, r128)
    if is_error(r129) goto L66 (error at <module>:77) else goto L44
L44:
    r130 = (r124, r129)
    r131 = box(tuple[list, object], r130)
    r132 = PyObject_GetItem(r120, r131)
    dec_ref r120
    dec_ref r131
    if is_error(r132) goto L55 (error at <module>:77) else goto L45
L45:
    r133 = dank_mids._web3.formatters.globals :: static
    r134 = 'NullFormatter'
    r135 = CPyDict_SetItem(r133, r134, r132)
    dec_ref r132
    r136 = r135 >= 0 :: signed
    if not r136 goto L55 (error at <module>:77) else goto L46 :: bool
L46:
    r137 = dank_mids._web3.formatters.globals :: static
    r138 = 'Tuple'
    r139 = CPyDict_GetItem(r137, r138)
    if is_error(r139) goto L55 (error at <module>:79) else goto L47
L47:
    r140 = dank_mids._web3.formatters.globals :: static
    r141 = 'SuccessFormatter'
    r142 = CPyDict_GetItem(r140, r141)
    if is_error(r142) goto L67 (error at <module>:79) else goto L48
L48:
    r143 = dank_mids._web3.formatters.globals :: static
    r144 = 'ErrorFormatter'
    r145 = CPyDict_GetItem(r143, r144)
    if is_error(r145) goto L68 (error at <module>:79) else goto L49
L49:
    r146 = dank_mids._web3.formatters.globals :: static
    r147 = 'NullFormatter'
    r148 = CPyDict_GetItem(r146, r147)
    if is_error(r148) goto L69 (error at <module>:79) else goto L50
L50:
    r149 = (r142, r145, r148)
    r150 = box(tuple[object, object, object], r149)
    r151 = PyObject_GetItem(r139, r150)
    dec_ref r139
    dec_ref r150
    if is_error(r151) goto L55 (error at <module>:79) else goto L51
L51:
    r152 = dank_mids._web3.formatters.globals :: static
    r153 = 'ResponseFormatters'
    r154 = CPyDict_SetItem(r152, r153, r151)
    dec_ref r151
    r155 = r154 >= 0 :: signed
    if not r155 goto L55 (error at <module>:79) else goto L52 :: bool
L52:
    r156 = PyDict_New()
    if is_error(r156) goto L55 (error at <module>:81) else goto L53
L53:
    dank_mids._web3.formatters._response_formatters = r156 :: static
    r157 = dank_mids._web3.formatters.globals :: static
    r158 = '_response_formatters'
    r159 = CPyDict_SetItem(r157, r158, r156)
    dec_ref r156
    r160 = r159 >= 0 :: signed
    if not r160 goto L55 (error at <module>:81) else goto L54 :: bool
L54:
    return 1
L55:
    r161 = <error> :: None
    return r161
L56:
    dec_ref r50
    goto L55
L57:
    dec_ref r65
    goto L55
L58:
    dec_ref r82
    goto L55
L59:
    dec_ref r82
    dec_ref r85
    goto L55
L60:
    dec_ref r82
    dec_ref r86
    goto L55
L61:
    dec_ref r101
    goto L55
L62:
    dec_ref r101
    dec_ref r104
    goto L55
L63:
    dec_ref r101
    dec_ref r105
    goto L55
L64:
    dec_ref r120
    goto L55
L65:
    dec_ref r120
    dec_ref r123
    goto L55
L66:
    dec_ref r120
    dec_ref r124
    goto L55
L67:
    dec_ref r139
    goto L55
L68:
    dec_ref r139
    dec_ref r142
    goto L55
L69:
    dec_ref r139
    dec_ref r142
    dec_ref r145
    goto L55

def error_logger_log_debug(msg, args):
    msg :: str
    args :: tuple
    r0 :: int
    r1 :: bool
    r2 :: object
    r3 :: bool
    r4 :: object
    r5 :: object[3]
    r6 :: object_ptr
    r7 :: object
    r8 :: None
L0:
    r0 = dank_mids._logging.DEBUG :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "DEBUG" was not set')
    if not r1 goto L8 (error at error_logger_log_debug:19) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = dank_mids.helpers._errors.error_logger_log :: static
    if is_error(r2) goto L4 else goto L6
L4:
    r3 = raise NameError('value for final name "error_logger_log" was not set')
    if not r3 goto L8 (error at error_logger_log_debug:19) else goto L5 :: bool
L5:
    unreachable
L6:
    inc_ref r0 :: int
    r4 = box(int, r0)
    r5 = [r4, msg, args]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r2, r6, 3, 0)
    if is_error(r7) goto L9 (error at error_logger_log_debug:19) else goto L10
L7:
    dec_ref r4
    return 1
L8:
    r8 = <error> :: None
    return r8
L9:
    dec_ref r4
    goto L8
L10:
    dec_ref r7
    goto L7

def revert_logger_log_debug(msg, args):
    msg :: str
    args :: tuple
    r0 :: int
    r1 :: bool
    r2 :: object
    r3 :: bool
    r4 :: object
    r5 :: object[3]
    r6 :: object_ptr
    r7 :: object
    r8 :: None
L0:
    r0 = dank_mids._logging.DEBUG :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "DEBUG" was not set')
    if not r1 goto L8 (error at revert_logger_log_debug:27) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = dank_mids.helpers._errors.revert_logger_log :: static
    if is_error(r2) goto L4 else goto L6
L4:
    r3 = raise NameError('value for final name "revert_logger_log" was not set')
    if not r3 goto L8 (error at revert_logger_log_debug:27) else goto L5 :: bool
L5:
    unreachable
L6:
    inc_ref r0 :: int
    r4 = box(int, r0)
    r5 = [r4, msg, args]
    r6 = load_address r5
    r7 = PyObject_Vectorcall(r2, r6, 3, 0)
    if is_error(r7) goto L9 (error at revert_logger_log_debug:27) else goto L10
L7:
    dec_ref r4
    return 1
L8:
    r8 = <error> :: None
    return r8
L9:
    dec_ref r4
    goto L8
L10:
    dec_ref r7
    goto L7

def log_internal_error(logger, batch, exc):
    logger, batch, exc :: object
    r0, batch_objs :: list
    r1 :: tuple[object, object, object]
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: bit
    r6 :: list
    r7, r8 :: ptr
    r9 :: bit
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: str
    r15 :: ptr
    r16 :: native_int
    r17 :: short_int
    r18 :: object
    r19 :: str
    r20 :: object
    r21, r22 :: str
    r23, r24 :: object
    r25 :: object[8]
    r26 :: object_ptr
    r27, r28 :: object
    r29 :: None
L0:
L1:
    r0 = PySequence_List(batch)
    if is_error(r0) goto L3 (error at log_internal_error:49) else goto L2
L2:
    batch_objs = r0
    goto L12
L3:
    r1 = CPy_CatchError()
    r2 = builtins :: module
    r3 = 'TypeError'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L10 (error at log_internal_error:50) else goto L4
L4:
    r5 = CPy_ExceptionMatches(r4)
    dec_ref r4
    if r5 goto L5 else goto L7 :: bool
L5:
    r6 = PyList_New(1)
    if is_error(r6) goto L10 (error at log_internal_error:52) else goto L6
L6:
    r7 = get_element_ptr r6 ob_item :: PyListObject
    r8 = load_mem r7 :: ptr*
    inc_ref batch
    set_mem r8, batch :: builtins.object*
    batch_objs = r6
    goto L9
L7:
    CPy_Reraise()
    if not 0 goto L10 else goto L19 :: bool
L8:
    unreachable
L9:
    CPy_RestoreExcInfo(r1)
    dec_ref r1
    goto L12
L10:
    CPy_RestoreExcInfo(r1)
    dec_ref r1
    r9 = CPy_KeepPropagating()
    if not r9 goto L18 else goto L11 :: bool
L11:
    unreachable
L12:
    r10 = "That's not good, there was an exception in a %s (len=%s). These are supposed to be handled.\nExc: %s\n%s contents: %s\n\n"
    r11 = PyObject_Type(batch)
    r12 = '__name__'
    r13 = CPyObject_GetAttr(r11, r12)
    dec_ref r11
    if is_error(r13) goto L20 (error at log_internal_error:57) else goto L13
L13:
    r14 = cast(str, r13)
    if is_error(r14) goto L20 (error at log_internal_error:57) else goto L14
L14:
    r15 = get_element_ptr batch_objs ob_size :: PyVarObject
    r16 = load_mem r15 :: native_int*
    r17 = r16 << 1
    r18 = PyObject_Type(batch)
    r19 = '__name__'
    r20 = CPyObject_GetAttr(r18, r19)
    dec_ref r18
    if is_error(r20) goto L21 (error at log_internal_error:60) else goto L15
L15:
    r21 = cast(str, r20)
    if is_error(r21) goto L21 (error at log_internal_error:60) else goto L16
L16:
    r22 = 'error'
    r23 = box(short_int, r17)
    r24 = box(bool, 1)
    r25 = [logger, r10, r14, r23, exc, r21, batch_objs, r24]
    r26 = load_address r25
    r27 = ('exc_info',)
    r28 = PyObject_VectorcallMethod(r22, r26, 9223372036854775815, r27)
    if is_error(r28) goto L22 (error at log_internal_error:53) else goto L23
L17:
    dec_ref r14
    dec_ref r23
    dec_ref r21
    dec_ref batch_objs
    return 1
L18:
    r29 = <error> :: None
    return r29
L19:
    dec_ref r1
    goto L8
L20:
    dec_ref batch_objs
    goto L18
L21:
    dec_ref batch_objs
    dec_ref r14
    goto L18
L22:
    dec_ref batch_objs
    dec_ref r14
    dec_ref r21
    dec_ref r23
    goto L18
L23:
    dec_ref r28
    goto L17

def needs_full_request_spec(response):
    response :: object
    r0 :: str
    r1, r2 :: object
    r3 :: bit
    r4 :: bool
    r5 :: str
    r6 :: object
    r7 :: str
    r8 :: object
    r9, r10 :: str
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14, r15 :: str
    r16 :: i32
    r17 :: bit
    r18 :: object
    r19, r20, r21 :: bit
    r22 :: bool
    r23 :: str
    r24 :: object
    r25 :: str
    r26 :: object
    r27, r28 :: str
    r29 :: object[1]
    r30 :: object_ptr
    r31 :: object
    r32, r33 :: str
    r34 :: i32
    r35 :: bit
    r36 :: object
    r37, r38, r39 :: bit
    r40 :: bool
L0:
    r0 = 'error'
    r1 = CPyObject_GetAttr(response, r0)
    if is_error(r1) goto L24 (error at needs_full_request_spec:79) else goto L1
L1:
    r2 = load_address _Py_NoneStruct
    r3 = r1 != r2
    dec_ref r1
    if r3 goto L3 else goto L2 :: bool
L2:
    r4 = r3
    goto L23
L3:
    r5 = 'error'
    r6 = CPyObject_GetAttr(response, r5)
    if is_error(r6) goto L24 (error at needs_full_request_spec:79) else goto L4
L4:
    r7 = 'message'
    r8 = CPyObject_GetAttr(r6, r7)
    dec_ref r6
    if is_error(r8) goto L24 (error at needs_full_request_spec:79) else goto L5
L5:
    r9 = cast(str, r8)
    if is_error(r9) goto L24 (error at needs_full_request_spec:79) else goto L6
L6:
    r10 = 'lower'
    r11 = [r9]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775809, 0)
    if is_error(r13) goto L25 (error at needs_full_request_spec:79) else goto L7
L7:
    dec_ref r9
    r14 = cast(str, r13)
    if is_error(r14) goto L24 (error at needs_full_request_spec:79) else goto L8
L8:
    r15 = 'invalid request'
    r16 = PyUnicode_Compare(r14, r15)
    dec_ref r14
    r17 = r16 == -1
    if r17 goto L9 else goto L11 :: bool
L9:
    r18 = PyErr_Occurred()
    r19 = r18 != 0
    if r19 goto L10 else goto L11 :: bool
L10:
    r20 = CPy_KeepPropagating()
    if not r20 goto L24 (error at needs_full_request_spec:-1) else goto L11 :: bool
L11:
    r21 = r16 == 0
    if r21 goto L12 else goto L13 :: bool
L12:
    r22 = r21
    goto L22
L13:
    r23 = 'error'
    r24 = CPyObject_GetAttr(response, r23)
    if is_error(r24) goto L24 (error at needs_full_request_spec:79) else goto L14
L14:
    r25 = 'message'
    r26 = CPyObject_GetAttr(r24, r25)
    dec_ref r24
    if is_error(r26) goto L24 (error at needs_full_request_spec:79) else goto L15
L15:
    r27 = cast(str, r26)
    if is_error(r27) goto L24 (error at needs_full_request_spec:79) else goto L16
L16:
    r28 = 'lower'
    r29 = [r27]
    r30 = load_address r29
    r31 = PyObject_VectorcallMethod(r28, r30, 9223372036854775809, 0)
    if is_error(r31) goto L26 (error at needs_full_request_spec:79) else goto L17
L17:
    dec_ref r27
    r32 = cast(str, r31)
    if is_error(r32) goto L24 (error at needs_full_request_spec:79) else goto L18
L18:
    r33 = 'parse error'
    r34 = PyUnicode_Compare(r32, r33)
    dec_ref r32
    r35 = r34 == -1
    if r35 goto L19 else goto L21 :: bool
L19:
    r36 = PyErr_Occurred()
    r37 = r36 != 0
    if r37 goto L20 else goto L21 :: bool
L20:
    r38 = CPy_KeepPropagating()
    if not r38 goto L24 (error at needs_full_request_spec:-1) else goto L21 :: bool
L21:
    r39 = r34 == 0
    r22 = r39
L22:
    r4 = r22
L23:
    return r4
L24:
    r40 = <error> :: bool
    return r40
L25:
    dec_ref r9
    goto L24
L26:
    dec_ref r27
    goto L24

def is_call_revert(e):
    e :: dank_mids._exceptions.BadResponse
    r0, r1, r2 :: str
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: str
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11 :: str
    r12 :: bool
    r13 :: set
    r14 :: bool
    r15, r16 :: object
    r17 :: str
    r18 :: i32
    r19 :: bit
    r20 :: bool
    r21 :: bit
    r22 :: bool
L0:
    r0 = '{:{}}'
    r1 = ''
    r2 = 'format'
    r3 = [r0, e, r1]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r2, r4, 9223372036854775811, 0)
    if is_error(r5) goto L15 (error at is_call_revert:95) else goto L1
L1:
    r6 = cast(str, r5)
    if is_error(r6) goto L15 (error at is_call_revert:95) else goto L2
L2:
    r7 = 'lower'
    r8 = [r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775809, 0)
    if is_error(r10) goto L16 (error at is_call_revert:95) else goto L3
L3:
    dec_ref r6
    r11 = cast(str, r10)
    if is_error(r11) goto L15 (error at is_call_revert:95) else goto L4
L4:
    r12 = 0
    r13 = dank_mids.helpers._errors.INDIVIDUAL_CALL_REVERT_STRINGS :: static
    if is_error(r13) goto L17 else goto L7
L5:
    r14 = raise NameError('value for final name "INDIVIDUAL_CALL_REVERT_STRINGS" was not set')
    if not r14 goto L15 (error at is_call_revert:96) else goto L6 :: bool
L6:
    unreachable
L7:
    r15 = PyObject_GetIter(r13)
    if is_error(r15) goto L18 (error at is_call_revert:96) else goto L8
L8:
    r16 = PyIter_Next(r15)
    if is_error(r16) goto L19 else goto L9
L9:
    r17 = cast(str, r16)
    if is_error(r17) goto L20 (error at is_call_revert:96) else goto L10
L10:
    r18 = PyUnicode_Contains(r11, r17)
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L20 (error at is_call_revert:96) else goto L11 :: bool
L11:
    r20 = truncate r18: i32 to builtins.bool
    if r20 goto L21 else goto L8 :: bool
L12:
    r12 = 1
    goto L14
L13:
    r21 = CPy_NoErrOccurred()
    if not r21 goto L15 (error at is_call_revert:96) else goto L14 :: bool
L14:
    return r12
L15:
    r22 = <error> :: bool
    return r22
L16:
    dec_ref r6
    goto L15
L17:
    dec_ref r11
    goto L5
L18:
    dec_ref r11
    goto L15
L19:
    dec_ref r11
    dec_ref r15
    goto L13
L20:
    dec_ref r11
    dec_ref r15
    goto L15
L21:
    dec_ref r11
    dec_ref r15
    goto L12

def is_revert_bytes(data):
    data, r0 :: object
    r1 :: i32
    r2 :: bit
    r3, r4, r5 :: bool
    r6 :: tuple[bytes, bytes]
    r7 :: bool
    r8, r9, r10 :: object
    r11, r12 :: bytes
    r13 :: str
    r14 :: object[2]
    r15 :: object_ptr
    r16 :: object
    r17 :: bool
    r18 :: bit
    r19 :: bool
L0:
    r0 = load_address PyBytes_Type
    r1 = PyObject_IsInstance(data, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L17 (error at is_revert_bytes:109) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L3 else goto L2 :: bool
L2:
    r4 = r3
    goto L16
L3:
    r5 = 0
    r6 = dank_mids.constants.REVERT_SELECTORS :: static
    if is_error(r6) goto L4 else goto L6
L4:
    r7 = raise NameError('value for final name "REVERT_SELECTORS" was not set')
    if not r7 goto L17 (error at is_revert_bytes:110) else goto L5 :: bool
L5:
    unreachable
L6:
    inc_ref r6
    r8 = box(tuple[bytes, bytes], r6)
    r9 = PyObject_GetIter(r8)
    dec_ref r8
    if is_error(r9) goto L17 (error at is_revert_bytes:109) else goto L7
L7:
    r10 = PyIter_Next(r9)
    if is_error(r10) goto L18 else goto L8
L8:
    r11 = cast(bytes, r10)
    if is_error(r11) goto L19 (error at is_revert_bytes:109) else goto L9
L9:
    inc_ref data
    r12 = cast(bytes, data)
    if is_error(r12) goto L20 (error at is_revert_bytes:110) else goto L10
L10:
    r13 = 'startswith'
    r14 = [r12, r11]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r13, r15, 9223372036854775810, 0)
    if is_error(r16) goto L21 (error at is_revert_bytes:110) else goto L11
L11:
    dec_ref r12
    dec_ref r11
    r17 = unbox(bool, r16)
    dec_ref r16
    if is_error(r17) goto L19 (error at is_revert_bytes:110) else goto L12
L12:
    if r17 goto L22 else goto L7 :: bool
L13:
    r5 = 1
    goto L15
L14:
    r18 = CPy_NoErrOccurred()
    if not r18 goto L17 (error at is_revert_bytes:109) else goto L15 :: bool
L15:
    r4 = r5
L16:
    return r4
L17:
    r19 = <error> :: bool
    return r19
L18:
    dec_ref r9
    goto L14
L19:
    dec_ref r9
    goto L17
L20:
    dec_ref r9
    dec_ref r11
    goto L17
L21:
    dec_ref r9
    dec_ref r11
    dec_ref r12
    goto L17
L22:
    dec_ref r9
    goto L13

def log_request_type_switch():
    r0 :: str
    r1 :: object
    r2 :: bool
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: None
L0:
    r0 = 'your node says the partial request was invalid but its okay, we can use the full jsonrpc spec instead'
    r1 = dank_mids.helpers._errors.error_logger_debug :: static
    if is_error(r1) goto L1 else goto L3
L1:
    r2 = raise NameError('value for final name "error_logger_debug" was not set')
    if not r2 goto L5 (error at log_request_type_switch:115) else goto L2 :: bool
L2:
    unreachable
L3:
    r3 = [r0]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r1, r4, 1, 0)
    if is_error(r5) goto L5 (error at log_request_type_switch:115) else goto L6
L4:
    return 1
L5:
    r6 = <error> :: None
    return r6
L6:
    dec_ref r5
    goto L4

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24, r25 :: object
    r26 :: str
    r27 :: dict
    r28 :: object
    r29 :: str
    r30 :: object
    r31 :: bool
    r32 :: object[1]
    r33 :: object_ptr
    r34 :: object
    r35 :: dict
    r36 :: str
    r37 :: i32
    r38 :: bit
    r39 :: object
    r40 :: bool
    r41 :: str
    r42 :: object
    r43 :: dict
    r44 :: str
    r45 :: i32
    r46 :: bit
    r47 :: object
    r48 :: bool
    r49 :: str
    r50 :: object
    r51 :: dict
    r52 :: str
    r53 :: i32
    r54 :: bit
    r55 :: object
    r56 :: bool
    r57, r58 :: str
    r59 :: object[2]
    r60 :: object_ptr
    r61 :: object
    r62 :: dict
    r63 :: str
    r64 :: i32
    r65 :: bit
    r66 :: object
    r67 :: bool
    r68 :: str
    r69 :: object
    r70 :: dict
    r71 :: str
    r72 :: i32
    r73 :: bit
    r74 :: object
    r75 :: bool
    r76, r77 :: str
    r78 :: object[2]
    r79 :: object_ptr
    r80 :: object
    r81 :: dict
    r82 :: str
    r83 :: i32
    r84 :: bit
    r85 :: object
    r86 :: bool
    r87 :: str
    r88 :: object
    r89 :: dict
    r90 :: str
    r91 :: i32
    r92 :: bit
    r93 :: object
    r94 :: bool
    r95 :: str
    r96 :: object
    r97 :: dict
    r98 :: str
    r99 :: i32
    r100 :: bit
    r101 :: object
    r102 :: bool
    r103, r104 :: str
    r105 :: object[2]
    r106 :: object_ptr
    r107 :: object
    r108 :: dict
    r109 :: str
    r110 :: i32
    r111 :: bit
    r112 :: object
    r113 :: bool
    r114 :: str
    r115 :: object
    r116 :: dict
    r117 :: str
    r118 :: i32
    r119 :: bit
    r120, r121, r122, r123, r124 :: str
    r125 :: set
    r126 :: i32
    r127 :: bit
    r128 :: i32
    r129 :: bit
    r130 :: i32
    r131 :: bit
    r132 :: i32
    r133 :: bit
    r134 :: i32
    r135 :: bit
    r136 :: dict
    r137 :: str
    r138 :: i32
    r139 :: bit
    r140 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L68 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Logger',)
    r6 = 'logging'
    r7 = dank_mids.helpers._errors.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L68 (error at <module>:1) else goto L4
L4:
    logging = r8 :: module
    dec_ref r8
    r9 = ('TYPE_CHECKING', 'Any', 'Final')
    r10 = 'typing'
    r11 = dank_mids.helpers._errors.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L68 (error at <module>:2) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = ('BadResponse',)
    r14 = 'dank_mids._exceptions'
    r15 = dank_mids.helpers._errors.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L68 (error at <module>:4) else goto L6
L6:
    dank_mids._exceptions = r16 :: module
    dec_ref r16
    r17 = ('DEBUG', 'getLogger')
    r18 = 'dank_mids._logging'
    r19 = dank_mids.helpers._errors.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L68 (error at <module>:5) else goto L7
L7:
    dank_mids._logging = r20 :: module
    dec_ref r20
    r21 = ('REVERT_SELECTORS',)
    r22 = 'dank_mids.constants'
    r23 = dank_mids.helpers._errors.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L68 (error at <module>:6) else goto L8
L8:
    dank_mids.constants = r24 :: module
    dec_ref r24
    r25 = ('PartialResponse',)
    r26 = 'dank_mids.types'
    r27 = dank_mids.helpers._errors.globals :: static
    r28 = CPyImport_ImportFromMany(r26, r25, r25, r27)
    if is_error(r28) goto L68 (error at <module>:7) else goto L9
L9:
    dank_mids.types = r28 :: module
    dec_ref r28
    if 0 goto L10 else goto L10 :: bool
L10:
    r29 = 'dank_mids.errors'
    r30 = dank_mids._logging.getLogger :: static
    if is_error(r30) goto L11 else goto L13
L11:
    r31 = raise NameError('value for final name "getLogger" was not set')
    if not r31 goto L68 (error at <module>:13) else goto L12 :: bool
L12:
    unreachable
L13:
    r32 = [r29]
    r33 = load_address r32
    r34 = PyObject_Vectorcall(r30, r33, 1, 0)
    if is_error(r34) goto L68 (error at <module>:13) else goto L14
L14:
    dank_mids.helpers._errors.error_logger = r34 :: static
    r35 = dank_mids.helpers._errors.globals :: static
    r36 = 'error_logger'
    r37 = CPyDict_SetItem(r35, r36, r34)
    dec_ref r34
    r38 = r37 >= 0 :: signed
    if not r38 goto L68 (error at <module>:13) else goto L15 :: bool
L15:
    r39 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r39) goto L16 else goto L18
L16:
    r40 = raise NameError('value for final name "error_logger" was not set')
    if not r40 goto L68 (error at <module>:14) else goto L17 :: bool
L17:
    unreachable
L18:
    r41 = 'debug'
    r42 = CPyObject_GetAttr(r39, r41)
    if is_error(r42) goto L68 (error at <module>:14) else goto L19
L19:
    dank_mids.helpers._errors.error_logger_debug = r42 :: static
    r43 = dank_mids.helpers._errors.globals :: static
    r44 = 'error_logger_debug'
    r45 = CPyDict_SetItem(r43, r44, r42)
    dec_ref r42
    r46 = r45 >= 0 :: signed
    if not r46 goto L68 (error at <module>:14) else goto L20 :: bool
L20:
    r47 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r47) goto L21 else goto L23
L21:
    r48 = raise NameError('value for final name "error_logger" was not set')
    if not r48 goto L68 (error at <module>:15) else goto L22 :: bool
L22:
    unreachable
L23:
    r49 = '_log'
    r50 = CPyObject_GetAttr(r47, r49)
    if is_error(r50) goto L68 (error at <module>:15) else goto L24
L24:
    dank_mids.helpers._errors.error_logger_log = r50 :: static
    r51 = dank_mids.helpers._errors.globals :: static
    r52 = 'error_logger_log'
    r53 = CPyDict_SetItem(r51, r52, r50)
    dec_ref r50
    r54 = r53 >= 0 :: signed
    if not r54 goto L68 (error at <module>:15) else goto L25 :: bool
L25:
    r55 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r55) goto L26 else goto L28
L26:
    r56 = raise NameError('value for final name "error_logger" was not set')
    if not r56 goto L68 (error at <module>:22) else goto L27 :: bool
L27:
    unreachable
L28:
    r57 = 'reverts'
    r58 = 'getChild'
    r59 = [r55, r57]
    r60 = load_address r59
    r61 = PyObject_VectorcallMethod(r58, r60, 9223372036854775810, 0)
    if is_error(r61) goto L68 (error at <module>:22) else goto L29
L29:
    dank_mids.helpers._errors.revert_logger = r61 :: static
    r62 = dank_mids.helpers._errors.globals :: static
    r63 = 'revert_logger'
    r64 = CPyDict_SetItem(r62, r63, r61)
    dec_ref r61
    r65 = r64 >= 0 :: signed
    if not r65 goto L68 (error at <module>:22) else goto L30 :: bool
L30:
    r66 = dank_mids.helpers._errors.revert_logger :: static
    if is_error(r66) goto L31 else goto L33
L31:
    r67 = raise NameError('value for final name "revert_logger" was not set')
    if not r67 goto L68 (error at <module>:23) else goto L32 :: bool
L32:
    unreachable
L33:
    r68 = '_log'
    r69 = CPyObject_GetAttr(r66, r68)
    if is_error(r69) goto L68 (error at <module>:23) else goto L34
L34:
    dank_mids.helpers._errors.revert_logger_log = r69 :: static
    r70 = dank_mids.helpers._errors.globals :: static
    r71 = 'revert_logger_log'
    r72 = CPyDict_SetItem(r70, r71, r69)
    dec_ref r69
    r73 = r72 >= 0 :: signed
    if not r73 goto L68 (error at <module>:23) else goto L35 :: bool
L35:
    r74 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r74) goto L36 else goto L38
L36:
    r75 = raise NameError('value for final name "error_logger" was not set')
    if not r75 goto L68 (error at <module>:30) else goto L37 :: bool
L37:
    unreachable
L38:
    r76 = 'timeouts'
    r77 = 'getChild'
    r78 = [r74, r76]
    r79 = load_address r78
    r80 = PyObject_VectorcallMethod(r77, r79, 9223372036854775810, 0)
    if is_error(r80) goto L68 (error at <module>:30) else goto L39
L39:
    dank_mids.helpers._errors.timeout_logger = r80 :: static
    r81 = dank_mids.helpers._errors.globals :: static
    r82 = 'timeout_logger'
    r83 = CPyDict_SetItem(r81, r82, r80)
    dec_ref r80
    r84 = r83 >= 0 :: signed
    if not r84 goto L68 (error at <module>:30) else goto L40 :: bool
L40:
    r85 = dank_mids.helpers._errors.timeout_logger :: static
    if is_error(r85) goto L41 else goto L43
L41:
    r86 = raise NameError('value for final name "timeout_logger" was not set')
    if not r86 goto L68 (error at <module>:31) else goto L42 :: bool
L42:
    unreachable
L43:
    r87 = 'debug'
    r88 = CPyObject_GetAttr(r85, r87)
    if is_error(r88) goto L68 (error at <module>:31) else goto L44
L44:
    dank_mids.helpers._errors.timeout_logger_debug = r88 :: static
    r89 = dank_mids.helpers._errors.globals :: static
    r90 = 'timeout_logger_debug'
    r91 = CPyDict_SetItem(r89, r90, r88)
    dec_ref r88
    r92 = r91 >= 0 :: signed
    if not r92 goto L68 (error at <module>:31) else goto L45 :: bool
L45:
    r93 = dank_mids.helpers._errors.timeout_logger :: static
    if is_error(r93) goto L46 else goto L48
L46:
    r94 = raise NameError('value for final name "timeout_logger" was not set')
    if not r94 goto L68 (error at <module>:32) else goto L47 :: bool
L47:
    unreachable
L48:
    r95 = 'warning'
    r96 = CPyObject_GetAttr(r93, r95)
    if is_error(r96) goto L68 (error at <module>:32) else goto L49
L49:
    dank_mids.helpers._errors.timeout_logger_warning = r96 :: static
    r97 = dank_mids.helpers._errors.globals :: static
    r98 = 'timeout_logger_warning'
    r99 = CPyDict_SetItem(r97, r98, r96)
    dec_ref r96
    r100 = r99 >= 0 :: signed
    if not r100 goto L68 (error at <module>:32) else goto L50 :: bool
L50:
    r101 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r101) goto L51 else goto L53
L51:
    r102 = raise NameError('value for final name "error_logger" was not set')
    if not r102 goto L68 (error at <module>:35) else goto L52 :: bool
L52:
    unreachable
L53:
    r103 = 'gas'
    r104 = 'getChild'
    r105 = [r101, r103]
    r106 = load_address r105
    r107 = PyObject_VectorcallMethod(r104, r106, 9223372036854775810, 0)
    if is_error(r107) goto L68 (error at <module>:35) else goto L54
L54:
    dank_mids.helpers._errors.gas_logger = r107 :: static
    r108 = dank_mids.helpers._errors.globals :: static
    r109 = 'gas_logger'
    r110 = CPyDict_SetItem(r108, r109, r107)
    dec_ref r107
    r111 = r110 >= 0 :: signed
    if not r111 goto L68 (error at <module>:35) else goto L55 :: bool
L55:
    r112 = dank_mids.helpers._errors.gas_logger :: static
    if is_error(r112) goto L56 else goto L58
L56:
    r113 = raise NameError('value for final name "gas_logger" was not set')
    if not r113 goto L68 (error at <module>:36) else goto L57 :: bool
L57:
    unreachable
L58:
    r114 = 'debug'
    r115 = CPyObject_GetAttr(r112, r114)
    if is_error(r115) goto L68 (error at <module>:36) else goto L59
L59:
    dank_mids.helpers._errors.gas_logger_debug = r115 :: static
    r116 = dank_mids.helpers._errors.globals :: static
    r117 = 'gas_logger_debug'
    r118 = CPyDict_SetItem(r116, r117, r115)
    dec_ref r115
    r119 = r118 >= 0 :: signed
    if not r119 goto L68 (error at <module>:36) else goto L60 :: bool
L60:
    r120 = 'invalid opcode'
    r121 = 'missing trie node'
    r122 = 'resource not found'
    r123 = 'invalid ether transfer'
    r124 = 'error processing call revert'
    r125 = PySet_New(0)
    if is_error(r125) goto L68 (error at <module>:38) else goto L61
L61:
    r126 = PySet_Add(r125, r120)
    r127 = r126 >= 0 :: signed
    if not r127 goto L69 (error at <module>:38) else goto L62 :: bool
L62:
    r128 = PySet_Add(r125, r121)
    r129 = r128 >= 0 :: signed
    if not r129 goto L69 (error at <module>:38) else goto L63 :: bool
L63:
    r130 = PySet_Add(r125, r122)
    r131 = r130 >= 0 :: signed
    if not r131 goto L69 (error at <module>:38) else goto L64 :: bool
L64:
    r132 = PySet_Add(r125, r123)
    r133 = r132 >= 0 :: signed
    if not r133 goto L69 (error at <module>:38) else goto L65 :: bool
L65:
    r134 = PySet_Add(r125, r124)
    r135 = r134 >= 0 :: signed
    if not r135 goto L69 (error at <module>:38) else goto L66 :: bool
L66:
    dank_mids.helpers._errors.INDIVIDUAL_CALL_REVERT_STRINGS = r125 :: static
    r136 = dank_mids.helpers._errors.globals :: static
    r137 = 'INDIVIDUAL_CALL_REVERT_STRINGS'
    r138 = CPyDict_SetItem(r136, r137, r125)
    dec_ref r125
    r139 = r138 >= 0 :: signed
    if not r139 goto L68 (error at <module>:38) else goto L67 :: bool
L67:
    return 1
L68:
    r140 = <error> :: None
    return r140
L69:
    dec_ref r125
    goto L68

def patch_eth_utils():
    r0 :: dict
    r1, r2 :: object
    r3 :: bit
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: str
    r9 :: object
    r10 :: i32
    r11 :: bit
    r12 :: dict
    r13 :: str
    r14 :: object
    r15 :: dict
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: str
    r21 :: i32
    r22 :: bit
    r23 :: dict
    r24, r25 :: object
    r26 :: bit
    r27 :: str
    r28 :: object
    r29 :: str
    r30 :: dict
    r31 :: str
    r32 :: object
    r33 :: i32
    r34 :: bit
    r35 :: dict
    r36 :: str
    r37 :: object
    r38 :: dict
    r39 :: str
    r40 :: object
    r41 :: str
    r42 :: object
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: dict
    r47 :: str
    r48 :: object
    r49 :: dict
    r50 :: str
    r51 :: object
    r52 :: str
    r53 :: object
    r54 :: str
    r55 :: i32
    r56 :: bit
    r57 :: dict
    r58, r59 :: object
    r60 :: bit
    r61 :: str
    r62 :: object
    r63 :: str
    r64 :: dict
    r65 :: str
    r66 :: object
    r67 :: i32
    r68 :: bit
    r69 :: dict
    r70 :: str
    r71 :: object
    r72 :: dict
    r73 :: str
    r74 :: object
    r75 :: str
    r76 :: object
    r77 :: str
    r78 :: object
    r79 :: str
    r80 :: i32
    r81 :: bit
    r82 :: dict
    r83, r84 :: object
    r85 :: bit
    r86 :: str
    r87 :: object
    r88 :: str
    r89 :: dict
    r90 :: str
    r91 :: object
    r92 :: i32
    r93 :: bit
    r94 :: dict
    r95 :: str
    r96 :: object
    r97 :: dict
    r98 :: str
    r99 :: object
    r100 :: str
    r101 :: object
    r102 :: str
    r103 :: object
    r104 :: str
    r105 :: i32
    r106 :: bit
    r107 :: dict
    r108, r109 :: object
    r110 :: bit
    r111 :: str
    r112 :: object
    r113 :: str
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: i32
    r118 :: bit
    r119 :: dict
    r120 :: str
    r121 :: object
    r122 :: dict
    r123 :: str
    r124 :: object
    r125 :: str
    r126 :: object
    r127 :: str
    r128 :: object
    r129 :: str
    r130 :: i32
    r131 :: bit
    r132 :: dict
    r133 :: str
    r134 :: object
    r135 :: dict
    r136 :: str
    r137 :: object
    r138 :: str
    r139 :: object
    r140 :: str
    r141 :: object
    r142 :: str
    r143 :: i32
    r144 :: bit
    r145 :: dict
    r146, r147 :: object
    r148 :: bit
    r149 :: str
    r150 :: object
    r151 :: str
    r152 :: dict
    r153 :: str
    r154 :: object
    r155 :: i32
    r156 :: bit
    r157 :: dict
    r158 :: str
    r159 :: object
    r160 :: dict
    r161 :: str
    r162 :: object
    r163 :: str
    r164 :: object
    r165 :: str
    r166 :: object
    r167 :: str
    r168 :: i32
    r169 :: bit
    r170 :: dict
    r171 :: str
    r172 :: object
    r173 :: dict
    r174 :: str
    r175 :: object
    r176 :: str
    r177 :: object
    r178 :: str
    r179 :: object
    r180 :: str
    r181 :: i32
    r182 :: bit
    r183 :: dict
    r184, r185 :: object
    r186 :: bit
    r187 :: str
    r188 :: object
    r189 :: str
    r190 :: dict
    r191 :: str
    r192 :: object
    r193 :: i32
    r194 :: bit
    r195 :: dict
    r196 :: str
    r197 :: object
    r198 :: dict
    r199 :: str
    r200 :: object
    r201 :: str
    r202 :: object
    r203 :: str
    r204 :: object
    r205 :: str
    r206 :: i32
    r207 :: bit
    r208 :: dict
    r209 :: str
    r210 :: object
    r211 :: dict
    r212 :: str
    r213 :: object
    r214 :: str
    r215 :: object
    r216 :: str
    r217 :: object
    r218 :: str
    r219 :: i32
    r220 :: bit
    r221 :: dict
    r222, r223 :: object
    r224 :: bit
    r225 :: str
    r226 :: object
    r227 :: str
    r228 :: dict
    r229 :: str
    r230 :: object
    r231 :: i32
    r232 :: bit
    r233 :: tuple[object, object, object]
    r234 :: object
    r235 :: str
    r236 :: object
    r237, r238 :: bit
    r239 :: dict
    r240 :: str
    r241 :: object
    r242 :: dict
    r243 :: str
    r244 :: object
    r245 :: str
    r246 :: object
    r247 :: str
    r248 :: object
    r249 :: str
    r250 :: i32
    r251 :: bit
    r252 :: dict
    r253 :: str
    r254 :: object
    r255 :: dict
    r256 :: str
    r257 :: object
    r258 :: str
    r259 :: object
    r260 :: str
    r261 :: object
    r262 :: str
    r263 :: i32
    r264 :: bit
    r265 :: None
L0:
    r0 = dank_mids._eth_utils.globals :: static
    r1 = eth_utils.crypto :: module
    r2 = load_address _Py_NoneStruct
    r3 = r1 != r2
    if r3 goto L3 else goto L1 :: bool
L1:
    r4 = 'eth_utils.crypto'
    r5 = PyImport_Import(r4)
    if is_error(r5) goto L110 (error at patch_eth_utils:25) else goto L2
L2:
    eth_utils.crypto = r5 :: module
    dec_ref r5
L3:
    r6 = 'eth_utils'
    r7 = PyImport_GetModuleDict()
    r8 = 'eth_utils'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L110 (error at patch_eth_utils:25) else goto L4
L4:
    r10 = CPyDict_SetItem(r0, r6, r9)
    dec_ref r9
    r11 = r10 >= 0 :: signed
    if not r11 goto L110 (error at patch_eth_utils:25) else goto L5 :: bool
L5:
    r12 = dank_mids._eth_utils.globals :: static
    r13 = 'to_bytes'
    r14 = CPyDict_GetItem(r12, r13)
    if is_error(r14) goto L110 (error at patch_eth_utils:27) else goto L6
L6:
    r15 = dank_mids._eth_utils.globals :: static
    r16 = 'eth_utils'
    r17 = CPyDict_GetItem(r15, r16)
    if is_error(r17) goto L111 (error at patch_eth_utils:27) else goto L7
L7:
    r18 = 'crypto'
    r19 = CPyObject_GetAttr(r17, r18)
    dec_ref r17
    if is_error(r19) goto L111 (error at patch_eth_utils:27) else goto L8
L8:
    r20 = 'to_bytes'
    r21 = PyObject_SetAttr(r19, r20, r14)
    dec_ref r19
    dec_ref r14
    r22 = r21 >= 0 :: signed
    if not r22 goto L110 (error at patch_eth_utils:27) else goto L9 :: bool
L9:
    r23 = dank_mids._eth_utils.globals :: static
    r24 = web3.main :: module
    r25 = load_address _Py_NoneStruct
    r26 = r24 != r25
    if r26 goto L12 else goto L10 :: bool
L10:
    r27 = 'web3.main'
    r28 = PyImport_Import(r27)
    if is_error(r28) goto L110 (error at patch_eth_utils:29) else goto L11
L11:
    web3.main = r28 :: module
    dec_ref r28
L12:
    r29 = 'web3'
    r30 = PyImport_GetModuleDict()
    r31 = 'web3'
    r32 = CPyDict_GetItem(r30, r31)
    if is_error(r32) goto L110 (error at patch_eth_utils:29) else goto L13
L13:
    r33 = CPyDict_SetItem(r23, r29, r32)
    dec_ref r32
    r34 = r33 >= 0 :: signed
    if not r34 goto L110 (error at patch_eth_utils:29) else goto L14 :: bool
L14:
    r35 = dank_mids._eth_utils.globals :: static
    r36 = 'to_hex'
    r37 = CPyDict_GetItem(r35, r36)
    if is_error(r37) goto L110 (error at patch_eth_utils:31) else goto L15
L15:
    r38 = dank_mids._eth_utils.globals :: static
    r39 = 'web3'
    r40 = CPyDict_GetItem(r38, r39)
    if is_error(r40) goto L112 (error at patch_eth_utils:31) else goto L16
L16:
    r41 = 'main'
    r42 = CPyObject_GetAttr(r40, r41)
    dec_ref r40
    if is_error(r42) goto L112 (error at patch_eth_utils:31) else goto L17
L17:
    r43 = 'to_hex'
    r44 = PyObject_SetAttr(r42, r43, r37)
    dec_ref r42
    dec_ref r37
    r45 = r44 >= 0 :: signed
    if not r45 goto L110 (error at patch_eth_utils:31) else goto L18 :: bool
L18:
    r46 = dank_mids._eth_utils.globals :: static
    r47 = 'to_bytes'
    r48 = CPyDict_GetItem(r46, r47)
    if is_error(r48) goto L110 (error at patch_eth_utils:32) else goto L19
L19:
    r49 = dank_mids._eth_utils.globals :: static
    r50 = 'web3'
    r51 = CPyDict_GetItem(r49, r50)
    if is_error(r51) goto L113 (error at patch_eth_utils:32) else goto L20
L20:
    r52 = 'main'
    r53 = CPyObject_GetAttr(r51, r52)
    dec_ref r51
    if is_error(r53) goto L113 (error at patch_eth_utils:32) else goto L21
L21:
    r54 = 'to_bytes'
    r55 = PyObject_SetAttr(r53, r54, r48)
    dec_ref r53
    dec_ref r48
    r56 = r55 >= 0 :: signed
    if not r56 goto L110 (error at patch_eth_utils:32) else goto L22 :: bool
L22:
    r57 = dank_mids._eth_utils.globals :: static
    r58 = web3.middleware.filter :: module
    r59 = load_address _Py_NoneStruct
    r60 = r58 != r59
    if r60 goto L25 else goto L23 :: bool
L23:
    r61 = 'web3.middleware.filter'
    r62 = PyImport_Import(r61)
    if is_error(r62) goto L110 (error at patch_eth_utils:34) else goto L24
L24:
    web3.middleware.filter = r62 :: module
    dec_ref r62
L25:
    r63 = 'web3'
    r64 = PyImport_GetModuleDict()
    r65 = 'web3'
    r66 = CPyDict_GetItem(r64, r65)
    if is_error(r66) goto L110 (error at patch_eth_utils:34) else goto L26
L26:
    r67 = CPyDict_SetItem(r57, r63, r66)
    dec_ref r66
    r68 = r67 >= 0 :: signed
    if not r68 goto L110 (error at patch_eth_utils:34) else goto L27 :: bool
L27:
    r69 = dank_mids._eth_utils.globals :: static
    r70 = 'to_hex'
    r71 = CPyDict_GetItem(r69, r70)
    if is_error(r71) goto L110 (error at patch_eth_utils:36) else goto L28
L28:
    r72 = dank_mids._eth_utils.globals :: static
    r73 = 'web3'
    r74 = CPyDict_GetItem(r72, r73)
    if is_error(r74) goto L114 (error at patch_eth_utils:36) else goto L29
L29:
    r75 = 'middleware'
    r76 = CPyObject_GetAttr(r74, r75)
    dec_ref r74
    if is_error(r76) goto L114 (error at patch_eth_utils:36) else goto L30
L30:
    r77 = 'filter'
    r78 = CPyObject_GetAttr(r76, r77)
    dec_ref r76
    if is_error(r78) goto L114 (error at patch_eth_utils:36) else goto L31
L31:
    r79 = 'to_hex'
    r80 = PyObject_SetAttr(r78, r79, r71)
    dec_ref r78
    dec_ref r71
    r81 = r80 >= 0 :: signed
    if not r81 goto L110 (error at patch_eth_utils:36) else goto L32 :: bool
L32:
    r82 = dank_mids._eth_utils.globals :: static
    r83 = web3.providers.base :: module
    r84 = load_address _Py_NoneStruct
    r85 = r83 != r84
    if r85 goto L35 else goto L33 :: bool
L33:
    r86 = 'web3.providers.base'
    r87 = PyImport_Import(r86)
    if is_error(r87) goto L110 (error at patch_eth_utils:38) else goto L34
L34:
    web3.providers.base = r87 :: module
    dec_ref r87
L35:
    r88 = 'web3'
    r89 = PyImport_GetModuleDict()
    r90 = 'web3'
    r91 = CPyDict_GetItem(r89, r90)
    if is_error(r91) goto L110 (error at patch_eth_utils:38) else goto L36
L36:
    r92 = CPyDict_SetItem(r82, r88, r91)
    dec_ref r91
    r93 = r92 >= 0 :: signed
    if not r93 goto L110 (error at patch_eth_utils:38) else goto L37 :: bool
L37:
    r94 = dank_mids._eth_utils.globals :: static
    r95 = 'to_bytes'
    r96 = CPyDict_GetItem(r94, r95)
    if is_error(r96) goto L110 (error at patch_eth_utils:40) else goto L38
L38:
    r97 = dank_mids._eth_utils.globals :: static
    r98 = 'web3'
    r99 = CPyDict_GetItem(r97, r98)
    if is_error(r99) goto L115 (error at patch_eth_utils:40) else goto L39
L39:
    r100 = 'providers'
    r101 = CPyObject_GetAttr(r99, r100)
    dec_ref r99
    if is_error(r101) goto L115 (error at patch_eth_utils:40) else goto L40
L40:
    r102 = 'base'
    r103 = CPyObject_GetAttr(r101, r102)
    dec_ref r101
    if is_error(r103) goto L115 (error at patch_eth_utils:40) else goto L41
L41:
    r104 = 'to_bytes'
    r105 = PyObject_SetAttr(r103, r104, r96)
    dec_ref r103
    dec_ref r96
    r106 = r105 >= 0 :: signed
    if not r106 goto L110 (error at patch_eth_utils:40) else goto L42 :: bool
L42:
    r107 = dank_mids._eth_utils.globals :: static
    r108 = web3._utils.encoding :: module
    r109 = load_address _Py_NoneStruct
    r110 = r108 != r109
    if r110 goto L45 else goto L43 :: bool
L43:
    r111 = 'web3._utils.encoding'
    r112 = PyImport_Import(r111)
    if is_error(r112) goto L110 (error at patch_eth_utils:42) else goto L44
L44:
    web3._utils.encoding = r112 :: module
    dec_ref r112
L45:
    r113 = 'web3'
    r114 = PyImport_GetModuleDict()
    r115 = 'web3'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L110 (error at patch_eth_utils:42) else goto L46
L46:
    r117 = CPyDict_SetItem(r107, r113, r116)
    dec_ref r116
    r118 = r117 >= 0 :: signed
    if not r118 goto L110 (error at patch_eth_utils:42) else goto L47 :: bool
L47:
    r119 = dank_mids._eth_utils.globals :: static
    r120 = 'to_hex'
    r121 = CPyDict_GetItem(r119, r120)
    if is_error(r121) goto L110 (error at patch_eth_utils:44) else goto L48
L48:
    r122 = dank_mids._eth_utils.globals :: static
    r123 = 'web3'
    r124 = CPyDict_GetItem(r122, r123)
    if is_error(r124) goto L116 (error at patch_eth_utils:44) else goto L49
L49:
    r125 = '_utils'
    r126 = CPyObject_GetAttr(r124, r125)
    dec_ref r124
    if is_error(r126) goto L116 (error at patch_eth_utils:44) else goto L50
L50:
    r127 = 'encoding'
    r128 = CPyObject_GetAttr(r126, r127)
    dec_ref r126
    if is_error(r128) goto L116 (error at patch_eth_utils:44) else goto L51
L51:
    r129 = 'to_hex'
    r130 = PyObject_SetAttr(r128, r129, r121)
    dec_ref r128
    dec_ref r121
    r131 = r130 >= 0 :: signed
    if not r131 goto L110 (error at patch_eth_utils:44) else goto L52 :: bool
L52:
    r132 = dank_mids._eth_utils.globals :: static
    r133 = 'to_bytes'
    r134 = CPyDict_GetItem(r132, r133)
    if is_error(r134) goto L110 (error at patch_eth_utils:45) else goto L53
L53:
    r135 = dank_mids._eth_utils.globals :: static
    r136 = 'web3'
    r137 = CPyDict_GetItem(r135, r136)
    if is_error(r137) goto L117 (error at patch_eth_utils:45) else goto L54
L54:
    r138 = '_utils'
    r139 = CPyObject_GetAttr(r137, r138)
    dec_ref r137
    if is_error(r139) goto L117 (error at patch_eth_utils:45) else goto L55
L55:
    r140 = 'encoding'
    r141 = CPyObject_GetAttr(r139, r140)
    dec_ref r139
    if is_error(r141) goto L117 (error at patch_eth_utils:45) else goto L56
L56:
    r142 = 'to_bytes'
    r143 = PyObject_SetAttr(r141, r142, r134)
    dec_ref r141
    dec_ref r134
    r144 = r143 >= 0 :: signed
    if not r144 goto L110 (error at patch_eth_utils:45) else goto L57 :: bool
L57:
    r145 = dank_mids._eth_utils.globals :: static
    r146 = web3._utils.events :: module
    r147 = load_address _Py_NoneStruct
    r148 = r146 != r147
    if r148 goto L60 else goto L58 :: bool
L58:
    r149 = 'web3._utils.events'
    r150 = PyImport_Import(r149)
    if is_error(r150) goto L110 (error at patch_eth_utils:47) else goto L59
L59:
    web3._utils.events = r150 :: module
    dec_ref r150
L60:
    r151 = 'web3'
    r152 = PyImport_GetModuleDict()
    r153 = 'web3'
    r154 = CPyDict_GetItem(r152, r153)
    if is_error(r154) goto L110 (error at patch_eth_utils:47) else goto L61
L61:
    r155 = CPyDict_SetItem(r145, r151, r154)
    dec_ref r154
    r156 = r155 >= 0 :: signed
    if not r156 goto L110 (error at patch_eth_utils:47) else goto L62 :: bool
L62:
    r157 = dank_mids._eth_utils.globals :: static
    r158 = 'to_hex'
    r159 = CPyDict_GetItem(r157, r158)
    if is_error(r159) goto L110 (error at patch_eth_utils:49) else goto L63
L63:
    r160 = dank_mids._eth_utils.globals :: static
    r161 = 'web3'
    r162 = CPyDict_GetItem(r160, r161)
    if is_error(r162) goto L118 (error at patch_eth_utils:49) else goto L64
L64:
    r163 = '_utils'
    r164 = CPyObject_GetAttr(r162, r163)
    dec_ref r162
    if is_error(r164) goto L118 (error at patch_eth_utils:49) else goto L65
L65:
    r165 = 'events'
    r166 = CPyObject_GetAttr(r164, r165)
    dec_ref r164
    if is_error(r166) goto L118 (error at patch_eth_utils:49) else goto L66
L66:
    r167 = 'to_hex'
    r168 = PyObject_SetAttr(r166, r167, r159)
    dec_ref r166
    dec_ref r159
    r169 = r168 >= 0 :: signed
    if not r169 goto L110 (error at patch_eth_utils:49) else goto L67 :: bool
L67:
    r170 = dank_mids._eth_utils.globals :: static
    r171 = 'to_bytes'
    r172 = CPyDict_GetItem(r170, r171)
    if is_error(r172) goto L110 (error at patch_eth_utils:50) else goto L68
L68:
    r173 = dank_mids._eth_utils.globals :: static
    r174 = 'web3'
    r175 = CPyDict_GetItem(r173, r174)
    if is_error(r175) goto L119 (error at patch_eth_utils:50) else goto L69
L69:
    r176 = '_utils'
    r177 = CPyObject_GetAttr(r175, r176)
    dec_ref r175
    if is_error(r177) goto L119 (error at patch_eth_utils:50) else goto L70
L70:
    r178 = 'events'
    r179 = CPyObject_GetAttr(r177, r178)
    dec_ref r177
    if is_error(r179) goto L119 (error at patch_eth_utils:50) else goto L71
L71:
    r180 = 'to_bytes'
    r181 = PyObject_SetAttr(r179, r180, r172)
    dec_ref r179
    dec_ref r172
    r182 = r181 >= 0 :: signed
    if not r182 goto L110 (error at patch_eth_utils:50) else goto L72 :: bool
L72:
    r183 = dank_mids._eth_utils.globals :: static
    r184 = web3._utils.normalizers :: module
    r185 = load_address _Py_NoneStruct
    r186 = r184 != r185
    if r186 goto L75 else goto L73 :: bool
L73:
    r187 = 'web3._utils.normalizers'
    r188 = PyImport_Import(r187)
    if is_error(r188) goto L110 (error at patch_eth_utils:52) else goto L74
L74:
    web3._utils.normalizers = r188 :: module
    dec_ref r188
L75:
    r189 = 'web3'
    r190 = PyImport_GetModuleDict()
    r191 = 'web3'
    r192 = CPyDict_GetItem(r190, r191)
    if is_error(r192) goto L110 (error at patch_eth_utils:52) else goto L76
L76:
    r193 = CPyDict_SetItem(r183, r189, r192)
    dec_ref r192
    r194 = r193 >= 0 :: signed
    if not r194 goto L110 (error at patch_eth_utils:52) else goto L77 :: bool
L77:
    r195 = dank_mids._eth_utils.globals :: static
    r196 = 'to_hex'
    r197 = CPyDict_GetItem(r195, r196)
    if is_error(r197) goto L110 (error at patch_eth_utils:54) else goto L78
L78:
    r198 = dank_mids._eth_utils.globals :: static
    r199 = 'web3'
    r200 = CPyDict_GetItem(r198, r199)
    if is_error(r200) goto L120 (error at patch_eth_utils:54) else goto L79
L79:
    r201 = '_utils'
    r202 = CPyObject_GetAttr(r200, r201)
    dec_ref r200
    if is_error(r202) goto L120 (error at patch_eth_utils:54) else goto L80
L80:
    r203 = 'normalizers'
    r204 = CPyObject_GetAttr(r202, r203)
    dec_ref r202
    if is_error(r204) goto L120 (error at patch_eth_utils:54) else goto L81
L81:
    r205 = 'to_hex'
    r206 = PyObject_SetAttr(r204, r205, r197)
    dec_ref r204
    dec_ref r197
    r207 = r206 >= 0 :: signed
    if not r207 goto L110 (error at patch_eth_utils:54) else goto L82 :: bool
L82:
    r208 = dank_mids._eth_utils.globals :: static
    r209 = 'to_bytes'
    r210 = CPyDict_GetItem(r208, r209)
    if is_error(r210) goto L110 (error at patch_eth_utils:55) else goto L83
L83:
    r211 = dank_mids._eth_utils.globals :: static
    r212 = 'web3'
    r213 = CPyDict_GetItem(r211, r212)
    if is_error(r213) goto L121 (error at patch_eth_utils:55) else goto L84
L84:
    r214 = '_utils'
    r215 = CPyObject_GetAttr(r213, r214)
    dec_ref r213
    if is_error(r215) goto L121 (error at patch_eth_utils:55) else goto L85
L85:
    r216 = 'normalizers'
    r217 = CPyObject_GetAttr(r215, r216)
    dec_ref r215
    if is_error(r217) goto L121 (error at patch_eth_utils:55) else goto L86
L86:
    r218 = 'to_bytes'
    r219 = PyObject_SetAttr(r217, r218, r210)
    dec_ref r217
    dec_ref r210
    r220 = r219 >= 0 :: signed
    if not r220 goto L110 (error at patch_eth_utils:55) else goto L87 :: bool
L87:
    r221 = dank_mids._eth_utils.globals :: static
    r222 = web3._utils.type_conversion :: module
    r223 = load_address _Py_NoneStruct
    r224 = r222 != r223
    if r224 goto L90 else goto L88 :: bool
L88:
    r225 = 'web3._utils.type_conversion'
    r226 = PyImport_Import(r225)
    if is_error(r226) goto L92 (error at patch_eth_utils:59) else goto L89
L89:
    web3._utils.type_conversion = r226 :: module
    dec_ref r226
L90:
    r227 = 'web3'
    r228 = PyImport_GetModuleDict()
    r229 = 'web3'
    r230 = CPyDict_GetItem(r228, r229)
    if is_error(r230) goto L92 (error at patch_eth_utils:59) else goto L91
L91:
    r231 = CPyDict_SetItem(r221, r227, r230)
    dec_ref r230
    r232 = r231 >= 0 :: signed
    if not r232 goto L92 (error at patch_eth_utils:59) else goto L99 :: bool
L92:
    r233 = CPy_CatchError()
    r234 = builtins :: module
    r235 = 'ModuleNotFoundError'
    r236 = CPyObject_GetAttr(r234, r235)
    if is_error(r236) goto L97 (error at patch_eth_utils:60) else goto L93
L93:
    r237 = CPy_ExceptionMatches(r236)
    dec_ref r236
    if r237 goto L96 else goto L94 :: bool
L94:
    CPy_Reraise()
    if not 0 goto L97 else goto L122 :: bool
L95:
    unreachable
L96:
    CPy_RestoreExcInfo(r233)
    dec_ref r233
    goto L109
L97:
    CPy_RestoreExcInfo(r233)
    dec_ref r233
    r238 = CPy_KeepPropagating()
    if not r238 goto L110 else goto L98 :: bool
L98:
    unreachable
L99:
    r239 = dank_mids._eth_utils.globals :: static
    r240 = 'to_hex'
    r241 = CPyDict_GetItem(r239, r240)
    if is_error(r241) goto L110 (error at patch_eth_utils:63) else goto L100
L100:
    r242 = dank_mids._eth_utils.globals :: static
    r243 = 'web3'
    r244 = CPyDict_GetItem(r242, r243)
    if is_error(r244) goto L123 (error at patch_eth_utils:63) else goto L101
L101:
    r245 = '_utils'
    r246 = CPyObject_GetAttr(r244, r245)
    dec_ref r244
    if is_error(r246) goto L123 (error at patch_eth_utils:63) else goto L102
L102:
    r247 = 'type_conversion'
    r248 = CPyObject_GetAttr(r246, r247)
    dec_ref r246
    if is_error(r248) goto L123 (error at patch_eth_utils:63) else goto L103
L103:
    r249 = 'to_hex'
    r250 = PyObject_SetAttr(r248, r249, r241)
    dec_ref r248
    dec_ref r241
    r251 = r250 >= 0 :: signed
    if not r251 goto L110 (error at patch_eth_utils:63) else goto L104 :: bool
L104:
    r252 = dank_mids._eth_utils.globals :: static
    r253 = 'to_bytes'
    r254 = CPyDict_GetItem(r252, r253)
    if is_error(r254) goto L110 (error at patch_eth_utils:64) else goto L105
L105:
    r255 = dank_mids._eth_utils.globals :: static
    r256 = 'web3'
    r257 = CPyDict_GetItem(r255, r256)
    if is_error(r257) goto L124 (error at patch_eth_utils:64) else goto L106
L106:
    r258 = '_utils'
    r259 = CPyObject_GetAttr(r257, r258)
    dec_ref r257
    if is_error(r259) goto L124 (error at patch_eth_utils:64) else goto L107
L107:
    r260 = 'type_conversion'
    r261 = CPyObject_GetAttr(r259, r260)
    dec_ref r259
    if is_error(r261) goto L124 (error at patch_eth_utils:64) else goto L108
L108:
    r262 = 'to_bytes'
    r263 = PyObject_SetAttr(r261, r262, r254)
    dec_ref r261
    dec_ref r254
    r264 = r263 >= 0 :: signed
    if not r264 goto L110 (error at patch_eth_utils:64) else goto L109 :: bool
L109:
    return 1
L110:
    r265 = <error> :: None
    return r265
L111:
    dec_ref r14
    goto L110
L112:
    dec_ref r37
    goto L110
L113:
    dec_ref r48
    goto L110
L114:
    dec_ref r71
    goto L110
L115:
    dec_ref r96
    goto L110
L116:
    dec_ref r121
    goto L110
L117:
    dec_ref r134
    goto L110
L118:
    dec_ref r159
    goto L110
L119:
    dec_ref r172
    goto L110
L120:
    dec_ref r197
    goto L110
L121:
    dec_ref r210
    goto L110
L122:
    dec_ref r233
    goto L95
L123:
    dec_ref r241
    goto L110
L124:
    dec_ref r254
    goto L110

def to_hex(primitive, hexstr, text):
    primitive, hexstr :: union[object, None]
    text :: union[str, None]
    r0, r1, r2, r3 :: object
    r4 :: bit
    r5 :: object
    r6 :: str
    r7 :: object[1]
    r8 :: object_ptr
    r9, r10, r11 :: object
    r12 :: bit
    r13 :: str
    r14 :: bytes
    r15, r16 :: object
    r17 :: i32
    r18 :: bit
    r19, r20 :: bool
    r21, r22, r23 :: str
    r24, r25 :: object
    r26 :: str
    r27 :: object
    r28 :: tuple[object, object]
    r29 :: object
    r30 :: i32
    r31 :: bit
    r32 :: bool
    r33, r34 :: object
    r35 :: str
    r36 :: object
    r37 :: i32
    r38 :: bit
    r39 :: bool
    r40 :: object
    r41 :: object[1]
    r42 :: object_ptr
    r43 :: object
    r44 :: bytes
    r45, r46 :: object
    r47 :: i32
    r48 :: bit
    r49 :: bool
    r50 :: str
    r51 :: object
    r52 :: str
    r53 :: object
    r54 :: object[1]
    r55 :: object_ptr
    r56, r57 :: object
    r58 :: i32
    r59 :: bit
    r60 :: bool
    r61 :: int
    r62 :: object
    r63 :: str
    r64, r65 :: object
    r66 :: object[1]
    r67 :: object_ptr
    r68 :: object
    r69, r70 :: str
    r71 :: object
    r72, r73, r74 :: str
    r75 :: object
    r76 :: str
    r77 :: object
    r78 :: object[1]
    r79 :: object_ptr
    r80, r81 :: object
L0:
    if is_error(primitive) goto L1 else goto L55
L1:
    r0 = box(None, 1)
    inc_ref r0
    primitive = r0
L2:
    if is_error(hexstr) goto L3 else goto L56
L3:
    r1 = box(None, 1)
    inc_ref r1
    hexstr = r1
L4:
    if is_error(text) goto L5 else goto L57
L5:
    r2 = box(None, 1)
    inc_ref r2
    text = r2
L6:
    r3 = load_address _Py_NoneStruct
    r4 = hexstr != r3
    if r4 goto L58 else goto L59 :: bool
L7:
    r5 = hexstr
    r6 = 'lower'
    r7 = [r5]
    r8 = load_address r7
    r9 = PyObject_VectorcallMethod(r6, r8, 9223372036854775809, 0)
    if is_error(r9) goto L60 (error at to_hex:78) else goto L8
L8:
    dec_ref r5
L9:
    r10 = add_0x_prefix(r9)
    dec_ref r9
    if is_error(r10) goto L54 (error at to_hex:78) else goto L10
L10:
    return r10
L11:
    r11 = load_address _Py_NoneStruct
    r12 = text != r11
    if r12 goto L61 else goto L62 :: bool
L12:
    r13 = cast(str, text)
    if is_error(r13) goto L54 (error at to_hex:81) else goto L13
L13:
    r14 = PyUnicode_AsUTF8String(r13)
    dec_ref r13
    if is_error(r14) goto L54 (error at to_hex:81) else goto L14
L14:
    r15 = encode_hex(r14)
    dec_ref r14
    if is_error(r15) goto L54 (error at to_hex:81) else goto L15
L15:
    return r15
L16:
    r16 = load_address PyBool_Type
    r17 = PyObject_IsInstance(primitive, r16)
    r18 = r17 >= 0 :: signed
    if not r18 goto L63 (error at to_hex:83) else goto L17 :: bool
L17:
    r19 = truncate r17: i32 to builtins.bool
    if r19 goto L18 else goto L23 :: bool
L18:
    r20 = unbox(bool, primitive)
    dec_ref primitive
    if is_error(r20) goto L54 (error at to_hex:84) else goto L19
L19:
    if r20 goto L20 else goto L21 :: bool
L20:
    r21 = '0x1'
    inc_ref r21
    r22 = r21
    goto L22
L21:
    r23 = '0x0'
    inc_ref r23
    r22 = r23
L22:
    return r22
L23:
    r24 = load_address PyBytes_Type
    r25 = builtins :: module
    r26 = 'bytearray'
    r27 = CPyObject_GetAttr(r25, r26)
    if is_error(r27) goto L63 (error at to_hex:86) else goto L24
L24:
    inc_ref r24
    r28 = (r24, r27)
    r29 = box(tuple[object, object], r28)
    r30 = PyObject_IsInstance(primitive, r29)
    dec_ref r29
    r31 = r30 >= 0 :: signed
    if not r31 goto L63 (error at to_hex:86) else goto L25 :: bool
L25:
    r32 = truncate r30: i32 to builtins.bool
    if r32 goto L26 else goto L28 :: bool
L26:
    r33 = encode_hex(primitive)
    dec_ref primitive
    if is_error(r33) goto L54 (error at to_hex:87) else goto L27
L27:
    return r33
L28:
    r34 = builtins :: module
    r35 = 'memoryview'
    r36 = CPyObject_GetAttr(r34, r35)
    if is_error(r36) goto L63 (error at to_hex:89) else goto L29
L29:
    r37 = PyObject_IsInstance(primitive, r36)
    dec_ref r36
    r38 = r37 >= 0 :: signed
    if not r38 goto L63 (error at to_hex:89) else goto L30 :: bool
L30:
    r39 = truncate r37: i32 to builtins.bool
    if r39 goto L31 else goto L35 :: bool
L31:
    r40 = load_address PyBytes_Type
    r41 = [primitive]
    r42 = load_address r41
    r43 = PyObject_Vectorcall(r40, r42, 1, 0)
    if is_error(r43) goto L63 (error at to_hex:90) else goto L32
L32:
    dec_ref primitive
    r44 = cast(bytes, r43)
    if is_error(r44) goto L54 (error at to_hex:90) else goto L33
L33:
    r45 = encode_hex(r44)
    dec_ref r44
    if is_error(r45) goto L54 (error at to_hex:90) else goto L34
L34:
    return r45
L35:
    r46 = load_address PyUnicode_Type
    r47 = PyObject_IsInstance(primitive, r46)
    r48 = r47 >= 0 :: signed
    if not r48 goto L63 (error at to_hex:92) else goto L36 :: bool
L36:
    r49 = truncate r47: i32 to builtins.bool
    if r49 goto L64 else goto L41 :: bool
L37:
    r50 = 'Unsupported type: The primitive argument must be one of: bytes,bytearray, int or bool and not str'
    r51 = builtins :: module
    r52 = 'TypeError'
    r53 = CPyObject_GetAttr(r51, r52)
    if is_error(r53) goto L54 (error at to_hex:93) else goto L38
L38:
    r54 = [r50]
    r55 = load_address r54
    r56 = PyObject_Vectorcall(r53, r55, 1, 0)
    dec_ref r53
    if is_error(r56) goto L54 (error at to_hex:93) else goto L39
L39:
    CPy_Raise(r56)
    dec_ref r56
    if not 0 goto L54 (error at to_hex:93) else goto L40 :: bool
L40:
    unreachable
L41:
    r57 = load_address PyLong_Type
    r58 = PyObject_IsInstance(primitive, r57)
    r59 = r58 >= 0 :: signed
    if not r59 goto L63 (error at to_hex:98) else goto L42 :: bool
L42:
    r60 = truncate r58: i32 to builtins.bool
    if r60 goto L43 else goto L48 :: bool
L43:
    r61 = unbox(int, primitive)
    dec_ref primitive
    if is_error(r61) goto L54 (error at to_hex:99) else goto L44
L44:
    r62 = builtins :: module
    r63 = 'hex'
    r64 = CPyObject_GetAttr(r62, r63)
    if is_error(r64) goto L65 (error at to_hex:99) else goto L45
L45:
    r65 = box(int, r61)
    r66 = [r65]
    r67 = load_address r66
    r68 = PyObject_Vectorcall(r64, r67, 1, 0)
    dec_ref r64
    if is_error(r68) goto L66 (error at to_hex:99) else goto L46
L46:
    dec_ref r65
    r69 = cast(str, r68)
    if is_error(r69) goto L54 (error at to_hex:99) else goto L47
L47:
    return r69
L48:
    r70 = "Unsupported type: '"
    r71 = PyObject_Type(primitive)
    dec_ref primitive
    r72 = PyObject_Repr(r71)
    dec_ref r71
    if is_error(r72) goto L54 (error at to_hex:102) else goto L49
L49:
    r73 = "'. Must be one of: bool, str, bytes, bytearray or int."
    r74 = CPyStr_Build(3, r70, r72, r73)
    dec_ref r72
    if is_error(r74) goto L54 (error at to_hex:102) else goto L50
L50:
    r75 = builtins :: module
    r76 = 'TypeError'
    r77 = CPyObject_GetAttr(r75, r76)
    if is_error(r77) goto L67 (error at to_hex:101) else goto L51
L51:
    r78 = [r74]
    r79 = load_address r78
    r80 = PyObject_Vectorcall(r77, r79, 1, 0)
    dec_ref r77
    if is_error(r80) goto L67 (error at to_hex:101) else goto L52
L52:
    dec_ref r74
    CPy_Raise(r80)
    dec_ref r80
    if not 0 goto L54 (error at to_hex:101) else goto L53 :: bool
L53:
    unreachable
L54:
    r81 = <error> :: object
    return r81
L55:
    inc_ref primitive
    goto L2
L56:
    inc_ref hexstr
    goto L4
L57:
    inc_ref text
    goto L6
L58:
    dec_ref primitive
    dec_ref text
    goto L7
L59:
    dec_ref hexstr
    goto L11
L60:
    dec_ref r5
    goto L54
L61:
    dec_ref primitive
    goto L12
L62:
    dec_ref text
    goto L16
L63:
    dec_ref primitive
    goto L54
L64:
    dec_ref primitive
    goto L37
L65:
    dec_ref r61 :: int
    goto L54
L66:
    dec_ref r65
    goto L54
L67:
    dec_ref r74
    goto L54

def to_bytes(primitive, hexstr, text):
    primitive, hexstr :: union[object, None]
    text :: union[str, None]
    r0, r1, r2, r3 :: object
    r4 :: i32
    r5 :: bit
    r6, r7 :: bool
    r8, r9, r10 :: bytes
    r11 :: object
    r12 :: str
    r13, r14 :: object
    r15 :: str
    r16 :: object
    r17 :: tuple[object, object]
    r18 :: object
    r19 :: i32
    r20 :: bit
    r21 :: bool
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: bytes
    r27 :: object
    r28 :: i32
    r29 :: bit
    r30 :: bool
    r31 :: bytes
    r32 :: object
    r33 :: i32
    r34 :: bit
    r35 :: bool
    r36 :: int
    r37 :: object
    r38 :: union[object, None]
    r39 :: union[str, None]
    r40 :: object
    r41 :: union[object, None]
    r42 :: union[str, None]
    r43 :: bytes
    r44 :: object
    r45 :: bit
    r46, r47 :: int
    r48 :: bit
    r49 :: str
    r50 :: object
    r51, r52 :: str
    r53 :: union[str, object]
    r54 :: str
    r55 :: bytes
    r56 :: object
    r57 :: bit
    r58 :: str
    r59 :: bytes
    r60 :: str
    r61 :: object
    r62 :: str
    r63 :: object
    r64 :: object[1]
    r65 :: object_ptr
    r66 :: object
    r67 :: bytes
L0:
    if is_error(primitive) goto L1 else goto L51
L1:
    r0 = box(None, 1)
    inc_ref r0
    primitive = r0
L2:
    if is_error(hexstr) goto L3 else goto L52
L3:
    r1 = box(None, 1)
    inc_ref r1
    hexstr = r1
L4:
    if is_error(text) goto L5 else goto L53
L5:
    r2 = box(None, 1)
    inc_ref r2
    text = r2
L6:
    r3 = load_address PyBool_Type
    r4 = PyObject_IsInstance(primitive, r3)
    r5 = r4 >= 0 :: signed
    if not r5 goto L54 (error at to_bytes:112) else goto L7 :: bool
L7:
    r6 = truncate r4: i32 to builtins.bool
    if r6 goto L55 else goto L13 :: bool
L8:
    r7 = unbox(bool, primitive)
    dec_ref primitive
    if is_error(r7) goto L50 (error at to_bytes:113) else goto L9
L9:
    if r7 goto L10 else goto L11 :: bool
L10:
    r8 = b'\x01'
    inc_ref r8
    r9 = r8
    goto L12
L11:
    r10 = b'\x00'
    inc_ref r10
    r9 = r10
L12:
    return r9
L13:
    r11 = builtins :: module
    r12 = 'bytearray'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L54 (error at to_bytes:114) else goto L14
L14:
    r14 = builtins :: module
    r15 = 'memoryview'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L56 (error at to_bytes:114) else goto L15
L15:
    r17 = (r13, r16)
    r18 = box(tuple[object, object], r17)
    r19 = PyObject_IsInstance(primitive, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L54 (error at to_bytes:114) else goto L16 :: bool
L16:
    r21 = truncate r19: i32 to builtins.bool
    if r21 goto L57 else goto L20 :: bool
L17:
    r22 = load_address PyBytes_Type
    r23 = [primitive]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    if is_error(r25) goto L58 (error at to_bytes:115) else goto L18
L18:
    dec_ref primitive
    r26 = cast(bytes, r25)
    if is_error(r26) goto L50 (error at to_bytes:115) else goto L19
L19:
    return r26
L20:
    r27 = load_address PyBytes_Type
    r28 = PyObject_IsInstance(primitive, r27)
    r29 = r28 >= 0 :: signed
    if not r29 goto L54 (error at to_bytes:116) else goto L21 :: bool
L21:
    r30 = truncate r28: i32 to builtins.bool
    if r30 goto L59 else goto L24 :: bool
L22:
    r31 = cast(bytes, primitive)
    if is_error(r31) goto L50 (error at to_bytes:117) else goto L23
L23:
    return r31
L24:
    r32 = load_address PyLong_Type
    r33 = PyObject_IsInstance(primitive, r32)
    r34 = r33 >= 0 :: signed
    if not r34 goto L54 (error at to_bytes:118) else goto L25 :: bool
L25:
    r35 = truncate r33: i32 to builtins.bool
    if r35 goto L60 else goto L61 :: bool
L26:
    r36 = unbox(int, primitive)
    dec_ref primitive
    if is_error(r36) goto L50 (error at to_bytes:119) else goto L27
L27:
    r37 = box(int, r36)
    r38 = <error> :: union[object, None]
    r39 = <error> :: union[str, None]
    r40 = to_hex(r37, r38, r39)
    dec_ref r37
    if is_error(r40) goto L50 (error at to_bytes:119) else goto L28
L28:
    r41 = <error> :: union[object, None]
    r42 = <error> :: union[str, None]
    r43 = to_bytes(r41, r40, r42)
    dec_ref r40
    if is_error(r43) goto L50 (error at to_bytes:119) else goto L29
L29:
    return r43
L30:
    r44 = load_address _Py_NoneStruct
    r45 = hexstr != r44
    if r45 goto L62 else goto L63 :: bool
L31:
    r46 = CPyObject_Size(hexstr)
    if is_error(r46) goto L64 (error at to_bytes:121) else goto L32
L32:
    r47 = CPyTagged_Remainder(r46, 4)
    dec_ref r46 :: int
    if is_error(r47) goto L64 (error at to_bytes:121) else goto L33
L33:
    r48 = r47 != 0
    dec_ref r47 :: int
    if r48 goto L34 else goto L38 :: bool
L34:
    r49 = '0x0'
    r50 = remove_0x_prefix(hexstr)
    dec_ref hexstr
    if is_error(r50) goto L50 (error at to_bytes:121) else goto L35
L35:
    r51 = PyObject_Str(r50)
    dec_ref r50
    if is_error(r51) goto L50 (error at to_bytes:121) else goto L36
L36:
    r52 = CPyStr_Build(2, r49, r51)
    dec_ref r51
    if is_error(r52) goto L50 (error at to_bytes:121) else goto L37
L37:
    r53 = r52
    goto L39
L38:
    r53 = hexstr
L39:
    r54 = cast(str, r53)
    if is_error(r54) goto L50 (error at to_bytes:121) else goto L40
L40:
    r55 = decode_hex(r54)
    dec_ref r54
    if is_error(r55) goto L50 (error at to_bytes:121) else goto L41
L41:
    return r55
L42:
    r56 = load_address _Py_NoneStruct
    r57 = text != r56
    if r57 goto L43 else goto L65 :: bool
L43:
    r58 = cast(str, text)
    if is_error(r58) goto L50 (error at to_bytes:123) else goto L44
L44:
    r59 = PyUnicode_AsUTF8String(r58)
    dec_ref r58
    if is_error(r59) goto L50 (error at to_bytes:123) else goto L45
L45:
    return r59
L46:
    r60 = 'expected a bool, int, byte or bytearray in first arg, or keyword of hexstr or text'
    r61 = builtins :: module
    r62 = 'TypeError'
    r63 = CPyObject_GetAttr(r61, r62)
    if is_error(r63) goto L50 (error at to_bytes:124) else goto L47
L47:
    r64 = [r60]
    r65 = load_address r64
    r66 = PyObject_Vectorcall(r63, r65, 1, 0)
    dec_ref r63
    if is_error(r66) goto L50 (error at to_bytes:124) else goto L48
L48:
    CPy_Raise(r66)
    dec_ref r66
    if not 0 goto L50 (error at to_bytes:124) else goto L49 :: bool
L49:
    unreachable
L50:
    r67 = <error> :: bytes
    return r67
L51:
    inc_ref primitive
    goto L2
L52:
    inc_ref hexstr
    goto L4
L53:
    inc_ref text
    goto L6
L54:
    dec_ref primitive
    dec_ref hexstr
    dec_ref text
    goto L50
L55:
    dec_ref hexstr
    dec_ref text
    goto L8
L56:
    dec_ref primitive
    dec_ref hexstr
    dec_ref text
    dec_ref r13
    goto L50
L57:
    dec_ref hexstr
    dec_ref text
    goto L17
L58:
    dec_ref primitive
    goto L50
L59:
    dec_ref hexstr
    dec_ref text
    goto L22
L60:
    dec_ref hexstr
    dec_ref text
    goto L26
L61:
    dec_ref primitive
    goto L30
L62:
    dec_ref text
    goto L31
L63:
    dec_ref hexstr
    goto L42
L64:
    dec_ref hexstr
    goto L50
L65:
    dec_ref text
    goto L46

def decode_hex(value):
    value :: str
    r0 :: object
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10, r11 :: object
    r12, r13 :: str
    r14 :: object[2]
    r15 :: object_ptr
    r16, r17 :: object
    r18 :: bool
    r19 :: object[1]
    r20 :: object_ptr
    r21 :: object
    r22, r23 :: bytes
L0:
    r0 = load_address PyUnicode_Type
    r1 = PyObject_IsInstance(value, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L14 (error at decode_hex:130) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L6 else goto L2 :: bool
L2:
    r4 = 'Value must be an instance of str'
    r5 = builtins :: module
    r6 = 'TypeError'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L14 (error at decode_hex:131) else goto L3
L3:
    r8 = [r4]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L14 (error at decode_hex:131) else goto L4
L4:
    CPy_Raise(r10)
    dec_ref r10
    if not 0 goto L14 (error at decode_hex:131) else goto L5 :: bool
L5:
    unreachable
L6:
    r11 = remove_0x_prefix(value)
    if is_error(r11) goto L14 (error at decode_hex:132) else goto L7
L7:
    r12 = 'ascii'
    r13 = 'encode'
    r14 = [r11, r12]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r13, r15, 9223372036854775810, 0)
    if is_error(r16) goto L15 (error at decode_hex:134) else goto L8
L8:
    dec_ref r11
    r17 = dank_mids._eth_utils.unhexlify :: static
    if is_error(r17) goto L16 else goto L11
L9:
    r18 = raise NameError('value for final name "unhexlify" was not set')
    if not r18 goto L14 (error at decode_hex:135) else goto L10 :: bool
L10:
    unreachable
L11:
    r19 = [r16]
    r20 = load_address r19
    r21 = PyObject_Vectorcall(r17, r20, 1, 0)
    if is_error(r21) goto L17 (error at decode_hex:135) else goto L12
L12:
    dec_ref r16
    r22 = cast(bytes, r21)
    if is_error(r22) goto L14 (error at decode_hex:135) else goto L13
L13:
    return r22
L14:
    r23 = <error> :: bytes
    return r23
L15:
    dec_ref r11
    goto L14
L16:
    dec_ref r16
    goto L9
L17:
    dec_ref r16
    goto L14

def encode_hex(value):
    value, r0, r1 :: object
    r2 :: str
    r3 :: object
    r4 :: tuple[object, object]
    r5 :: object
    r6 :: i32
    r7 :: bit
    r8 :: bool
    r9, ascii_bytes :: bytes
    r10 :: object
    r11 :: i32
    r12 :: bit
    r13 :: bool
    r14 :: str
    r15 :: bytes
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[1]
    r21 :: object_ptr
    r22, r23 :: object
    r24 :: bool
    r25 :: object[1]
    r26 :: object_ptr
    r27 :: object
    r28 :: bytes
    r29, r30 :: str
    r31, r32 :: object
L0:
    r0 = load_address PyBytes_Type
    r1 = builtins :: module
    r2 = 'bytearray'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L22 (error at encode_hex:139) else goto L1
L1:
    inc_ref r0
    r4 = (r0, r3)
    r5 = box(tuple[object, object], r4)
    r6 = PyObject_IsInstance(value, r5)
    dec_ref r5
    r7 = r6 >= 0 :: signed
    if not r7 goto L22 (error at encode_hex:139) else goto L2 :: bool
L2:
    r8 = truncate r6: i32 to builtins.bool
    if r8 goto L3 else goto L5 :: bool
L3:
    inc_ref value
    r9 = cast(bytes, value)
    if is_error(r9) goto L22 (error at encode_hex:140) else goto L4
L4:
    ascii_bytes = r9
    goto L14
L5:
    r10 = load_address PyUnicode_Type
    r11 = PyObject_IsInstance(value, r10)
    r12 = r11 >= 0 :: signed
    if not r12 goto L22 (error at encode_hex:141) else goto L6 :: bool
L6:
    r13 = truncate r11: i32 to builtins.bool
    if r13 goto L7 else goto L10 :: bool
L7:
    inc_ref value
    r14 = cast(str, value)
    if is_error(r14) goto L22 (error at encode_hex:142) else goto L8
L8:
    r15 = PyUnicode_AsASCIIString(r14)
    dec_ref r14
    if is_error(r15) goto L22 (error at encode_hex:142) else goto L9
L9:
    ascii_bytes = r15
    goto L14
L10:
    r16 = 'Value must be an instance of str or unicode'
    r17 = builtins :: module
    r18 = 'TypeError'
    r19 = CPyObject_GetAttr(r17, r18)
    if is_error(r19) goto L22 (error at encode_hex:144) else goto L11
L11:
    r20 = [r16]
    r21 = load_address r20
    r22 = PyObject_Vectorcall(r19, r21, 1, 0)
    dec_ref r19
    if is_error(r22) goto L22 (error at encode_hex:144) else goto L12
L12:
    CPy_Raise(r22)
    dec_ref r22
    if not 0 goto L22 (error at encode_hex:144) else goto L13 :: bool
L13:
    unreachable
L14:
    r23 = dank_mids._eth_utils.hexlify :: static
    if is_error(r23) goto L23 else goto L17
L15:
    r24 = raise NameError('value for final name "hexlify" was not set')
    if not r24 goto L22 (error at encode_hex:145) else goto L16 :: bool
L16:
    unreachable
L17:
    r25 = [ascii_bytes]
    r26 = load_address r25
    r27 = PyObject_Vectorcall(r23, r26, 1, 0)
    if is_error(r27) goto L24 (error at encode_hex:145) else goto L18
L18:
    dec_ref ascii_bytes
    r28 = cast(bytes, r27)
    if is_error(r28) goto L22 (error at encode_hex:145) else goto L19
L19:
    r29 = 'ascii'
    r30 = CPy_Decode(r28, r29, 0)
    dec_ref r28
    if is_error(r30) goto L22 (error at encode_hex:145) else goto L20
L20:
    r31 = add_0x_prefix(r30)
    dec_ref r30
    if is_error(r31) goto L22 (error at encode_hex:146) else goto L21
L21:
    return r31
L22:
    r32 = <error> :: object
    return r32
L23:
    dec_ref ascii_bytes
    goto L15
L24:
    dec_ref ascii_bytes
    goto L22

def is_0x_prefixed(value):
    value :: str
    r0 :: object
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4, r5, r6, r7, r8, r9 :: str
    r10 :: object[3]
    r11 :: object_ptr
    r12 :: object
    r13 :: list
    r14, r15, r16 :: ptr
    r17 :: str
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24, r25 :: str
    r26 :: tuple[str, str]
    r27 :: object
    r28, r29 :: bool
L0:
    r0 = load_address PyUnicode_Type
    r1 = PyObject_IsInstance(value, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L12 (error at is_0x_prefixed:150) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L10 else goto L2 :: bool
L2:
    r4 = ''
    r5 = 'is_0x_prefixed requires text typed arguments. Got: '
    r6 = '{:{}}'
    r7 = PyObject_Repr(value)
    if is_error(r7) goto L12 (error at is_0x_prefixed:151) else goto L3
L3:
    r8 = ''
    r9 = 'format'
    r10 = [r6, r7, r8]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775811, 0)
    if is_error(r12) goto L13 (error at is_0x_prefixed:151) else goto L4
L4:
    dec_ref r7
    r13 = PyList_New(2)
    if is_error(r13) goto L14 (error at is_0x_prefixed:151) else goto L5
L5:
    r14 = get_element_ptr r13 ob_item :: PyListObject
    r15 = load_mem r14 :: ptr*
    inc_ref r5
    set_mem r15, r5 :: builtins.object*
    r16 = r15 + 8
    set_mem r16, r12 :: builtins.object*
    r17 = PyUnicode_Join(r4, r13)
    dec_ref r13
    if is_error(r17) goto L12 (error at is_0x_prefixed:151) else goto L6
L6:
    r18 = builtins :: module
    r19 = 'TypeError'
    r20 = CPyObject_GetAttr(r18, r19)
    if is_error(r20) goto L15 (error at is_0x_prefixed:151) else goto L7
L7:
    r21 = [r17]
    r22 = load_address r21
    r23 = PyObject_Vectorcall(r20, r22, 1, 0)
    dec_ref r20
    if is_error(r23) goto L15 (error at is_0x_prefixed:151) else goto L8
L8:
    dec_ref r17
    CPy_Raise(r23)
    dec_ref r23
    if not 0 goto L12 (error at is_0x_prefixed:151) else goto L9 :: bool
L9:
    unreachable
L10:
    r24 = '0x'
    r25 = '0X'
    inc_ref r24
    inc_ref r25
    r26 = (r24, r25)
    r27 = box(tuple[str, str], r26)
    r28 = CPyStr_Startswith(value, r27)
    dec_ref r27
    if is_error(r28) goto L12 (error at is_0x_prefixed:152) else goto L11
L11:
    return r28
L12:
    r29 = <error> :: bool
    return r29
L13:
    dec_ref r7
    goto L12
L14:
    dec_ref r12
    goto L12
L15:
    dec_ref r17
    goto L12

def remove_0x_prefix(value):
    value :: object
    r0 :: str
    r1 :: bool
    r2, r3, r4, r5, r6, r7 :: object
L0:
    inc_ref value
    r0 = cast(str, value)
    if is_error(r0) goto L7 (error at remove_0x_prefix:157) else goto L1
L1:
    r1 = is_0x_prefixed(r0)
    dec_ref r0
    if is_error(r1) goto L7 (error at remove_0x_prefix:157) else goto L2
L2:
    if r1 goto L3 else goto L6 :: bool
L3:
    r2 = load_address _Py_NoneStruct
    r3 = load_address _Py_NoneStruct
    r4 = object 2
    r5 = PySlice_New(r4, r2, r3)
    if is_error(r5) goto L7 (error at remove_0x_prefix:158) else goto L4
L4:
    r6 = PyObject_GetItem(value, r5)
    dec_ref r5
    if is_error(r6) goto L7 (error at remove_0x_prefix:158) else goto L5
L5:
    return r6
L6:
    inc_ref value
    return value
L7:
    r7 = <error> :: object
    return r7

def add_0x_prefix(value):
    value :: object
    r0 :: str
    r1 :: bool
    r2, r3, r4 :: str
    r5 :: object
L0:
    inc_ref value
    r0 = cast(str, value)
    if is_error(r0) goto L7 (error at add_0x_prefix:164) else goto L1
L1:
    r1 = is_0x_prefixed(r0)
    dec_ref r0
    if is_error(r1) goto L7 (error at add_0x_prefix:164) else goto L2
L2:
    if r1 goto L3 else goto L4 :: bool
L3:
    inc_ref value
    return value
L4:
    r2 = '0x'
    r3 = PyObject_Str(value)
    if is_error(r3) goto L7 (error at add_0x_prefix:166) else goto L5
L5:
    r4 = CPyStr_Build(2, r2, r3)
    dec_ref r3
    if is_error(r4) goto L7 (error at add_0x_prefix:166) else goto L6
L6:
    return r4
L7:
    r5 = <error> :: object
    return r5

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: dict
    r34 :: str
    r35 :: i32
    r36 :: bit
    r37 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L11 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address binascii :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [8]
    r9 = load_address r8
    r10 = (('binascii', 'binascii', 'binascii'),)
    r11 = dank_mids._eth_utils.globals :: static
    r12 = 'dank_mids\\_eth_utils.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L11 else goto L4 :: bool
L4:
    r15 = ('Any', 'AnyStr', 'Final', 'Optional')
    r16 = 'typing'
    r17 = dank_mids._eth_utils.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L11 (error at <module>:9) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = ('HexStr',)
    r20 = 'eth_typing'
    r21 = dank_mids._eth_utils.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L11 (error at <module>:11) else goto L6
L6:
    eth_typing = r22 :: module
    dec_ref r22
    r23 = binascii :: module
    r24 = 'hexlify'
    r25 = CPyObject_GetAttr(r23, r24)
    if is_error(r25) goto L11 (error at <module>:14) else goto L7
L7:
    dank_mids._eth_utils.hexlify = r25 :: static
    r26 = dank_mids._eth_utils.globals :: static
    r27 = 'hexlify'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L11 (error at <module>:14) else goto L8 :: bool
L8:
    r30 = binascii :: module
    r31 = 'unhexlify'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L11 (error at <module>:15) else goto L9
L9:
    dank_mids._eth_utils.unhexlify = r32 :: static
    r33 = dank_mids._eth_utils.globals :: static
    r34 = 'unhexlify'
    r35 = CPyDict_SetItem(r33, r34, r32)
    dec_ref r32
    r36 = r35 >= 0 :: signed
    if not r36 goto L11 (error at <module>:15) else goto L10 :: bool
L10:
    return 1
L11:
    r37 = <error> :: None
    return r37

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: object
    r22 :: dict
    r23 :: str
    r24 :: i32
    r25 :: bit
    r26 :: dict
    r27 :: str
    r28 :: object
    r29 :: i32
    r30 :: bit
    r31 :: dict
    r32 :: str
    r33 :: object
    r34 :: i32
    r35 :: bit
    r36 :: dict
    r37 :: str
    r38 :: object
    r39 :: i32
    r40 :: bit
    r41 :: dict
    r42 :: str
    r43 :: object
    r44 :: i32
    r45 :: bit
    r46 :: dict
    r47 :: str
    r48 :: object
    r49 :: i32
    r50 :: bit
    r51 :: dict
    r52 :: str
    r53 :: object
    r54 :: i32
    r55 :: bit
    r56 :: dict
    r57 :: str
    r58 :: object
    r59 :: i32
    r60 :: bit
    r61 :: dict
    r62 :: str
    r63 :: object
    r64 :: i32
    r65 :: bit
    r66 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L16 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address logging :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('logging', 'logging', 'logging'),)
    r11 = dank_mids._logging.globals :: static
    r12 = 'dank_mids\\_logging.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L16 else goto L4 :: bool
L4:
    r15 = ('Final',)
    r16 = 'typing'
    r17 = dank_mids._logging.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L16 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = logging :: module
    r20 = 'getLogger'
    r21 = CPyObject_GetAttr(r19, r20)
    if is_error(r21) goto L16 (error at <module>:5) else goto L6
L6:
    dank_mids._logging.getLogger = r21 :: static
    r22 = dank_mids._logging.globals :: static
    r23 = 'getLogger'
    r24 = CPyDict_SetItem(r22, r23, r21)
    dec_ref r21
    r25 = r24 >= 0 :: signed
    if not r25 goto L16 (error at <module>:5) else goto L7 :: bool
L7:
    dank_mids._logging.CRITICAL = 100 :: static
    r26 = dank_mids._logging.globals :: static
    r27 = 'CRITICAL'
    r28 = object 50
    r29 = CPyDict_SetItem(r26, r27, r28)
    r30 = r29 >= 0 :: signed
    if not r30 goto L16 (error at <module>:6) else goto L8 :: bool
L8:
    dank_mids._logging.FATAL = 100 :: static
    r31 = dank_mids._logging.globals :: static
    r32 = 'FATAL'
    r33 = object 50
    r34 = CPyDict_SetItem(r31, r32, r33)
    r35 = r34 >= 0 :: signed
    if not r35 goto L16 (error at <module>:7) else goto L9 :: bool
L9:
    dank_mids._logging.ERROR = 80 :: static
    r36 = dank_mids._logging.globals :: static
    r37 = 'ERROR'
    r38 = object 40
    r39 = CPyDict_SetItem(r36, r37, r38)
    r40 = r39 >= 0 :: signed
    if not r40 goto L16 (error at <module>:8) else goto L10 :: bool
L10:
    dank_mids._logging.WARN = 60 :: static
    r41 = dank_mids._logging.globals :: static
    r42 = 'WARN'
    r43 = object 30
    r44 = CPyDict_SetItem(r41, r42, r43)
    r45 = r44 >= 0 :: signed
    if not r45 goto L16 (error at <module>:9) else goto L11 :: bool
L11:
    dank_mids._logging.WARNING = 60 :: static
    r46 = dank_mids._logging.globals :: static
    r47 = 'WARNING'
    r48 = object 30
    r49 = CPyDict_SetItem(r46, r47, r48)
    r50 = r49 >= 0 :: signed
    if not r50 goto L16 (error at <module>:10) else goto L12 :: bool
L12:
    dank_mids._logging.INFO = 40 :: static
    r51 = dank_mids._logging.globals :: static
    r52 = 'INFO'
    r53 = object 20
    r54 = CPyDict_SetItem(r51, r52, r53)
    r55 = r54 >= 0 :: signed
    if not r55 goto L16 (error at <module>:11) else goto L13 :: bool
L13:
    dank_mids._logging.DEBUG = 20 :: static
    r56 = dank_mids._logging.globals :: static
    r57 = 'DEBUG'
    r58 = object 10
    r59 = CPyDict_SetItem(r56, r57, r58)
    r60 = r59 >= 0 :: signed
    if not r60 goto L16 (error at <module>:12) else goto L14 :: bool
L14:
    dank_mids._logging.NOTSET = 0 :: static
    r61 = dank_mids._logging.globals :: static
    r62 = 'NOTSET'
    r63 = object 0
    r64 = CPyDict_SetItem(r61, r62, r63)
    r65 = r64 >= 0 :: signed
    if not r65 goto L16 (error at <module>:13) else goto L15 :: bool
L15:
    return 1
L16:
    r66 = <error> :: None
    return r66

def WeakList.__init__(self, data):
    self :: dank_mids.helpers._weaklist.WeakList
    data :: union[object, None]
    r0 :: object
    r1 :: dict
    r2 :: bool
    r3 :: object
    r4 :: bit
    r5, r6 :: None
L0:
    if is_error(data) goto L1 else goto L8
L1:
    r0 = box(None, 1)
    inc_ref r0
    data = r0
L2:
    r1 = PyDict_New()
    if is_error(r1) goto L9 (error at __init__:18) else goto L3
L3:
    self._refs = r1; r2 = is_error
    if not r2 goto L9 (error at __init__:18) else goto L4 :: bool
L4:
    r3 = load_address _Py_NoneStruct
    r4 = data != r3
    if r4 goto L5 else goto L10 :: bool
L5:
    r5 = self.extend(data)
    dec_ref data
    if is_error(r5) goto L7 (error at __init__:20) else goto L6
L6:
    return 1
L7:
    r6 = <error> :: None
    return r6
L8:
    inc_ref data
    goto L2
L9:
    dec_ref data
    goto L7
L10:
    dec_ref data
    goto L6

def WeakList.__repr__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: object
    r1 :: str
    r2 :: object
    r3, r4, r5 :: str
    r6 :: object
    r7 :: str
    r8, r9 :: object
    r10 :: str
    r11 :: object
    r12 :: object[2]
    r13 :: object_ptr
    r14 :: object
    r15, r16, r17, r18 :: str
L0:
    r0 = PyObject_Type(self)
    r1 = '__name__'
    r2 = CPyObject_GetAttr(r0, r1)
    dec_ref r0
    if is_error(r2) goto L8 (error at __repr__:24) else goto L1
L1:
    r3 = cast(str, r2)
    if is_error(r3) goto L8 (error at __repr__:24) else goto L2
L2:
    r4 = '(['
    r5 = ', '
    r6 = builtins :: module
    r7 = 'repr'
    r8 = CPyObject_GetAttr(r6, r7)
    if is_error(r8) goto L9 (error at __repr__:24) else goto L3
L3:
    r9 = builtins :: module
    r10 = 'map'
    r11 = CPyObject_GetAttr(r9, r10)
    if is_error(r11) goto L10 (error at __repr__:24) else goto L4
L4:
    r12 = [r8, self]
    r13 = load_address r12
    r14 = PyObject_Vectorcall(r11, r13, 2, 0)
    dec_ref r11
    if is_error(r14) goto L10 (error at __repr__:24) else goto L5
L5:
    dec_ref r8
    r15 = PyUnicode_Join(r5, r14)
    dec_ref r14
    if is_error(r15) goto L9 (error at __repr__:24) else goto L6
L6:
    r16 = '])'
    r17 = CPyStr_Build(4, r3, r4, r15, r16)
    dec_ref r3
    dec_ref r15
    if is_error(r17) goto L8 (error at __repr__:24) else goto L7
L7:
    return r17
L8:
    r18 = <error> :: str
    return r18
L9:
    dec_ref r3
    goto L8
L10:
    dec_ref r3
    dec_ref r8
    goto L8

def WeakList.__len__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: dict
    r1 :: native_int
    r2 :: short_int
    r3 :: int
L0:
    r0 = self._refs
    if is_error(r0) goto L2 (error at __len__:27) else goto L1
L1:
    r1 = PyDict_Size(r0)
    dec_ref r0
    r2 = r1 << 1
    return r2
L2:
    r3 = <error> :: int
    return r3

def WeakList.__bool__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: object
    r1 :: str
    r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bool
L0:
    r0 = builtins :: module
    r1 = 'any'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L4 (error at __bool__:30) else goto L1
L1:
    r3 = [self]
    r4 = load_address r3
    r5 = PyObject_Vectorcall(r2, r4, 1, 0)
    dec_ref r2
    if is_error(r5) goto L4 (error at __bool__:30) else goto L2
L2:
    r6 = unbox(bool, r5)
    dec_ref r5
    if is_error(r6) goto L4 (error at __bool__:30) else goto L3
L3:
    return r6
L4:
    r7 = <error> :: bool
    return r7

def WeakList.__contains__(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: dict
    r1 :: int
    r2, r3 :: object
    ref :: union[object, None]
    r4 :: object
    r5 :: bit
    r6 :: bool
    r7 :: object
    r8 :: bit
    r9 :: bool
L0:
    r0 = self._refs
    if is_error(r0) goto L7 (error at __contains__:33) else goto L1
L1:
    r1 = CPyTagged_Id(item)
    r2 = box(int, r1)
    r3 = CPyDict_GetWithNone(r0, r2)
    dec_ref r0
    dec_ref r2
    if is_error(r3) goto L7 (error at __contains__:33) else goto L2
L2:
    ref = r3
    r4 = load_address _Py_NoneStruct
    r5 = ref == r4
    if r5 goto L8 else goto L4 :: bool
L3:
    r6 = 0
    goto L6
L4:
    r7 = PyObject_Vectorcall(ref, 0, 0, 0)
    dec_ref ref
    if is_error(r7) goto L7 (error at __contains__:34) else goto L5
L5:
    r8 = r7 == item
    dec_ref r7
    r6 = r8
L6:
    return r6
L7:
    r9 = <error> :: bool
    return r9
L8:
    dec_ref ref
    goto L3

def __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    type, value, traceback, arg :: object
    r0 :: dank_mids.helpers._weaklist.__iter___WeakList_env
    r1 :: int
    r2 :: object
    r3 :: bit
    r4 :: dank_mids.helpers._weaklist.WeakList
    r5 :: dict
    r6, r7 :: bool
    r8 :: dict
    r9 :: native_int
    r10 :: short_int
    r11 :: bool
    r12 :: object
    r13 :: bool
    r14 :: object
    r15 :: short_int
    r16 :: tuple[bool, short_int, object]
    r17 :: short_int
    r18, r19 :: bool
    r20 :: object
    r21 :: bool
    r22, r23 :: object
    r24 :: bool
    r25 :: object[1]
    r26 :: object_ptr
    r27 :: object
    r28 :: bool
    r29 :: union[object, None]
    r30 :: object
    r31 :: bit
    r32 :: union[object, None]
    r33 :: bool
    r34 :: object
    r35 :: bit
    r36 :: dict
    r37 :: short_int
    r38, r39 :: bit
    r40 :: object
    r41 :: bool
    r42, r43 :: bit
    r44 :: bool
    r45 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L43 (error at __iter__:36) else goto L1
L1:
    r1 = r0.__mypyc_next_label__
    if is_error(r1) goto L44 (error at __iter__:36) else goto L39
L2:
    r2 = load_address _Py_NoneStruct
    r3 = type != r2
    if r3 goto L45 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L43 (error at __iter__:36) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = r0.self
    if is_error(r4) goto L44 (error at __iter__:37) else goto L6
L6:
    r5 = r4._refs
    dec_ref r4
    if is_error(r5) goto L44 (error at __iter__:37) else goto L7
L7:
    inc_ref r5
    r0.__mypyc_temp__0 = r5; r6 = is_error
    if not r6 goto L46 (error at __iter__:-1) else goto L8 :: bool
L8:
    r0.__mypyc_temp__1 = 0; r7 = is_error
    if not r7 goto L46 (error at __iter__:-1) else goto L9 :: bool
L9:
    r8 = r0.__mypyc_temp__0
    if is_error(r8) goto L46 (error at __iter__:37) else goto L10
L10:
    r9 = PyDict_Size(r8)
    dec_ref r8
    r10 = r9 << 1
    r0.__mypyc_temp__2 = r10; r11 = is_error
    if not r11 goto L46 (error at __iter__:-1) else goto L11 :: bool
L11:
    r12 = CPyDict_GetValuesIter(r5)
    dec_ref r5
    if is_error(r12) goto L44 (error at __iter__:37) else goto L12
L12:
    r0.__mypyc_temp__3 = r12; r13 = is_error
    if not r13 goto L44 (error at __iter__:-1) else goto L13 :: bool
L13:
    r14 = r0.__mypyc_temp__3
    if is_error(r14) goto L44 (error at __iter__:37) else goto L14
L14:
    r15 = r0.__mypyc_temp__1
    if is_error(r15) goto L47 (error at __iter__:37) else goto L15
L15:
    r16 = CPyDict_NextValue(r14, r15)
    dec_ref r14
    r17 = r16[1]
    r0.__mypyc_temp__1 = r17; r18 = is_error
    if not r18 goto L48 (error at __iter__:37) else goto L16 :: bool
L16:
    r19 = r16[0]
    if r19 goto L17 else goto L49 :: bool
L17:
    r20 = r16[2]
    dec_ref r16
    r0.r = r20; r21 = is_error
    if not r21 goto L44 (error at __iter__:37) else goto L18 :: bool
L18:
    r22 = r0.r
    if is_error(r22) goto L44 (error at __iter__:38) else goto L19
L19:
    r23 = dank_mids.helpers._weaklist._call_ref :: static
    if is_error(r23) goto L50 else goto L22
L20:
    r24 = raise NameError('value for final name "_call_ref" was not set')
    if not r24 goto L43 (error at __iter__:38) else goto L21 :: bool
L21:
    unreachable
L22:
    r25 = [r22]
    r26 = load_address r25
    r27 = PyObject_Vectorcall(r23, r26, 1, 0)
    if is_error(r27) goto L51 (error at __iter__:38) else goto L23
L23:
    dec_ref r22
    r0.obj = r27; r28 = is_error
    if not r28 goto L44 (error at __iter__:38) else goto L24 :: bool
L24:
    r29 = r0.obj
    if is_error(r29) goto L44 (error at __iter__:39) else goto L25
L25:
    r30 = load_address _Py_NoneStruct
    r31 = r29 != r30
    dec_ref r29
    if r31 goto L26 else goto L32 :: bool
L26:
    r32 = r0.obj
    if is_error(r32) goto L44 (error at __iter__:40) else goto L27
L27:
    r0.__mypyc_next_label__ = 2; r33 = is_error
    dec_ref r0
    if not r33 goto L52 (error at __iter__:40) else goto L28 :: bool
L28:
    return r32
L29:
    r34 = load_address _Py_NoneStruct
    r35 = type != r34
    if r35 goto L53 else goto L32 :: bool
L30:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L43 (error at __iter__:40) else goto L31 :: bool
L31:
    unreachable
L32:
    r36 = r0.__mypyc_temp__0
    if is_error(r36) goto L44 (error at __iter__:37) else goto L33
L33:
    r37 = r0.__mypyc_temp__2
    if is_error(r37) goto L54 (error at __iter__:37) else goto L34
L34:
    r38 = CPyDict_CheckSize(r36, r37)
    dec_ref r36
    if not r38 goto L44 (error at __iter__:37) else goto L13 :: bool
L35:
    r39 = CPy_NoErrOccurred()
    if not r39 goto L44 (error at __iter__:37) else goto L36 :: bool
L36:
    r40 = box(None, 1)
    r0.__mypyc_next_label__ = -2; r41 = is_error
    dec_ref r0
    if not r41 goto L43 (error at __iter__:36) else goto L37 :: bool
L37:
    CPyGen_SetStopIterationValue(r40)
    if not 0 goto L43 else goto L38 :: bool
L38:
    unreachable
L39:
    r42 = r1 == 0
    if r42 goto L55 else goto L40 :: bool
L40:
    r43 = r1 == 2
    dec_ref r1 :: int
    if r43 goto L29 else goto L56 :: bool
L41:
    r44 = raise StopIteration
    if not r44 goto L43 (error at __iter__:36) else goto L42 :: bool
L42:
    unreachable
L43:
    r45 = <error> :: object
    return r45
L44:
    dec_ref r0
    goto L43
L45:
    dec_ref r0
    goto L3
L46:
    dec_ref r0
    dec_ref r5
    goto L43
L47:
    dec_ref r0
    dec_ref r14
    goto L43
L48:
    dec_ref r0
    dec_ref r16
    goto L43
L49:
    dec_ref r16
    goto L35
L50:
    dec_ref r0
    dec_ref r22
    goto L20
L51:
    dec_ref r0
    dec_ref r22
    goto L43
L52:
    dec_ref r32
    goto L43
L53:
    dec_ref r0
    goto L30
L54:
    dec_ref r0
    dec_ref r36
    goto L43
L55:
    dec_ref r1 :: int
    goto L2
L56:
    dec_ref r0
    goto L41

def __iter___WeakList_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __iter___WeakList_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __iter___WeakList_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def __iter___WeakList_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def __iter___WeakList_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def WeakList.__iter__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: dank_mids.helpers._weaklist.__iter___WeakList_env
    r1 :: bool
    r2 :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = __iter___WeakList_env()
    if is_error(r0) goto L6 (error at __iter__:36) else goto L1
L1:
    inc_ref self
    r0.self = self; r1 = is_error
    if not r1 goto L7 (error at __iter__:36) else goto L2 :: bool
L2:
    r2 = __iter___WeakList_gen()
    if is_error(r2) goto L7 (error at __iter__:36) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L8 (error at __iter__:36) else goto L4 :: bool
L4:
    r0.__mypyc_next_label__ = 0; r4 = is_error
    dec_ref r0
    if not r4 goto L9 (error at __iter__:36) else goto L5 :: bool
L5:
    return r2
L6:
    r5 = <error> :: object
    return r5
L7:
    dec_ref r0
    goto L6
L8:
    dec_ref r0
    dec_ref r2
    goto L6
L9:
    dec_ref r2
    goto L6

def WeakList.append(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: str
    r1, r2 :: object
    r3 :: bool
    r4 :: object[2]
    r5 :: object_ptr
    r6 :: object
    r7 :: dict
    r8 :: int
    r9 :: object
    r10 :: i32
    r11 :: bit
    r12 :: None
L0:
    r0 = '_gc_callback'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L8 (error at append:44) else goto L1
L1:
    r2 = dank_mids.helpers._weaklist.ref :: static
    if is_error(r2) goto L9 else goto L4
L2:
    r3 = raise NameError('value for final name "ref" was not set')
    if not r3 goto L8 (error at append:44) else goto L3 :: bool
L3:
    unreachable
L4:
    r4 = [item, r1]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r2, r5, 2, 0)
    if is_error(r6) goto L10 (error at append:44) else goto L5
L5:
    dec_ref r1
    r7 = self._refs
    if is_error(r7) goto L11 (error at append:44) else goto L6
L6:
    r8 = CPyTagged_Id(item)
    r9 = box(int, r8)
    r10 = CPyDict_SetItem(r7, r9, r6)
    dec_ref r7
    dec_ref r9
    dec_ref r6
    r11 = r10 >= 0 :: signed
    if not r11 goto L8 (error at append:44) else goto L7 :: bool
L7:
    return 1
L8:
    r12 = <error> :: None
    return r12
L9:
    dec_ref r1
    goto L2
L10:
    dec_ref r1
    goto L8
L11:
    dec_ref r6
    goto L8

def WeakList.extend(self, items):
    self :: dank_mids.helpers._weaklist.WeakList
    items :: object
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: list
    r4, r5 :: object
    r6 :: int
    r7 :: object
    r8 :: bool
    r9 :: object[2]
    r10 :: object_ptr
    r11 :: object
    r12 :: tuple[int, object]
    r13 :: object
    r14 :: i32
    r15, r16 :: bit
    r17 :: i32
    r18 :: bit
    r19 :: None
L0:
    r0 = '_gc_callback'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L13 (error at extend:47) else goto L1
L1:
    r2 = self._refs
    if is_error(r2) goto L14 (error at extend:48) else goto L2
L2:
    r3 = PyList_New(0)
    if is_error(r3) goto L15 (error at extend:48) else goto L3
L3:
    r4 = PyObject_GetIter(items)
    if is_error(r4) goto L16 (error at extend:48) else goto L4
L4:
    r5 = PyIter_Next(r4)
    if is_error(r5) goto L17 else goto L5
L5:
    r6 = CPyTagged_Id(r5)
    r7 = dank_mids.helpers._weaklist.ref :: static
    if is_error(r7) goto L18 else goto L8
L6:
    r8 = raise NameError('value for final name "ref" was not set')
    if not r8 goto L13 (error at extend:48) else goto L7 :: bool
L7:
    unreachable
L8:
    r9 = [r5, r1]
    r10 = load_address r9
    r11 = PyObject_Vectorcall(r7, r10, 2, 0)
    if is_error(r11) goto L19 (error at extend:48) else goto L9
L9:
    dec_ref r5
    r12 = (r6, r11)
    r13 = box(tuple[int, object], r12)
    r14 = PyList_Append(r3, r13)
    dec_ref r13
    r15 = r14 >= 0 :: signed
    if not r15 goto L20 (error at extend:48) else goto L4 :: bool
L10:
    r16 = CPy_NoErrOccurred()
    if not r16 goto L21 (error at extend:48) else goto L11 :: bool
L11:
    r17 = CPyDict_UpdateFromAny(r2, r3)
    dec_ref r2
    dec_ref r3
    r18 = r17 >= 0 :: signed
    if not r18 goto L13 (error at extend:48) else goto L12 :: bool
L12:
    return 1
L13:
    r19 = <error> :: None
    return r19
L14:
    dec_ref r1
    goto L13
L15:
    dec_ref r1
    dec_ref r2
    goto L13
L16:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    goto L13
L17:
    dec_ref r1
    dec_ref r4
    goto L10
L18:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    dec_ref r5
    dec_ref r6 :: int
    goto L6
L19:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    dec_ref r5
    dec_ref r6 :: int
    goto L13
L20:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    goto L13
L21:
    dec_ref r2
    dec_ref r3
    goto L13

def WeakList.remove(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: int
    r1 :: dict
    r2, r3 :: object
    ref :: union[object, None]
    r4 :: object
    r5 :: bit
    r6 :: object
    r7, r8 :: bit
    r9 :: str
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: dict
    r17 :: object
    r18 :: i32
    r19 :: bit
    r20 :: None
L0:
    r0 = CPyTagged_Id(item)
    r1 = self._refs
    if is_error(r1) goto L13 (error at remove:52) else goto L1
L1:
    inc_ref r0 :: int
    r2 = box(int, r0)
    r3 = CPyDict_GetWithNone(r1, r2)
    dec_ref r1
    dec_ref r2
    if is_error(r3) goto L13 (error at remove:52) else goto L2
L2:
    ref = r3
    r4 = load_address _Py_NoneStruct
    r5 = ref == r4
    if r5 goto L14 else goto L3 :: bool
L3:
    r6 = PyObject_Vectorcall(ref, 0, 0, 0)
    dec_ref ref
    if is_error(r6) goto L13 (error at remove:53) else goto L4
L4:
    r7 = r6 == item
    dec_ref r6
    r8 = r7 ^ 1
    if r8 goto L15 else goto L9 :: bool
L5:
    r9 = 'list.remove(x): x not in list'
    r10 = builtins :: module
    r11 = 'ValueError'
    r12 = CPyObject_GetAttr(r10, r11)
    if is_error(r12) goto L12 (error at remove:54) else goto L6
L6:
    r13 = [r9]
    r14 = load_address r13
    r15 = PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L12 (error at remove:54) else goto L7
L7:
    CPy_Raise(r15)
    dec_ref r15
    if not 0 goto L12 (error at remove:54) else goto L8 :: bool
L8:
    unreachable
L9:
    r16 = self._refs
    if is_error(r16) goto L13 (error at remove:55) else goto L10
L10:
    r17 = box(int, r0)
    r18 = PyObject_DelItem(r16, r17)
    dec_ref r16
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L12 (error at remove:55) else goto L11 :: bool
L11:
    return 1
L12:
    r20 = <error> :: None
    return r20
L13:
    dec_ref r0 :: int
    goto L12
L14:
    dec_ref r0 :: int
    dec_ref ref
    goto L5
L15:
    dec_ref r0 :: int
    goto L5

def WeakList._gc_callback(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: dict
    r1 :: int
    r2 :: str
    r3, r4 :: object
    r5 :: object[3]
    r6 :: object_ptr
    r7 :: object
    r8 :: None
L0:
    r0 = self._refs
    if is_error(r0) goto L3 (error at _gc_callback:59) else goto L1
L1:
    r1 = CPyTagged_Id(item)
    r2 = 'pop'
    r3 = box(int, r1)
    r4 = box(None, 1)
    r5 = [r0, r3, r4]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r2, r6, 9223372036854775811, 0)
    if is_error(r7) goto L4 (error at _gc_callback:59) else goto L5
L2:
    dec_ref r0
    dec_ref r3
    return 1
L3:
    r8 = <error> :: None
    return r8
L4:
    dec_ref r0
    dec_ref r3
    goto L3
L5:
    dec_ref r7
    goto L2

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18 :: object
    r19 :: str
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: dict
    r34 :: str
    r35 :: i32
    r36 :: bit
    r37 :: dict
    r38 :: str
    r39 :: object
    r40 :: dict
    r41 :: str
    r42 :: object
    r43 :: list
    r44, r45 :: ptr
    r46 :: object
    r47 :: tuple[list, object]
    r48, r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: object
    r55 :: str
    r56 :: object
    r57 :: dict
    r58 :: str
    r59 :: i32
    r60 :: bit
    r61 :: object
    r62 :: str
    r63 :: object
    r64 :: str
    r65 :: object
    r66 :: dict
    r67 :: str
    r68 :: i32
    r69 :: bit
    r70 :: dict
    r71 :: str
    r72 :: object
    r73 :: dict
    r74 :: str
    r75, r76 :: object
    r77 :: tuple
    r78 :: str
    r79, r80 :: object
    r81 :: bool
    r82, r83, r84 :: str
    r85 :: tuple
    r86 :: i32
    r87 :: bit
    r88 :: dict
    r89 :: str
    r90 :: i32
    r91 :: bit
    r92 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L30 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address weakref :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('weakref', 'weakref', 'weakref'),)
    r11 = dank_mids.helpers._weaklist.globals :: static
    r12 = 'dank_mids\\helpers\\_weaklist.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L30 else goto L4 :: bool
L4:
    r15 = ('Any', 'Callable', 'Dict', 'Final', 'Generic', 'Iterable', 'Iterator', 'Optional', 'TypeVar', 'final')
    r16 = 'typing'
    r17 = dank_mids.helpers._weaklist.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L30 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = '_T'
    r20 = dank_mids.helpers._weaklist.globals :: static
    r21 = 'TypeVar'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L30 (error at <module>:5) else goto L6
L6:
    r23 = [r19]
    r24 = load_address r23
    r25 = PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L30 (error at <module>:5) else goto L7
L7:
    r26 = dank_mids.helpers._weaklist.globals :: static
    r27 = '_T'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L30 (error at <module>:5) else goto L8 :: bool
L8:
    r30 = weakref :: module
    r31 = 'ReferenceType'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L30 (error at <module>:7) else goto L9
L9:
    r33 = dank_mids.helpers._weaklist.globals :: static
    r34 = 'Ref'
    r35 = CPyDict_SetItem(r33, r34, r32)
    dec_ref r32
    r36 = r35 >= 0 :: signed
    if not r36 goto L30 (error at <module>:7) else goto L10 :: bool
L10:
    r37 = dank_mids.helpers._weaklist.globals :: static
    r38 = 'Callable'
    r39 = CPyDict_GetItem(r37, r38)
    if is_error(r39) goto L30 (error at <module>:8) else goto L11
L11:
    r40 = dank_mids.helpers._weaklist.globals :: static
    r41 = 'Any'
    r42 = CPyDict_GetItem(r40, r41)
    if is_error(r42) goto L31 (error at <module>:8) else goto L12
L12:
    r43 = PyList_New(1)
    if is_error(r43) goto L32 (error at <module>:8) else goto L13
L13:
    r44 = get_element_ptr r43 ob_item :: PyListObject
    r45 = load_mem r44 :: ptr*
    set_mem r45, r42 :: builtins.object*
    r46 = box(None, 1)
    inc_ref r46
    r47 = (r43, r46)
    r48 = box(tuple[list, object], r47)
    r49 = PyObject_GetItem(r39, r48)
    dec_ref r39
    dec_ref r48
    if is_error(r49) goto L30 (error at <module>:8) else goto L14
L14:
    r50 = dank_mids.helpers._weaklist.globals :: static
    r51 = 'GCCallback'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L30 (error at <module>:8) else goto L15 :: bool
L15:
    r54 = weakref :: module
    r55 = 'ref'
    r56 = CPyObject_GetAttr(r54, r55)
    if is_error(r56) goto L30 (error at <module>:10) else goto L16
L16:
    dank_mids.helpers._weaklist.ref = r56 :: static
    r57 = dank_mids.helpers._weaklist.globals :: static
    r58 = 'ref'
    r59 = CPyDict_SetItem(r57, r58, r56)
    dec_ref r56
    r60 = r59 >= 0 :: signed
    if not r60 goto L30 (error at <module>:10) else goto L17 :: bool
L17:
    r61 = weakref :: module
    r62 = 'ref'
    r63 = CPyObject_GetAttr(r61, r62)
    if is_error(r63) goto L30 (error at <module>:11) else goto L18
L18:
    r64 = '__call__'
    r65 = CPyObject_GetAttr(r63, r64)
    dec_ref r63
    if is_error(r65) goto L30 (error at <module>:11) else goto L19
L19:
    dank_mids.helpers._weaklist._call_ref = r65 :: static
    r66 = dank_mids.helpers._weaklist.globals :: static
    r67 = '_call_ref'
    r68 = CPyDict_SetItem(r66, r67, r65)
    dec_ref r65
    r69 = r68 >= 0 :: signed
    if not r69 goto L30 (error at <module>:11) else goto L20 :: bool
L20:
    r70 = dank_mids.helpers._weaklist.globals :: static
    r71 = 'Generic'
    r72 = CPyDict_GetItem(r70, r71)
    if is_error(r72) goto L30 (error at <module>:15) else goto L21
L21:
    r73 = dank_mids.helpers._weaklist.globals :: static
    r74 = '_T'
    r75 = CPyDict_GetItem(r73, r74)
    if is_error(r75) goto L33 (error at <module>:15) else goto L22
L22:
    r76 = PyObject_GetItem(r72, r75)
    dec_ref r72
    dec_ref r75
    if is_error(r76) goto L30 (error at <module>:15) else goto L23
L23:
    r77 = PyTuple_Pack(1, r76)
    dec_ref r76
    if is_error(r77) goto L30 (error at <module>:15) else goto L24
L24:
    r78 = 'dank_mids.helpers._weaklist'
    r79 = dank_mids.helpers._weaklist.WeakList_template :: type
    r80 = CPyType_FromTemplate(r79, r77, r78)
    dec_ref r77
    if is_error(r80) goto L30 (error at <module>:15) else goto L25
L25:
    r81 = WeakList_trait_vtable_setup()
    if is_error(r81) goto L34 (error at <module>:-1) else goto L26
L26:
    r82 = '__mypyc_attrs__'
    r83 = '_refs'
    r84 = '__dict__'
    r85 = PyTuple_Pack(2, r83, r84)
    if is_error(r85) goto L34 (error at <module>:15) else goto L27
L27:
    r86 = PyObject_SetAttr(r80, r82, r85)
    dec_ref r85
    r87 = r86 >= 0 :: signed
    if not r87 goto L34 (error at <module>:15) else goto L28 :: bool
L28:
    dank_mids.helpers._weaklist.WeakList = r80 :: type
    r88 = dank_mids.helpers._weaklist.globals :: static
    r89 = 'WeakList'
    r90 = CPyDict_SetItem(r88, r89, r80)
    dec_ref r80
    r91 = r90 >= 0 :: signed
    if not r91 goto L30 (error at <module>:15) else goto L29 :: bool
L29:
    return 1
L30:
    r92 = <error> :: None
    return r92
L31:
    dec_ref r39
    goto L30
L32:
    dec_ref r39
    dec_ref r42
    goto L30
L33:
    dec_ref r72
    goto L30
L34:
    dec_ref r80
    goto L30

def log_check(batch_type, member_type, num_calls):
    batch_type, member_type :: str
    num_calls :: int
    r0 :: str
    r1 :: object
    r2 :: bool
    r3 :: object
    r4 :: object[4]
    r5 :: object_ptr
    r6 :: object
    r7 :: None
L0:
    r0 = 'checking if we should reduce %s batch size... (%s %s)'
    r1 = dank_mids.helpers.batch_size._log_info :: static
    if is_error(r1) goto L1 else goto L3
L1:
    r2 = raise NameError('value for final name "_log_info" was not set')
    if not r2 goto L5 (error at log_check:14) else goto L2 :: bool
L2:
    unreachable
L3:
    inc_ref num_calls :: int
    r3 = box(int, num_calls)
    r4 = [r0, batch_type, r3, member_type]
    r5 = load_address r4
    r6 = PyObject_Vectorcall(r1, r5, 4, 0)
    if is_error(r6) goto L6 (error at log_check:14) else goto L7
L4:
    dec_ref r3
    return 1
L5:
    r7 = <error> :: None
    return r7
L6:
    dec_ref r3
    goto L5
L7:
    dec_ref r6
    goto L4

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13 :: str
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: object[1]
    r18 :: object_ptr
    r19 :: object
    r20 :: dict
    r21 :: str
    r22 :: i32
    r23 :: bit
    r24 :: object
    r25 :: bool
    r26 :: str
    r27 :: object
    r28 :: dict
    r29 :: str
    r30 :: i32
    r31 :: bit
    r32 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L14 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('getLogger',)
    r6 = 'logging'
    r7 = dank_mids.helpers.batch_size.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L14 (error at <module>:1) else goto L4
L4:
    logging = r8 :: module
    dec_ref r8
    r9 = ('Final', 'Literal')
    r10 = 'typing'
    r11 = dank_mids.helpers.batch_size.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L14 (error at <module>:2) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = 'dank_mids.batch_size'
    r14 = dank_mids.helpers.batch_size.globals :: static
    r15 = 'getLogger'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L14 (error at <module>:5) else goto L6
L6:
    r17 = [r13]
    r18 = load_address r17
    r19 = PyObject_Vectorcall(r16, r18, 1, 0)
    dec_ref r16
    if is_error(r19) goto L14 (error at <module>:5) else goto L7
L7:
    dank_mids.helpers.batch_size.batch_size_logger = r19 :: static
    r20 = dank_mids.helpers.batch_size.globals :: static
    r21 = 'batch_size_logger'
    r22 = CPyDict_SetItem(r20, r21, r19)
    dec_ref r19
    r23 = r22 >= 0 :: signed
    if not r23 goto L14 (error at <module>:5) else goto L8 :: bool
L8:
    r24 = dank_mids.helpers.batch_size.batch_size_logger :: static
    if is_error(r24) goto L9 else goto L11
L9:
    r25 = raise NameError('value for final name "batch_size_logger" was not set')
    if not r25 goto L14 (error at <module>:6) else goto L10 :: bool
L10:
    unreachable
L11:
    r26 = 'info'
    r27 = CPyObject_GetAttr(r24, r26)
    if is_error(r27) goto L14 (error at <module>:6) else goto L12
L12:
    dank_mids.helpers.batch_size._log_info = r27 :: static
    r28 = dank_mids.helpers.batch_size.globals :: static
    r29 = '_log_info'
    r30 = CPyDict_SetItem(r28, r29, r27)
    dec_ref r27
    r31 = r30 >= 0 :: signed
    if not r31 goto L14 (error at <module>:6) else goto L13 :: bool
L13:
    return 1
L14:
    r32 = <error> :: None
    return r32

def coroutine__patch_overloaded_method_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def coroutine__patch_overloaded_method_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    type, value, traceback, arg, r0, r1 :: object
    r2 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_env
    r3 :: int
    r4 :: dank_mids.brownie_patch.overloaded._patch_overloaded_method_env
    r5 :: object
    r6 :: bit
    r7 :: object
    r8 :: tuple
    r9 :: str
    r10 :: object[2]
    r11 :: object_ptr
    r12 :: object
    r13 :: bool
    r14 :: tuple[object, object, object]
    r15 :: bool
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: bit
    r20 :: object
    r21 :: bool
    r22 :: object
    r23 :: str
    r24 :: bool
    r25 :: str
    r26 :: object
    r27 :: str
    r28 :: object
    r29, r30, r31 :: str
    r32 :: object
    r33 :: str
    r34 :: object
    r35, r36 :: str
    r37 :: tuple[str, str]
    r38, r39 :: bool
    r40 :: tuple[str, str]
    r41, r42 :: object
    r43, r44 :: bool
    r45, r46 :: object
    r47 :: str
    r48 :: bool
    r49, r50 :: str
    r51 :: i32
    r52 :: bit
    r53, r54 :: bool
    r55 :: bit
    r56, r57 :: str
    r58 :: int
    r59 :: bool
    r60 :: str
    r61 :: int
    r62 :: object
    r63, r64, r65 :: str
    r66 :: int
    r67 :: object
    r68, r69 :: str
    r70 :: object
    r71 :: str
    r72 :: object
    r73 :: object[1]
    r74 :: object_ptr
    r75 :: object
    r76 :: tuple[object, object, object]
    r77 :: bit
    r78 :: str
    r79 :: union[int, str, bytes, None]
    r80 :: str
    r81 :: union[int, None]
    r82 :: str
    r83 :: union[dict, None]
    r84 :: dict
    r85 :: bool
    r86 :: dict
    r87 :: bool
    r88 :: dict
    r89, r90 :: bool
    r91 :: dict
    r92 :: native_int
    r93 :: short_int
    r94 :: bool
    r95 :: object
    r96 :: bool
    r97 :: object
    r98 :: short_int
    r99 :: tuple[bool, short_int, object, object]
    r100 :: short_int
    r101, r102 :: bool
    r103, r104 :: object
    r105 :: str
    r106 :: union[int, str, bytes, None, dict]
    r107, r108 :: bool
    r109 :: union[int, str, bytes, None, dict]
    r110 :: object
    r111 :: bit
    r112 :: str
    r113 :: union[int, str, bytes, None, dict]
    r114 :: union[int, str, bytes, dict]
    r115 :: dict
    r116 :: i32
    r117 :: bit
    r118 :: dict
    r119 :: short_int
    r120, r121 :: bit
    r122 :: dict
    r123 :: bool
    r124 :: object
    r125 :: tuple
    r126 :: dict
    r127 :: str
    r128 :: object
    r129 :: list
    r130 :: object
    r131 :: dict
    r132 :: i32
    r133 :: bit
    r134 :: tuple
    r135, r136 :: object
    r137 :: bool
    r138, r139, r140, r141, r142 :: object
    r143 :: bool
    r144 :: object
    r145 :: bit
    r146 :: tuple[object, object, object]
    r147 :: bool
    r148 :: object_ptr
    r149 :: object
    r150 :: bool
    r151, r152, r153 :: tuple[object, object, object]
    r154 :: bit
    r155, r156, r157 :: object
    r158 :: bool
    r159, r160 :: bit
    r161 :: bool
    r162 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_env__
    if is_error(r2) goto L146 (error at coroutine:23) else goto L1
L1:
    r3 = r2.__mypyc_next_label__
    if is_error(r3) goto L147 (error at coroutine:23) else goto L2
L2:
    r4 = r2.__mypyc_env__
    if is_error(r4) goto L148 (error at coroutine:23) else goto L141
L3:
    r5 = load_address _Py_NoneStruct
    r6 = type != r5
    if r6 goto L149 else goto L6 :: bool
L4:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L145 (error at coroutine:23) else goto L5 :: bool
L5:
    unreachable
L6:
    r7 = r2.self
    if is_error(r7) goto L150 (error at coroutine:44) else goto L7
L7:
    r8 = r2.args
    if is_error(r8) goto L151 (error at coroutine:44) else goto L8
L8:
    r9 = '_get_fn_from_args'
    r10 = [r7, r8]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775810, 0)
    if is_error(r12) goto L152 (error at coroutine:44) else goto L9
L9:
    dec_ref r7
    dec_ref r8
    r2.fn = r12; r13 = is_error
    if not r13 goto L150 (error at coroutine:44) else goto L153 :: bool
L10:
    r14 = CPy_CatchError()
    r2.__mypyc_temp__0 = r14; r15 = is_error
    if not r15 goto L154 (error at coroutine:-1) else goto L11 :: bool
L11:
    r16 = builtins :: module
    r17 = 'ValueError'
    r18 = CPyObject_GetAttr(r16, r17)
    if is_error(r18) goto L154 (error at coroutine:45) else goto L12
L12:
    r19 = CPy_ExceptionMatches(r18)
    dec_ref r18
    if r19 goto L13 else goto L155 :: bool
L13:
    r20 = CPy_GetExcValue()
    r2.e = r20; r21 = is_error
    if not r21 goto L154 (error at coroutine:45) else goto L14 :: bool
L14:
    r22 = r2.e
    if is_error(r22) goto L154 (error at coroutine:46) else goto L15
L15:
    r23 = PyObject_Str(r22)
    dec_ref r22
    if is_error(r23) goto L154 (error at coroutine:46) else goto L16
L16:
    r2.exc_str = r23; r24 = is_error
    if not r24 goto L154 (error at coroutine:46) else goto L17 :: bool
L17:
    r25 = "Contract has more than one function '."
    r26 = r4.call
    if is_error(r26) goto L154 (error at coroutine:48) else goto L18
L18:
    r27 = '_name'
    r28 = CPyObject_GetAttr(r26, r27)
    dec_ref r26
    if is_error(r28) goto L154 (error at coroutine:48) else goto L19
L19:
    r29 = PyObject_Str(r28)
    dec_ref r28
    if is_error(r29) goto L154 (error at coroutine:48) else goto L20
L20:
    r30 = CPyStr_Build(2, r25, r29)
    dec_ref r29
    if is_error(r30) goto L154 (error at coroutine:48) else goto L21
L21:
    r31 = 'You must explicitly declare which function you are calling, e.g. .'
    r32 = r4.call
    dec_ref r4
    if is_error(r32) goto L156 (error at coroutine:49) else goto L22
L22:
    r33 = '_name'
    r34 = CPyObject_GetAttr(r32, r33)
    dec_ref r32
    if is_error(r34) goto L156 (error at coroutine:49) else goto L23
L23:
    r35 = PyObject_Str(r34)
    dec_ref r34
    if is_error(r35) goto L156 (error at coroutine:49) else goto L24
L24:
    r36 = CPyStr_Build(2, r31, r35)
    dec_ref r35
    if is_error(r36) goto L156 (error at coroutine:49) else goto L25
L25:
    r37 = (r30, r36)
    r2.match_on = r37; r38 = is_error
    if not r38 goto L61 (error at coroutine:47) else goto L26 :: bool
L26:
    r39 = 1
    r40 = r2.match_on
    if is_error(r40) goto L61 (error at coroutine:51) else goto L27
L27:
    inc_ref r40
    r41 = box(tuple[str, str], r40)
    r42 = PyObject_GetIter(r41)
    dec_ref r41
    if is_error(r42) goto L157 (error at coroutine:51) else goto L28
L28:
    r2.__mypyc_temp__1 = r40; r43 = is_error
    if not r43 goto L158 (error at coroutine:-1) else goto L29 :: bool
L29:
    r2.__mypyc_temp__2 = r42; r44 = is_error
    if not r44 goto L61 (error at coroutine:-1) else goto L30 :: bool
L30:
    r45 = r2.__mypyc_temp__2
    if is_error(r45) goto L61 (error at coroutine:51) else goto L31
L31:
    r46 = PyIter_Next(r45)
    dec_ref r45
    if is_error(r46) goto L39 else goto L32
L32:
    r47 = cast(str, r46)
    if is_error(r47) goto L61 (error at coroutine:51) else goto L33
L33:
    r2.s = r47; r48 = is_error
    if not r48 goto L61 (error at coroutine:51) else goto L34 :: bool
L34:
    r49 = r2.s
    if is_error(r49) goto L61 (error at coroutine:51) else goto L35
L35:
    r50 = r2.exc_str
    if is_error(r50) goto L159 (error at coroutine:51) else goto L36
L36:
    r51 = PyUnicode_Contains(r50, r49)
    dec_ref r50
    dec_ref r49
    r52 = r51 >= 0 :: signed
    if not r52 goto L61 (error at coroutine:51) else goto L37 :: bool
L37:
    r53 = truncate r51: i32 to builtins.bool
    r54 = r53 ^ 1
    if r54 goto L38 else goto L30 :: bool
L38:
    r39 = 0
    goto L40
L39:
    r55 = CPy_NoErrOccurred()
    if not r55 goto L61 (error at coroutine:51) else goto L40 :: bool
L40:
    if r39 goto L41 else goto L57 :: bool
L41:
    r56 = r2.exc_str
    if is_error(r56) goto L61 (error at coroutine:52) else goto L42
L42:
    r57 = '(*args)'
    r58 = CPyStr_Find(r56, r57, 0, 1)
    dec_ref r56
    if is_error(r58) goto L61 (error at coroutine:52) else goto L43
L43:
    r2.breakpoint = r58; r59 = is_error
    if not r59 goto L61 (error at coroutine:52) else goto L44 :: bool
L44:
    r60 = r2.exc_str
    if is_error(r60) goto L61 (error at coroutine:53) else goto L45
L45:
    r61 = r2.breakpoint
    if is_error(r61) goto L160 (error at coroutine:53) else goto L46
L46:
    r62 = CPyStr_GetSlice(r60, 0, r61)
    dec_ref r60
    dec_ref r61 :: int
    if is_error(r62) goto L61 (error at coroutine:53) else goto L47
L47:
    r63 = cast(str, r62)
    if is_error(r63) goto L61 (error at coroutine:53) else goto L48
L48:
    r64 = '.coroutine'
    r65 = r2.exc_str
    if is_error(r65) goto L161 (error at coroutine:53) else goto L49
L49:
    r66 = r2.breakpoint
    if is_error(r66) goto L162 (error at coroutine:53) else goto L50
L50:
    r67 = CPyStr_GetSlice(r65, r66, 9223372036854775806)
    dec_ref r65
    dec_ref r66 :: int
    if is_error(r67) goto L161 (error at coroutine:53) else goto L51
L51:
    r68 = cast(str, r67)
    if is_error(r68) goto L161 (error at coroutine:53) else goto L52
L52:
    r69 = CPyStr_Build(3, r63, r64, r68)
    dec_ref r63
    dec_ref r68
    if is_error(r69) goto L61 (error at coroutine:53) else goto L53
L53:
    r70 = builtins :: module
    r71 = 'ValueError'
    r72 = CPyObject_GetAttr(r70, r71)
    if is_error(r72) goto L163 (error at coroutine:53) else goto L54
L54:
    r73 = [r69]
    r74 = load_address r73
    r75 = PyObject_Vectorcall(r72, r74, 1, 0)
    dec_ref r72
    if is_error(r75) goto L163 (error at coroutine:53) else goto L55
L55:
    dec_ref r69
    CPy_Raise(r75)
    dec_ref r75
    if not 0 goto L61 (error at coroutine:53) else goto L164 :: bool
L56:
    unreachable
L57:
    CPy_Reraise()
    if not 0 goto L61 else goto L165 :: bool
L58:
    unreachable
L59:
    CPy_Reraise()
    if not 0 goto L61 else goto L166 :: bool
L60:
    unreachable
L61:
    r76 = r2.__mypyc_temp__0
    dec_ref r2
    if is_error(r76) goto L145 (error at coroutine:-1) else goto L62
L62:
    CPy_RestoreExcInfo(r76)
    dec_ref r76
    r77 = CPy_KeepPropagating()
    if not r77 goto L145 else goto L63 :: bool
L63:
    unreachable
L64:
    r78 = 'block_identifier'
    r79 = r2.block_identifier
    if is_error(r79) goto L147 (error at coroutine:56) else goto L65
L65:
    r80 = 'decimals'
    r81 = r2.decimals
    if is_error(r81) goto L167 (error at coroutine:56) else goto L66
L66:
    r82 = 'override'
    r83 = r2.override
    if is_error(r83) goto L168 (error at coroutine:56) else goto L67
L67:
    r84 = CPyDict_Build(3, r78, r79, r80, r81, r82, r83)
    dec_ref r79
    dec_ref r81
    dec_ref r83
    if is_error(r84) goto L147 (error at coroutine:56) else goto L68
L68:
    r2.kwargs = r84; r85 = is_error
    if not r85 goto L147 (error at coroutine:56) else goto L69 :: bool
L69:
    r86 = PyDict_New()
    if is_error(r86) goto L147 (error at coroutine:57) else goto L70
L70:
    r2.__mypyc_temp__3 = r86; r87 = is_error
    if not r87 goto L147 (error at coroutine:-1) else goto L71 :: bool
L71:
    r88 = r2.kwargs
    if is_error(r88) goto L147 (error at coroutine:57) else goto L72
L72:
    inc_ref r88
    r2.__mypyc_temp__4 = r88; r89 = is_error
    if not r89 goto L169 (error at coroutine:-1) else goto L73 :: bool
L73:
    r2.__mypyc_temp__5 = 0; r90 = is_error
    if not r90 goto L169 (error at coroutine:-1) else goto L74 :: bool
L74:
    r91 = r2.__mypyc_temp__4
    if is_error(r91) goto L169 (error at coroutine:57) else goto L75
L75:
    r92 = PyDict_Size(r91)
    dec_ref r91
    r93 = r92 << 1
    r2.__mypyc_temp__6 = r93; r94 = is_error
    if not r94 goto L169 (error at coroutine:-1) else goto L76 :: bool
L76:
    r95 = CPyDict_GetItemsIter(r88)
    dec_ref r88
    if is_error(r95) goto L147 (error at coroutine:57) else goto L77
L77:
    r2.__mypyc_temp__7 = r95; r96 = is_error
    if not r96 goto L147 (error at coroutine:-1) else goto L78 :: bool
L78:
    r97 = r2.__mypyc_temp__7
    if is_error(r97) goto L147 (error at coroutine:57) else goto L79
L79:
    r98 = r2.__mypyc_temp__5
    if is_error(r98) goto L170 (error at coroutine:57) else goto L80
L80:
    r99 = CPyDict_NextItem(r97, r98)
    dec_ref r97
    r100 = r99[1]
    r2.__mypyc_temp__5 = r100; r101 = is_error
    if not r101 goto L171 (error at coroutine:57) else goto L81 :: bool
L81:
    r102 = r99[0]
    if r102 goto L82 else goto L172 :: bool
L82:
    r103 = r99[2]
    r104 = r99[3]
    dec_ref r99
    r105 = cast(str, r103)
    if is_error(r105) goto L173 (error at coroutine:57) else goto L83
L83:
    r106 = cast(union[int, str, bytes, None, dict], r104)
    if is_error(r106) goto L174 (error at coroutine:57) else goto L84
L84:
    r2.k = r105; r107 = is_error
    if not r107 goto L175 (error at coroutine:57) else goto L85 :: bool
L85:
    r2.v = r106; r108 = is_error
    if not r108 goto L147 (error at coroutine:57) else goto L86 :: bool
L86:
    r109 = r2.v
    if is_error(r109) goto L147 (error at coroutine:57) else goto L87
L87:
    r110 = load_address _Py_NoneStruct
    r111 = r109 != r110
    dec_ref r109
    if r111 goto L88 else goto L93 :: bool
L88:
    r112 = r2.k
    if is_error(r112) goto L147 (error at coroutine:57) else goto L89
L89:
    r113 = r2.v
    if is_error(r113) goto L176 (error at coroutine:57) else goto L90
L90:
    r114 = cast(union[int, str, bytes, dict], r113)
    if is_error(r114) goto L176 (error at coroutine:57) else goto L91
L91:
    r115 = r2.__mypyc_temp__3
    if is_error(r115) goto L177 (error at coroutine:-1) else goto L92
L92:
    r116 = CPyDict_SetItem(r115, r112, r114)
    dec_ref r115
    dec_ref r112
    dec_ref r114
    r117 = r116 >= 0 :: signed
    if not r117 goto L147 (error at coroutine:57) else goto L93 :: bool
L93:
    r118 = r2.__mypyc_temp__4
    if is_error(r118) goto L147 (error at coroutine:57) else goto L94
L94:
    r119 = r2.__mypyc_temp__6
    if is_error(r119) goto L178 (error at coroutine:57) else goto L95
L95:
    r120 = CPyDict_CheckSize(r118, r119)
    dec_ref r118
    if not r120 goto L147 (error at coroutine:57) else goto L78 :: bool
L96:
    r121 = CPy_NoErrOccurred()
    if not r121 goto L147 (error at coroutine:57) else goto L97 :: bool
L97:
    r122 = r2.__mypyc_temp__3
    if is_error(r122) goto L147 (error at coroutine:-1) else goto L98
L98:
    r2.kwargs = r122; r123 = is_error
    if not r123 goto L147 (error at coroutine:57) else goto L99 :: bool
L99:
    r124 = r2.fn
    if is_error(r124) goto L147 (error at coroutine:58) else goto L100
L100:
    r125 = r2.args
    if is_error(r125) goto L179 (error at coroutine:58) else goto L101
L101:
    r126 = r2.kwargs
    if is_error(r126) goto L180 (error at coroutine:58) else goto L102
L102:
    r127 = 'coroutine'
    r128 = CPyObject_GetAttr(r124, r127)
    dec_ref r124
    if is_error(r128) goto L181 (error at coroutine:58) else goto L103
L103:
    r129 = PyList_New(0)
    if is_error(r129) goto L182 (error at coroutine:58) else goto L104
L104:
    r130 = CPyList_Extend(r129, r125)
    dec_ref r125
    if is_error(r130) goto L183 (error at coroutine:58) else goto L184
L105:
    r131 = PyDict_New()
    if is_error(r131) goto L183 (error at coroutine:58) else goto L106
L106:
    r132 = CPyDict_UpdateInDisplay(r131, r126)
    dec_ref r126
    r133 = r132 >= 0 :: signed
    if not r133 goto L185 (error at coroutine:58) else goto L107 :: bool
L107:
    r134 = PyList_AsTuple(r129)
    dec_ref r129
    if is_error(r134) goto L186 (error at coroutine:58) else goto L108
L108:
    r135 = PyObject_Call(r128, r134, r131)
    dec_ref r128
    dec_ref r134
    dec_ref r131
    if is_error(r135) goto L147 (error at coroutine:58) else goto L109
L109:
    r136 = CPy_GetCoro(r135)
    dec_ref r135
    if is_error(r136) goto L147 (error at coroutine:58) else goto L110
L110:
    r2.__mypyc_temp__8 = r136; r137 = is_error
    if not r137 goto L147 (error at coroutine:-1) else goto L111 :: bool
L111:
    r138 = r2.__mypyc_temp__8
    if is_error(r138) goto L147 (error at coroutine:-1) else goto L112
L112:
    r139 = CPyIter_Next(r138)
    dec_ref r138
    if is_error(r139) goto L187 else goto L115
L113:
    r140 = CPy_FetchStopIterationValue()
    if is_error(r140) goto L188 (error at coroutine:58) else goto L114
L114:
    r141 = r140
    goto L138
L115:
    r142 = r139
L116:
    r2.__mypyc_next_label__ = 2; r143 = is_error
    if not r143 goto L189 (error at coroutine:58) else goto L190 :: bool
L117:
    return r142
L118:
    r144 = load_address _Py_NoneStruct
    r145 = type != r144
    if r145 goto L119 else goto L121 :: bool
L119:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L122 (error at coroutine:58) else goto L191 :: bool
L120:
    unreachable
L121:
    inc_ref arg
    goto L133
L122:
    r146 = CPy_CatchError()
    r2.__mypyc_temp__9 = r146; r147 = is_error
    if not r147 goto L192 (error at coroutine:-1) else goto L123 :: bool
L123:
    r148 = load_address r1
    r149 = r2.__mypyc_temp__8
    if is_error(r149) goto L192 (error at coroutine:-1) else goto L124
L124:
    r150 = CPy_YieldFromErrorHandle(r149, r148)
    dec_ref r149
    if is_error(r150) goto L192 (error at coroutine:58) else goto L125
L125:
    if r150 goto L128 else goto L126 :: bool
L126:
    inc_ref r1
    r142 = r1
    r151 = r2.__mypyc_temp__9
    if is_error(r151) goto L193 (error at coroutine:-1) else goto L127
L127:
    CPy_RestoreExcInfo(r151)
    dec_ref r151
    goto L116
L128:
    r141 = r1
    r152 = r2.__mypyc_temp__9
    if is_error(r152) goto L194 (error at coroutine:-1) else goto L129
L129:
    CPy_RestoreExcInfo(r152)
    dec_ref r152
    goto L138
L130:
    r153 = r2.__mypyc_temp__9
    dec_ref r2
    if is_error(r153) goto L145 (error at coroutine:-1) else goto L131
L131:
    CPy_RestoreExcInfo(r153)
    dec_ref r153
    r154 = CPy_KeepPropagating()
    if not r154 goto L145 else goto L132 :: bool
L132:
    unreachable
L133:
    r155 = r2.__mypyc_temp__8
    if is_error(r155) goto L195 (error at coroutine:-1) else goto L134
L134:
    r156 = CPyIter_Send(r155, arg)
    dec_ref r155
    dec_ref arg
    if is_error(r156) goto L196 else goto L135
L135:
    r142 = r156
    goto L116
L136:
    r157 = CPy_FetchStopIterationValue()
    if is_error(r157) goto L188 (error at coroutine:58) else goto L137
L137:
    r141 = r157
L138:
    r2.__mypyc_next_label__ = -2; r158 = is_error
    dec_ref r2
    if not r158 goto L197 (error at coroutine:58) else goto L139 :: bool
L139:
    CPyGen_SetStopIterationValue(r141)
    dec_ref r141
    if not 0 goto L145 else goto L140 :: bool
L140:
    unreachable
L141:
    r159 = r3 == 0
    if r159 goto L198 else goto L199 :: bool
L142:
    r160 = r3 == 2
    dec_ref r3 :: int
    if r160 goto L118 else goto L200 :: bool
L143:
    r161 = raise StopIteration
    if not r161 goto L145 (error at coroutine:23) else goto L144 :: bool
L144:
    unreachable
L145:
    r162 = <error> :: object
    return r162
L146:
    xdec_ref r1
    goto L145
L147:
    xdec_ref r1
    dec_ref r2
    goto L145
L148:
    xdec_ref r1
    dec_ref r2
    dec_ref r3 :: int
    goto L145
L149:
    xdec_ref r1
    dec_ref r2
    dec_ref r4
    goto L4
L150:
    xdec_ref r1
    goto L10
L151:
    xdec_ref r1
    dec_ref r7
    goto L10
L152:
    xdec_ref r1
    dec_ref r7
    dec_ref r8
    goto L10
L153:
    dec_ref r4
    goto L64
L154:
    dec_ref r4
    goto L61
L155:
    dec_ref r4
    goto L59
L156:
    dec_ref r30
    goto L61
L157:
    dec_ref r40
    goto L61
L158:
    dec_ref r42
    goto L61
L159:
    dec_ref r49
    goto L61
L160:
    dec_ref r60
    goto L61
L161:
    dec_ref r63
    goto L61
L162:
    dec_ref r63
    dec_ref r65
    goto L61
L163:
    dec_ref r69
    goto L61
L164:
    dec_ref r2
    goto L56
L165:
    dec_ref r2
    goto L58
L166:
    dec_ref r2
    goto L60
L167:
    xdec_ref r1
    dec_ref r2
    dec_ref r79
    goto L145
L168:
    xdec_ref r1
    dec_ref r2
    dec_ref r79
    dec_ref r81
    goto L145
L169:
    xdec_ref r1
    dec_ref r2
    dec_ref r88
    goto L145
L170:
    xdec_ref r1
    dec_ref r2
    dec_ref r97
    goto L145
L171:
    xdec_ref r1
    dec_ref r2
    dec_ref r99
    goto L145
L172:
    dec_ref r99
    goto L96
L173:
    xdec_ref r1
    dec_ref r2
    dec_ref r104
    goto L145
L174:
    xdec_ref r1
    dec_ref r2
    dec_ref r105
    goto L145
L175:
    xdec_ref r1
    dec_ref r2
    dec_ref r106
    goto L145
L176:
    xdec_ref r1
    dec_ref r2
    dec_ref r112
    goto L145
L177:
    xdec_ref r1
    dec_ref r2
    dec_ref r112
    dec_ref r114
    goto L145
L178:
    xdec_ref r1
    dec_ref r2
    dec_ref r118
    goto L145
L179:
    xdec_ref r1
    dec_ref r2
    dec_ref r124
    goto L145
L180:
    xdec_ref r1
    dec_ref r2
    dec_ref r124
    dec_ref r125
    goto L145
L181:
    xdec_ref r1
    dec_ref r2
    dec_ref r125
    dec_ref r126
    goto L145
L182:
    xdec_ref r1
    dec_ref r2
    dec_ref r125
    dec_ref r126
    dec_ref r128
    goto L145
L183:
    xdec_ref r1
    dec_ref r2
    dec_ref r126
    dec_ref r128
    dec_ref r129
    goto L145
L184:
    dec_ref r130
    goto L105
L185:
    xdec_ref r1
    dec_ref r2
    dec_ref r128
    dec_ref r129
    dec_ref r131
    goto L145
L186:
    xdec_ref r1
    dec_ref r2
    dec_ref r128
    dec_ref r131
    goto L145
L187:
    xdec_ref r1
    goto L113
L188:
    dec_ref r2
    goto L145
L189:
    dec_ref r142
    goto L122
L190:
    xdec_ref r1
    dec_ref r2
    goto L117
L191:
    xdec_ref r1
    dec_ref r2
    goto L120
L192:
    xdec_ref r1
    goto L130
L193:
    xdec_ref r1
    dec_ref r142
    goto L130
L194:
    dec_ref r141
    goto L130
L195:
    xdec_ref r1
    dec_ref r2
    dec_ref arg
    goto L145
L196:
    xdec_ref r1
    goto L136
L197:
    dec_ref r141
    goto L145
L198:
    dec_ref r3 :: int
    goto L3
L199:
    dec_ref r4
    goto L142
L200:
    xdec_ref r1
    dec_ref r2
    goto L143

def coroutine__patch_overloaded_method_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine__patch_overloaded_method_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine__patch_overloaded_method_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine__patch_overloaded_method_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine__patch_overloaded_method_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine__patch_overloaded_method_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutine__patch_overloaded_method_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutine__patch_overloaded_method_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def coroutine__patch_overloaded_method_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine__patch_overloaded_method_obj.__call__(__mypyc_self__, self, args, block_identifier, decimals, override):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_obj
    self :: object
    args :: tuple
    block_identifier :: union[int, str, bytes, None]
    decimals :: union[int, None]
    override :: union[dict, None]
    r0 :: dank_mids.brownie_patch.overloaded._patch_overloaded_method_env
    r1, r2, r3 :: object
    r4 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_env
    r5, r6, r7, r8, r9, r10 :: bool
    r11 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    r12, r13 :: bool
    r14 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L18 (error at coroutine:23) else goto L1
L1:
    if is_error(block_identifier) goto L2 else goto L19
L2:
    r1 = box(None, 1)
    inc_ref r1
    block_identifier = r1
L3:
    if is_error(decimals) goto L4 else goto L20
L4:
    r2 = box(None, 1)
    inc_ref r2
    decimals = r2
L5:
    if is_error(override) goto L6 else goto L21
L6:
    r3 = box(None, 1)
    inc_ref r3
    override = r3
L7:
    r4 = coroutine__patch_overloaded_method_env()
    if is_error(r4) goto L22 (error at coroutine:23) else goto L8
L8:
    r4.__mypyc_env__ = r0; r5 = is_error
    if not r5 goto L23 (error at coroutine:23) else goto L9 :: bool
L9:
    inc_ref self
    r4.self = self; r6 = is_error
    if not r6 goto L23 (error at coroutine:23) else goto L10 :: bool
L10:
    inc_ref args
    r4.args = args; r7 = is_error
    if not r7 goto L23 (error at coroutine:23) else goto L11 :: bool
L11:
    r4.block_identifier = block_identifier; r8 = is_error
    if not r8 goto L24 (error at coroutine:23) else goto L12 :: bool
L12:
    r4.decimals = decimals; r9 = is_error
    if not r9 goto L25 (error at coroutine:23) else goto L13 :: bool
L13:
    r4.override = override; r10 = is_error
    if not r10 goto L26 (error at coroutine:23) else goto L14 :: bool
L14:
    r11 = coroutine__patch_overloaded_method_gen()
    if is_error(r11) goto L26 (error at coroutine:23) else goto L15
L15:
    inc_ref r4
    r11.__mypyc_env__ = r4; r12 = is_error
    if not r12 goto L27 (error at coroutine:23) else goto L16 :: bool
L16:
    r4.__mypyc_next_label__ = 0; r13 = is_error
    dec_ref r4
    if not r13 goto L28 (error at coroutine:23) else goto L17 :: bool
L17:
    return r11
L18:
    r14 = <error> :: object
    return r14
L19:
    inc_ref block_identifier
    goto L3
L20:
    inc_ref decimals
    goto L5
L21:
    inc_ref override
    goto L7
L22:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r0
    goto L18
L23:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L18
L24:
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L18
L25:
    dec_ref override
    dec_ref r4
    goto L18
L26:
    dec_ref r4
    goto L18
L27:
    dec_ref r4
    dec_ref r11
    goto L18
L28:
    dec_ref r11
    goto L18

def _patch_overloaded_method(call, w3):
    call, w3 :: object
    r0 :: dank_mids.brownie_patch.overloaded._patch_overloaded_method_env
    r1 :: bool
    r2 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_obj
    r3 :: bool
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: i32
    r17 :: bit
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: str
    r24 :: object[1]
    r25 :: object_ptr
    r26, r27, r28 :: object
    r29 :: dict
    r30 :: str
    r31 :: object
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: tuple[object, object]
    r36 :: object
    r37 :: i32
    r38 :: bit
    r39 :: bool
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: object
    r45 :: set
    r46 :: i32
    r47 :: bit
    r48 :: bool
    r49 :: str
    r50 :: object
    r51 :: i32
    r52 :: bit
    r53 :: str
    r54 :: object
    r55 :: str
    r56 :: object
    r57 :: int
    r58 :: dict
    r59 :: str
    r60, r61 :: object
    r62 :: object[2]
    r63 :: object_ptr
    r64 :: object
    r65 :: dict
    r66 :: str
    r67 :: object
    r68 :: object[2]
    r69 :: object_ptr
    r70 :: object
    r71 :: str
    r72 :: i32
    r73, r74 :: bit
    r75 :: object
    r76 :: dict
    r77 :: str
    r78 :: object
    r79 :: object[2]
    r80 :: object_ptr
    r81, r82 :: object
    r83 :: str
    r84 :: i32
    r85 :: bit
    r86 :: None
L0:
    r0 = _patch_overloaded_method_env()
    if is_error(r0) goto L39 (error at _patch_overloaded_method:11) else goto L1
L1:
    inc_ref call
    r0.call = call; r1 = is_error
    if not r1 goto L40 (error at _patch_overloaded_method:11) else goto L2 :: bool
L2:
    r2 = coroutine__patch_overloaded_method_obj()
    if is_error(r2) goto L40 (error at _patch_overloaded_method:23) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L41 (error at _patch_overloaded_method:23) else goto L4 :: bool
L4:
    r4 = r0.call
    if is_error(r4) goto L41 (error at _patch_overloaded_method:22) else goto L5
L5:
    r5 = dank_mids.brownie_patch.overloaded.globals :: static
    r6 = 'wraps'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L42 (error at _patch_overloaded_method:22) else goto L6
L6:
    r8 = [r4]
    r9 = load_address r8
    r10 = PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L42 (error at _patch_overloaded_method:22) else goto L7
L7:
    dec_ref r4
    r11 = [r2]
    r12 = load_address r11
    r13 = PyObject_Vectorcall(r10, r12, 1, 0)
    dec_ref r10
    if is_error(r13) goto L41 (error at _patch_overloaded_method:23) else goto L8
L8:
    dec_ref r2
    inc_ref r13
    r14 = dank_mids.brownie_patch.overloaded.globals :: static
    r15 = 'coroutine'
    r16 = CPyDict_SetItem(r14, r15, r13)
    dec_ref r13
    r17 = r16 >= 0 :: signed
    if not r17 goto L43 (error at _patch_overloaded_method:23) else goto L9 :: bool
L9:
    r18 = r0.call
    if is_error(r18) goto L43 (error at _patch_overloaded_method:60) else goto L10
L10:
    r19 = '__dict__'
    r20 = CPyObject_GetAttr(r18, r19)
    dec_ref r18
    if is_error(r20) goto L43 (error at _patch_overloaded_method:60) else goto L11
L11:
    r21 = 'methods'
    r22 = PyObject_GetItem(r20, r21)
    dec_ref r20
    if is_error(r22) goto L43 (error at _patch_overloaded_method:60) else goto L12
L12:
    r23 = 'values'
    r24 = [r22]
    r25 = load_address r24
    r26 = PyObject_VectorcallMethod(r23, r25, 9223372036854775809, 0)
    if is_error(r26) goto L44 (error at _patch_overloaded_method:60) else goto L13
L13:
    dec_ref r22
    r27 = PyObject_GetIter(r26)
    dec_ref r26
    if is_error(r27) goto L43 (error at _patch_overloaded_method:60) else goto L14
L14:
    r28 = PyIter_Next(r27)
    if is_error(r28) goto L45 else goto L15
L15:
    r29 = dank_mids.brownie_patch.overloaded.globals :: static
    r30 = 'ContractCall'
    r31 = CPyDict_GetItem(r29, r30)
    if is_error(r31) goto L46 (error at _patch_overloaded_method:61) else goto L16
L16:
    r32 = dank_mids.brownie_patch.overloaded.globals :: static
    r33 = 'ContractTx'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L47 (error at _patch_overloaded_method:61) else goto L17
L17:
    r35 = (r31, r34)
    r36 = box(tuple[object, object], r35)
    r37 = PyObject_IsInstance(r28, r36)
    dec_ref r36
    r38 = r37 >= 0 :: signed
    if not r38 goto L46 (error at _patch_overloaded_method:61) else goto L18 :: bool
L18:
    r39 = truncate r37: i32 to builtins.bool
    if r39 goto L19 else goto L48 :: bool
L19:
    r40 = '_address'
    r41 = CPyObject_GetAttr(r28, r40)
    if is_error(r41) goto L46 (error at _patch_overloaded_method:62) else goto L20
L20:
    r42 = dank_mids.brownie_patch.overloaded.globals :: static
    r43 = '_skip_proc_pool'
    r44 = CPyDict_GetItem(r42, r43)
    if is_error(r44) goto L49 (error at _patch_overloaded_method:62) else goto L21
L21:
    r45 = cast(set, r44)
    if is_error(r45) goto L49 (error at _patch_overloaded_method:62) else goto L22
L22:
    r46 = PySet_Contains(r45, r41)
    dec_ref r45
    dec_ref r41
    r47 = r46 >= 0 :: signed
    if not r47 goto L46 (error at _patch_overloaded_method:62) else goto L23 :: bool
L23:
    r48 = truncate r46: i32 to builtins.bool
    r49 = '_skip_decoder_proc_pool'
    r50 = box(bool, r48)
    r51 = PyObject_SetAttr(r28, r49, r50)
    r52 = r51 >= 0 :: signed
    if not r52 goto L46 (error at _patch_overloaded_method:62) else goto L24 :: bool
L24:
    r53 = 'abi'
    r54 = CPyObject_GetAttr(r28, r53)
    if is_error(r54) goto L46 (error at _patch_overloaded_method:63) else goto L25
L25:
    r55 = 'inputs'
    r56 = PyObject_GetItem(r54, r55)
    dec_ref r54
    if is_error(r56) goto L46 (error at _patch_overloaded_method:63) else goto L26
L26:
    r57 = CPyObject_Size(r56)
    dec_ref r56
    if is_error(r57) goto L46 (error at _patch_overloaded_method:63) else goto L27
L27:
    r58 = dank_mids.brownie_patch.overloaded.globals :: static
    r59 = '_get_coroutine_fn'
    r60 = CPyDict_GetItem(r58, r59)
    if is_error(r60) goto L50 (error at _patch_overloaded_method:63) else goto L28
L28:
    r61 = box(int, r57)
    r62 = [w3, r61]
    r63 = load_address r62
    r64 = PyObject_Vectorcall(r60, r63, 2, 0)
    dec_ref r60
    if is_error(r64) goto L51 (error at _patch_overloaded_method:63) else goto L29
L29:
    dec_ref r61
    r65 = dank_mids.brownie_patch.overloaded.globals :: static
    r66 = 'MethodType'
    r67 = CPyDict_GetItem(r65, r66)
    if is_error(r67) goto L52 (error at _patch_overloaded_method:63) else goto L30
L30:
    r68 = [r64, r28]
    r69 = load_address r68
    r70 = PyObject_Vectorcall(r67, r69, 2, 0)
    dec_ref r67
    if is_error(r70) goto L52 (error at _patch_overloaded_method:63) else goto L31
L31:
    dec_ref r64
    r71 = 'coroutine'
    r72 = PyObject_SetAttr(r28, r71, r70)
    dec_ref r28
    dec_ref r70
    r73 = r72 >= 0 :: signed
    if not r73 goto L53 (error at _patch_overloaded_method:63) else goto L14 :: bool
L32:
    r74 = CPy_NoErrOccurred()
    if not r74 goto L43 (error at _patch_overloaded_method:60) else goto L33 :: bool
L33:
    r75 = r0.call
    if is_error(r75) goto L43 (error at _patch_overloaded_method:68) else goto L34
L34:
    r76 = dank_mids.brownie_patch.overloaded.globals :: static
    r77 = 'MethodType'
    r78 = CPyDict_GetItem(r76, r77)
    if is_error(r78) goto L54 (error at _patch_overloaded_method:68) else goto L35
L35:
    r79 = [r13, r75]
    r80 = load_address r79
    r81 = PyObject_Vectorcall(r78, r80, 2, 0)
    dec_ref r78
    if is_error(r81) goto L54 (error at _patch_overloaded_method:68) else goto L36
L36:
    dec_ref r13
    dec_ref r75
    r82 = r0.call
    dec_ref r0
    if is_error(r82) goto L55 (error at _patch_overloaded_method:68) else goto L37
L37:
    r83 = 'coroutine'
    r84 = PyObject_SetAttr(r82, r83, r81)
    dec_ref r82
    dec_ref r81
    r85 = r84 >= 0 :: signed
    if not r85 goto L39 (error at _patch_overloaded_method:68) else goto L38 :: bool
L38:
    return 1
L39:
    r86 = <error> :: None
    return r86
L40:
    dec_ref r0
    goto L39
L41:
    dec_ref r0
    dec_ref r2
    goto L39
L42:
    dec_ref r0
    dec_ref r2
    dec_ref r4
    goto L39
L43:
    dec_ref r0
    dec_ref r13
    goto L39
L44:
    dec_ref r0
    dec_ref r13
    dec_ref r22
    goto L39
L45:
    dec_ref r27
    goto L32
L46:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    goto L39
L47:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r31
    goto L39
L48:
    dec_ref r28
    goto L14
L49:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r41
    goto L39
L50:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r57 :: int
    goto L39
L51:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r61
    goto L39
L52:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r64
    goto L39
L53:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    goto L39
L54:
    dec_ref r0
    dec_ref r13
    dec_ref r75
    goto L39
L55:
    dec_ref r81
    goto L39

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24, r25 :: object
    r26 :: str
    r27 :: dict
    r28, r29 :: object
    r30 :: str
    r31 :: dict
    r32 :: object
    r33 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L11 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('wraps',)
    r6 = 'functools'
    r7 = dank_mids.brownie_patch.overloaded.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L11 (error at <module>:1) else goto L4
L4:
    functools = r8 :: module
    dec_ref r8
    r9 = ('MethodType',)
    r10 = 'types'
    r11 = dank_mids.brownie_patch.overloaded.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L11 (error at <module>:2) else goto L5
L5:
    types = r12 :: module
    dec_ref r12
    r13 = ('Any', 'Dict', 'Optional', 'Union')
    r14 = 'typing'
    r15 = dank_mids.brownie_patch.overloaded.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L11 (error at <module>:3) else goto L6
L6:
    typing = r16 :: module
    dec_ref r16
    r17 = ('Contract',)
    r18 = 'brownie'
    r19 = dank_mids.brownie_patch.overloaded.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L11 (error at <module>:5) else goto L7
L7:
    brownie = r20 :: module
    dec_ref r20
    r21 = ('ContractCall', 'ContractTx', 'OverloadedMethod')
    r22 = 'brownie.network.contract'
    r23 = dank_mids.brownie_patch.overloaded.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L11 (error at <module>:6) else goto L8
L8:
    brownie.network.contract = r24 :: module
    dec_ref r24
    r25 = ('_get_coroutine_fn', '_skip_proc_pool')
    r26 = 'dank_mids.brownie_patch.call'
    r27 = dank_mids.brownie_patch.overloaded.globals :: static
    r28 = CPyImport_ImportFromMany(r26, r25, r25, r27)
    if is_error(r28) goto L11 (error at <module>:7) else goto L9
L9:
    dank_mids.brownie_patch.call = r28 :: module
    dec_ref r28
    r29 = ('DankWeb3',)
    r30 = 'dank_mids.helpers._helpers'
    r31 = dank_mids.brownie_patch.overloaded.globals :: static
    r32 = CPyImport_ImportFromMany(r30, r29, r29, r31)
    if is_error(r32) goto L11 (error at <module>:8) else goto L10
L10:
    dank_mids.helpers._helpers = r32 :: module
    dec_ref r32
    return 1
L11:
    r33 = <error> :: None
    return r33
