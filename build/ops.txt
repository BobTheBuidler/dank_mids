def DummyLogger.info(args, kwargs):
    args :: tuple
    kwargs :: dict
L0:
    return 1

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19, r20 :: object
    r21 :: bool
    r22 :: str
    r23 :: tuple
    r24 :: i32
    r25 :: bit
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: bool
    r32 :: i32
    r33 :: bit
    r34 :: bool
    r35 :: str
    r36 :: object
    r37 :: bool
    r38 :: object[1]
    r39 :: object_ptr
    r40 :: object
    r41 :: dict
    r42 :: str
    r43 :: i32
    r44 :: bit
    r45 :: dank_mids._demo_mode.DummyLogger
    r46 :: dict
    r47 :: str
    r48 :: i32
    r49 :: bit
    r50 :: dict
    r51 :: str
    r52 :: object
    r53 :: dict
    r54 :: str
    r55 :: i32
    r56 :: bit
    r57 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L26 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Final', 'final')
    r6 = 'typing'
    r7 = dank_mids._demo_mode.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L26 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ENVIRONMENT_VARIABLES',)
    r10 = 'dank_mids'
    r11 = dank_mids._demo_mode.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L26 (error at <module>:3) else goto L5
L5:
    dank_mids = r12 :: module
    dec_ref r12
    r13 = ('getLogger',)
    r14 = 'dank_mids._logging'
    r15 = dank_mids._demo_mode.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L26 (error at <module>:4) else goto L6
L6:
    dank_mids._logging = r16 :: module
    dec_ref r16
    r17 = <error> :: object
    r18 = 'dank_mids._demo_mode'
    r19 = dank_mids._demo_mode.DummyLogger_template :: type
    r20 = CPyType_FromTemplate(r19, r17, r18)
    if is_error(r20) goto L26 (error at <module>:8) else goto L7
L7:
    r21 = DummyLogger_trait_vtable_setup()
    if is_error(r21) goto L27 (error at <module>:-1) else goto L8
L8:
    r22 = '__mypyc_attrs__'
    r23 = PyTuple_Pack(0)
    if is_error(r23) goto L27 (error at <module>:8) else goto L9
L9:
    r24 = PyObject_SetAttr(r20, r22, r23)
    dec_ref r23
    r25 = r24 >= 0 :: signed
    if not r25 goto L27 (error at <module>:8) else goto L10 :: bool
L10:
    dank_mids._demo_mode.DummyLogger = r20 :: type
    r26 = dank_mids._demo_mode.globals :: static
    r27 = 'DummyLogger'
    r28 = CPyDict_SetItem(r26, r27, r20)
    dec_ref r20
    r29 = r28 >= 0 :: signed
    if not r29 goto L26 (error at <module>:8) else goto L11 :: bool
L11:
    r30 = dank_mids.ENVIRONMENT_VARIABLES.DEMO_MODE :: static
    if is_error(r30) goto L12 else goto L14
L12:
    r31 = raise NameError('value for final name "DEMO_MODE" was not set')
    if not r31 goto L26 (error at <module>:30) else goto L13 :: bool
L13:
    unreachable
L14:
    r32 = PyObject_IsTrue(r30)
    r33 = r32 >= 0 :: signed
    if not r33 goto L26 (error at <module>:30) else goto L15 :: bool
L15:
    r34 = truncate r32: i32 to builtins.bool
    if r34 goto L16 else goto L21 :: bool
L16:
    r35 = 'dank_mids.demo'
    r36 = dank_mids._logging.getLogger :: static
    if is_error(r36) goto L17 else goto L19
L17:
    r37 = raise NameError('value for final name "getLogger" was not set')
    if not r37 goto L26 (error at <module>:31) else goto L18 :: bool
L18:
    unreachable
L19:
    r38 = [r35]
    r39 = load_address r38
    r40 = _PyObject_Vectorcall(r36, r39, 1, 0)
    if is_error(r40) goto L26 (error at <module>:31) else goto L20
L20:
    r41 = dank_mids._demo_mode.globals :: static
    r42 = '_logger'
    r43 = CPyDict_SetItem(r41, r42, r40)
    dec_ref r40
    r44 = r43 >= 0 :: signed
    if not r44 goto L26 (error at <module>:31) else goto L23 :: bool
L21:
    r45 = DummyLogger()
    if is_error(r45) goto L26 (error at <module>:33) else goto L22
L22:
    r46 = dank_mids._demo_mode.globals :: static
    r47 = '_logger'
    r48 = CPyDict_SetItem(r46, r47, r45)
    dec_ref r45
    r49 = r48 >= 0 :: signed
    if not r49 goto L26 (error at <module>:33) else goto L23 :: bool
L23:
    r50 = dank_mids._demo_mode.globals :: static
    r51 = '_logger'
    r52 = CPyDict_GetItem(r50, r51)
    if is_error(r52) goto L26 (error at <module>:35) else goto L24
L24:
    dank_mids._demo_mode.demo_logger = r52 :: static
    r53 = dank_mids._demo_mode.globals :: static
    r54 = 'demo_logger'
    r55 = CPyDict_SetItem(r53, r54, r52)
    dec_ref r52
    r56 = r55 >= 0 :: signed
    if not r56 goto L26 (error at <module>:35) else goto L25 :: bool
L25:
    return 1
L26:
    r57 = <error> :: None
    return r57
L27:
    dec_ref r20
    goto L26

def lru_cache_lite_wrap_lru_cache_lite_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def lru_cache_lite_wrap_lru_cache_lite_obj.__call__(__mypyc_self__, args):
    __mypyc_self__ :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_obj
    args :: tuple
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_env
    r1 :: dict
    r2, r3, retval, r4 :: object
    r5 :: bit
    r6 :: object
    r7 :: list
    r8 :: object
    r9 :: tuple
    r10 :: dict
    r11 :: object
    r12 :: dict
    r13 :: i32
    r14 :: bit
    r15 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L15 (error at lru_cache_lite_wrap:41) else goto L1
L1:
    r1 = r0.cache
    if is_error(r1) goto L16 (error at lru_cache_lite_wrap:42) else goto L2
L2:
    r2 = r0.cache_miss
    if is_error(r2) goto L17 (error at lru_cache_lite_wrap:42) else goto L3
L3:
    r3 = CPyDict_Get(r1, args, r2)
    dec_ref r1
    dec_ref r2
    if is_error(r3) goto L16 (error at lru_cache_lite_wrap:42) else goto L4
L4:
    retval = r3
    r4 = r0.cache_miss
    if is_error(r4) goto L18 (error at lru_cache_lite_wrap:43) else goto L5
L5:
    r5 = retval == r4
    dec_ref r4
    if r5 goto L19 else goto L20 :: bool
L6:
    r6 = r0.func
    if is_error(r6) goto L16 (error at lru_cache_lite_wrap:44) else goto L7
L7:
    r7 = PyList_New(0)
    if is_error(r7) goto L21 (error at lru_cache_lite_wrap:44) else goto L8
L8:
    r8 = CPyList_Extend(r7, args)
    if is_error(r8) goto L22 (error at lru_cache_lite_wrap:44) else goto L23
L9:
    r9 = PyList_AsTuple(r7)
    dec_ref r7
    if is_error(r9) goto L21 (error at lru_cache_lite_wrap:44) else goto L10
L10:
    r10 = PyDict_New()
    if is_error(r10) goto L24 (error at lru_cache_lite_wrap:44) else goto L11
L11:
    r11 = PyObject_Call(r6, r9, r10)
    dec_ref r6
    dec_ref r9
    dec_ref r10
    if is_error(r11) goto L16 (error at lru_cache_lite_wrap:44) else goto L12
L12:
    retval = r11
    r12 = r0.cache
    dec_ref r0
    if is_error(r12) goto L25 (error at lru_cache_lite_wrap:45) else goto L13
L13:
    r13 = CPyDict_SetItem(r12, args, retval)
    dec_ref r12
    r14 = r13 >= 0 :: signed
    if not r14 goto L25 (error at lru_cache_lite_wrap:45) else goto L14 :: bool
L14:
    return retval
L15:
    r15 = <error> :: object
    return r15
L16:
    dec_ref r0
    goto L15
L17:
    dec_ref r0
    dec_ref r1
    goto L15
L18:
    dec_ref r0
    dec_ref retval
    goto L15
L19:
    dec_ref retval
    goto L6
L20:
    dec_ref r0
    goto L14
L21:
    dec_ref r0
    dec_ref r6
    goto L15
L22:
    dec_ref r0
    dec_ref r6
    dec_ref r7
    goto L15
L23:
    dec_ref r8
    goto L9
L24:
    dec_ref r0
    dec_ref r6
    dec_ref r9
    goto L15
L25:
    dec_ref retval
    goto L15

def lru_cache_lite(func):
    func :: object
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_env
    r1 :: bool
    r2 :: dict
    r3 :: bool
    r4 :: object
    r5 :: str
    r6, r7 :: object
    r8 :: bool
    r9 :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_obj
    r10 :: bool
    r11 :: object
    r12 :: dict
    r13 :: str
    r14 :: object
    r15 :: object[1]
    r16 :: object_ptr
    r17 :: object
    r18 :: object[1]
    r19 :: object_ptr
    r20 :: object
    r21 :: dict
    r22 :: str
    r23 :: i32
    r24 :: bit
    r25 :: dict
    r26 :: str
    r27 :: i32
    r28 :: bit
    r29 :: object
L0:
    r0 = lru_cache_lite_env()
    if is_error(r0) goto L17 (error at lru_cache_lite:11) else goto L1
L1:
    inc_ref func
    r0.func = func; r1 = is_error
    if not r1 goto L18 (error at lru_cache_lite:11) else goto L2 :: bool
L2:
    r2 = PyDict_New()
    if is_error(r2) goto L18 (error at lru_cache_lite:37) else goto L3
L3:
    r0.cache = r2; r3 = is_error
    if not r3 goto L18 (error at lru_cache_lite:37) else goto L4 :: bool
L4:
    r4 = builtins :: module
    r5 = 'object'
    r6 = CPyObject_GetAttr(r4, r5)
    if is_error(r6) goto L18 (error at lru_cache_lite:38) else goto L5
L5:
    r7 = _PyObject_Vectorcall(r6, 0, 0, 0)
    dec_ref r6
    if is_error(r7) goto L18 (error at lru_cache_lite:38) else goto L6
L6:
    r0.cache_miss = r7; r8 = is_error
    if not r8 goto L18 (error at lru_cache_lite:38) else goto L7 :: bool
L7:
    r9 = lru_cache_lite_wrap_lru_cache_lite_obj()
    if is_error(r9) goto L18 (error at lru_cache_lite:41) else goto L8
L8:
    inc_ref r0
    r9.__mypyc_env__ = r0; r10 = is_error
    if not r10 goto L19 (error at lru_cache_lite:41) else goto L9 :: bool
L9:
    r11 = r0.func
    if is_error(r11) goto L19 (error at lru_cache_lite:40) else goto L10
L10:
    r12 = dank_mids.helpers.lru_cache.globals :: static
    r13 = 'wraps'
    r14 = CPyDict_GetItem(r12, r13)
    if is_error(r14) goto L20 (error at lru_cache_lite:40) else goto L11
L11:
    r15 = [r11]
    r16 = load_address r15
    r17 = _PyObject_Vectorcall(r14, r16, 1, 0)
    dec_ref r14
    if is_error(r17) goto L20 (error at lru_cache_lite:40) else goto L12
L12:
    dec_ref r11
    r18 = [r9]
    r19 = load_address r18
    r20 = _PyObject_Vectorcall(r17, r19, 1, 0)
    dec_ref r17
    if is_error(r20) goto L19 (error at lru_cache_lite:41) else goto L13
L13:
    dec_ref r9
    inc_ref r20
    r21 = dank_mids.helpers.lru_cache.globals :: static
    r22 = 'lru_cache_lite_wrap'
    r23 = CPyDict_SetItem(r21, r22, r20)
    dec_ref r20
    r24 = r23 >= 0 :: signed
    if not r24 goto L21 (error at lru_cache_lite:41) else goto L14 :: bool
L14:
    r25 = r0.cache
    dec_ref r0
    if is_error(r25) goto L22 (error at lru_cache_lite:48) else goto L15
L15:
    r26 = 'cache'
    r27 = PyObject_SetAttr(r20, r26, r25)
    dec_ref r25
    r28 = r27 >= 0 :: signed
    if not r28 goto L22 (error at lru_cache_lite:48) else goto L16 :: bool
L16:
    return r20
L17:
    r29 = <error> :: object
    return r29
L18:
    dec_ref r0
    goto L17
L19:
    dec_ref r0
    dec_ref r9
    goto L17
L20:
    dec_ref r0
    dec_ref r9
    dec_ref r11
    goto L17
L21:
    dec_ref r0
    dec_ref r20
    goto L17
L22:
    dec_ref r20
    goto L17

def lru_cache_lite_wrap_lru_cache_lite_nonull_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def lru_cache_lite_wrap_lru_cache_lite_nonull_obj.__call__(__mypyc_self__, args):
    __mypyc_self__ :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_nonull_obj
    args :: tuple
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_nonull_env
    r1 :: dict
    r2 :: object
    retval :: union[object, None]
    r3 :: object
    r4 :: bit
    r5 :: object
    r6 :: list
    r7 :: object
    r8 :: tuple
    r9 :: dict
    r10 :: object
    r11 :: dict
    r12 :: i32
    r13 :: bit
    r14 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L13 (error at lru_cache_lite_wrap:89) else goto L1
L1:
    r1 = r0.cache
    if is_error(r1) goto L14 (error at lru_cache_lite_wrap:90) else goto L2
L2:
    r2 = CPyDict_GetWithNone(r1, args)
    dec_ref r1
    if is_error(r2) goto L14 (error at lru_cache_lite_wrap:90) else goto L3
L3:
    retval = r2
    r3 = load_address _Py_NoneStruct
    r4 = retval == r3
    if r4 goto L15 else goto L16 :: bool
L4:
    r5 = r0.func
    if is_error(r5) goto L14 (error at lru_cache_lite_wrap:92) else goto L5
L5:
    r6 = PyList_New(0)
    if is_error(r6) goto L17 (error at lru_cache_lite_wrap:92) else goto L6
L6:
    r7 = CPyList_Extend(r6, args)
    if is_error(r7) goto L18 (error at lru_cache_lite_wrap:92) else goto L19
L7:
    r8 = PyList_AsTuple(r6)
    dec_ref r6
    if is_error(r8) goto L17 (error at lru_cache_lite_wrap:92) else goto L8
L8:
    r9 = PyDict_New()
    if is_error(r9) goto L20 (error at lru_cache_lite_wrap:92) else goto L9
L9:
    r10 = PyObject_Call(r5, r8, r9)
    dec_ref r5
    dec_ref r8
    dec_ref r9
    if is_error(r10) goto L14 (error at lru_cache_lite_wrap:92) else goto L10
L10:
    retval = r10
    r11 = r0.cache
    dec_ref r0
    if is_error(r11) goto L21 (error at lru_cache_lite_wrap:93) else goto L11
L11:
    r12 = CPyDict_SetItem(r11, args, retval)
    dec_ref r11
    r13 = r12 >= 0 :: signed
    if not r13 goto L21 (error at lru_cache_lite_wrap:93) else goto L12 :: bool
L12:
    return retval
L13:
    r14 = <error> :: object
    return r14
L14:
    dec_ref r0
    goto L13
L15:
    dec_ref retval
    goto L4
L16:
    dec_ref r0
    goto L12
L17:
    dec_ref r0
    dec_ref r5
    goto L13
L18:
    dec_ref r0
    dec_ref r5
    dec_ref r6
    goto L13
L19:
    dec_ref r7
    goto L7
L20:
    dec_ref r0
    dec_ref r5
    dec_ref r8
    goto L13
L21:
    dec_ref retval
    goto L13

def lru_cache_lite_nonull(func):
    func :: object
    r0 :: dank_mids.helpers.lru_cache.lru_cache_lite_nonull_env
    r1 :: bool
    r2 :: dict
    r3 :: bool
    r4 :: dank_mids.helpers.lru_cache.lru_cache_lite_wrap_lru_cache_lite_nonull_obj
    r5 :: bool
    r6 :: object
    r7 :: dict
    r8 :: str
    r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: i32
    r19 :: bit
    r20 :: dict
    r21 :: str
    r22 :: i32
    r23 :: bit
    r24 :: object
L0:
    r0 = lru_cache_lite_nonull_env()
    if is_error(r0) goto L14 (error at lru_cache_lite_nonull:52) else goto L1
L1:
    inc_ref func
    r0.func = func; r1 = is_error
    if not r1 goto L15 (error at lru_cache_lite_nonull:52) else goto L2 :: bool
L2:
    r2 = PyDict_New()
    if is_error(r2) goto L15 (error at lru_cache_lite_nonull:86) else goto L3
L3:
    r0.cache = r2; r3 = is_error
    if not r3 goto L15 (error at lru_cache_lite_nonull:86) else goto L4 :: bool
L4:
    r4 = lru_cache_lite_wrap_lru_cache_lite_nonull_obj()
    if is_error(r4) goto L15 (error at lru_cache_lite_nonull:89) else goto L5
L5:
    inc_ref r0
    r4.__mypyc_env__ = r0; r5 = is_error
    if not r5 goto L16 (error at lru_cache_lite_nonull:89) else goto L6 :: bool
L6:
    r6 = r0.func
    if is_error(r6) goto L16 (error at lru_cache_lite_nonull:88) else goto L7
L7:
    r7 = dank_mids.helpers.lru_cache.globals :: static
    r8 = 'wraps'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L17 (error at lru_cache_lite_nonull:88) else goto L8
L8:
    r10 = [r6]
    r11 = load_address r10
    r12 = _PyObject_Vectorcall(r9, r11, 1, 0)
    dec_ref r9
    if is_error(r12) goto L17 (error at lru_cache_lite_nonull:88) else goto L9
L9:
    dec_ref r6
    r13 = [r4]
    r14 = load_address r13
    r15 = _PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L16 (error at lru_cache_lite_nonull:89) else goto L10
L10:
    dec_ref r4
    inc_ref r15
    r16 = dank_mids.helpers.lru_cache.globals :: static
    r17 = 'lru_cache_lite_wrap'
    r18 = CPyDict_SetItem(r16, r17, r15)
    dec_ref r15
    r19 = r18 >= 0 :: signed
    if not r19 goto L18 (error at lru_cache_lite_nonull:89) else goto L11 :: bool
L11:
    r20 = r0.cache
    dec_ref r0
    if is_error(r20) goto L19 (error at lru_cache_lite_nonull:96) else goto L12
L12:
    r21 = 'cache'
    r22 = PyObject_SetAttr(r15, r21, r20)
    dec_ref r20
    r23 = r22 >= 0 :: signed
    if not r23 goto L19 (error at lru_cache_lite_nonull:96) else goto L13 :: bool
L13:
    return r15
L14:
    r24 = <error> :: object
    return r24
L15:
    dec_ref r0
    goto L14
L16:
    dec_ref r0
    dec_ref r4
    goto L14
L17:
    dec_ref r0
    dec_ref r4
    dec_ref r6
    goto L14
L18:
    dec_ref r0
    dec_ref r15
    goto L14
L19:
    dec_ref r15
    goto L14

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16 :: object
    r17 :: str
    r18 :: dict
    r19 :: str
    r20 :: object
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: dict
    r25 :: str
    r26 :: i32
    r27 :: bit
    r28 :: str
    r29 :: dict
    r30 :: str
    r31 :: object
    r32 :: object[1]
    r33 :: object_ptr
    r34 :: object
    r35 :: dict
    r36 :: str
    r37 :: i32
    r38 :: bit
    r39, r40 :: str
    r41 :: list
    r42, r43, r44 :: ptr
    r45 :: dict
    r46 :: str
    r47 :: i32
    r48 :: bit
    r49 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L15 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('wraps',)
    r6 = 'functools'
    r7 = dank_mids.helpers.lru_cache.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L15 (error at <module>:1) else goto L4
L4:
    functools = r8 :: module
    dec_ref r8
    r9 = ('Callable', 'Dict', 'TypeVar')
    r10 = 'typing'
    r11 = dank_mids.helpers.lru_cache.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L15 (error at <module>:2) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = ('ParamSpec',)
    r14 = 'typing_extensions'
    r15 = dank_mids.helpers.lru_cache.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L15 (error at <module>:4) else goto L6
L6:
    typing_extensions = r16 :: module
    dec_ref r16
    r17 = '__P'
    r18 = dank_mids.helpers.lru_cache.globals :: static
    r19 = 'ParamSpec'
    r20 = CPyDict_GetItem(r18, r19)
    if is_error(r20) goto L15 (error at <module>:7) else goto L7
L7:
    r21 = [r17]
    r22 = load_address r21
    r23 = _PyObject_Vectorcall(r20, r22, 1, 0)
    dec_ref r20
    if is_error(r23) goto L15 (error at <module>:7) else goto L8
L8:
    r24 = dank_mids.helpers.lru_cache.globals :: static
    r25 = '__P'
    r26 = CPyDict_SetItem(r24, r25, r23)
    dec_ref r23
    r27 = r26 >= 0 :: signed
    if not r27 goto L15 (error at <module>:7) else goto L9 :: bool
L9:
    r28 = '__T'
    r29 = dank_mids.helpers.lru_cache.globals :: static
    r30 = 'TypeVar'
    r31 = CPyDict_GetItem(r29, r30)
    if is_error(r31) goto L15 (error at <module>:8) else goto L10
L10:
    r32 = [r28]
    r33 = load_address r32
    r34 = _PyObject_Vectorcall(r31, r33, 1, 0)
    dec_ref r31
    if is_error(r34) goto L15 (error at <module>:8) else goto L11
L11:
    r35 = dank_mids.helpers.lru_cache.globals :: static
    r36 = '__T'
    r37 = CPyDict_SetItem(r35, r36, r34)
    dec_ref r34
    r38 = r37 >= 0 :: signed
    if not r38 goto L15 (error at <module>:8) else goto L12 :: bool
L12:
    r39 = 'lru_cache_lite'
    r40 = 'lru_cache_lite_nonull'
    r41 = PyList_New(2)
    if is_error(r41) goto L15 (error at <module>:100) else goto L13
L13:
    r42 = get_element_ptr r41 ob_item :: PyListObject
    r43 = load_mem r42 :: ptr*
    inc_ref r39
    set_mem r43, r39 :: builtins.object*
    inc_ref r40
    r44 = r43 + 8
    set_mem r44, r40 :: builtins.object*
    r45 = dank_mids.helpers.lru_cache.globals :: static
    r46 = '__all__'
    r47 = CPyDict_SetItem(r45, r46, r41)
    dec_ref r41
    r48 = r47 >= 0 :: signed
    if not r48 goto L15 (error at <module>:100) else goto L14 :: bool
L14:
    return 1
L15:
    r49 = <error> :: None
    return r49

def FunctionABI.__init__(self, abi):
    self :: dank_mids.brownie_patch._abi.FunctionABI
    abi :: dict
    r0 :: bool
    r1 :: str
    r2 :: bool
    r3 :: str
    r4 :: bool
    r5 :: None
L0:
    inc_ref abi
    self.abi = abi; r0 = is_error
    if not r0 goto L6 (error at __init__:44) else goto L1 :: bool
L1:
    r1 = build_function_signature(abi)
    if is_error(r1) goto L6 (error at __init__:50) else goto L2
L2:
    inc_ref r1
    self.input_sig = r1; r2 = is_error
    if not r2 goto L7 (error at __init__:51) else goto L3 :: bool
L3:
    r3 = build_function_selector(r1)
    dec_ref r1
    if is_error(r3) goto L6 (error at __init__:57) else goto L4
L4:
    self.signature = r3; r4 = is_error
    if not r4 goto L6 (error at __init__:57) else goto L5 :: bool
L5:
    return 1
L6:
    r5 = <error> :: None
    return r5
L7:
    dec_ref r1
    goto L6

def FunctionABI.singleton(abi):
    abi :: dict
    r0 :: object
    r1 :: str
    r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: list
    r7 :: ptr
    r8 :: native_int
    r9 :: tuple
    r10 :: short_int
    r11 :: ptr
    r12 :: native_int
    r13 :: short_int
    r14 :: bit
    r15 :: native_int
    r16, r17 :: ptr
    r18 :: native_int
    r19 :: ptr
    r20 :: object
    r21 :: str
    r22, r23 :: object
    r24 :: bool
    r25 :: object[1]
    r26 :: object_ptr
    r27 :: object
    r28 :: tuple[str, object]
    r29 :: object
    r30 :: bit
    r31 :: short_int
    r32 :: object
    r33 :: bool
    r34 :: object
    r35 :: dank_mids.brownie_patch._abi.FunctionABI
    r36 :: tuple[object, object, object]
    r37 :: object
    r38 :: str
    r39 :: object
    r40 :: bit
    r41 :: object
    r42 :: dict
    r43 :: i32
    r44 :: bit
    r45 :: tuple
    r46 :: object
    r47 :: dank_mids.brownie_patch._abi.FunctionABI
    r48 :: object
    r49 :: bool
    r50 :: i32
    r51 :: bit
    r52 :: object
    r53 :: str
    r54 :: object
    r55 :: bit
    r56 :: object
    r57 :: str
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: object[2]
    r62 :: object_ptr
    r63 :: object
    r64 :: bit
    r65 :: dank_mids.brownie_patch._abi.FunctionABI
L0:
    r0 = builtins :: module
    r1 = 'sorted'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L44 (error at singleton:71) else goto L1
L1:
    r3 = [abi]
    r4 = load_address r3
    r5 = _PyObject_Vectorcall(r2, r4, 1, 0)
    dec_ref r2
    if is_error(r5) goto L44 (error at singleton:71) else goto L2
L2:
    r6 = cast(list, r5)
    if is_error(r6) goto L44 (error at singleton:71) else goto L3
L3:
    r7 = get_element_ptr r6 ob_size :: PyVarObject
    r8 = load_mem r7 :: native_int*
    r9 = PyTuple_New(r8)
    if is_error(r9) goto L45 (error at singleton:71) else goto L4
L4:
    r10 = 0
L5:
    r11 = get_element_ptr r6 ob_size :: PyVarObject
    r12 = load_mem r11 :: native_int*
    r13 = r12 << 1
    r14 = r10 < r13 :: signed
    if r14 goto L6 else goto L46 :: bool
L6:
    r15 = r10 >> 1
    r16 = get_element_ptr r6 ob_item :: PyListObject
    r17 = load_mem r16 :: ptr*
    r18 = r15 * 8
    r19 = r17 + r18
    r20 = load_mem r19 :: builtins.object*
    inc_ref r20
    r21 = cast(str, r20)
    if is_error(r21) goto L47 (error at singleton:71) else goto L7
L7:
    r22 = CPyDict_GetItem(abi, r21)
    if is_error(r22) goto L48 (error at singleton:71) else goto L8
L8:
    r23 = dank_mids.brownie_patch._abi._make_hashable :: static
    if is_error(r23) goto L49 else goto L11
L9:
    r24 = raise NameError('value for final name "_make_hashable" was not set')
    if not r24 goto L44 (error at singleton:71) else goto L10 :: bool
L10:
    unreachable
L11:
    r25 = [r22]
    r26 = load_address r25
    r27 = _PyObject_Vectorcall(r23, r26, 1, 0)
    if is_error(r27) goto L50 (error at singleton:71) else goto L12
L12:
    dec_ref r22
    r28 = (r21, r27)
    r29 = box(tuple[str, object], r28)
    r30 = CPySequenceTuple_SetItemUnsafe(r9, r10, r29)
    if not r30 goto L47 (error at singleton:71) else goto L13 :: bool
L13:
    r31 = r10 + 2
    r10 = r31
    goto L5
L14:
L15:
    r32 = dank_mids.brownie_patch._abi._singletons :: static
    if is_error(r32) goto L16 else goto L18
L16:
    r33 = raise NameError('value for final name "_singletons" was not set')
    if not r33 goto L21 (error at singleton:73) else goto L51 :: bool
L17:
    unreachable
L18:
    r34 = PyObject_GetItem(r32, r9)
    if is_error(r34) goto L21 (error at singleton:73) else goto L19
L19:
    r35 = cast(dank_mids.brownie_patch._abi.FunctionABI, r34)
    if is_error(r35) goto L21 (error at singleton:73) else goto L52
L20:
    return r35
L21:
    r36 = CPy_CatchError()
    r37 = builtins :: module
    r38 = 'KeyError'
    r39 = CPyObject_GetAttr(r37, r38)
    if is_error(r39) goto L53 (error at singleton:74) else goto L22
L22:
    r40 = CPy_ExceptionMatches(r39)
    dec_ref r39
    if r40 goto L23 else goto L33 :: bool
L23:
    r41 = dank_mids.brownie_patch._abi.FunctionABI :: type
    r42 = PyDict_New()
    if is_error(r42) goto L53 (error at singleton:75) else goto L24
L24:
    r43 = CPyDict_UpdateInDisplay(r42, abi)
    r44 = r43 >= 0 :: signed
    if not r44 goto L54 (error at singleton:75) else goto L25 :: bool
L25:
    r45 = PyTuple_Pack(0)
    if is_error(r45) goto L54 (error at singleton:75) else goto L26
L26:
    r46 = PyObject_Call(r41, r45, r42)
    dec_ref r45
    dec_ref r42
    if is_error(r46) goto L53 (error at singleton:75) else goto L27
L27:
    r47 = cast(dank_mids.brownie_patch._abi.FunctionABI, r46)
    if is_error(r47) goto L53 (error at singleton:75) else goto L28
L28:
    inc_ref r47
    r48 = dank_mids.brownie_patch._abi._singletons :: static
    if is_error(r48) goto L55 else goto L31
L29:
    r49 = raise NameError('value for final name "_singletons" was not set')
    if not r49 goto L42 (error at singleton:75) else goto L56 :: bool
L30:
    unreachable
L31:
    r50 = PyObject_SetItem(r48, r9, r47)
    dec_ref r9
    dec_ref r47
    r51 = r50 >= 0 :: signed
    if not r51 goto L57 (error at singleton:75) else goto L32 :: bool
L32:
    CPy_RestoreExcInfo(r36)
    dec_ref r36
    return r47
L33:
    r52 = builtins :: module
    r53 = 'AttributeError'
    r54 = CPyObject_GetAttr(r52, r53)
    if is_error(r54) goto L53 (error at singleton:77) else goto L34
L34:
    r55 = CPy_ExceptionMatches(r54)
    dec_ref r54
    if r55 goto L35 else goto L58 :: bool
L35:
    r56 = CPy_GetExcValue()
    r57 = PyObject_Str(r56)
    dec_ref r56
    if is_error(r57) goto L53 (error at singleton:78) else goto L36
L36:
    r58 = builtins :: module
    r59 = 'AttributeError'
    r60 = CPyObject_GetAttr(r58, r59)
    if is_error(r60) goto L59 (error at singleton:78) else goto L37
L37:
    r61 = [r57, r9]
    r62 = load_address r61
    r63 = _PyObject_Vectorcall(r60, r62, 2, 0)
    dec_ref r60
    if is_error(r63) goto L59 (error at singleton:78) else goto L38
L38:
    dec_ref r57
    dec_ref r9
    CPy_Raise(r63)
    dec_ref r63
    if not 0 goto L42 (error at singleton:78) else goto L60 :: bool
L39:
    unreachable
L40:
    CPy_Reraise()
    if not 0 goto L42 else goto L61 :: bool
L41:
    unreachable
L42:
    CPy_RestoreExcInfo(r36)
    dec_ref r36
    r64 = CPy_KeepPropagating()
    if not r64 goto L44 else goto L43 :: bool
L43:
    unreachable
L44:
    r65 = <error> :: dank_mids.brownie_patch._abi.FunctionABI
    return r65
L45:
    dec_ref r6
    goto L44
L46:
    dec_ref r6
    goto L14
L47:
    dec_ref r6
    dec_ref r9
    goto L44
L48:
    dec_ref r6
    dec_ref r9
    dec_ref r21
    goto L44
L49:
    dec_ref r6
    dec_ref r9
    dec_ref r21
    dec_ref r22
    goto L9
L50:
    dec_ref r6
    dec_ref r9
    dec_ref r21
    dec_ref r22
    goto L44
L51:
    dec_ref r9
    goto L17
L52:
    dec_ref r9
    goto L20
L53:
    dec_ref r9
    goto L42
L54:
    dec_ref r9
    dec_ref r42
    goto L42
L55:
    dec_ref r9
    dec_ref r47
    dec_ref r47
    goto L29
L56:
    dec_ref r36
    goto L30
L57:
    dec_ref r47
    goto L42
L58:
    dec_ref r9
    goto L40
L59:
    dec_ref r9
    dec_ref r57
    goto L42
L60:
    dec_ref r36
    goto L39
L61:
    dec_ref r36
    goto L41

def get_type_strings(abi_params, substitutions):
    abi_params :: list
    substitutions :: union[dict, None]
    r0 :: object
    r1 :: list
    r2 :: object
    r3 :: bit
    r4 :: dict
    r5 :: short_int
    r6 :: ptr
    r7 :: native_int
    r8 :: short_int
    r9 :: bit
    r10 :: native_int
    r11, r12 :: ptr
    r13 :: native_int
    r14 :: ptr
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: object
    r19, type_str, r20 :: str
    r21 :: bool
    r22 :: str
    r23 :: object
    r24 :: dict
    r25, r26 :: list
    r27 :: str
    r28, r29, r30, r31, r32, r33 :: object
    r34, r35, r36, r37, r38, r39 :: str
    r40 :: i32
    r41 :: bit
    r42 :: dict
    r43 :: short_int
    r44 :: native_int
    r45 :: short_int
    r46 :: object
    r47 :: tuple[bool, short_int, object, object]
    r48 :: short_int
    r49 :: bool
    r50, r51 :: object
    r52 :: str
    r53 :: bool
    r54 :: str
    r55 :: object[3]
    r56 :: object_ptr
    r57 :: object
    r58 :: str
    r59, r60 :: bit
    r61 :: i32
    r62 :: bit
    r63 :: short_int
    r64 :: list
L0:
    if is_error(substitutions) goto L1 else goto L37
L1:
    r0 = box(None, 1)
    inc_ref r0
    substitutions = r0
L2:
    r1 = PyList_New(0)
    if is_error(r1) goto L38 (error at get_type_strings:86) else goto L3
L3:
    r2 = load_address _Py_NoneStruct
    r3 = substitutions == r2
    if r3 goto L39 else goto L6 :: bool
L4:
    r4 = PyDict_New()
    if is_error(r4) goto L40 (error at get_type_strings:88) else goto L5
L5:
    substitutions = r4
L6:
    r5 = 0
L7:
    r6 = get_element_ptr abi_params ob_size :: PyVarObject
    r7 = load_mem r6 :: native_int*
    r8 = r7 << 1
    r9 = r5 < r8 :: signed
    if r9 goto L8 else goto L41 :: bool
L8:
    r10 = r5 >> 1
    r11 = get_element_ptr abi_params ob_item :: PyListObject
    r12 = load_mem r11 :: ptr*
    r13 = r10 * 8
    r14 = r12 + r13
    r15 = load_mem r14 :: builtins.object*
    inc_ref r15
    r16 = cast(dict, r15)
    if is_error(r16) goto L42 (error at get_type_strings:90) else goto L9
L9:
    r17 = 'type'
    r18 = CPyDict_GetItem(r16, r17)
    if is_error(r18) goto L43 (error at get_type_strings:91) else goto L10
L10:
    r19 = cast(str, r18)
    if is_error(r19) goto L43 (error at get_type_strings:91) else goto L11
L11:
    type_str = r19
    r20 = 'tuple'
    r21 = CPyStr_Startswith(type_str, r20)
    if r21 goto L44 else goto L45 :: bool
L12:
    r22 = 'components'
    r23 = CPyDict_GetItem(r16, r22)
    if is_error(r23) goto L43 (error at get_type_strings:93) else goto L13
L13:
    inc_ref substitutions
    r24 = cast(dict, substitutions)
    if is_error(r24) goto L46 (error at get_type_strings:93) else goto L14
L14:
    r25 = cast(list, r23)
    if is_error(r25) goto L47 (error at get_type_strings:93) else goto L15
L15:
    r26 = get_type_strings(r25, r24)
    dec_ref r25
    dec_ref r24
    if is_error(r26) goto L43 (error at get_type_strings:93) else goto L16
L16:
    r27 = 'type'
    r28 = CPyDict_GetItem(r16, r27)
    dec_ref r16
    if is_error(r28) goto L48 (error at get_type_strings:94) else goto L17
L17:
    r29 = load_address _Py_NoneStruct
    r30 = load_address _Py_NoneStruct
    r31 = object 5
    r32 = PySlice_New(r31, r29, r30)
    if is_error(r32) goto L49 (error at get_type_strings:94) else goto L18
L18:
    r33 = PyObject_GetItem(r28, r32)
    dec_ref r28
    dec_ref r32
    if is_error(r33) goto L48 (error at get_type_strings:94) else goto L19
L19:
    r34 = '('
    r35 = ','
    r36 = PyUnicode_Join(r35, r26)
    dec_ref r26
    if is_error(r36) goto L50 (error at get_type_strings:95) else goto L20
L20:
    r37 = ')'
    r38 = PyObject_Str(r33)
    dec_ref r33
    if is_error(r38) goto L51 (error at get_type_strings:95) else goto L21
L21:
    r39 = CPyStr_Build(4, r34, r36, r37, r38)
    dec_ref r36
    dec_ref r38
    if is_error(r39) goto L42 (error at get_type_strings:95) else goto L22
L22:
    r40 = PyList_Append(r1, r39)
    dec_ref r39
    r41 = r40 >= 0 :: signed
    if not r41 goto L42 (error at get_type_strings:95) else goto L34 :: bool
L23:
    inc_ref substitutions
    r42 = cast(dict, substitutions)
    if is_error(r42) goto L52 (error at get_type_strings:97) else goto L24
L24:
    r43 = 0
    r44 = PyDict_Size(r42)
    r45 = r44 << 1
    r46 = CPyDict_GetItemsIter(r42)
    if is_error(r46) goto L53 (error at get_type_strings:97) else goto L25
L25:
    r47 = CPyDict_NextItem(r46, r43)
    r48 = r47[1]
    r43 = r48
    r49 = r47[0]
    if r49 goto L26 else goto L54 :: bool
L26:
    r50 = r47[2]
    r51 = r47[3]
    dec_ref r47
    r52 = cast(str, r50)
    if is_error(r52) goto L55 (error at get_type_strings:97) else goto L27
L27:
    r53 = CPyStr_Startswith(type_str, r52)
    if r53 goto L28 else goto L56 :: bool
L28:
    r54 = 'replace'
    r55 = [type_str, r52, r51]
    r56 = load_address r55
    r57 = PyObject_VectorcallMethod(r54, r56, 9223372036854775811, 0)
    if is_error(r57) goto L57 (error at get_type_strings:99) else goto L29
L29:
    dec_ref type_str
    dec_ref r52
    dec_ref r51
    r58 = cast(str, r57)
    if is_error(r58) goto L58 (error at get_type_strings:99) else goto L30
L30:
    type_str = r58
L31:
    r59 = CPyDict_CheckSize(r42, r45)
    if not r59 goto L59 (error at get_type_strings:97) else goto L25 :: bool
L32:
    r60 = CPy_NoErrOccurred()
    if not r60 goto L52 (error at get_type_strings:97) else goto L33 :: bool
L33:
    r61 = PyList_Append(r1, type_str)
    dec_ref type_str
    r62 = r61 >= 0 :: signed
    if not r62 goto L42 (error at get_type_strings:100) else goto L34 :: bool
L34:
    r63 = r5 + 2
    r5 = r63
    goto L7
L35:
    return r1
L36:
    r64 = <error> :: list
    return r64
L37:
    inc_ref substitutions
    goto L2
L38:
    dec_ref substitutions
    goto L36
L39:
    dec_ref substitutions
    goto L4
L40:
    dec_ref r1
    goto L36
L41:
    dec_ref substitutions
    goto L35
L42:
    dec_ref substitutions
    dec_ref r1
    goto L36
L43:
    dec_ref substitutions
    dec_ref r1
    dec_ref r16
    goto L36
L44:
    dec_ref type_str
    goto L12
L45:
    dec_ref r16
    goto L23
L46:
    dec_ref substitutions
    dec_ref r1
    dec_ref r16
    dec_ref r23
    goto L36
L47:
    dec_ref substitutions
    dec_ref r1
    dec_ref r16
    dec_ref r24
    goto L36
L48:
    dec_ref substitutions
    dec_ref r1
    dec_ref r26
    goto L36
L49:
    dec_ref substitutions
    dec_ref r1
    dec_ref r26
    dec_ref r28
    goto L36
L50:
    dec_ref substitutions
    dec_ref r1
    dec_ref r33
    goto L36
L51:
    dec_ref substitutions
    dec_ref r1
    dec_ref r36
    goto L36
L52:
    dec_ref substitutions
    dec_ref r1
    dec_ref type_str
    goto L36
L53:
    dec_ref substitutions
    dec_ref r1
    dec_ref type_str
    dec_ref r42
    goto L36
L54:
    dec_ref r42
    dec_ref r46
    dec_ref r47
    goto L32
L55:
    dec_ref substitutions
    dec_ref r1
    dec_ref type_str
    dec_ref r42
    dec_ref r46
    dec_ref r51
    goto L36
L56:
    dec_ref r52
    dec_ref r51
    goto L31
L57:
    dec_ref substitutions
    dec_ref r1
    dec_ref type_str
    dec_ref r42
    dec_ref r46
    dec_ref r52
    dec_ref r51
    goto L36
L58:
    dec_ref substitutions
    dec_ref r1
    dec_ref r42
    dec_ref r46
    goto L36
L59:
    dec_ref substitutions
    dec_ref r1
    dec_ref type_str
    dec_ref r42
    dec_ref r46
    goto L36

def build_function_signature(abi):
    abi :: dict
    r0 :: str
    r1 :: object
    r2 :: list
    r3 :: union[dict, None]
    r4 :: list
    r5 :: str
    r6 :: object
    r7, r8, r9, r10, r11, r12, r13 :: str
L0:
    r0 = 'inputs'
    r1 = CPyDict_GetItem(abi, r0)
    if is_error(r1) goto L8 (error at build_function_signature:106) else goto L1
L1:
    r2 = cast(list, r1)
    if is_error(r2) goto L8 (error at build_function_signature:106) else goto L2
L2:
    r3 = <error> :: union[dict, None]
    r4 = get_type_strings(r2, r3)
    dec_ref r2
    if is_error(r4) goto L8 (error at build_function_signature:106) else goto L3
L3:
    r5 = 'name'
    r6 = CPyDict_GetItem(abi, r5)
    if is_error(r6) goto L9 (error at build_function_signature:107) else goto L4
L4:
    r7 = PyObject_Str(r6)
    dec_ref r6
    if is_error(r7) goto L9 (error at build_function_signature:107) else goto L5
L5:
    r8 = '('
    r9 = ','
    r10 = PyUnicode_Join(r9, r4)
    dec_ref r4
    if is_error(r10) goto L10 (error at build_function_signature:107) else goto L6
L6:
    r11 = ')'
    r12 = CPyStr_Build(4, r7, r8, r10, r11)
    dec_ref r7
    dec_ref r10
    if is_error(r12) goto L8 (error at build_function_signature:107) else goto L7
L7:
    return r12
L8:
    r13 = <error> :: str
    return r13
L9:
    dec_ref r4
    goto L8
L10:
    dec_ref r7
    goto L8

def build_function_selector(input_signature):
    input_signature, r0 :: str
    r1 :: bytes
    r2 :: object
    r3 :: bool
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: str
    r8 :: object[1]
    r9 :: object_ptr
    r10, r11, r12, r13, r14, r15 :: object
    r16, r17, r18 :: str
L0:
    r0 = '0x'
    r1 = PyUnicode_AsUTF8String(input_signature)
    if is_error(r1) goto L11 (error at build_function_selector:111) else goto L1
L1:
    r2 = dank_mids.brownie_patch._abi.keccak :: static
    if is_error(r2) goto L12 else goto L4
L2:
    r3 = raise NameError('value for final name "keccak" was not set')
    if not r3 goto L11 (error at build_function_selector:111) else goto L3 :: bool
L3:
    unreachable
L4:
    r4 = [r1]
    r5 = load_address r4
    r6 = _PyObject_Vectorcall(r2, r5, 1, 0)
    if is_error(r6) goto L13 (error at build_function_selector:111) else goto L5
L5:
    dec_ref r1
    r7 = 'hex'
    r8 = [r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775809, 0)
    if is_error(r10) goto L14 (error at build_function_selector:111) else goto L6
L6:
    dec_ref r6
    r11 = load_address _Py_NoneStruct
    r12 = load_address _Py_NoneStruct
    r13 = object 8
    r14 = PySlice_New(r11, r13, r12)
    if is_error(r14) goto L15 (error at build_function_selector:111) else goto L7
L7:
    r15 = PyObject_GetItem(r10, r14)
    dec_ref r10
    dec_ref r14
    if is_error(r15) goto L11 (error at build_function_selector:111) else goto L8
L8:
    r16 = PyObject_Str(r15)
    dec_ref r15
    if is_error(r16) goto L11 (error at build_function_selector:111) else goto L9
L9:
    r17 = CPyStr_Build(2, r0, r16)
    dec_ref r16
    if is_error(r17) goto L11 (error at build_function_selector:111) else goto L10
L10:
    return r17
L11:
    r18 = <error> :: str
    return r18
L12:
    dec_ref r1
    goto L2
L13:
    dec_ref r1
    goto L11
L14:
    dec_ref r6
    goto L11
L15:
    dec_ref r10
    goto L11

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24 :: object
    r25 :: dict
    r26 :: str
    r27 :: object
    r28 :: dict
    r29 :: str
    r30, r31 :: object
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: tuple[object, object]
    r36, r37, r38 :: object
    r39 :: tuple[object, object]
    r40, r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: dict
    r47 :: str
    r48, r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: dict
    r55 :: str
    r56 :: object
    r57 :: str
    r58 :: object
    r59 :: dict
    r60 :: str
    r61 :: i32
    r62 :: bit
    r63 :: dict
    r64 :: str
    r65 :: object
    r66 :: str
    r67 :: object
    r68 :: dict
    r69 :: str
    r70 :: i32
    r71 :: bit
    r72 :: dict
    r73 :: str
    r74 :: object
    r75 :: str
    r76 :: object
    r77 :: tuple
    r78 :: str
    r79, r80 :: object
    r81 :: bool
    r82, r83, r84, r85, r86 :: str
    r87 :: tuple
    r88 :: i32
    r89 :: bit
    r90 :: dict
    r91 :: str
    r92 :: i32
    r93 :: bit
    r94 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L32 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Dict', 'Final', 'List', 'Optional', 'Tuple', 'final')
    r6 = 'typing'
    r7 = dank_mids.brownie_patch._abi.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L32 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('WeakValueDictionary',)
    r10 = 'weakref'
    r11 = dank_mids.brownie_patch._abi.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L32 (error at <module>:2) else goto L5
L5:
    weakref = r12 :: module
    dec_ref r12
    r13 = ('auto',)
    r14 = 'eth_hash'
    r15 = dank_mids.brownie_patch._abi.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L32 (error at <module>:4) else goto L6
L6:
    eth_hash = r16 :: module
    dec_ref r16
    r17 = ('_nocompile',)
    r18 = 'dank_mids.brownie_patch'
    r19 = dank_mids.brownie_patch._abi.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L32 (error at <module>:6) else goto L7
L7:
    dank_mids.brownie_patch = r20 :: module
    dec_ref r20
    r21 = ('_helpers',)
    r22 = 'dank_mids.helpers'
    r23 = dank_mids.brownie_patch._abi.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L32 (error at <module>:7) else goto L8
L8:
    dank_mids.helpers = r24 :: module
    dec_ref r24
    r25 = dank_mids.brownie_patch._abi.globals :: static
    r26 = 'Tuple'
    r27 = CPyDict_GetItem(r25, r26)
    if is_error(r27) goto L32 (error at <module>:10) else goto L9
L9:
    r28 = dank_mids.brownie_patch._abi.globals :: static
    r29 = 'Tuple'
    r30 = CPyDict_GetItem(r28, r29)
    if is_error(r30) goto L33 (error at <module>:10) else goto L10
L10:
    r31 = load_address PyUnicode_Type
    r32 = dank_mids.brownie_patch._abi.globals :: static
    r33 = 'Any'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L34 (error at <module>:10) else goto L11
L11:
    inc_ref r31
    r35 = (r31, r34)
    r36 = box(tuple[object, object], r35)
    r37 = PyObject_GetItem(r30, r36)
    dec_ref r30
    dec_ref r36
    if is_error(r37) goto L33 (error at <module>:10) else goto L12
L12:
    r38 = load_address _Py_EllipsisObject
    inc_ref r38
    r39 = (r37, r38)
    r40 = box(tuple[object, object], r39)
    r41 = PyObject_GetItem(r27, r40)
    dec_ref r27
    dec_ref r40
    if is_error(r41) goto L32 (error at <module>:10) else goto L13
L13:
    r42 = dank_mids.brownie_patch._abi.globals :: static
    r43 = 'SingletonKey'
    r44 = CPyDict_SetItem(r42, r43, r41)
    dec_ref r41
    r45 = r44 >= 0 :: signed
    if not r45 goto L32 (error at <module>:10) else goto L14 :: bool
L14:
    r46 = dank_mids.brownie_patch._abi.globals :: static
    r47 = 'WeakValueDictionary'
    r48 = CPyDict_GetItem(r46, r47)
    if is_error(r48) goto L32 (error at <module>:12) else goto L15
L15:
    r49 = _PyObject_Vectorcall(r48, 0, 0, 0)
    dec_ref r48
    if is_error(r49) goto L32 (error at <module>:12) else goto L16
L16:
    dank_mids.brownie_patch._abi._singletons = r49 :: static
    r50 = dank_mids.brownie_patch._abi.globals :: static
    r51 = '_singletons'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L32 (error at <module>:12) else goto L17 :: bool
L17:
    r54 = dank_mids.brownie_patch._abi.globals :: static
    r55 = 'auto'
    r56 = CPyDict_GetItem(r54, r55)
    if is_error(r56) goto L32 (error at <module>:15) else goto L18
L18:
    r57 = 'keccak'
    r58 = CPyObject_GetAttr(r56, r57)
    dec_ref r56
    if is_error(r58) goto L32 (error at <module>:15) else goto L19
L19:
    dank_mids.brownie_patch._abi.keccak = r58 :: static
    r59 = dank_mids.brownie_patch._abi.globals :: static
    r60 = 'keccak'
    r61 = CPyDict_SetItem(r59, r60, r58)
    dec_ref r58
    r62 = r61 >= 0 :: signed
    if not r62 goto L32 (error at <module>:15) else goto L20 :: bool
L20:
    r63 = dank_mids.brownie_patch._abi.globals :: static
    r64 = '_helpers'
    r65 = CPyDict_GetItem(r63, r64)
    if is_error(r65) goto L32 (error at <module>:17) else goto L21
L21:
    r66 = '_make_hashable'
    r67 = CPyObject_GetAttr(r65, r66)
    dec_ref r65
    if is_error(r67) goto L32 (error at <module>:17) else goto L22
L22:
    dank_mids.brownie_patch._abi._make_hashable = r67 :: static
    r68 = dank_mids.brownie_patch._abi.globals :: static
    r69 = '_make_hashable'
    r70 = CPyDict_SetItem(r68, r69, r67)
    dec_ref r67
    r71 = r70 >= 0 :: signed
    if not r71 goto L32 (error at <module>:17) else goto L23 :: bool
L23:
    r72 = dank_mids.brownie_patch._abi.globals :: static
    r73 = '_nocompile'
    r74 = CPyDict_GetItem(r72, r73)
    if is_error(r74) goto L32 (error at <module>:28) else goto L24
L24:
    r75 = '_FunctionABI'
    r76 = CPyObject_GetAttr(r74, r75)
    dec_ref r74
    if is_error(r76) goto L32 (error at <module>:28) else goto L25
L25:
    r77 = PyTuple_Pack(1, r76)
    dec_ref r76
    if is_error(r77) goto L32 (error at <module>:28) else goto L26
L26:
    r78 = 'dank_mids.brownie_patch._abi'
    r79 = dank_mids.brownie_patch._abi.FunctionABI_template :: type
    r80 = CPyType_FromTemplate(r79, r77, r78)
    dec_ref r77
    if is_error(r80) goto L32 (error at <module>:28) else goto L27
L27:
    r81 = FunctionABI_trait_vtable_setup()
    if is_error(r81) goto L35 (error at <module>:-1) else goto L28
L28:
    r82 = '__mypyc_attrs__'
    r83 = 'abi'
    r84 = 'input_sig'
    r85 = 'signature'
    r86 = '__dict__'
    r87 = PyTuple_Pack(4, r83, r84, r85, r86)
    if is_error(r87) goto L35 (error at <module>:28) else goto L29
L29:
    r88 = PyObject_SetAttr(r80, r82, r87)
    dec_ref r87
    r89 = r88 >= 0 :: signed
    if not r89 goto L35 (error at <module>:28) else goto L30 :: bool
L30:
    dank_mids.brownie_patch._abi.FunctionABI = r80 :: type
    r90 = dank_mids.brownie_patch._abi.globals :: static
    r91 = 'FunctionABI'
    r92 = CPyDict_SetItem(r90, r91, r80)
    dec_ref r80
    r93 = r92 >= 0 :: signed
    if not r93 goto L32 (error at <module>:28) else goto L31 :: bool
L31:
    return 1
L32:
    r94 = <error> :: None
    return r94
L33:
    dec_ref r27
    goto L32
L34:
    dec_ref r27
    dec_ref r30
    goto L32
L35:
    dec_ref r80
    goto L32

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13, r14 :: object_ptr
    r15 :: object_ptr[2]
    r16 :: c_ptr
    r17 :: native_int[2]
    r18 :: c_ptr
    r19 :: object
    r20 :: dict
    r21, r22 :: str
    r23 :: bit
    r24 :: object
    r25 :: str
    r26 :: dict
    r27, r28 :: object
    r29 :: str
    r30 :: dict
    r31, r32 :: object
    r33 :: str
    r34 :: dict
    r35, r36 :: object
    r37 :: str
    r38 :: dict
    r39, r40 :: object
    r41 :: str
    r42 :: dict
    r43 :: object
    r44 :: str
    r45 :: object
    r46 :: bool
    r47 :: object[1]
    r48 :: object_ptr
    r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: dict
    r55 :: str
    r56 :: object
    r57 :: str
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: i32
    r62 :: bit
    r63 :: bool
    r64 :: object
    r65 :: bool
    r66 :: str
    r67 :: object[1]
    r68 :: object_ptr
    r69 :: object
    r70 :: bool
    r71 :: object
    r72 :: bool
    r73 :: dict
    r74 :: str
    r75, r76 :: object
    r77 :: str
    r78 :: object[2]
    r79 :: object_ptr
    r80, r81 :: object
    r82 :: bool
    r83 :: int
    r84 :: bool
    r85 :: str
    r86 :: object
    r87 :: object[2]
    r88 :: object_ptr
    r89 :: object
    r90 :: bool
    r91 :: object
    r92 :: bool
    r93 :: int
    r94 :: bool
    r95 :: str
    r96 :: object
    r97 :: object[2]
    r98 :: object_ptr
    r99, r100 :: object
    r101 :: bool
    r102, r103 :: str
    r104 :: object[2]
    r105 :: object_ptr
    r106 :: object
    r107 :: str
    r108 :: dict
    r109 :: str
    r110 :: object
    r111 :: str
    r112 :: object
    r113 :: bool
    r114 :: object
    r115 :: object[4]
    r116 :: object_ptr
    r117, r118 :: object
    r119 :: dict
    r120 :: str
    r121 :: i32
    r122 :: bit
    r123 :: str
    r124, r125 :: object
    r126 :: bool
    r127 :: object
    r128 :: object[3]
    r129 :: object_ptr
    r130, r131 :: object
    r132 :: dict
    r133 :: str
    r134 :: i32
    r135 :: bit
    r136 :: str
    r137, r138 :: object
    r139 :: bool
    r140 :: object
    r141 :: object[3]
    r142 :: object_ptr
    r143, r144 :: object
    r145 :: dict
    r146 :: str
    r147 :: i32
    r148 :: bit
    r149 :: str
    r150, r151 :: object
    r152 :: bool
    r153 :: object
    r154 :: object[3]
    r155 :: object_ptr
    r156, r157 :: object
    r158 :: dict
    r159 :: str
    r160 :: i32
    r161 :: bit
    r162 :: str
    r163, r164 :: object
    r165 :: bool
    r166 :: object
    r167 :: object[3]
    r168 :: object_ptr
    r169, r170 :: object
    r171 :: dict
    r172 :: str
    r173 :: i32
    r174 :: bit
    r175 :: object
    r176 :: bool
    r177 :: str
    r178 :: object
    r179 :: str
    r180, r181 :: object
    r182 :: object[5]
    r183 :: object_ptr
    r184, r185 :: object
    r186 :: dict
    r187 :: str
    r188 :: i32
    r189 :: bit
    r190 :: str
    r191, r192 :: object
    r193 :: bool
    r194 :: i32
    r195 :: bit
    r196 :: bool
    r197 :: object
    r198 :: bool
    r199, r200 :: object
    r201 :: object[4]
    r202 :: object_ptr
    r203, r204 :: object
    r205 :: dict
    r206 :: str
    r207 :: i32
    r208 :: bit
    r209 :: object
    r210 :: bool
    r211 :: str
    r212 :: object
    r213 :: str
    r214, r215 :: object
    r216 :: object[5]
    r217 :: object_ptr
    r218, r219 :: object
    r220 :: dict
    r221 :: str
    r222 :: i32
    r223 :: bit
    r224 :: str
    r225, r226 :: object
    r227 :: bool
    r228 :: i32
    r229 :: bit
    r230 :: bool
    r231 :: object
    r232 :: bool
    r233 :: object
    r234 :: object[3]
    r235 :: object_ptr
    r236, r237 :: object
    r238 :: dict
    r239 :: str
    r240 :: i32
    r241 :: bit
    r242 :: str
    r243, r244 :: object
    r245 :: bool
    r246 :: object
    r247 :: object[3]
    r248 :: object_ptr
    r249, r250 :: object
    r251 :: dict
    r252 :: str
    r253 :: i32
    r254 :: bit
    r255 :: object
    r256 :: bool
    r257 :: str
    r258 :: object
    r259 :: str
    r260, r261 :: object
    r262 :: object[5]
    r263 :: object_ptr
    r264, r265 :: object
    r266 :: dict
    r267 :: str
    r268 :: i32
    r269 :: bit
    r270 :: str
    r271 :: dict
    r272 :: str
    r273, r274 :: object
    r275 :: bool
    r276 :: object
    r277 :: bool
    r278 :: str
    r279 :: object
    r280 :: i32
    r281 :: bit
    r282 :: bool
    r283 :: object
    r284 :: bool
    r285 :: object
    r286 :: object[4]
    r287 :: object_ptr
    r288, r289 :: object
    r290 :: dict
    r291 :: str
    r292 :: i32
    r293 :: bit
    r294 :: str
    r295 :: dict
    r296 :: str
    r297, r298 :: object
    r299 :: bool
    r300 :: str
    r301, r302, r303, r304 :: object
    r305 :: bool
    r306 :: str
    r307 :: object
    r308 :: i32
    r309 :: bit
    r310 :: bool
    r311 :: object
    r312 :: bool
    r313 :: object
    r314 :: object[4]
    r315 :: object_ptr
    r316, r317 :: object
    r318 :: dict
    r319 :: str
    r320 :: i32
    r321 :: bit
    r322 :: str
    r323 :: dict
    r324 :: str
    r325, r326 :: object
    r327 :: bool
    r328 :: str
    r329 :: object
    r330 :: i32
    r331 :: bit
    r332 :: bool
    r333 :: int
    r334 :: object
    r335 :: bool
    r336 :: str
    r337 :: object
    r338 :: i32
    r339 :: bit
    r340 :: bool
    r341 :: object
    r342 :: bool
    r343, r344 :: object
    r345 :: object[4]
    r346 :: object_ptr
    r347, r348 :: object
    r349 :: dict
    r350 :: str
    r351 :: i32
    r352 :: bit
    r353 :: str
    r354 :: dict
    r355 :: str
    r356, r357 :: object
    r358 :: bool
    r359 :: str
    r360 :: object
    r361 :: i32
    r362 :: bit
    r363 :: bool
    r364 :: int
    r365 :: object
    r366 :: bool
    r367 :: str
    r368 :: object
    r369 :: i32
    r370 :: bit
    r371 :: bool
    r372 :: object
    r373 :: bool
    r374, r375 :: object
    r376 :: object[4]
    r377 :: object_ptr
    r378, r379 :: object
    r380 :: dict
    r381 :: str
    r382 :: i32
    r383 :: bit
    r384 :: str
    r385 :: dict
    r386 :: str
    r387, r388 :: object
    r389 :: bool
    r390 :: str
    r391 :: object
    r392 :: i32
    r393 :: bit
    r394 :: bool
    r395 :: int
    r396 :: object
    r397 :: bool
    r398 :: str
    r399 :: object
    r400 :: i32
    r401 :: bit
    r402 :: bool
    r403 :: object
    r404 :: bool
    r405, r406 :: object
    r407 :: object[4]
    r408 :: object_ptr
    r409, r410 :: object
    r411 :: dict
    r412 :: str
    r413 :: i32
    r414 :: bit
    r415 :: str
    r416, r417 :: object
    r418 :: bool
    r419 :: str
    r420 :: object
    r421 :: i32
    r422 :: bit
    r423 :: bool
    r424 :: int
    r425 :: object
    r426 :: bool
    r427 :: str
    r428 :: object
    r429 :: i32
    r430 :: bit
    r431 :: bool
    r432 :: object
    r433 :: bool
    r434, r435 :: object
    r436 :: object[4]
    r437 :: object_ptr
    r438, r439 :: object
    r440 :: dict
    r441 :: str
    r442 :: i32
    r443 :: bit
    r444 :: str
    r445, r446 :: object
    r447 :: bool
    r448, r449 :: object
    r450 :: object[4]
    r451 :: object_ptr
    r452, r453 :: object
    r454 :: dict
    r455 :: str
    r456 :: i32
    r457 :: bit
    r458 :: str
    r459, r460 :: object
    r461 :: bool
    r462, r463 :: object
    r464 :: object[4]
    r465 :: object_ptr
    r466, r467 :: object
    r468 :: dict
    r469 :: str
    r470 :: i32
    r471 :: bit
    r472 :: str
    r473, r474 :: object
    r475 :: bool
    r476, r477 :: object
    r478 :: object[4]
    r479 :: object_ptr
    r480, r481 :: object
    r482 :: dict
    r483 :: str
    r484 :: i32
    r485 :: bit
    r486 :: str
    r487, r488 :: object
    r489 :: bool
    r490 :: object
    r491 :: bool
    r492 :: i32
    r493 :: bit
    r494 :: bool
    r495 :: object
    r496 :: bool
    r497 :: object
    r498 :: object[4]
    r499 :: object_ptr
    r500, r501 :: object
    r502 :: dict
    r503 :: str
    r504 :: i32
    r505 :: bit
    r506 :: str
    r507, r508 :: object
    r509 :: bool
    r510 :: object
    r511 :: object[3]
    r512 :: object_ptr
    r513, r514 :: object
    r515 :: dict
    r516 :: str
    r517 :: i32
    r518 :: bit
    r519, r520 :: str
    r521 :: dict
    r522 :: str
    r523, r524 :: object
    r525 :: bool
    r526 :: str
    r527, r528 :: object
    r529 :: bool
    r530 :: object
    r531 :: object[4]
    r532 :: object_ptr
    r533, r534 :: object
    r535, r536 :: str
    r537 :: dict
    r538 :: str
    r539 :: object
    r540 :: str
    r541, r542 :: object
    r543 :: bool
    r544, r545 :: object
    r546 :: object[4]
    r547 :: object_ptr
    r548, r549 :: object
    r550, r551 :: str
    r552 :: dict
    r553 :: str
    r554 :: object
    r555 :: str
    r556, r557 :: object
    r558 :: bool
    r559, r560 :: object
    r561 :: object[4]
    r562 :: object_ptr
    r563, r564 :: object
    r565, r566 :: dict
    r567 :: str
    r568 :: i32
    r569 :: bit
    r570 :: dict
    r571 :: str
    r572 :: object
    r573 :: str
    r574 :: object
    r575 :: str
    r576 :: object
    r577 :: i32
    r578 :: bit
    r579 :: bool
    r580 :: object
    r581 :: bool
    r582, r583 :: str
    r584 :: object[2]
    r585 :: object_ptr
    r586, r587 :: object
    r588 :: bool
    r589, r590 :: str
    r591 :: object[2]
    r592 :: object_ptr
    r593, r594 :: object
    r595 :: bool
    r596 :: str
    r597 :: object
    r598 :: i32
    r599 :: bit
    r600 :: bool
    r601 :: object
    r602 :: bool
    r603, r604 :: str
    r605 :: object[2]
    r606 :: object_ptr
    r607, r608 :: object
    r609 :: bool
    r610 :: str
    r611 :: object
    r612 :: i32
    r613 :: bit
    r614 :: bool
    r615 :: dict
    r616 :: str
    r617 :: object
    r618 :: dict
    r619 :: str
    r620 :: object
    r621 :: dict
    r622 :: str
    r623 :: object
    r624 :: set
    r625 :: i32
    r626 :: bit
    r627 :: i32
    r628 :: bit
    r629 :: i32
    r630 :: bit
    r631, r632 :: object
    r633 :: dict
    r634 :: str
    r635 :: i32
    r636 :: bit
    r637 :: dict
    r638 :: str
    r639 :: object
    r640 :: str
    r641 :: object
    r642 :: i32
    r643 :: bit
    r644 :: bool
    r645 :: str
    r646 :: dict
    r647 :: str
    r648 :: object
    r649 :: str
    r650 :: object
    r651, r652, r653 :: str
    r654 :: object
    r655 :: str
    r656 :: object
    r657 :: object[1]
    r658 :: object_ptr
    r659 :: object
    r660 :: bit
    r661 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L332 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('StreamHandler',)
    r6 = 'logging'
    r7 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L332 (error at <module>:2) else goto L4
L4:
    logging = r8 :: module
    dec_ref r8
    r9 = ('Dict', 'Final')
    r10 = 'typing'
    r11 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L332 (error at <module>:3) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = load_address a_sync :: module
    r14 = load_address typed_envs :: module
    r15 = [r13, r14]
    r16 = load_address r15
    r17 = [5, 6]
    r18 = load_address r17
    r19 = (('a_sync', 'a_sync', 'a_sync'), ('typed_envs', 'typed_envs', 'typed_envs'))
    r20 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r21 = 'dank_mids\\ENVIRONMENT_VARIABLES.py'
    r22 = '<module>'
    r23 = CPyImport_ImportMany(r19, r16, r20, r21, r22, r18)
    if not r23 goto L332 else goto L6 :: bool
L6:
    r24 = ('AsyncProcessPoolExecutor',)
    r25 = 'a_sync'
    r26 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r27 = CPyImport_ImportFromMany(r25, r24, r24, r26)
    if is_error(r27) goto L332 (error at <module>:7) else goto L7
L7:
    a_sync = r27 :: module
    dec_ref r27
    r28 = ('_envs',)
    r29 = 'dank_mids'
    r30 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r31 = CPyImport_ImportFromMany(r29, r28, r28, r30)
    if is_error(r31) goto L332 (error at <module>:9) else goto L8
L8:
    dank_mids = r31 :: module
    dec_ref r31
    r32 = ('INFO', 'getLogger')
    r33 = 'dank_mids._logging'
    r34 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r35 = CPyImport_ImportFromMany(r33, r32, r32, r34)
    if is_error(r35) goto L332 (error at <module>:10) else goto L9
L9:
    dank_mids._logging = r35 :: module
    dec_ref r35
    r36 = ('OperationMode',)
    r37 = 'dank_mids._mode'
    r38 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r39 = CPyImport_ImportFromMany(r37, r36, r36, r38)
    if is_error(r39) goto L332 (error at <module>:11) else goto L10
L10:
    dank_mids._mode = r39 :: module
    dec_ref r39
    r40 = ('BlockSemaphore',)
    r41 = 'dank_mids.semaphores'
    r42 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r43 = CPyImport_ImportFromMany(r41, r40, r40, r42)
    if is_error(r43) goto L332 (error at <module>:12) else goto L11
L11:
    dank_mids.semaphores = r43 :: module
    dec_ref r43
    r44 = 'dank_mids.envs'
    r45 = dank_mids._logging.getLogger :: static
    if is_error(r45) goto L12 else goto L14
L12:
    r46 = raise NameError('value for final name "getLogger" was not set')
    if not r46 goto L332 (error at <module>:15) else goto L13 :: bool
L13:
    unreachable
L14:
    r47 = [r44]
    r48 = load_address r47
    r49 = _PyObject_Vectorcall(r45, r48, 1, 0)
    if is_error(r49) goto L332 (error at <module>:15) else goto L15
L15:
    dank_mids.ENVIRONMENT_VARIABLES.logger = r49 :: static
    r50 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r51 = 'logger'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L332 (error at <module>:15) else goto L16 :: bool
L16:
    r54 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r55 = 'typed_envs'
    r56 = CPyDict_GetItem(r54, r55)
    if is_error(r56) goto L332 (error at <module>:17) else goto L17
L17:
    r57 = 'logger'
    r58 = CPyObject_GetAttr(r56, r57)
    dec_ref r56
    if is_error(r58) goto L332 (error at <module>:17) else goto L18
L18:
    r59 = 'disabled'
    r60 = CPyObject_GetAttr(r58, r59)
    dec_ref r58
    if is_error(r60) goto L332 (error at <module>:17) else goto L19
L19:
    r61 = PyObject_IsTrue(r60)
    dec_ref r60
    r62 = r61 >= 0 :: signed
    if not r62 goto L332 (error at <module>:17) else goto L20 :: bool
L20:
    r63 = truncate r61: i32 to builtins.bool
    if r63 goto L55 else goto L21 :: bool
L21:
    r64 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r64) goto L22 else goto L24
L22:
    r65 = raise NameError('value for final name "logger" was not set')
    if not r65 goto L332 (error at <module>:18) else goto L23 :: bool
L23:
    unreachable
L24:
    r66 = 'hasHandlers'
    r67 = [r64]
    r68 = load_address r67
    r69 = PyObject_VectorcallMethod(r66, r68, 9223372036854775809, 0)
    if is_error(r69) goto L332 (error at <module>:18) else goto L25
L25:
    r70 = unbox(bool, r69)
    dec_ref r69
    if is_error(r70) goto L332 (error at <module>:18) else goto L26
L26:
    if r70 goto L34 else goto L27 :: bool
L27:
    r71 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r71) goto L28 else goto L30
L28:
    r72 = raise NameError('value for final name "logger" was not set')
    if not r72 goto L332 (error at <module>:19) else goto L29 :: bool
L29:
    unreachable
L30:
    r73 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r74 = 'StreamHandler'
    r75 = CPyDict_GetItem(r73, r74)
    if is_error(r75) goto L332 (error at <module>:19) else goto L31
L31:
    r76 = _PyObject_Vectorcall(r75, 0, 0, 0)
    dec_ref r75
    if is_error(r76) goto L332 (error at <module>:19) else goto L32
L32:
    r77 = 'addHandler'
    r78 = [r71, r76]
    r79 = load_address r78
    r80 = PyObject_VectorcallMethod(r77, r79, 9223372036854775810, 0)
    if is_error(r80) goto L333 (error at <module>:19) else goto L334
L33:
    dec_ref r76
L34:
    r81 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r81) goto L35 else goto L37
L35:
    r82 = raise NameError('value for final name "logger" was not set')
    if not r82 goto L332 (error at <module>:20) else goto L36 :: bool
L36:
    unreachable
L37:
    r83 = dank_mids._logging.INFO :: static
    if is_error(r83) goto L38 else goto L40
L38:
    r84 = raise NameError('value for final name "INFO" was not set')
    if not r84 goto L332 (error at <module>:20) else goto L39 :: bool
L39:
    unreachable
L40:
    r85 = 'isEnabledFor'
    inc_ref r83 :: int
    r86 = box(int, r83)
    r87 = [r81, r86]
    r88 = load_address r87
    r89 = PyObject_VectorcallMethod(r85, r88, 9223372036854775810, 0)
    if is_error(r89) goto L335 (error at <module>:20) else goto L41
L41:
    dec_ref r86
    r90 = unbox(bool, r89)
    dec_ref r89
    if is_error(r90) goto L332 (error at <module>:20) else goto L42
L42:
    if r90 goto L51 else goto L43 :: bool
L43:
    r91 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r91) goto L44 else goto L46
L44:
    r92 = raise NameError('value for final name "logger" was not set')
    if not r92 goto L332 (error at <module>:21) else goto L45 :: bool
L45:
    unreachable
L46:
    r93 = dank_mids._logging.INFO :: static
    if is_error(r93) goto L47 else goto L49
L47:
    r94 = raise NameError('value for final name "INFO" was not set')
    if not r94 goto L332 (error at <module>:21) else goto L48 :: bool
L48:
    unreachable
L49:
    r95 = 'setLevel'
    inc_ref r93 :: int
    r96 = box(int, r93)
    r97 = [r91, r96]
    r98 = load_address r97
    r99 = PyObject_VectorcallMethod(r95, r98, 9223372036854775810, 0)
    if is_error(r99) goto L336 (error at <module>:21) else goto L337
L50:
    dec_ref r96
L51:
    r100 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r100) goto L52 else goto L54
L52:
    r101 = raise NameError('value for final name "logger" was not set')
    if not r101 goto L332 (error at <module>:22) else goto L53 :: bool
L53:
    unreachable
L54:
    r102 = 'For your information, you can tweak your configuration for optimal performance using any of the envs below:'
    r103 = 'info'
    r104 = [r100, r102]
    r105 = load_address r104
    r106 = PyObject_VectorcallMethod(r103, r105, 9223372036854775810, 0)
    if is_error(r106) goto L332 (error at <module>:22) else goto L338
L55:
    r107 = 'OPERATION_MODE'
    r108 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r109 = 'OperationMode'
    r110 = CPyDict_GetItem(r108, r109)
    if is_error(r110) goto L332 (error at <module>:35) else goto L56
L56:
    r111 = 'infura'
    r112 = dank_mids._envs.create_env :: static
    if is_error(r112) goto L339 else goto L59
L57:
    r113 = raise NameError('value for final name "create_env" was not set')
    if not r113 goto L332 (error at <module>:34) else goto L58 :: bool
L58:
    unreachable
L59:
    r114 = box(bool, 0)
    r115 = [r107, r110, r111, r114]
    r116 = load_address r115
    r117 = ('default', 'verbose')
    r118 = _PyObject_Vectorcall(r112, r116, 2, r117)
    if is_error(r118) goto L340 (error at <module>:34) else goto L60
L60:
    dec_ref r110
    dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE = r118 :: static
    r119 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r120 = 'OPERATION_MODE'
    r121 = CPyDict_SetItem(r119, r120, r118)
    dec_ref r118
    r122 = r121 >= 0 :: signed
    if not r122 goto L332 (error at <module>:34) else goto L61 :: bool
L61:
    r123 = 'MAX_MULTICALL_SIZE'
    r124 = load_address PyLong_Type
    r125 = dank_mids._envs.create_env :: static
    if is_error(r125) goto L62 else goto L64
L62:
    r126 = raise NameError('value for final name "create_env" was not set')
    if not r126 goto L332 (error at <module>:39) else goto L63 :: bool
L63:
    unreachable
L64:
    r127 = object 10000
    r128 = [r123, r124, r127]
    r129 = load_address r128
    r130 = ('default',)
    r131 = _PyObject_Vectorcall(r125, r129, 2, r130)
    if is_error(r131) goto L332 (error at <module>:39) else goto L65
L65:
    dank_mids.ENVIRONMENT_VARIABLES.MAX_MULTICALL_SIZE = r131 :: static
    r132 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r133 = 'MAX_MULTICALL_SIZE'
    r134 = CPyDict_SetItem(r132, r133, r131)
    dec_ref r131
    r135 = r134 >= 0 :: signed
    if not r135 goto L332 (error at <module>:39) else goto L66 :: bool
L66:
    r136 = 'MAX_JSONRPC_BATCH_SIZE'
    r137 = load_address PyLong_Type
    r138 = dank_mids._envs.create_env :: static
    if is_error(r138) goto L67 else goto L69
L67:
    r139 = raise NameError('value for final name "create_env" was not set')
    if not r139 goto L332 (error at <module>:41) else goto L68 :: bool
L68:
    unreachable
L69:
    r140 = object 500
    r141 = [r136, r137, r140]
    r142 = load_address r141
    r143 = ('default',)
    r144 = _PyObject_Vectorcall(r138, r142, 2, r143)
    if is_error(r144) goto L332 (error at <module>:41) else goto L70
L70:
    dank_mids.ENVIRONMENT_VARIABLES.MAX_JSONRPC_BATCH_SIZE = r144 :: static
    r145 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r146 = 'MAX_JSONRPC_BATCH_SIZE'
    r147 = CPyDict_SetItem(r145, r146, r144)
    dec_ref r144
    r148 = r147 >= 0 :: signed
    if not r148 goto L332 (error at <module>:41) else goto L71 :: bool
L71:
    r149 = 'REQUESTS_PER_SECOND'
    r150 = load_address PyLong_Type
    r151 = dank_mids._envs.create_env :: static
    if is_error(r151) goto L72 else goto L74
L72:
    r152 = raise NameError('value for final name "create_env" was not set')
    if not r152 goto L332 (error at <module>:43) else goto L73 :: bool
L73:
    unreachable
L74:
    r153 = object 50
    r154 = [r149, r150, r153]
    r155 = load_address r154
    r156 = ('default',)
    r157 = _PyObject_Vectorcall(r151, r155, 2, r156)
    if is_error(r157) goto L332 (error at <module>:43) else goto L75
L75:
    dank_mids.ENVIRONMENT_VARIABLES.REQUESTS_PER_SECOND = r157 :: static
    r158 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r159 = 'REQUESTS_PER_SECOND'
    r160 = CPyDict_SetItem(r158, r159, r157)
    dec_ref r157
    r161 = r160 >= 0 :: signed
    if not r161 goto L332 (error at <module>:43) else goto L76 :: bool
L76:
    r162 = 'MIN_REQUESTS_PER_SECOND'
    r163 = load_address PyLong_Type
    r164 = dank_mids._envs.create_env :: static
    if is_error(r164) goto L77 else goto L79
L77:
    r165 = raise NameError('value for final name "create_env" was not set')
    if not r165 goto L332 (error at <module>:45) else goto L78 :: bool
L78:
    unreachable
L79:
    r166 = object 10
    r167 = [r162, r163, r166]
    r168 = load_address r167
    r169 = ('default',)
    r170 = _PyObject_Vectorcall(r164, r168, 2, r169)
    if is_error(r170) goto L332 (error at <module>:45) else goto L80
L80:
    dank_mids.ENVIRONMENT_VARIABLES.MIN_REQUESTS_PER_SECOND = r170 :: static
    r171 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r172 = 'MIN_REQUESTS_PER_SECOND'
    r173 = CPyDict_SetItem(r171, r172, r170)
    dec_ref r170
    r174 = r173 >= 0 :: signed
    if not r174 goto L332 (error at <module>:45) else goto L81 :: bool
L81:
    r175 = dank_mids._envs._deprecated_format :: static
    if is_error(r175) goto L82 else goto L84
L82:
    r176 = raise NameError('value for final name "_deprecated_format" was not set')
    if not r176 goto L332 (error at <module>:48) else goto L83 :: bool
L83:
    unreachable
L84:
    r177 = 'DEMO_MODE'
    r178 = load_address PyBool_Type
    r179 = 'create_env'
    r180 = box(bool, 0)
    r181 = box(bool, 0)
    r182 = [r175, r177, r178, r180, r181]
    r183 = load_address r182
    r184 = ('default', 'verbose')
    r185 = PyObject_VectorcallMethod(r179, r183, 9223372036854775811, r184)
    if is_error(r185) goto L332 (error at <module>:48) else goto L85
L85:
    dank_mids.ENVIRONMENT_VARIABLES.demo_mode = r185 :: static
    r186 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r187 = 'demo_mode'
    r188 = CPyDict_SetItem(r186, r187, r185)
    dec_ref r185
    r189 = r188 >= 0 :: signed
    if not r189 goto L332 (error at <module>:48) else goto L86 :: bool
L86:
    r190 = 'DEMO_MODE'
    r191 = load_address PyBool_Type
    r192 = dank_mids.ENVIRONMENT_VARIABLES.demo_mode :: static
    if is_error(r192) goto L87 else goto L89
L87:
    r193 = raise NameError('value for final name "demo_mode" was not set')
    if not r193 goto L332 (error at <module>:51) else goto L88 :: bool
L88:
    unreachable
L89:
    r194 = PyObject_IsTrue(r192)
    r195 = r194 >= 0 :: signed
    if not r195 goto L332 (error at <module>:51) else goto L90 :: bool
L90:
    r196 = truncate r194: i32 to builtins.bool
    r197 = dank_mids._envs.create_env :: static
    if is_error(r197) goto L91 else goto L93
L91:
    r198 = raise NameError('value for final name "create_env" was not set')
    if not r198 goto L332 (error at <module>:51) else goto L92 :: bool
L92:
    unreachable
L93:
    r199 = box(bool, r196)
    r200 = box(bool, 0)
    r201 = [r190, r191, r199, r200]
    r202 = load_address r201
    r203 = ('default', 'verbose')
    r204 = _PyObject_Vectorcall(r197, r202, 2, r203)
    if is_error(r204) goto L332 (error at <module>:51) else goto L94
L94:
    dank_mids.ENVIRONMENT_VARIABLES.DEMO_MODE = r204 :: static
    r205 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r206 = 'DEMO_MODE'
    r207 = CPyDict_SetItem(r205, r206, r204)
    dec_ref r204
    r208 = r207 >= 0 :: signed
    if not r208 goto L332 (error at <module>:51) else goto L95 :: bool
L95:
    r209 = dank_mids._envs._deprecated_format :: static
    if is_error(r209) goto L96 else goto L98
L96:
    r210 = raise NameError('value for final name "_deprecated_format" was not set')
    if not r210 goto L332 (error at <module>:54) else goto L97 :: bool
L97:
    unreachable
L98:
    r211 = 'GANACHE_FORK'
    r212 = load_address PyBool_Type
    r213 = 'create_env'
    r214 = box(bool, 0)
    r215 = box(bool, 0)
    r216 = [r209, r211, r212, r214, r215]
    r217 = load_address r216
    r218 = ('default', 'verbose')
    r219 = PyObject_VectorcallMethod(r213, r217, 9223372036854775811, r218)
    if is_error(r219) goto L332 (error at <module>:54) else goto L99
L99:
    dank_mids.ENVIRONMENT_VARIABLES.ganache_fork = r219 :: static
    r220 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r221 = 'ganache_fork'
    r222 = CPyDict_SetItem(r220, r221, r219)
    dec_ref r219
    r223 = r222 >= 0 :: signed
    if not r223 goto L332 (error at <module>:54) else goto L100 :: bool
L100:
    r224 = 'GANACHE_FORK'
    r225 = load_address PyBool_Type
    r226 = dank_mids.ENVIRONMENT_VARIABLES.ganache_fork :: static
    if is_error(r226) goto L101 else goto L103
L101:
    r227 = raise NameError('value for final name "ganache_fork" was not set')
    if not r227 goto L332 (error at <module>:57) else goto L102 :: bool
L102:
    unreachable
L103:
    r228 = PyObject_IsTrue(r226)
    r229 = r228 >= 0 :: signed
    if not r229 goto L332 (error at <module>:57) else goto L104 :: bool
L104:
    r230 = truncate r228: i32 to builtins.bool
    r231 = dank_mids._envs.create_env :: static
    if is_error(r231) goto L105 else goto L107
L105:
    r232 = raise NameError('value for final name "create_env" was not set')
    if not r232 goto L332 (error at <module>:57) else goto L106 :: bool
L106:
    unreachable
L107:
    r233 = box(bool, r230)
    r234 = [r224, r225, r233]
    r235 = load_address r234
    r236 = ('default',)
    r237 = _PyObject_Vectorcall(r231, r235, 2, r236)
    if is_error(r237) goto L332 (error at <module>:57) else goto L108
L108:
    dank_mids.ENVIRONMENT_VARIABLES.GANACHE_FORK = r237 :: static
    r238 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r239 = 'GANACHE_FORK'
    r240 = CPyDict_SetItem(r238, r239, r237)
    dec_ref r237
    r241 = r240 >= 0 :: signed
    if not r241 goto L332 (error at <module>:57) else goto L109 :: bool
L109:
    r242 = 'AIOHTTP_TIMEOUT'
    r243 = load_address PyLong_Type
    r244 = dank_mids._envs.create_env :: static
    if is_error(r244) goto L110 else goto L112
L110:
    r245 = raise NameError('value for final name "create_env" was not set')
    if not r245 goto L332 (error at <module>:61) else goto L111 :: bool
L111:
    unreachable
L112:
    r246 = object 1200
    r247 = [r242, r243, r246]
    r248 = load_address r247
    r249 = ('default',)
    r250 = _PyObject_Vectorcall(r244, r248, 2, r249)
    if is_error(r250) goto L332 (error at <module>:61) else goto L113
L113:
    dank_mids.ENVIRONMENT_VARIABLES.AIOHTTP_TIMEOUT = r250 :: static
    r251 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r252 = 'AIOHTTP_TIMEOUT'
    r253 = CPyDict_SetItem(r251, r252, r250)
    dec_ref r250
    r254 = r253 >= 0 :: signed
    if not r254 goto L332 (error at <module>:61) else goto L114 :: bool
L114:
    r255 = dank_mids._envs._deprecated_format :: static
    if is_error(r255) goto L115 else goto L117
L115:
    r256 = raise NameError('value for final name "_deprecated_format" was not set')
    if not r256 goto L332 (error at <module>:67) else goto L116 :: bool
L116:
    unreachable
L117:
    r257 = 'BROWNIE_CALL_SEMAPHORE'
    r258 = load_address PyLong_Type
    r259 = 'create_env'
    r260 = object 100000
    r261 = box(bool, 0)
    r262 = [r255, r257, r258, r260, r261]
    r263 = load_address r262
    r264 = ('default', 'verbose')
    r265 = PyObject_VectorcallMethod(r259, r263, 9223372036854775811, r264)
    if is_error(r265) goto L332 (error at <module>:67) else goto L118
L118:
    dank_mids.ENVIRONMENT_VARIABLES.brownie_semaphore = r265 :: static
    r266 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r267 = 'brownie_semaphore'
    r268 = CPyDict_SetItem(r266, r267, r265)
    dec_ref r265
    r269 = r268 >= 0 :: signed
    if not r269 goto L332 (error at <module>:67) else goto L119 :: bool
L119:
    r270 = 'BROWNIE_CALL_SEMAPHORE'
    r271 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r272 = 'BlockSemaphore'
    r273 = CPyDict_GetItem(r271, r272)
    if is_error(r273) goto L332 (error at <module>:72) else goto L120
L120:
    r274 = dank_mids.ENVIRONMENT_VARIABLES.brownie_semaphore :: static
    if is_error(r274) goto L341 else goto L123
L121:
    r275 = raise NameError('value for final name "brownie_semaphore" was not set')
    if not r275 goto L332 (error at <module>:73) else goto L122 :: bool
L122:
    unreachable
L123:
    r276 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r276) goto L342 else goto L126
L124:
    r277 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r277 goto L332 (error at <module>:74) else goto L125 :: bool
L125:
    unreachable
L126:
    r278 = 'infura'
    r279 = CPyObject_GetAttr(r276, r278)
    if is_error(r279) goto L343 (error at <module>:74) else goto L127
L127:
    r280 = PyObject_Not(r279)
    dec_ref r279
    r281 = r280 >= 0 :: signed
    if not r281 goto L343 (error at <module>:74) else goto L128 :: bool
L128:
    r282 = truncate r280: i32 to builtins.bool
    r283 = dank_mids._envs.create_env :: static
    if is_error(r283) goto L344 else goto L131
L129:
    r284 = raise NameError('value for final name "create_env" was not set')
    if not r284 goto L332 (error at <module>:70) else goto L130 :: bool
L130:
    unreachable
L131:
    r285 = box(bool, r282)
    r286 = [r270, r273, r274, r285]
    r287 = load_address r286
    r288 = ('default', 'verbose')
    r289 = _PyObject_Vectorcall(r283, r287, 2, r288)
    if is_error(r289) goto L343 (error at <module>:70) else goto L132
L132:
    dec_ref r273
    dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE = r289 :: static
    r290 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r291 = 'BROWNIE_CALL_SEMAPHORE'
    r292 = CPyDict_SetItem(r290, r291, r289)
    dec_ref r289
    r293 = r292 >= 0 :: signed
    if not r293 goto L332 (error at <module>:70) else goto L133 :: bool
L133:
    r294 = 'BROWNIE_ENCODER_SEMAPHORE'
    r295 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r296 = 'BlockSemaphore'
    r297 = CPyDict_GetItem(r295, r296)
    if is_error(r297) goto L332 (error at <module>:85) else goto L134
L134:
    r298 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE :: static
    if is_error(r298) goto L345 else goto L137
L135:
    r299 = raise NameError('value for final name "BROWNIE_CALL_SEMAPHORE" was not set')
    if not r299 goto L332 (error at <module>:86) else goto L136 :: bool
L136:
    unreachable
L137:
    r300 = '_default_value'
    r301 = CPyObject_GetAttr(r298, r300)
    if is_error(r301) goto L346 (error at <module>:86) else goto L138
L138:
    r302 = object 2
    r303 = PyNumber_Multiply(r301, r302)
    dec_ref r301
    if is_error(r303) goto L346 (error at <module>:86) else goto L139
L139:
    r304 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r304) goto L347 else goto L142
L140:
    r305 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r305 goto L332 (error at <module>:87) else goto L141 :: bool
L141:
    unreachable
L142:
    r306 = 'infura'
    r307 = CPyObject_GetAttr(r304, r306)
    if is_error(r307) goto L348 (error at <module>:87) else goto L143
L143:
    r308 = PyObject_Not(r307)
    dec_ref r307
    r309 = r308 >= 0 :: signed
    if not r309 goto L348 (error at <module>:87) else goto L144 :: bool
L144:
    r310 = truncate r308: i32 to builtins.bool
    r311 = dank_mids._envs.create_env :: static
    if is_error(r311) goto L349 else goto L147
L145:
    r312 = raise NameError('value for final name "create_env" was not set')
    if not r312 goto L332 (error at <module>:83) else goto L146 :: bool
L146:
    unreachable
L147:
    r313 = box(bool, r310)
    r314 = [r294, r297, r303, r313]
    r315 = load_address r314
    r316 = ('default', 'verbose')
    r317 = _PyObject_Vectorcall(r311, r315, 2, r316)
    if is_error(r317) goto L348 (error at <module>:83) else goto L148
L148:
    dec_ref r297
    dec_ref r303
    dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_ENCODER_SEMAPHORE = r317 :: static
    r318 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r319 = 'BROWNIE_ENCODER_SEMAPHORE'
    r320 = CPyDict_SetItem(r318, r319, r317)
    dec_ref r317
    r321 = r320 >= 0 :: signed
    if not r321 goto L332 (error at <module>:83) else goto L149 :: bool
L149:
    r322 = 'BROWNIE_ENCODER_PROCESSES'
    r323 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r324 = 'AsyncProcessPoolExecutor'
    r325 = CPyDict_GetItem(r323, r324)
    if is_error(r325) goto L332 (error at <module>:101) else goto L150
L150:
    r326 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r326) goto L350 else goto L153
L151:
    r327 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r327 goto L332 (error at <module>:102) else goto L152 :: bool
L152:
    unreachable
L153:
    r328 = 'infura'
    r329 = CPyObject_GetAttr(r326, r328)
    if is_error(r329) goto L351 (error at <module>:102) else goto L154
L154:
    r330 = PyObject_IsTrue(r329)
    dec_ref r329
    r331 = r330 >= 0 :: signed
    if not r331 goto L351 (error at <module>:102) else goto L155 :: bool
L155:
    r332 = truncate r330: i32 to builtins.bool
    if r332 goto L156 else goto L157 :: bool
L156:
    r333 = 0
    goto L158
L157:
    r333 = 2
L158:
    r334 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r334) goto L352 else goto L161
L159:
    r335 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r335 goto L332 (error at <module>:103) else goto L160 :: bool
L160:
    unreachable
L161:
    r336 = 'infura'
    r337 = CPyObject_GetAttr(r334, r336)
    if is_error(r337) goto L353 (error at <module>:103) else goto L162
L162:
    r338 = PyObject_Not(r337)
    dec_ref r337
    r339 = r338 >= 0 :: signed
    if not r339 goto L353 (error at <module>:103) else goto L163 :: bool
L163:
    r340 = truncate r338: i32 to builtins.bool
    r341 = dank_mids._envs.create_env :: static
    if is_error(r341) goto L354 else goto L166
L164:
    r342 = raise NameError('value for final name "create_env" was not set')
    if not r342 goto L332 (error at <module>:99) else goto L165 :: bool
L165:
    unreachable
L166:
    r343 = box(int, r333)
    r344 = box(bool, r340)
    r345 = [r322, r325, r343, r344]
    r346 = load_address r345
    r347 = ('default', 'verbose')
    r348 = _PyObject_Vectorcall(r341, r346, 2, r347)
    if is_error(r348) goto L355 (error at <module>:99) else goto L167
L167:
    dec_ref r325
    dec_ref r343
    r349 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r350 = 'BROWNIE_ENCODER_PROCESSES'
    r351 = CPyDict_SetItem(r349, r350, r348)
    dec_ref r348
    r352 = r351 >= 0 :: signed
    if not r352 goto L332 (error at <module>:99) else goto L168 :: bool
L168:
    r353 = 'BROWNIE_DECODER_PROCESSES'
    r354 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r355 = 'AsyncProcessPoolExecutor'
    r356 = CPyDict_GetItem(r354, r355)
    if is_error(r356) goto L332 (error at <module>:114) else goto L169
L169:
    r357 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r357) goto L356 else goto L172
L170:
    r358 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r358 goto L332 (error at <module>:115) else goto L171 :: bool
L171:
    unreachable
L172:
    r359 = 'infura'
    r360 = CPyObject_GetAttr(r357, r359)
    if is_error(r360) goto L357 (error at <module>:115) else goto L173
L173:
    r361 = PyObject_IsTrue(r360)
    dec_ref r360
    r362 = r361 >= 0 :: signed
    if not r362 goto L357 (error at <module>:115) else goto L174 :: bool
L174:
    r363 = truncate r361: i32 to builtins.bool
    if r363 goto L175 else goto L176 :: bool
L175:
    r364 = 0
    goto L177
L176:
    r364 = 2
L177:
    r365 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r365) goto L358 else goto L180
L178:
    r366 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r366 goto L332 (error at <module>:116) else goto L179 :: bool
L179:
    unreachable
L180:
    r367 = 'infura'
    r368 = CPyObject_GetAttr(r365, r367)
    if is_error(r368) goto L359 (error at <module>:116) else goto L181
L181:
    r369 = PyObject_Not(r368)
    dec_ref r368
    r370 = r369 >= 0 :: signed
    if not r370 goto L359 (error at <module>:116) else goto L182 :: bool
L182:
    r371 = truncate r369: i32 to builtins.bool
    r372 = dank_mids._envs.create_env :: static
    if is_error(r372) goto L360 else goto L185
L183:
    r373 = raise NameError('value for final name "create_env" was not set')
    if not r373 goto L332 (error at <module>:112) else goto L184 :: bool
L184:
    unreachable
L185:
    r374 = box(int, r364)
    r375 = box(bool, r371)
    r376 = [r353, r356, r374, r375]
    r377 = load_address r376
    r378 = ('default', 'verbose')
    r379 = _PyObject_Vectorcall(r372, r377, 2, r378)
    if is_error(r379) goto L361 (error at <module>:112) else goto L186
L186:
    dec_ref r356
    dec_ref r374
    r380 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r381 = 'BROWNIE_DECODER_PROCESSES'
    r382 = CPyDict_SetItem(r380, r381, r379)
    dec_ref r379
    r383 = r382 >= 0 :: signed
    if not r383 goto L332 (error at <module>:112) else goto L187 :: bool
L187:
    r384 = 'MULTICALL_DECODER_PROCESSES'
    r385 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r386 = 'AsyncProcessPoolExecutor'
    r387 = CPyDict_GetItem(r385, r386)
    if is_error(r387) goto L332 (error at <module>:127) else goto L188
L188:
    r388 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r388) goto L362 else goto L191
L189:
    r389 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r389 goto L332 (error at <module>:128) else goto L190 :: bool
L190:
    unreachable
L191:
    r390 = 'infura'
    r391 = CPyObject_GetAttr(r388, r390)
    if is_error(r391) goto L363 (error at <module>:128) else goto L192
L192:
    r392 = PyObject_IsTrue(r391)
    dec_ref r391
    r393 = r392 >= 0 :: signed
    if not r393 goto L363 (error at <module>:128) else goto L193 :: bool
L193:
    r394 = truncate r392: i32 to builtins.bool
    if r394 goto L194 else goto L195 :: bool
L194:
    r395 = 0
    goto L196
L195:
    r395 = 2
L196:
    r396 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r396) goto L364 else goto L199
L197:
    r397 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r397 goto L332 (error at <module>:129) else goto L198 :: bool
L198:
    unreachable
L199:
    r398 = 'infura'
    r399 = CPyObject_GetAttr(r396, r398)
    if is_error(r399) goto L365 (error at <module>:129) else goto L200
L200:
    r400 = PyObject_Not(r399)
    dec_ref r399
    r401 = r400 >= 0 :: signed
    if not r401 goto L365 (error at <module>:129) else goto L201 :: bool
L201:
    r402 = truncate r400: i32 to builtins.bool
    r403 = dank_mids._envs.create_env :: static
    if is_error(r403) goto L366 else goto L204
L202:
    r404 = raise NameError('value for final name "create_env" was not set')
    if not r404 goto L332 (error at <module>:125) else goto L203 :: bool
L203:
    unreachable
L204:
    r405 = box(int, r395)
    r406 = box(bool, r402)
    r407 = [r384, r387, r405, r406]
    r408 = load_address r407
    r409 = ('default', 'verbose')
    r410 = _PyObject_Vectorcall(r403, r408, 2, r409)
    if is_error(r410) goto L367 (error at <module>:125) else goto L205
L205:
    dec_ref r387
    dec_ref r405
    r411 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r412 = 'MULTICALL_DECODER_PROCESSES'
    r413 = CPyDict_SetItem(r411, r412, r410)
    dec_ref r410
    r414 = r413 >= 0 :: signed
    if not r414 goto L332 (error at <module>:125) else goto L206 :: bool
L206:
    r415 = 'COLLECTION_FACTOR'
    r416 = load_address PyLong_Type
    r417 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r417) goto L207 else goto L209
L207:
    r418 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r418 goto L332 (error at <module>:141) else goto L208 :: bool
L208:
    unreachable
L209:
    r419 = 'infura'
    r420 = CPyObject_GetAttr(r417, r419)
    if is_error(r420) goto L332 (error at <module>:141) else goto L210
L210:
    r421 = PyObject_IsTrue(r420)
    dec_ref r420
    r422 = r421 >= 0 :: signed
    if not r422 goto L332 (error at <module>:141) else goto L211 :: bool
L211:
    r423 = truncate r421: i32 to builtins.bool
    if r423 goto L212 else goto L213 :: bool
L212:
    r424 = 20
    goto L214
L213:
    r424 = 2
L214:
    r425 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r425) goto L368 else goto L217
L215:
    r426 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r426 goto L332 (error at <module>:142) else goto L216 :: bool
L216:
    unreachable
L217:
    r427 = 'infura'
    r428 = CPyObject_GetAttr(r425, r427)
    if is_error(r428) goto L369 (error at <module>:142) else goto L218
L218:
    r429 = PyObject_Not(r428)
    dec_ref r428
    r430 = r429 >= 0 :: signed
    if not r430 goto L369 (error at <module>:142) else goto L219 :: bool
L219:
    r431 = truncate r429: i32 to builtins.bool
    r432 = dank_mids._envs.create_env :: static
    if is_error(r432) goto L370 else goto L222
L220:
    r433 = raise NameError('value for final name "create_env" was not set')
    if not r433 goto L332 (error at <module>:138) else goto L221 :: bool
L221:
    unreachable
L222:
    r434 = box(int, r424)
    r435 = box(bool, r431)
    r436 = [r415, r416, r434, r435]
    r437 = load_address r436
    r438 = ('default', 'verbose')
    r439 = _PyObject_Vectorcall(r432, r437, 2, r438)
    if is_error(r439) goto L371 (error at <module>:138) else goto L223
L223:
    dec_ref r434
    dank_mids.ENVIRONMENT_VARIABLES.COLLECTION_FACTOR = r439 :: static
    r440 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r441 = 'COLLECTION_FACTOR'
    r442 = CPyDict_SetItem(r440, r441, r439)
    dec_ref r439
    r443 = r442 >= 0 :: signed
    if not r443 goto L332 (error at <module>:138) else goto L224 :: bool
L224:
    r444 = 'USE_FULL_REQUEST'
    r445 = load_address PyBool_Type
    r446 = dank_mids._envs.create_env :: static
    if is_error(r446) goto L225 else goto L227
L225:
    r447 = raise NameError('value for final name "create_env" was not set')
    if not r447 goto L332 (error at <module>:148) else goto L226 :: bool
L226:
    unreachable
L227:
    r448 = box(bool, 0)
    r449 = box(bool, 0)
    r450 = [r444, r445, r448, r449]
    r451 = load_address r450
    r452 = ('default', 'verbose')
    r453 = _PyObject_Vectorcall(r446, r451, 2, r452)
    if is_error(r453) goto L332 (error at <module>:148) else goto L228
L228:
    dank_mids.ENVIRONMENT_VARIABLES.USE_FULL_REQUEST = r453 :: static
    r454 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r455 = 'USE_FULL_REQUEST'
    r456 = CPyDict_SetItem(r454, r455, r453)
    dec_ref r453
    r457 = r456 >= 0 :: signed
    if not r457 goto L332 (error at <module>:148) else goto L229 :: bool
L229:
    r458 = 'DEBUG'
    r459 = load_address PyBool_Type
    r460 = dank_mids._envs.create_env :: static
    if is_error(r460) goto L230 else goto L232
L230:
    r461 = raise NameError('value for final name "create_env" was not set')
    if not r461 goto L332 (error at <module>:151) else goto L231 :: bool
L231:
    unreachable
L232:
    r462 = box(bool, 0)
    r463 = box(bool, 0)
    r464 = [r458, r459, r462, r463]
    r465 = load_address r464
    r466 = ('default', 'verbose')
    r467 = _PyObject_Vectorcall(r460, r465, 2, r466)
    if is_error(r467) goto L332 (error at <module>:151) else goto L233
L233:
    dank_mids.ENVIRONMENT_VARIABLES.DEBUG = r467 :: static
    r468 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r469 = 'DEBUG'
    r470 = CPyDict_SetItem(r468, r469, r467)
    dec_ref r467
    r471 = r470 >= 0 :: signed
    if not r471 goto L332 (error at <module>:151) else goto L234 :: bool
L234:
    r472 = 'EXPORT_STATS'
    r473 = load_address PyBool_Type
    r474 = dank_mids._envs.create_env :: static
    if is_error(r474) goto L235 else goto L237
L235:
    r475 = raise NameError('value for final name "create_env" was not set')
    if not r475 goto L332 (error at <module>:154) else goto L236 :: bool
L236:
    unreachable
L237:
    r476 = box(bool, 0)
    r477 = box(bool, 0)
    r478 = [r472, r473, r476, r477]
    r479 = load_address r478
    r480 = ('default', 'verbose')
    r481 = _PyObject_Vectorcall(r474, r479, 2, r480)
    if is_error(r481) goto L332 (error at <module>:154) else goto L238
L238:
    dank_mids.ENVIRONMENT_VARIABLES.EXPORT_STATS = r481 :: static
    r482 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r483 = 'EXPORT_STATS'
    r484 = CPyDict_SetItem(r482, r483, r481)
    dec_ref r481
    r485 = r484 >= 0 :: signed
    if not r485 goto L332 (error at <module>:154) else goto L239 :: bool
L239:
    r486 = 'COLLECT_STATS'
    r487 = load_address PyBool_Type
    r488 = dank_mids.ENVIRONMENT_VARIABLES.EXPORT_STATS :: static
    if is_error(r488) goto L240 else goto L242
L240:
    r489 = raise NameError('value for final name "EXPORT_STATS" was not set')
    if not r489 goto L332 (error at <module>:157) else goto L241 :: bool
L241:
    unreachable
L242:
    r490 = dank_mids.ENVIRONMENT_VARIABLES.EXPORT_STATS :: static
    if is_error(r490) goto L243 else goto L245
L243:
    r491 = raise NameError('value for final name "EXPORT_STATS" was not set')
    if not r491 goto L332 (error at <module>:157) else goto L244 :: bool
L244:
    unreachable
L245:
    r492 = PyObject_Not(r490)
    r493 = r492 >= 0 :: signed
    if not r493 goto L332 (error at <module>:157) else goto L246 :: bool
L246:
    r494 = truncate r492: i32 to builtins.bool
    r495 = dank_mids._envs.create_env :: static
    if is_error(r495) goto L247 else goto L249
L247:
    r496 = raise NameError('value for final name "create_env" was not set')
    if not r496 goto L332 (error at <module>:156) else goto L248 :: bool
L248:
    unreachable
L249:
    r497 = box(bool, r494)
    r498 = [r486, r487, r488, r497]
    r499 = load_address r498
    r500 = ('default', 'verbose')
    r501 = _PyObject_Vectorcall(r495, r499, 2, r500)
    if is_error(r501) goto L332 (error at <module>:156) else goto L250
L250:
    dank_mids.ENVIRONMENT_VARIABLES.COLLECT_STATS = r501 :: static
    r502 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r503 = 'COLLECT_STATS'
    r504 = CPyDict_SetItem(r502, r503, r501)
    dec_ref r501
    r505 = r504 >= 0 :: signed
    if not r505 goto L332 (error at <module>:156) else goto L251 :: bool
L251:
    r506 = 'STUCK_CALL_TIMEOUT'
    r507 = load_address PyLong_Type
    r508 = dank_mids._envs.create_env :: static
    if is_error(r508) goto L252 else goto L254
L252:
    r509 = raise NameError('value for final name "create_env" was not set')
    if not r509 goto L332 (error at <module>:161) else goto L253 :: bool
L253:
    unreachable
L254:
    r510 = object 120
    r511 = [r506, r507, r510]
    r512 = load_address r511
    r513 = ('default',)
    r514 = _PyObject_Vectorcall(r508, r512, 2, r513)
    if is_error(r514) goto L332 (error at <module>:161) else goto L255
L255:
    dank_mids.ENVIRONMENT_VARIABLES.STUCK_CALL_TIMEOUT = r514 :: static
    r515 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r516 = 'STUCK_CALL_TIMEOUT'
    r517 = CPyDict_SetItem(r515, r516, r514)
    dec_ref r514
    r518 = r517 >= 0 :: signed
    if not r518 goto L332 (error at <module>:161) else goto L256 :: bool
L256:
    r519 = 'eth_call'
    r520 = 'ETH_CALL_SEMAPHORE'
    r521 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r522 = 'BlockSemaphore'
    r523 = CPyDict_GetItem(r521, r522)
    if is_error(r523) goto L332 (error at <module>:167) else goto L257
L257:
    r524 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE :: static
    if is_error(r524) goto L372 else goto L260
L258:
    r525 = raise NameError('value for final name "BROWNIE_CALL_SEMAPHORE" was not set')
    if not r525 goto L332 (error at <module>:168) else goto L259 :: bool
L259:
    unreachable
L260:
    r526 = '_value'
    r527 = CPyObject_GetAttr(r524, r526)
    if is_error(r527) goto L373 (error at <module>:168) else goto L261
L261:
    r528 = dank_mids._envs.create_env :: static
    if is_error(r528) goto L374 else goto L264
L262:
    r529 = raise NameError('value for final name "create_env" was not set')
    if not r529 goto L332 (error at <module>:165) else goto L263 :: bool
L263:
    unreachable
L264:
    r530 = box(bool, 0)
    r531 = [r520, r523, r527, r530]
    r532 = load_address r531
    r533 = ('default', 'verbose')
    r534 = _PyObject_Vectorcall(r528, r532, 2, r533)
    if is_error(r534) goto L375 (error at <module>:165) else goto L265
L265:
    dec_ref r523
    dec_ref r527
    r535 = 'eth_getBlock'
    r536 = 'ETH_GETBLOCK_SEMAPHORE'
    r537 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r538 = 'a_sync'
    r539 = CPyDict_GetItem(r537, r538)
    if is_error(r539) goto L376 (error at <module>:173) else goto L266
L266:
    r540 = 'Semaphore'
    r541 = CPyObject_GetAttr(r539, r540)
    dec_ref r539
    if is_error(r541) goto L376 (error at <module>:173) else goto L267
L267:
    r542 = dank_mids._envs.create_env :: static
    if is_error(r542) goto L377 else goto L270
L268:
    r543 = raise NameError('value for final name "create_env" was not set')
    if not r543 goto L332 (error at <module>:171) else goto L269 :: bool
L269:
    unreachable
L270:
    r544 = object 1000
    r545 = box(bool, 0)
    r546 = [r536, r541, r544, r545]
    r547 = load_address r546
    r548 = ('default', 'verbose')
    r549 = _PyObject_Vectorcall(r542, r547, 2, r548)
    if is_error(r549) goto L378 (error at <module>:171) else goto L271
L271:
    dec_ref r541
    r550 = 'eth_getCode'
    r551 = 'ETH_GETCODE_SEMAPHORE'
    r552 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r553 = 'a_sync'
    r554 = CPyDict_GetItem(r552, r553)
    if is_error(r554) goto L379 (error at <module>:179) else goto L272
L272:
    r555 = 'Semaphore'
    r556 = CPyObject_GetAttr(r554, r555)
    dec_ref r554
    if is_error(r556) goto L379 (error at <module>:179) else goto L273
L273:
    r557 = dank_mids._envs.create_env :: static
    if is_error(r557) goto L380 else goto L276
L274:
    r558 = raise NameError('value for final name "create_env" was not set')
    if not r558 goto L332 (error at <module>:177) else goto L275 :: bool
L275:
    unreachable
L276:
    r559 = object 5000
    r560 = box(bool, 0)
    r561 = [r551, r556, r559, r560]
    r562 = load_address r561
    r563 = ('default', 'verbose')
    r564 = _PyObject_Vectorcall(r557, r562, 2, r563)
    if is_error(r564) goto L381 (error at <module>:177) else goto L277
L277:
    dec_ref r556
    r565 = CPyDict_Build(3, r519, r534, r535, r549, r550, r564)
    dec_ref r534
    dec_ref r549
    dec_ref r564
    if is_error(r565) goto L332 (error at <module>:164) else goto L278
L278:
    dank_mids.ENVIRONMENT_VARIABLES.method_semaphores = r565 :: static
    r566 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r567 = 'method_semaphores'
    r568 = CPyDict_SetItem(r566, r567, r565)
    dec_ref r565
    r569 = r568 >= 0 :: signed
    if not r569 goto L332 (error at <module>:164) else goto L279 :: bool
L279:
    r570 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r571 = 'typed_envs'
    r572 = CPyDict_GetItem(r570, r571)
    if is_error(r572) goto L332 (error at <module>:185) else goto L280
L280:
    r573 = 'logger'
    r574 = CPyObject_GetAttr(r572, r573)
    dec_ref r572
    if is_error(r574) goto L332 (error at <module>:185) else goto L281
L281:
    r575 = 'disabled'
    r576 = CPyObject_GetAttr(r574, r575)
    dec_ref r574
    if is_error(r576) goto L332 (error at <module>:185) else goto L282
L282:
    r577 = PyObject_IsTrue(r576)
    dec_ref r576
    r578 = r577 >= 0 :: signed
    if not r578 goto L332 (error at <module>:185) else goto L283 :: bool
L283:
    r579 = truncate r577: i32 to builtins.bool
    if r579 goto L292 else goto L284 :: bool
L284:
    r580 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r580) goto L285 else goto L287
L285:
    r581 = raise NameError('value for final name "logger" was not set')
    if not r581 goto L332 (error at <module>:186) else goto L286 :: bool
L286:
    unreachable
L287:
    r582 = 'More details can be found in dank_mids/ENVIRONMENT_VARIABLES.py'
    r583 = 'info'
    r584 = [r580, r582]
    r585 = load_address r584
    r586 = PyObject_VectorcallMethod(r583, r585, 9223372036854775810, 0)
    if is_error(r586) goto L332 (error at <module>:186) else goto L382
L288:
    r587 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r587) goto L289 else goto L291
L289:
    r588 = raise NameError('value for final name "logger" was not set')
    if not r588 goto L332 (error at <module>:187) else goto L290 :: bool
L290:
    unreachable
L291:
    r589 = 'NOTE: You can disable these logs by setting the `TYPEDENVS_SHUTUP` env var to any value.'
    r590 = 'info'
    r591 = [r587, r589]
    r592 = load_address r591
    r593 = PyObject_VectorcallMethod(r590, r592, 9223372036854775810, 0)
    if is_error(r593) goto L332 (error at <module>:187) else goto L383
L292:
    r594 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r594) goto L293 else goto L295
L293:
    r595 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r595 goto L332 (error at <module>:195) else goto L294 :: bool
L294:
    unreachable
L295:
    r596 = 'infura'
    r597 = CPyObject_GetAttr(r594, r596)
    if is_error(r597) goto L332 (error at <module>:195) else goto L296
L296:
    r598 = PyObject_IsTrue(r597)
    dec_ref r597
    r599 = r598 >= 0 :: signed
    if not r599 goto L332 (error at <module>:195) else goto L297 :: bool
L297:
    r600 = truncate r598: i32 to builtins.bool
    if r600 goto L302 else goto L298 :: bool
L298:
    r601 = dank_mids.ENVIRONMENT_VARIABLES.logger :: static
    if is_error(r601) goto L299 else goto L301
L299:
    r602 = raise NameError('value for final name "logger" was not set')
    if not r602 goto L332 (error at <module>:196) else goto L300 :: bool
L300:
    unreachable
L301:
    r603 = "Unless you know what you're doing, dank mids should be run in infura mode for now"
    r604 = 'warning'
    r605 = [r601, r603]
    r606 = load_address r605
    r607 = PyObject_VectorcallMethod(r604, r606, 9223372036854775810, 0)
    if is_error(r607) goto L332 (error at <module>:196) else goto L384
L302:
    r608 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r608) goto L303 else goto L305
L303:
    r609 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r609 goto L332 (error at <module>:200) else goto L304 :: bool
L304:
    unreachable
L305:
    r610 = 'infura'
    r611 = CPyObject_GetAttr(r608, r610)
    if is_error(r611) goto L332 (error at <module>:200) else goto L306
L306:
    r612 = PyObject_IsTrue(r611)
    dec_ref r611
    r613 = r612 >= 0 :: signed
    if not r613 goto L332 (error at <module>:200) else goto L307 :: bool
L307:
    r614 = truncate r612: i32 to builtins.bool
    if r614 goto L308 else goto L331 :: bool
L308:
    r615 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r616 = 'MULTICALL_DECODER_PROCESSES'
    r617 = CPyDict_GetItem(r615, r616)
    if is_error(r617) goto L332 (error at <module>:202) else goto L309
L309:
    r618 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r619 = 'BROWNIE_DECODER_PROCESSES'
    r620 = CPyDict_GetItem(r618, r619)
    if is_error(r620) goto L385 (error at <module>:203) else goto L310
L310:
    r621 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r622 = 'BROWNIE_ENCODER_PROCESSES'
    r623 = CPyDict_GetItem(r621, r622)
    if is_error(r623) goto L386 (error at <module>:204) else goto L311
L311:
    r624 = PySet_New(0)
    if is_error(r624) goto L387 (error at <module>:201) else goto L312
L312:
    r625 = PySet_Add(r624, r617)
    dec_ref r617
    r626 = r625 >= 0 :: signed
    if not r626 goto L388 (error at <module>:201) else goto L313 :: bool
L313:
    r627 = PySet_Add(r624, r620)
    dec_ref r620
    r628 = r627 >= 0 :: signed
    if not r628 goto L389 (error at <module>:201) else goto L314 :: bool
L314:
    r629 = PySet_Add(r624, r623)
    dec_ref r623
    r630 = r629 >= 0 :: signed
    if not r630 goto L390 (error at <module>:201) else goto L315 :: bool
L315:
    r631 = PyObject_GetIter(r624)
    dec_ref r624
    if is_error(r631) goto L332 (error at <module>:201) else goto L316
L316:
    r632 = PyIter_Next(r631)
    if is_error(r632) goto L391 else goto L317
L317:
    r633 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r634 = 'process_pool'
    r635 = CPyDict_SetItem(r633, r634, r632)
    dec_ref r632
    r636 = r635 >= 0 :: signed
    if not r636 goto L392 (error at <module>:201) else goto L318 :: bool
L318:
    r637 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r638 = 'process_pool'
    r639 = CPyDict_GetItem(r637, r638)
    if is_error(r639) goto L392 (error at <module>:206) else goto L319
L319:
    r640 = '_max_workers'
    r641 = CPyObject_GetAttr(r639, r640)
    dec_ref r639
    if is_error(r641) goto L392 (error at <module>:206) else goto L320
L320:
    r642 = PyObject_IsTrue(r641)
    dec_ref r641
    r643 = r642 >= 0 :: signed
    if not r643 goto L392 (error at <module>:206) else goto L321 :: bool
L321:
    r644 = truncate r642: i32 to builtins.bool
    if r644 goto L393 else goto L316 :: bool
L322:
    r645 = 'You cannot set env var '
    r646 = dank_mids.ENVIRONMENT_VARIABLES.globals :: static
    r647 = 'process_pool'
    r648 = CPyDict_GetItem(r646, r647)
    if is_error(r648) goto L332 (error at <module>:208) else goto L323
L323:
    r649 = 'name'
    r650 = CPyObject_GetAttr(r648, r649)
    dec_ref r648
    if is_error(r650) goto L332 (error at <module>:208) else goto L324
L324:
    r651 = PyObject_Str(r650)
    dec_ref r650
    if is_error(r651) goto L332 (error at <module>:208) else goto L325
L325:
    r652 = ' while running dank in infura mode.'
    r653 = CPyStr_Build(3, r645, r651, r652)
    dec_ref r651
    if is_error(r653) goto L332 (error at <module>:208) else goto L326
L326:
    r654 = builtins :: module
    r655 = 'ValueError'
    r656 = CPyObject_GetAttr(r654, r655)
    if is_error(r656) goto L394 (error at <module>:207) else goto L327
L327:
    r657 = [r653]
    r658 = load_address r657
    r659 = _PyObject_Vectorcall(r656, r658, 1, 0)
    dec_ref r656
    if is_error(r659) goto L394 (error at <module>:207) else goto L328
L328:
    dec_ref r653
    CPy_Raise(r659)
    dec_ref r659
    if not 0 goto L332 (error at <module>:207) else goto L329 :: bool
L329:
    unreachable
L330:
    r660 = CPy_NoErrOccurred()
    if not r660 goto L332 (error at <module>:201) else goto L331 :: bool
L331:
    return 1
L332:
    r661 = <error> :: None
    return r661
L333:
    dec_ref r76
    goto L332
L334:
    dec_ref r80
    goto L33
L335:
    dec_ref r86
    goto L332
L336:
    dec_ref r96
    goto L332
L337:
    dec_ref r99
    goto L50
L338:
    dec_ref r106
    goto L55
L339:
    dec_ref r110
    goto L57
L340:
    dec_ref r110
    goto L332
L341:
    dec_ref r273
    goto L121
L342:
    dec_ref r273
    goto L124
L343:
    dec_ref r273
    goto L332
L344:
    dec_ref r273
    goto L129
L345:
    dec_ref r297
    goto L135
L346:
    dec_ref r297
    goto L332
L347:
    dec_ref r297
    dec_ref r303
    goto L140
L348:
    dec_ref r297
    dec_ref r303
    goto L332
L349:
    dec_ref r297
    dec_ref r303
    goto L145
L350:
    dec_ref r325
    goto L151
L351:
    dec_ref r325
    goto L332
L352:
    dec_ref r325
    dec_ref r333 :: int
    goto L159
L353:
    dec_ref r325
    dec_ref r333 :: int
    goto L332
L354:
    dec_ref r325
    dec_ref r333 :: int
    goto L164
L355:
    dec_ref r325
    dec_ref r343
    goto L332
L356:
    dec_ref r356
    goto L170
L357:
    dec_ref r356
    goto L332
L358:
    dec_ref r356
    dec_ref r364 :: int
    goto L178
L359:
    dec_ref r356
    dec_ref r364 :: int
    goto L332
L360:
    dec_ref r356
    dec_ref r364 :: int
    goto L183
L361:
    dec_ref r356
    dec_ref r374
    goto L332
L362:
    dec_ref r387
    goto L189
L363:
    dec_ref r387
    goto L332
L364:
    dec_ref r387
    dec_ref r395 :: int
    goto L197
L365:
    dec_ref r387
    dec_ref r395 :: int
    goto L332
L366:
    dec_ref r387
    dec_ref r395 :: int
    goto L202
L367:
    dec_ref r387
    dec_ref r405
    goto L332
L368:
    dec_ref r424 :: int
    goto L215
L369:
    dec_ref r424 :: int
    goto L332
L370:
    dec_ref r424 :: int
    goto L220
L371:
    dec_ref r434
    goto L332
L372:
    dec_ref r523
    goto L258
L373:
    dec_ref r523
    goto L332
L374:
    dec_ref r523
    dec_ref r527
    goto L262
L375:
    dec_ref r523
    dec_ref r527
    goto L332
L376:
    dec_ref r534
    goto L332
L377:
    dec_ref r534
    dec_ref r541
    goto L268
L378:
    dec_ref r534
    dec_ref r541
    goto L332
L379:
    dec_ref r534
    dec_ref r549
    goto L332
L380:
    dec_ref r534
    dec_ref r549
    dec_ref r556
    goto L274
L381:
    dec_ref r534
    dec_ref r549
    dec_ref r556
    goto L332
L382:
    dec_ref r586
    goto L288
L383:
    dec_ref r593
    goto L292
L384:
    dec_ref r607
    goto L302
L385:
    dec_ref r617
    goto L332
L386:
    dec_ref r617
    dec_ref r620
    goto L332
L387:
    dec_ref r617
    dec_ref r620
    dec_ref r623
    goto L332
L388:
    dec_ref r620
    dec_ref r623
    dec_ref r624
    goto L332
L389:
    dec_ref r623
    dec_ref r624
    goto L332
L390:
    dec_ref r624
    goto L332
L391:
    dec_ref r631
    goto L330
L392:
    dec_ref r631
    goto L332
L393:
    dec_ref r631
    goto L322
L394:
    dec_ref r653
    goto L332

def coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    type, value, traceback, arg, r0, r1 :: object
    r2 :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_env
    r3 :: int
    r4 :: object
    r5 :: bit
    r6 :: dank_mids.brownie_patch.types.DankOverloadedMethod
    r7 :: tuple
    r8 :: str
    r9 :: object[2]
    r10 :: object_ptr
    r11 :: object
    r12 :: union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx]
    r13 :: bool
    r14 :: union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx]
    r15 :: tuple
    r16, r17 :: union[int, None]
    r18 :: union[dict, None]
    r19 :: str
    r20 :: object
    r21 :: list
    r22 :: object
    r23, r24, r25 :: str
    r26 :: tuple
    r27 :: dict
    r28, r29 :: object
    r30 :: bool
    r31, r32, r33, r34, r35 :: object
    r36 :: bool
    r37 :: object
    r38 :: bit
    r39 :: tuple[object, object, object]
    r40 :: bool
    r41 :: object_ptr
    r42 :: object
    r43, r44 :: bool
    r45 :: tuple[object, object, object]
    r46 :: bool
    r47, r48 :: tuple[object, object, object]
    r49 :: bit
    r50, r51, r52 :: object
    r53 :: bool
    r54, r55 :: bit
    r56 :: bool
    r57 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_env__
    if is_error(r2) goto L64 (error at coroutine:56) else goto L1
L1:
    r3 = r2.__mypyc_next_label__
    if is_error(r3) goto L65 (error at coroutine:56) else goto L59
L2:
    r4 = load_address _Py_NoneStruct
    r5 = type != r4
    if r5 goto L66 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L63 (error at coroutine:56) else goto L4 :: bool
L4:
    unreachable
L5:
    r6 = r2.self
    if is_error(r6) goto L65 (error at coroutine:74) else goto L6
L6:
    r7 = r2.args
    if is_error(r7) goto L67 (error at coroutine:74) else goto L7
L7:
    r8 = '_get_fn_from_args'
    r9 = [r6, r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775810, 0)
    if is_error(r11) goto L68 (error at coroutine:74) else goto L8
L8:
    dec_ref r6
    dec_ref r7
    r12 = cast(union[dank_mids.brownie_patch.types.DankContractCall, dank_mids.brownie_patch.types.DankContractTx], r11)
    if is_error(r12) goto L65 (error at coroutine:74) else goto L9
L9:
    r2.call = r12; r13 = is_error
    if not r13 goto L65 (error at coroutine:74) else goto L10 :: bool
L10:
    r14 = r2.call
    if is_error(r14) goto L65 (error at coroutine:75) else goto L11
L11:
    r15 = r2.args
    if is_error(r15) goto L69 (error at coroutine:76) else goto L12
L12:
    r16 = r2.block_identifier
    if is_error(r16) goto L70 (error at coroutine:76) else goto L13
L13:
    r17 = r2.decimals
    if is_error(r17) goto L71 (error at coroutine:76) else goto L14
L14:
    r18 = r2.override
    if is_error(r18) goto L72 (error at coroutine:76) else goto L15
L15:
    r19 = 'coroutine'
    r20 = CPyObject_GetAttr(r14, r19)
    dec_ref r14
    if is_error(r20) goto L73 (error at coroutine:75) else goto L16
L16:
    r21 = PyList_New(0)
    if is_error(r21) goto L74 (error at coroutine:75) else goto L17
L17:
    r22 = CPyList_Extend(r21, r15)
    dec_ref r15
    if is_error(r22) goto L75 (error at coroutine:75) else goto L76
L18:
    r23 = 'block_identifier'
    r24 = 'decimals'
    r25 = 'override'
    r26 = PyList_AsTuple(r21)
    dec_ref r21
    if is_error(r26) goto L77 (error at coroutine:75) else goto L19
L19:
    r27 = CPyDict_Build(3, r23, r16, r24, r17, r25, r18)
    dec_ref r16
    dec_ref r17
    dec_ref r18
    if is_error(r27) goto L78 (error at coroutine:75) else goto L20
L20:
    r28 = PyObject_Call(r20, r26, r27)
    dec_ref r20
    dec_ref r26
    dec_ref r27
    if is_error(r28) goto L65 (error at coroutine:75) else goto L21
L21:
    r29 = CPy_GetCoro(r28)
    dec_ref r28
    if is_error(r29) goto L65 (error at coroutine:75) else goto L22
L22:
    r2.__mypyc_temp__0 = r29; r30 = is_error
    if not r30 goto L65 (error at coroutine:-1) else goto L23 :: bool
L23:
    r31 = r2.__mypyc_temp__0
    if is_error(r31) goto L65 (error at coroutine:-1) else goto L24
L24:
    r32 = CPyIter_Next(r31)
    dec_ref r31
    if is_error(r32) goto L79 else goto L27
L25:
    r33 = CPy_FetchStopIterationValue()
    if is_error(r33) goto L80 (error at coroutine:75) else goto L26
L26:
    r34 = r33
    goto L56
L27:
    r35 = r32
L28:
    r2.__mypyc_next_label__ = 2; r36 = is_error
    if not r36 goto L81 (error at coroutine:75) else goto L82 :: bool
L29:
    return r35
L30:
    r37 = load_address _Py_NoneStruct
    r38 = type != r37
    if r38 goto L31 else goto L33 :: bool
L31:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L34 (error at coroutine:75) else goto L83 :: bool
L32:
    unreachable
L33:
    inc_ref arg
    goto L51
L34:
    r39 = CPy_CatchError()
    r2.__mypyc_temp__1 = r39; r40 = is_error
    if not r40 goto L84 (error at coroutine:-1) else goto L35 :: bool
L35:
    r41 = load_address r1
    r42 = r2.__mypyc_temp__0
    if is_error(r42) goto L84 (error at coroutine:-1) else goto L36
L36:
    r43 = CPy_YieldFromErrorHandle(r42, r41)
    dec_ref r42
    if is_error(r43) goto L84 (error at coroutine:75) else goto L37
L37:
    if r43 goto L43 else goto L38 :: bool
L38:
    if is_error(r1) goto L39 else goto L41
L39:
    r44 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r44 goto L48 (error at coroutine:-1) else goto L85 :: bool
L40:
    unreachable
L41:
    inc_ref r1
    r35 = r1
    r45 = r2.__mypyc_temp__1
    if is_error(r45) goto L86 (error at coroutine:-1) else goto L42
L42:
    CPy_RestoreExcInfo(r45)
    dec_ref r45
    goto L28
L43:
    if is_error(r1) goto L44 else goto L46
L44:
    r46 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r46 goto L48 (error at coroutine:-1) else goto L87 :: bool
L45:
    unreachable
L46:
    r34 = r1
    r47 = r2.__mypyc_temp__1
    if is_error(r47) goto L88 (error at coroutine:-1) else goto L47
L47:
    CPy_RestoreExcInfo(r47)
    dec_ref r47
    goto L56
L48:
    r48 = r2.__mypyc_temp__1
    dec_ref r2
    if is_error(r48) goto L63 (error at coroutine:-1) else goto L49
L49:
    CPy_RestoreExcInfo(r48)
    dec_ref r48
    r49 = CPy_KeepPropagating()
    if not r49 goto L63 else goto L50 :: bool
L50:
    unreachable
L51:
    r50 = r2.__mypyc_temp__0
    if is_error(r50) goto L89 (error at coroutine:-1) else goto L52
L52:
    r51 = CPyIter_Send(r50, arg)
    dec_ref r50
    dec_ref arg
    if is_error(r51) goto L90 else goto L53
L53:
    r35 = r51
    goto L28
L54:
    r52 = CPy_FetchStopIterationValue()
    if is_error(r52) goto L80 (error at coroutine:75) else goto L55
L55:
    r34 = r52
L56:
    r2.__mypyc_next_label__ = -2; r53 = is_error
    dec_ref r2
    if not r53 goto L91 (error at coroutine:75) else goto L57 :: bool
L57:
    CPyGen_SetStopIterationValue(r34)
    dec_ref r34
    if not 0 goto L63 else goto L58 :: bool
L58:
    unreachable
L59:
    r54 = r3 == 0
    if r54 goto L92 else goto L60 :: bool
L60:
    r55 = r3 == 2
    dec_ref r3 :: int
    if r55 goto L30 else goto L93 :: bool
L61:
    r56 = raise StopIteration
    if not r56 goto L63 (error at coroutine:56) else goto L62 :: bool
L62:
    unreachable
L63:
    r57 = <error> :: object
    return r57
L64:
    xdec_ref r1
    goto L63
L65:
    xdec_ref r1
    dec_ref r2
    goto L63
L66:
    xdec_ref r1
    dec_ref r2
    goto L3
L67:
    xdec_ref r1
    dec_ref r2
    dec_ref r6
    goto L63
L68:
    xdec_ref r1
    dec_ref r2
    dec_ref r6
    dec_ref r7
    goto L63
L69:
    xdec_ref r1
    dec_ref r2
    dec_ref r14
    goto L63
L70:
    xdec_ref r1
    dec_ref r2
    dec_ref r14
    dec_ref r15
    goto L63
L71:
    xdec_ref r1
    dec_ref r2
    dec_ref r14
    dec_ref r15
    dec_ref r16
    goto L63
L72:
    xdec_ref r1
    dec_ref r2
    dec_ref r14
    dec_ref r15
    dec_ref r16
    dec_ref r17
    goto L63
L73:
    xdec_ref r1
    dec_ref r2
    dec_ref r15
    dec_ref r16
    dec_ref r17
    dec_ref r18
    goto L63
L74:
    xdec_ref r1
    dec_ref r2
    dec_ref r15
    dec_ref r16
    dec_ref r17
    dec_ref r18
    dec_ref r20
    goto L63
L75:
    xdec_ref r1
    dec_ref r2
    dec_ref r16
    dec_ref r17
    dec_ref r18
    dec_ref r20
    dec_ref r21
    goto L63
L76:
    dec_ref r22
    goto L18
L77:
    xdec_ref r1
    dec_ref r2
    dec_ref r16
    dec_ref r17
    dec_ref r18
    dec_ref r20
    goto L63
L78:
    xdec_ref r1
    dec_ref r2
    dec_ref r20
    dec_ref r26
    goto L63
L79:
    xdec_ref r1
    goto L25
L80:
    dec_ref r2
    goto L63
L81:
    dec_ref r35
    goto L34
L82:
    xdec_ref r1
    dec_ref r2
    goto L29
L83:
    xdec_ref r1
    dec_ref r2
    goto L32
L84:
    xdec_ref r1
    goto L48
L85:
    dec_ref r2
    goto L40
L86:
    xdec_ref r1
    dec_ref r35
    goto L48
L87:
    dec_ref r2
    goto L45
L88:
    dec_ref r34
    goto L48
L89:
    xdec_ref r1
    dec_ref r2
    dec_ref arg
    goto L63
L90:
    xdec_ref r1
    goto L54
L91:
    dec_ref r34
    goto L63
L92:
    dec_ref r3 :: int
    goto L2
L93:
    xdec_ref r1
    dec_ref r2
    goto L61

def coroutine_DankOverloadedMethod_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine_DankOverloadedMethod_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine_DankOverloadedMethod_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine_DankOverloadedMethod_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutine_DankOverloadedMethod_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutine_DankOverloadedMethod_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def coroutine_DankOverloadedMethod_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def DankOverloadedMethod.coroutine(self, args, block_identifier, decimals, override):
    self :: dank_mids.brownie_patch.types.DankOverloadedMethod
    args :: tuple
    block_identifier, decimals :: union[int, None]
    override :: union[dict, None]
    r0, r1, r2 :: object
    r3 :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_env
    r4, r5, r6, r7, r8 :: bool
    r9 :: dank_mids.brownie_patch.types.coroutine_DankOverloadedMethod_gen
    r10, r11 :: bool
    r12 :: object
L0:
    if is_error(block_identifier) goto L1 else goto L17
L1:
    r0 = box(None, 1)
    inc_ref r0
    block_identifier = r0
L2:
    if is_error(decimals) goto L3 else goto L18
L3:
    r1 = box(None, 1)
    inc_ref r1
    decimals = r1
L4:
    if is_error(override) goto L5 else goto L19
L5:
    r2 = box(None, 1)
    inc_ref r2
    override = r2
L6:
    r3 = coroutine_DankOverloadedMethod_env()
    if is_error(r3) goto L20 (error at coroutine:56) else goto L7
L7:
    inc_ref self
    r3.self = self; r4 = is_error
    if not r4 goto L21 (error at coroutine:56) else goto L8 :: bool
L8:
    inc_ref args
    r3.args = args; r5 = is_error
    if not r5 goto L21 (error at coroutine:56) else goto L9 :: bool
L9:
    r3.block_identifier = block_identifier; r6 = is_error
    if not r6 goto L22 (error at coroutine:56) else goto L10 :: bool
L10:
    r3.decimals = decimals; r7 = is_error
    if not r7 goto L23 (error at coroutine:56) else goto L11 :: bool
L11:
    r3.override = override; r8 = is_error
    if not r8 goto L24 (error at coroutine:56) else goto L12 :: bool
L12:
    r9 = coroutine_DankOverloadedMethod_gen()
    if is_error(r9) goto L24 (error at coroutine:56) else goto L13
L13:
    inc_ref r3
    r9.__mypyc_env__ = r3; r10 = is_error
    if not r10 goto L25 (error at coroutine:56) else goto L14 :: bool
L14:
    r3.__mypyc_next_label__ = 0; r11 = is_error
    dec_ref r3
    if not r11 goto L26 (error at coroutine:56) else goto L15 :: bool
L15:
    return r9
L16:
    r12 = <error> :: object
    return r12
L17:
    inc_ref block_identifier
    goto L2
L18:
    inc_ref decimals
    goto L4
L19:
    inc_ref override
    goto L6
L20:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    goto L16
L21:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r3
    goto L16
L22:
    dec_ref decimals
    dec_ref override
    dec_ref r3
    goto L16
L23:
    dec_ref override
    dec_ref r3
    goto L16
L24:
    dec_ref r3
    goto L16
L25:
    dec_ref r3
    dec_ref r9
    goto L16
L26:
    dec_ref r9
    goto L16

def DankOverloadedMethod._add_fn(self, abi, natspec):
    self :: dank_mids.brownie_patch.types.DankOverloadedMethod
    abi, natspec :: dict
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6, r7 :: str
    r8 :: object
    r9 :: list
    r10 :: str
    r11, r12, r13 :: object
    r14 :: str
    r15 :: object
    r16, r17, r18 :: str
    r19 :: object[3]
    r20 :: object_ptr
    r21 :: object
    r22 :: i32
    r23, r24 :: bit
    r25 :: tuple
    r26 :: dict
    r27 :: i32
    r28 :: bit
    r29 :: str
    r30 :: object
    r31 :: str
    r32 :: object[2]
    r33 :: object_ptr
    r34 :: object
    r35 :: None
L0:
    r0 = '_address'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L20 (error at _add_fn:90) else goto L1
L1:
    r2 = '_name'
    r3 = CPyObject_GetAttr(self, r2)
    if is_error(r3) goto L21 (error at _add_fn:90) else goto L2
L2:
    r4 = '_owner'
    r5 = CPyObject_GetAttr(self, r4)
    if is_error(r5) goto L22 (error at _add_fn:90) else goto L3
L3:
    r6 = cast(str, r1)
    if is_error(r6) goto L23 (error at _add_fn:90) else goto L4
L4:
    r7 = cast(str, r3)
    if is_error(r7) goto L24 (error at _add_fn:90) else goto L5
L5:
    r8 = _get_method_object(r6, abi, r7, r5, natspec)
    dec_ref r6
    dec_ref r7
    dec_ref r5
    if is_error(r8) goto L20 (error at _add_fn:90) else goto L6
L6:
    r9 = PyList_New(0)
    if is_error(r9) goto L25 (error at _add_fn:91) else goto L7
L7:
    r10 = 'inputs'
    r11 = CPyDict_GetItem(abi, r10)
    if is_error(r11) goto L26 (error at _add_fn:91) else goto L8
L8:
    r12 = PyObject_GetIter(r11)
    dec_ref r11
    if is_error(r12) goto L26 (error at _add_fn:91) else goto L9
L9:
    r13 = PyIter_Next(r12)
    if is_error(r13) goto L27 else goto L10
L10:
    r14 = 'type'
    r15 = PyObject_GetItem(r13, r14)
    dec_ref r13
    if is_error(r15) goto L28 (error at _add_fn:91) else goto L11
L11:
    r16 = '256'
    r17 = ''
    r18 = 'replace'
    r19 = [r15, r16, r17]
    r20 = load_address r19
    r21 = PyObject_VectorcallMethod(r18, r20, 9223372036854775811, 0)
    if is_error(r21) goto L29 (error at _add_fn:91) else goto L12
L12:
    dec_ref r15
    r22 = PyList_Append(r9, r21)
    dec_ref r21
    r23 = r22 >= 0 :: signed
    if not r23 goto L28 (error at _add_fn:91) else goto L9 :: bool
L13:
    r24 = CPy_NoErrOccurred()
    if not r24 goto L26 (error at _add_fn:91) else goto L14 :: bool
L14:
    r25 = PyList_AsTuple(r9)
    dec_ref r9
    if is_error(r25) goto L25 (error at _add_fn:91) else goto L15
L15:
    r26 = self.methods
    if is_error(r26) goto L30 (error at _add_fn:92) else goto L16
L16:
    r27 = CPyDict_SetItem(r26, r25, r8)
    dec_ref r26
    dec_ref r25
    dec_ref r8
    r28 = r27 >= 0 :: signed
    if not r28 goto L20 (error at _add_fn:92) else goto L17 :: bool
L17:
    r29 = 'natspec'
    r30 = CPyObject_GetAttr(self, r29)
    if is_error(r30) goto L20 (error at _add_fn:93) else goto L18
L18:
    r31 = 'update'
    r32 = [r30, natspec]
    r33 = load_address r32
    r34 = PyObject_VectorcallMethod(r31, r33, 9223372036854775810, 0)
    if is_error(r34) goto L31 (error at _add_fn:93) else goto L32
L19:
    dec_ref r30
    return 1
L20:
    r35 = <error> :: None
    return r35
L21:
    dec_ref r1
    goto L20
L22:
    dec_ref r1
    dec_ref r3
    goto L20
L23:
    dec_ref r3
    dec_ref r5
    goto L20
L24:
    dec_ref r5
    dec_ref r6
    goto L20
L25:
    dec_ref r8
    goto L20
L26:
    dec_ref r8
    dec_ref r9
    goto L20
L27:
    dec_ref r12
    goto L13
L28:
    dec_ref r8
    dec_ref r9
    dec_ref r12
    goto L20
L29:
    dec_ref r8
    dec_ref r9
    dec_ref r12
    dec_ref r15
    goto L20
L30:
    dec_ref r8
    dec_ref r25
    goto L20
L31:
    dec_ref r30
    goto L20
L32:
    dec_ref r34
    goto L19

def _get_method_object(address, abi, name, owner, natspec):
    address :: str
    abi :: dict
    name :: str
    owner :: union[object, None]
    natspec :: dict
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4 :: str
    r5, constant :: object
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10, r11 :: bool
    r12 :: str
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: bool
    r17 :: object
    r18 :: i32
    r19 :: bit
    r20 :: bool
    r21 :: tuple
    r22 :: dict
    r23 :: dank_mids.brownie_patch.types.DankContractCall
    r24 :: tuple
    r25 :: dict
    r26 :: dank_mids.brownie_patch.types.DankContractTx
    r27 :: object
L0:
    r0 = 'constant'
    r1 = PyDict_Contains(abi, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L24 (error at _get_method_object:125) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L2 else goto L4 :: bool
L2:
    r4 = 'constant'
    r5 = CPyDict_GetItem(abi, r4)
    if is_error(r5) goto L24 (error at _get_method_object:126) else goto L3
L3:
    constant = r5
    goto L14
L4:
    r6 = 'stateMutability'
    r7 = CPyDict_GetItem(abi, r6)
    if is_error(r7) goto L24 (error at _get_method_object:128) else goto L5
L5:
    r8 = 'view'
    r9 = PyObject_RichCompare(r7, r8, 2)
    dec_ref r7
    if is_error(r9) goto L24 (error at _get_method_object:-1) else goto L6
L6:
    r10 = unbox(bool, r9)
    dec_ref r9
    if is_error(r10) goto L24 (error at _get_method_object:-1) else goto L7
L7:
    if r10 goto L8 else goto L9 :: bool
L8:
    r11 = r10
    goto L13
L9:
    r12 = 'stateMutability'
    r13 = CPyDict_GetItem(abi, r12)
    if is_error(r13) goto L24 (error at _get_method_object:128) else goto L10
L10:
    r14 = 'pure'
    r15 = PyObject_RichCompare(r13, r14, 2)
    dec_ref r13
    if is_error(r15) goto L24 (error at _get_method_object:-1) else goto L11
L11:
    r16 = unbox(bool, r15)
    dec_ref r15
    if is_error(r16) goto L24 (error at _get_method_object:-1) else goto L12
L12:
    r11 = r16
L13:
    r17 = box(bool, r11)
    inc_ref r17
    constant = r17
L14:
    r18 = PyObject_IsTrue(constant)
    dec_ref constant
    r19 = r18 >= 0 :: signed
    if not r19 goto L24 (error at _get_method_object:126) else goto L15 :: bool
L15:
    r20 = truncate r18: i32 to builtins.bool
    if r20 goto L16 else goto L20 :: bool
L16:
    r21 = PyTuple_Pack(5, address, abi, name, owner, natspec)
    if is_error(r21) goto L24 (error at _get_method_object:131) else goto L17
L17:
    r22 = PyDict_New()
    if is_error(r22) goto L25 (error at _get_method_object:131) else goto L18
L18:
    r23 = DankContractCall(r21, r22)
    dec_ref r21
    dec_ref r22
    if is_error(r23) goto L24 (error at _get_method_object:131) else goto L19
L19:
    return r23
L20:
    r24 = PyTuple_Pack(5, address, abi, name, owner, natspec)
    if is_error(r24) goto L24 (error at _get_method_object:132) else goto L21
L21:
    r25 = PyDict_New()
    if is_error(r25) goto L26 (error at _get_method_object:132) else goto L22
L22:
    r26 = DankContractTx(r24, r25)
    dec_ref r24
    dec_ref r25
    if is_error(r26) goto L24 (error at _get_method_object:132) else goto L23
L23:
    return r26
L24:
    r27 = <error> :: object
    return r27
L25:
    dec_ref r21
    goto L24
L26:
    dec_ref r24
    goto L24

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20 :: object
    r21 :: str
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: object[1]
    r26 :: object_ptr
    r27 :: object
    r28 :: dict
    r29 :: str
    r30 :: i32
    r31 :: bit
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: dict
    r36 :: str
    r37 :: object
    r38 :: dict
    r39 :: str
    r40 :: object
    r41 :: dict
    r42 :: str
    r43 :: object
    r44 :: tuple[object, object, object]
    r45, r46 :: object
    r47 :: dict
    r48 :: str
    r49 :: i32
    r50 :: bit
    r51 :: dict
    r52 :: str
    r53 :: object
    r54 :: dict
    r55 :: str
    r56 :: object
    r57 :: tuple
    r58 :: str
    r59, r60 :: object
    r61 :: bool
    r62, r63 :: str
    r64 :: tuple
    r65 :: i32
    r66 :: bit
    r67 :: dict
    r68 :: str
    r69 :: i32
    r70 :: bit
    r71 :: dict
    r72 :: str
    r73 :: object
    r74 :: dict
    r75 :: str
    r76 :: object
    r77 :: tuple
    r78 :: str
    r79, r80 :: object
    r81 :: bool
    r82, r83 :: str
    r84 :: tuple
    r85 :: i32
    r86 :: bit
    r87 :: dict
    r88 :: str
    r89 :: i32
    r90 :: bit
    r91 :: dict
    r92 :: str
    r93, r94, r95 :: object
    r96 :: tuple[object, object]
    r97, r98 :: object
    r99 :: dict
    r100 :: str
    r101 :: i32
    r102 :: bit
    r103 :: dict
    r104 :: str
    r105 :: object
    r106 :: dict
    r107 :: str
    r108 :: object
    r109 :: dict
    r110 :: str
    r111, r112 :: object
    r113 :: tuple
    r114 :: str
    r115, r116 :: object
    r117 :: bool
    r118, r119, r120 :: str
    r121 :: tuple
    r122 :: i32
    r123 :: bit
    r124 :: dict
    r125 :: str
    r126 :: i32
    r127 :: bit
    r128 :: dict
    r129 :: str
    r130, r131, r132, r133 :: object
    r134 :: tuple[object, object, object]
    r135, r136 :: object
    r137 :: dict
    r138 :: str
    r139 :: i32
    r140 :: bit
    r141 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L49 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Dict', 'Optional', 'Tuple', 'TypeVar', 'Union', 'final')
    r6 = 'typing'
    r7 = dank_mids.brownie_patch.types.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L49 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('ContractCall', 'ContractTx', 'OverloadedMethod')
    r10 = 'brownie.network.contract'
    r11 = dank_mids.brownie_patch.types.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L49 (error at <module>:3) else goto L5
L5:
    brownie.network.contract = r12 :: module
    dec_ref r12
    r13 = ('AccountsType',)
    r14 = 'brownie.typing'
    r15 = dank_mids.brownie_patch.types.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L49 (error at <module>:4) else goto L6
L6:
    brownie.typing = r16 :: module
    dec_ref r16
    r17 = ('_DankMethod', '_DankMethodMixin', '_EVMType')
    r18 = 'dank_mids.brownie_patch._method'
    r19 = dank_mids.brownie_patch.types.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L49 (error at <module>:6) else goto L7
L7:
    dank_mids.brownie_patch._method = r20 :: module
    dec_ref r20
    r21 = '_T'
    r22 = dank_mids.brownie_patch.types.globals :: static
    r23 = 'TypeVar'
    r24 = CPyDict_GetItem(r22, r23)
    if is_error(r24) goto L49 (error at <module>:9) else goto L8
L8:
    r25 = [r21]
    r26 = load_address r25
    r27 = _PyObject_Vectorcall(r24, r26, 1, 0)
    dec_ref r24
    if is_error(r27) goto L49 (error at <module>:9) else goto L9
L9:
    r28 = dank_mids.brownie_patch.types.globals :: static
    r29 = '_T'
    r30 = CPyDict_SetItem(r28, r29, r27)
    dec_ref r27
    r31 = r30 >= 0 :: signed
    if not r31 goto L49 (error at <module>:9) else goto L10 :: bool
L10:
    r32 = dank_mids.brownie_patch.types.globals :: static
    r33 = 'Union'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L49 (error at <module>:11) else goto L11
L11:
    r35 = dank_mids.brownie_patch.types.globals :: static
    r36 = 'ContractCall'
    r37 = CPyDict_GetItem(r35, r36)
    if is_error(r37) goto L50 (error at <module>:11) else goto L12
L12:
    r38 = dank_mids.brownie_patch.types.globals :: static
    r39 = 'ContractTx'
    r40 = CPyDict_GetItem(r38, r39)
    if is_error(r40) goto L51 (error at <module>:11) else goto L13
L13:
    r41 = dank_mids.brownie_patch.types.globals :: static
    r42 = 'OverloadedMethod'
    r43 = CPyDict_GetItem(r41, r42)
    if is_error(r43) goto L52 (error at <module>:11) else goto L14
L14:
    r44 = (r37, r40, r43)
    r45 = box(tuple[object, object, object], r44)
    r46 = PyObject_GetItem(r34, r45)
    dec_ref r34
    dec_ref r45
    if is_error(r46) goto L49 (error at <module>:11) else goto L15
L15:
    r47 = dank_mids.brownie_patch.types.globals :: static
    r48 = 'ContractMethod'
    r49 = CPyDict_SetItem(r47, r48, r46)
    dec_ref r46
    r50 = r49 >= 0 :: signed
    if not r50 goto L49 (error at <module>:11) else goto L16 :: bool
L16:
    r51 = dank_mids.brownie_patch.types.globals :: static
    r52 = '_DankMethod'
    r53 = CPyDict_GetItem(r51, r52)
    if is_error(r53) goto L49 (error at <module>:16) else goto L17
L17:
    r54 = dank_mids.brownie_patch.types.globals :: static
    r55 = 'ContractCall'
    r56 = CPyDict_GetItem(r54, r55)
    if is_error(r56) goto L53 (error at <module>:16) else goto L18
L18:
    r57 = PyTuple_Pack(2, r53, r56)
    dec_ref r53
    dec_ref r56
    if is_error(r57) goto L49 (error at <module>:16) else goto L19
L19:
    r58 = 'dank_mids.brownie_patch.types'
    r59 = dank_mids.brownie_patch.types.DankContractCall_template :: type
    r60 = CPyType_FromTemplate(r59, r57, r58)
    dec_ref r57
    if is_error(r60) goto L49 (error at <module>:16) else goto L20
L20:
    r61 = DankContractCall_trait_vtable_setup()
    if is_error(r61) goto L54 (error at <module>:-1) else goto L21
L21:
    r62 = '__mypyc_attrs__'
    r63 = '__dict__'
    r64 = PyTuple_Pack(1, r63)
    if is_error(r64) goto L54 (error at <module>:16) else goto L22
L22:
    r65 = PyObject_SetAttr(r60, r62, r64)
    dec_ref r64
    r66 = r65 >= 0 :: signed
    if not r66 goto L54 (error at <module>:16) else goto L23 :: bool
L23:
    dank_mids.brownie_patch.types.DankContractCall = r60 :: type
    r67 = dank_mids.brownie_patch.types.globals :: static
    r68 = 'DankContractCall'
    r69 = CPyDict_SetItem(r67, r68, r60)
    dec_ref r60
    r70 = r69 >= 0 :: signed
    if not r70 goto L49 (error at <module>:16) else goto L24 :: bool
L24:
    r71 = dank_mids.brownie_patch.types.globals :: static
    r72 = '_DankMethod'
    r73 = CPyDict_GetItem(r71, r72)
    if is_error(r73) goto L49 (error at <module>:28) else goto L25
L25:
    r74 = dank_mids.brownie_patch.types.globals :: static
    r75 = 'ContractTx'
    r76 = CPyDict_GetItem(r74, r75)
    if is_error(r76) goto L55 (error at <module>:28) else goto L26
L26:
    r77 = PyTuple_Pack(2, r73, r76)
    dec_ref r73
    dec_ref r76
    if is_error(r77) goto L49 (error at <module>:28) else goto L27
L27:
    r78 = 'dank_mids.brownie_patch.types'
    r79 = dank_mids.brownie_patch.types.DankContractTx_template :: type
    r80 = CPyType_FromTemplate(r79, r77, r78)
    dec_ref r77
    if is_error(r80) goto L49 (error at <module>:28) else goto L28
L28:
    r81 = DankContractTx_trait_vtable_setup()
    if is_error(r81) goto L56 (error at <module>:-1) else goto L29
L29:
    r82 = '__mypyc_attrs__'
    r83 = '__dict__'
    r84 = PyTuple_Pack(1, r83)
    if is_error(r84) goto L56 (error at <module>:28) else goto L30
L30:
    r85 = PyObject_SetAttr(r80, r82, r84)
    dec_ref r84
    r86 = r85 >= 0 :: signed
    if not r86 goto L56 (error at <module>:28) else goto L31 :: bool
L31:
    dank_mids.brownie_patch.types.DankContractTx = r80 :: type
    r87 = dank_mids.brownie_patch.types.globals :: static
    r88 = 'DankContractTx'
    r89 = CPyDict_SetItem(r87, r88, r80)
    dec_ref r80
    r90 = r89 >= 0 :: signed
    if not r90 goto L49 (error at <module>:28) else goto L32 :: bool
L32:
    r91 = dank_mids.brownie_patch.types.globals :: static
    r92 = 'Union'
    r93 = CPyDict_GetItem(r91, r92)
    if is_error(r93) goto L49 (error at <module>:39) else goto L33
L33:
    r94 = dank_mids.brownie_patch.types.DankContractCall :: type
    r95 = dank_mids.brownie_patch.types.DankContractTx :: type
    inc_ref r94
    inc_ref r95
    r96 = (r94, r95)
    r97 = box(tuple[object, object], r96)
    r98 = PyObject_GetItem(r93, r97)
    dec_ref r93
    dec_ref r97
    if is_error(r98) goto L49 (error at <module>:39) else goto L34
L34:
    r99 = dank_mids.brownie_patch.types.globals :: static
    r100 = '_NonOverloaded'
    r101 = CPyDict_SetItem(r99, r100, r98)
    dec_ref r98
    r102 = r101 >= 0 :: signed
    if not r102 goto L49 (error at <module>:39) else goto L35 :: bool
L35:
    r103 = dank_mids.brownie_patch.types.globals :: static
    r104 = 'OverloadedMethod'
    r105 = CPyDict_GetItem(r103, r104)
    if is_error(r105) goto L49 (error at <module>:44) else goto L36
L36:
    r106 = dank_mids.brownie_patch.types.globals :: static
    r107 = '_DankMethodMixin'
    r108 = CPyDict_GetItem(r106, r107)
    if is_error(r108) goto L57 (error at <module>:44) else goto L37
L37:
    r109 = dank_mids.brownie_patch.types.globals :: static
    r110 = '_T'
    r111 = CPyDict_GetItem(r109, r110)
    if is_error(r111) goto L58 (error at <module>:44) else goto L38
L38:
    r112 = PyObject_GetItem(r108, r111)
    dec_ref r108
    dec_ref r111
    if is_error(r112) goto L57 (error at <module>:44) else goto L39
L39:
    r113 = PyTuple_Pack(2, r105, r112)
    dec_ref r105
    dec_ref r112
    if is_error(r113) goto L49 (error at <module>:44) else goto L40
L40:
    r114 = 'dank_mids.brownie_patch.types'
    r115 = dank_mids.brownie_patch.types.DankOverloadedMethod_template :: type
    r116 = CPyType_FromTemplate(r115, r113, r114)
    dec_ref r113
    if is_error(r116) goto L49 (error at <module>:44) else goto L41
L41:
    r117 = DankOverloadedMethod_trait_vtable_setup()
    if is_error(r117) goto L59 (error at <module>:-1) else goto L42
L42:
    r118 = '__mypyc_attrs__'
    r119 = 'methods'
    r120 = '__dict__'
    r121 = PyTuple_Pack(2, r119, r120)
    if is_error(r121) goto L59 (error at <module>:44) else goto L43
L43:
    r122 = PyObject_SetAttr(r116, r118, r121)
    dec_ref r121
    r123 = r122 >= 0 :: signed
    if not r123 goto L59 (error at <module>:44) else goto L44 :: bool
L44:
    dank_mids.brownie_patch.types.DankOverloadedMethod = r116 :: type
    r124 = dank_mids.brownie_patch.types.globals :: static
    r125 = 'DankOverloadedMethod'
    r126 = CPyDict_SetItem(r124, r125, r116)
    dec_ref r116
    r127 = r126 >= 0 :: signed
    if not r127 goto L49 (error at <module>:44) else goto L45 :: bool
L45:
    r128 = dank_mids.brownie_patch.types.globals :: static
    r129 = 'Union'
    r130 = CPyDict_GetItem(r128, r129)
    if is_error(r130) goto L49 (error at <module>:96) else goto L46
L46:
    r131 = dank_mids.brownie_patch.types.DankContractCall :: type
    r132 = dank_mids.brownie_patch.types.DankContractTx :: type
    r133 = dank_mids.brownie_patch.types.DankOverloadedMethod :: type
    inc_ref r131
    inc_ref r132
    inc_ref r133
    r134 = (r131, r132, r133)
    r135 = box(tuple[object, object, object], r134)
    r136 = PyObject_GetItem(r130, r135)
    dec_ref r130
    dec_ref r135
    if is_error(r136) goto L49 (error at <module>:96) else goto L47
L47:
    r137 = dank_mids.brownie_patch.types.globals :: static
    r138 = 'DankContractMethod'
    r139 = CPyDict_SetItem(r137, r138, r136)
    dec_ref r136
    r140 = r139 >= 0 :: signed
    if not r140 goto L49 (error at <module>:96) else goto L48 :: bool
L48:
    return 1
L49:
    r141 = <error> :: None
    return r141
L50:
    dec_ref r34
    goto L49
L51:
    dec_ref r34
    dec_ref r37
    goto L49
L52:
    dec_ref r34
    dec_ref r37
    dec_ref r40
    goto L49
L53:
    dec_ref r53
    goto L49
L54:
    dec_ref r60
    goto L49
L55:
    dec_ref r73
    goto L49
L56:
    dec_ref r80
    goto L49
L57:
    dec_ref r105
    goto L49
L58:
    dec_ref r105
    dec_ref r108
    goto L49
L59:
    dec_ref r116
    goto L49

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: object_ptr
    r10 :: object_ptr[1]
    r11 :: c_ptr
    r12 :: native_int[1]
    r13 :: c_ptr
    r14 :: object
    r15 :: dict
    r16, r17 :: str
    r18 :: bit
    r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26 :: object
    r27 :: str
    r28 :: dict
    r29 :: str
    r30 :: object
    r31 :: object[1]
    r32 :: object_ptr
    r33 :: object
    r34 :: dict
    r35 :: str
    r36 :: i32
    r37 :: bit
    r38 :: object
    r39 :: bool
    r40 :: dict
    r41 :: str
    r42 :: object
    r43 :: str
    r44, r45 :: object
    r46 :: str
    r47 :: object[3]
    r48 :: object_ptr
    r49, r50 :: object
    r51 :: bool
    r52 :: dict
    r53 :: str
    r54 :: object
    r55 :: str
    r56, r57 :: object
    r58 :: str
    r59 :: object[3]
    r60 :: object_ptr
    r61, r62 :: object
    r63 :: bool
    r64 :: dict
    r65 :: str
    r66, r67 :: object
    r68 :: str
    r69 :: object[3]
    r70 :: object_ptr
    r71, r72 :: object
    r73 :: bool
    r74 :: str
    r75 :: object
    r76 :: dict
    r77 :: str
    r78 :: i32
    r79 :: bit
    r80 :: str
    r81 :: dict
    r82 :: str
    r83 :: object
    r84 :: object[1]
    r85 :: object_ptr
    r86 :: object
    r87 :: dict
    r88 :: str
    r89 :: i32
    r90 :: bit
    r91 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L36 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Final',)
    r6 = 'typing'
    r7 = dank_mids._envs.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L36 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address a_sync :: module
    r10 = [r9]
    r11 = load_address r10
    r12 = [3]
    r13 = load_address r12
    r14 = (('a_sync', 'a_sync', 'a_sync'),)
    r15 = dank_mids._envs.globals :: static
    r16 = 'dank_mids\\_envs.py'
    r17 = '<module>'
    r18 = CPyImport_ImportMany(r14, r11, r15, r16, r17, r13)
    if not r18 goto L36 else goto L5 :: bool
L5:
    r19 = ('EnvVarFactory',)
    r20 = 'typed_envs'
    r21 = dank_mids._envs.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L36 (error at <module>:4) else goto L6
L6:
    typed_envs = r22 :: module
    dec_ref r22
    r23 = ('BlockSemaphore',)
    r24 = 'dank_mids.semaphores'
    r25 = dank_mids._envs.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L36 (error at <module>:6) else goto L7
L7:
    dank_mids.semaphores = r26 :: module
    dec_ref r26
    r27 = 'DANKMIDS'
    r28 = dank_mids._envs.globals :: static
    r29 = 'EnvVarFactory'
    r30 = CPyDict_GetItem(r28, r29)
    if is_error(r30) goto L36 (error at <module>:9) else goto L8
L8:
    r31 = [r27]
    r32 = load_address r31
    r33 = _PyObject_Vectorcall(r30, r32, 1, 0)
    dec_ref r30
    if is_error(r33) goto L36 (error at <module>:9) else goto L9
L9:
    dank_mids._envs._factory = r33 :: static
    r34 = dank_mids._envs.globals :: static
    r35 = '_factory'
    r36 = CPyDict_SetItem(r34, r35, r33)
    dec_ref r33
    r37 = r36 >= 0 :: signed
    if not r37 goto L36 (error at <module>:9) else goto L10 :: bool
L10:
    r38 = dank_mids._envs._factory :: static
    if is_error(r38) goto L11 else goto L13
L11:
    r39 = raise NameError('value for final name "_factory" was not set')
    if not r39 goto L36 (error at <module>:13) else goto L12 :: bool
L12:
    unreachable
L13:
    r40 = dank_mids._envs.globals :: static
    r41 = 'a_sync'
    r42 = CPyDict_GetItem(r40, r41)
    if is_error(r42) goto L36 (error at <module>:13) else goto L14
L14:
    r43 = 'Semaphore'
    r44 = CPyObject_GetAttr(r42, r43)
    dec_ref r42
    if is_error(r44) goto L36 (error at <module>:13) else goto L15
L15:
    r45 = load_address PyLong_Type
    r46 = 'register_string_converter'
    r47 = [r38, r44, r45]
    r48 = load_address r47
    r49 = PyObject_VectorcallMethod(r46, r48, 9223372036854775811, 0)
    if is_error(r49) goto L37 (error at <module>:13) else goto L38
L16:
    dec_ref r44
    r50 = dank_mids._envs._factory :: static
    if is_error(r50) goto L17 else goto L19
L17:
    r51 = raise NameError('value for final name "_factory" was not set')
    if not r51 goto L36 (error at <module>:14) else goto L18 :: bool
L18:
    unreachable
L19:
    r52 = dank_mids._envs.globals :: static
    r53 = 'a_sync'
    r54 = CPyDict_GetItem(r52, r53)
    if is_error(r54) goto L36 (error at <module>:14) else goto L20
L20:
    r55 = 'ProcessPoolExecutor'
    r56 = CPyObject_GetAttr(r54, r55)
    dec_ref r54
    if is_error(r56) goto L36 (error at <module>:14) else goto L21
L21:
    r57 = load_address PyLong_Type
    r58 = 'register_string_converter'
    r59 = [r50, r56, r57]
    r60 = load_address r59
    r61 = PyObject_VectorcallMethod(r58, r60, 9223372036854775811, 0)
    if is_error(r61) goto L39 (error at <module>:14) else goto L40
L22:
    dec_ref r56
    r62 = dank_mids._envs._factory :: static
    if is_error(r62) goto L23 else goto L25
L23:
    r63 = raise NameError('value for final name "_factory" was not set')
    if not r63 goto L36 (error at <module>:15) else goto L24 :: bool
L24:
    unreachable
L25:
    r64 = dank_mids._envs.globals :: static
    r65 = 'BlockSemaphore'
    r66 = CPyDict_GetItem(r64, r65)
    if is_error(r66) goto L36 (error at <module>:15) else goto L26
L26:
    r67 = load_address PyLong_Type
    r68 = 'register_string_converter'
    r69 = [r62, r66, r67]
    r70 = load_address r69
    r71 = PyObject_VectorcallMethod(r68, r70, 9223372036854775811, 0)
    if is_error(r71) goto L41 (error at <module>:15) else goto L42
L27:
    dec_ref r66
    r72 = dank_mids._envs._factory :: static
    if is_error(r72) goto L28 else goto L30
L28:
    r73 = raise NameError('value for final name "_factory" was not set')
    if not r73 goto L36 (error at <module>:17) else goto L29 :: bool
L29:
    unreachable
L30:
    r74 = 'create_env'
    r75 = CPyObject_GetAttr(r72, r74)
    if is_error(r75) goto L36 (error at <module>:17) else goto L31
L31:
    dank_mids._envs.create_env = r75 :: static
    r76 = dank_mids._envs.globals :: static
    r77 = 'create_env'
    r78 = CPyDict_SetItem(r76, r77, r75)
    dec_ref r75
    r79 = r78 >= 0 :: signed
    if not r79 goto L36 (error at <module>:17) else goto L32 :: bool
L32:
    r80 = 'DANK_MIDS'
    r81 = dank_mids._envs.globals :: static
    r82 = 'EnvVarFactory'
    r83 = CPyDict_GetItem(r81, r82)
    if is_error(r83) goto L36 (error at <module>:20) else goto L33
L33:
    r84 = [r80]
    r85 = load_address r84
    r86 = _PyObject_Vectorcall(r83, r85, 1, 0)
    dec_ref r83
    if is_error(r86) goto L36 (error at <module>:20) else goto L34
L34:
    dank_mids._envs._deprecated_format = r86 :: static
    r87 = dank_mids._envs.globals :: static
    r88 = '_deprecated_format'
    r89 = CPyDict_SetItem(r87, r88, r86)
    dec_ref r86
    r90 = r89 >= 0 :: signed
    if not r90 goto L36 (error at <module>:20) else goto L35 :: bool
L35:
    return 1
L36:
    r91 = <error> :: None
    return r91
L37:
    dec_ref r44
    goto L36
L38:
    dec_ref r49
    goto L16
L39:
    dec_ref r56
    goto L36
L40:
    dec_ref r61
    goto L22
L41:
    dec_ref r66
    goto L36
L42:
    dec_ref r71
    goto L27

def __mypyc_lambda__0_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__0_obj.__call__(__mypyc_self__, self, args):
    __mypyc_self__ :: dank_mids.brownie_patch.call.__mypyc_lambda__0_obj
    self, args :: object
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: list
    r15, r16, r17, r18 :: ptr
    r19 :: object
    r20 :: tuple
    r21 :: dict
    r22, r23 :: object
L0:
    r0 = dank_mids.brownie_patch.call.globals :: static
    r1 = 'ENVS'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L12 (error at <lambda>:82) else goto L1
L1:
    r3 = 'BROWNIE_ENCODER_PROCESSES'
    r4 = CPyObject_GetAttr(r2, r3)
    dec_ref r2
    if is_error(r4) goto L12 (error at <lambda>:82) else goto L2
L2:
    r5 = dank_mids.brownie_patch.call.globals :: static
    r6 = '__encode_input'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L13 (error at <lambda>:82) else goto L3
L3:
    r8 = 'abi'
    r9 = CPyObject_GetAttr(self, r8)
    if is_error(r9) goto L14 (error at <lambda>:82) else goto L4
L4:
    r10 = 'signature'
    r11 = CPyObject_GetAttr(self, r10)
    if is_error(r11) goto L15 (error at <lambda>:82) else goto L5
L5:
    r12 = 'run'
    r13 = CPyObject_GetAttr(r4, r12)
    dec_ref r4
    if is_error(r13) goto L16 (error at <lambda>:82) else goto L6
L6:
    r14 = PyList_New(3)
    if is_error(r14) goto L17 (error at <lambda>:82) else goto L7
L7:
    r15 = get_element_ptr r14 ob_item :: PyListObject
    r16 = load_mem r15 :: ptr*
    set_mem r16, r7 :: builtins.object*
    r17 = r16 + 8
    set_mem r17, r9 :: builtins.object*
    r18 = r16 + 16
    set_mem r18, r11 :: builtins.object*
    r19 = CPyList_Extend(r14, args)
    if is_error(r19) goto L18 (error at <lambda>:82) else goto L19
L8:
    r20 = PyList_AsTuple(r14)
    dec_ref r14
    if is_error(r20) goto L20 (error at <lambda>:82) else goto L9
L9:
    r21 = PyDict_New()
    if is_error(r21) goto L21 (error at <lambda>:82) else goto L10
L10:
    r22 = PyObject_Call(r13, r20, r21)
    dec_ref r13
    dec_ref r20
    dec_ref r21
    if is_error(r22) goto L12 (error at <lambda>:82) else goto L11
L11:
    return r22
L12:
    r23 = <error> :: object
    return r23
L13:
    dec_ref r4
    goto L12
L14:
    dec_ref r4
    dec_ref r7
    goto L12
L15:
    dec_ref r4
    dec_ref r7
    dec_ref r9
    goto L12
L16:
    dec_ref r7
    dec_ref r9
    dec_ref r11
    goto L12
L17:
    dec_ref r7
    dec_ref r9
    dec_ref r11
    dec_ref r13
    goto L12
L18:
    dec_ref r13
    dec_ref r14
    goto L12
L19:
    dec_ref r19
    goto L8
L20:
    dec_ref r13
    goto L12
L21:
    dec_ref r13
    dec_ref r20
    goto L12

def __mypyc_lambda__1_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__1_obj.__call__(__mypyc_self__, self, data):
    __mypyc_self__ :: dank_mids.brownie_patch.call.__mypyc_lambda__1_obj
    self :: object
    data :: bytes
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: str
    r11 :: object[4]
    r12 :: object_ptr
    r13, r14 :: object
L0:
    r0 = dank_mids.brownie_patch.call.globals :: static
    r1 = 'ENVS'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L6 (error at <lambda>:101) else goto L1
L1:
    r3 = 'BROWNIE_DECODER_PROCESSES'
    r4 = CPyObject_GetAttr(r2, r3)
    dec_ref r2
    if is_error(r4) goto L6 (error at <lambda>:101) else goto L2
L2:
    r5 = dank_mids.brownie_patch.call.globals :: static
    r6 = '__decode_output'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L7 (error at <lambda>:101) else goto L3
L3:
    r8 = 'abi'
    r9 = CPyObject_GetAttr(self, r8)
    if is_error(r9) goto L8 (error at <lambda>:101) else goto L4
L4:
    r10 = 'run'
    r11 = [r4, r7, data, r9]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775812, 0)
    if is_error(r13) goto L9 (error at <lambda>:101) else goto L5
L5:
    dec_ref r4
    dec_ref r7
    dec_ref r9
    return r13
L6:
    r14 = <error> :: object
    return r14
L7:
    dec_ref r4
    goto L6
L8:
    dec_ref r4
    dec_ref r7
    goto L6
L9:
    dec_ref r4
    dec_ref r7
    dec_ref r9
    goto L6

def _patch_call(call, w3):
    call, w3 :: object
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: set
    r6 :: i32
    r7 :: bit
    r8 :: bool
    r9 :: str
    r10 :: object
    r11 :: i32
    r12 :: bit
    r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: int
    r18 :: dict
    r19 :: str
    r20, r21 :: object
    r22 :: object[2]
    r23 :: object_ptr
    r24 :: object
    r25 :: dict
    r26 :: str
    r27 :: object
    r28 :: object[2]
    r29 :: object_ptr
    r30 :: object
    r31 :: str
    r32 :: i32
    r33 :: bit
    r34 :: dict
    r35 :: str
    r36 :: object
    r37 :: dict
    r38 :: str
    r39 :: object
    r40 :: object[2]
    r41 :: object_ptr
    r42 :: object
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: None
L0:
    r0 = '_address'
    r1 = CPyObject_GetAttr(call, r0)
    if is_error(r1) goto L18 (error at _patch_call:135) else goto L1
L1:
    r2 = dank_mids.brownie_patch.call.globals :: static
    r3 = '_skip_proc_pool'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L19 (error at _patch_call:135) else goto L2
L2:
    r5 = cast(set, r4)
    if is_error(r5) goto L19 (error at _patch_call:135) else goto L3
L3:
    r6 = PySet_Contains(r5, r1)
    dec_ref r5
    dec_ref r1
    r7 = r6 >= 0 :: signed
    if not r7 goto L18 (error at _patch_call:135) else goto L4 :: bool
L4:
    r8 = truncate r6: i32 to builtins.bool
    r9 = '_skip_decoder_proc_pool'
    r10 = box(bool, r8)
    r11 = PyObject_SetAttr(call, r9, r10)
    r12 = r11 >= 0 :: signed
    if not r12 goto L18 (error at _patch_call:135) else goto L5 :: bool
L5:
    r13 = 'abi'
    r14 = CPyObject_GetAttr(call, r13)
    if is_error(r14) goto L18 (error at _patch_call:136) else goto L6
L6:
    r15 = 'inputs'
    r16 = PyObject_GetItem(r14, r15)
    dec_ref r14
    if is_error(r16) goto L18 (error at _patch_call:136) else goto L7
L7:
    r17 = CPyObject_Size(r16)
    dec_ref r16
    if is_error(r17) goto L18 (error at _patch_call:136) else goto L8
L8:
    r18 = dank_mids.brownie_patch.call.globals :: static
    r19 = '_get_coroutine_fn'
    r20 = CPyDict_GetItem(r18, r19)
    if is_error(r20) goto L20 (error at _patch_call:136) else goto L9
L9:
    r21 = box(int, r17)
    r22 = [w3, r21]
    r23 = load_address r22
    r24 = _PyObject_Vectorcall(r20, r23, 2, 0)
    dec_ref r20
    if is_error(r24) goto L21 (error at _patch_call:136) else goto L10
L10:
    dec_ref r21
    r25 = dank_mids.brownie_patch.call.globals :: static
    r26 = 'MethodType'
    r27 = CPyDict_GetItem(r25, r26)
    if is_error(r27) goto L22 (error at _patch_call:136) else goto L11
L11:
    r28 = [r24, call]
    r29 = load_address r28
    r30 = _PyObject_Vectorcall(r27, r29, 2, 0)
    dec_ref r27
    if is_error(r30) goto L22 (error at _patch_call:136) else goto L12
L12:
    dec_ref r24
    r31 = 'coroutine'
    r32 = PyObject_SetAttr(call, r31, r30)
    dec_ref r30
    r33 = r32 >= 0 :: signed
    if not r33 goto L18 (error at _patch_call:136) else goto L13 :: bool
L13:
    r34 = dank_mids.brownie_patch.call.globals :: static
    r35 = '_call_no_args'
    r36 = CPyDict_GetItem(r34, r35)
    if is_error(r36) goto L18 (error at _patch_call:137) else goto L14
L14:
    r37 = dank_mids.brownie_patch.call.globals :: static
    r38 = 'MethodType'
    r39 = CPyDict_GetItem(r37, r38)
    if is_error(r39) goto L23 (error at _patch_call:137) else goto L15
L15:
    r40 = [r36, call]
    r41 = load_address r40
    r42 = _PyObject_Vectorcall(r39, r41, 2, 0)
    dec_ref r39
    if is_error(r42) goto L23 (error at _patch_call:137) else goto L16
L16:
    dec_ref r36
    r43 = '__await__'
    r44 = PyObject_SetAttr(call, r43, r42)
    dec_ref r42
    r45 = r44 >= 0 :: signed
    if not r45 goto L18 (error at _patch_call:137) else goto L17 :: bool
L17:
    return 1
L18:
    r46 = <error> :: None
    return r46
L19:
    dec_ref r1
    goto L18
L20:
    dec_ref r17 :: int
    goto L18
L21:
    dec_ref r21
    goto L18
L22:
    dec_ref r24
    goto L18
L23:
    dec_ref r36
    goto L18

def coroutine__get_coroutine_fn_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def coroutine__get_coroutine_fn_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    type, value, traceback, arg, r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11 :: object
    r12, r13 :: tuple[object, object, object]
    r14, r15, r16, r17 :: object
    r18, r19 :: tuple[object, object, object]
    r20, r21 :: object
    r22 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_env
    r23 :: int
    r24 :: dank_mids.brownie_patch.call._get_coroutine_fn_env
    r25 :: object
    r26 :: bit
    r27 :: union[dict, None]
    r28 :: object
    r29 :: bit
    r30 :: dict
    r31 :: native_int
    r32 :: short_int
    r33 :: bit
    r34 :: str
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: object[1]
    r39 :: object_ptr
    r40, r41 :: object
    r42 :: bool
    r43 :: union[object, None]
    r44, r45 :: object
    r46 :: str
    r47 :: object
    r48 :: bool
    r49 :: str
    r50 :: object
    r51 :: object[1]
    r52 :: object_ptr
    r53 :: object
    r54, r55 :: bool
    r56 :: object
    r57 :: bool
    r58, r59, r60, r61, r62 :: object
    r63 :: bool
    r64 :: object
    r65 :: bit
    r66 :: tuple[object, object, object]
    r67 :: bool
    r68 :: object_ptr
    r69 :: object
    r70, r71 :: bool
    r72 :: tuple[object, object, object]
    r73 :: bool
    r74, r75 :: tuple[object, object, object]
    r76 :: bit
    r77, r78, r79, r80 :: object
    r81 :: int
    r82 :: object
    r83 :: tuple
    r84 :: dict
    r85 :: str
    r86 :: object
    r87 :: list
    r88 :: object
    r89, r90, r91, r92 :: ptr
    r93 :: object
    r94 :: tuple
    r95 :: dict
    r96, r97 :: object
    r98 :: bool
    r99, r100, r101, r102, r103 :: object
    r104 :: bool
    r105 :: object
    r106 :: bit
    r107 :: tuple[object, object, object]
    r108 :: bool
    r109 :: object_ptr
    r110 :: object
    r111, r112 :: bool
    r113 :: tuple[object, object, object]
    r114 :: bool
    r115, r116 :: tuple[object, object, object]
    r117 :: bit
    r118, r119, r120 :: object
    r121 :: bool
    r122 :: object
    r123 :: bool
    r124 :: union[object, None]
    r125, r126 :: object
    r127 :: str
    r128 :: object
    r129 :: bool
    r130 :: str
    r131 :: object
    r132 :: object[1]
    r133 :: object_ptr
    r134 :: object
    r135, r136 :: bool
    r137 :: object
    r138 :: bool
    r139, r140, r141, r142, r143 :: object
    r144 :: bool
    r145 :: object
    r146 :: bit
    r147 :: tuple[object, object, object]
    r148 :: bool
    r149 :: object_ptr
    r150 :: object
    r151, r152 :: bool
    r153 :: tuple[object, object, object]
    r154 :: bool
    r155, r156 :: tuple[object, object, object]
    r157 :: bit
    r158, r159, r160, r161 :: object
    r162 :: str
    r163 :: object
    r164 :: str
    r165 :: object
    r166 :: str
    r167 :: object
    r168 :: str
    r169 :: object
    r170 :: dict
    r171 :: union[object, None]
    r172 :: str
    r173 :: object[3]
    r174 :: object_ptr
    r175, r176 :: object
    r177 :: bool
    r178, r179, r180, r181, r182 :: object
    r183 :: bool
    r184 :: object
    r185 :: bit
    r186 :: tuple[object, object, object]
    r187 :: bool
    r188 :: object_ptr
    r189 :: object
    r190, r191 :: bool
    r192 :: tuple[object, object, object]
    r193 :: bool
    r194, r195 :: tuple[object, object, object]
    r196 :: bit
    r197, r198, r199 :: object
    r200 :: bool
    r201 :: tuple[object, object, object]
    r202, r203 :: bool
    r204 :: tuple[object, object, object]
    r205, r206, r207, r208, r209 :: object
    r210 :: object[4]
    r211 :: object_ptr
    r212, r213 :: object
    r214 :: bool
    r215, r216, r217, r218, r219 :: object
    r220 :: bool
    r221 :: object
    r222 :: bit
    r223 :: tuple[object, object, object]
    r224 :: bool
    r225 :: object_ptr
    r226 :: object
    r227, r228 :: bool
    r229 :: tuple[object, object, object]
    r230 :: bool
    r231, r232 :: tuple[object, object, object]
    r233 :: bit
    r234, r235, r236 :: object
    r237 :: i32
    r238 :: bit
    r239 :: bool
    r240, r241 :: tuple[object, object, object]
    r242 :: bit
    r243, r244 :: tuple[object, object, object]
    r245 :: bool
    r246, r247, r248 :: object
    r249 :: object[4]
    r250 :: object_ptr
    r251, r252 :: object
    r253 :: bool
    r254, r255, r256, r257, r258 :: object
    r259 :: bool
    r260 :: object
    r261 :: bit
    r262 :: tuple[object, object, object]
    r263 :: bool
    r264 :: object_ptr
    r265 :: object
    r266, r267 :: bool
    r268 :: tuple[object, object, object]
    r269 :: bool
    r270, r271 :: tuple[object, object, object]
    r272 :: bit
    r273, r274, r275 :: object
    r276 :: bool
    r277 :: bit
    r278 :: tuple[object, object, object]
    r279, r280 :: bool
    r281 :: tuple[object, object, object]
    r282, r283, r284, r285, r286 :: object
    r287 :: object[4]
    r288 :: object_ptr
    r289, r290 :: object
    r291 :: bool
    r292, r293, r294, r295, r296 :: object
    r297 :: bool
    r298 :: object
    r299 :: bit
    r300 :: tuple[object, object, object]
    r301 :: bool
    r302 :: object_ptr
    r303 :: object
    r304, r305 :: bool
    r306 :: tuple[object, object, object]
    r307 :: bool
    r308, r309 :: tuple[object, object, object]
    r310 :: bit
    r311, r312, r313 :: object
    r314 :: i32
    r315 :: bit
    r316 :: bool
    r317, r318 :: tuple[object, object, object]
    r319 :: bit
    r320, r321 :: tuple[object, object, object]
    r322 :: bool
    r323, r324, r325 :: object
    r326 :: object[4]
    r327 :: object_ptr
    r328, r329 :: object
    r330 :: bool
    r331, r332, r333, r334, r335 :: object
    r336 :: bool
    r337 :: object
    r338 :: bit
    r339 :: tuple[object, object, object]
    r340 :: bool
    r341 :: object_ptr
    r342 :: object
    r343, r344 :: bool
    r345 :: tuple[object, object, object]
    r346 :: bool
    r347, r348 :: tuple[object, object, object]
    r349 :: bit
    r350, r351, r352 :: object
    r353 :: bool
    r354 :: bit
    r355, r356 :: object
    r357 :: bytes
    r358, r359 :: object
    r360 :: bool
    r361, r362, r363, r364, r365 :: object
    r366 :: bool
    r367 :: object
    r368 :: bit
    r369 :: tuple[object, object, object]
    r370 :: bool
    r371 :: object_ptr
    r372 :: object
    r373, r374 :: bool
    r375 :: tuple[object, object, object]
    r376 :: bool
    r377, r378 :: tuple[object, object, object]
    r379 :: bit
    r380, r381, r382 :: object
    r383 :: bool
    r384 :: tuple[object, object, object]
    r385 :: bool
    r386 :: dict
    r387 :: str
    r388 :: object
    r389 :: bit
    r390 :: object
    r391 :: bool
    r392 :: object
    r393 :: str
    r394, r395 :: object
    r396 :: str
    r397, r398 :: object
    r399 :: dict
    r400 :: str
    r401 :: object
    r402 :: object[4]
    r403 :: object_ptr
    r404 :: object
    r405 :: tuple[object, object, object]
    r406 :: bit
    r407 :: union[int, None]
    r408 :: object
    r409 :: bit
    r410, r411, r412 :: object
    r413 :: union[int, None]
    r414 :: int
    r415 :: object
    r416 :: bool
    r417 :: object
    r418 :: object[1]
    r419 :: object_ptr
    r420, r421, r422, r423 :: object
    r424 :: bool
    r425, r426, r427, r428, r429, r430, r431, r432, r433, r434 :: bit
    r435 :: bool
    r436 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = <error> :: object
    r5 = r4
    r6 = <error> :: object
    r7 = r6
    r8 = <error> :: object
    r9 = r8
    r10 = <error> :: object
    r11 = r10
    r12 = <error> :: tuple[object, object, object]
    r13 = r12
    r14 = <error> :: object
    r15 = r14
    r16 = <error> :: object
    r17 = r16
    r18 = <error> :: tuple[object, object, object]
    r19 = r18
    r20 = <error> :: object
    r21 = r20
    r22 = __mypyc_self__.__mypyc_env__
    if is_error(r22) goto L487 (error at coroutine:147) else goto L1
L1:
    r23 = r22.__mypyc_next_label__
    if is_error(r23) goto L488 (error at coroutine:147) else goto L2
L2:
    r24 = r22.__mypyc_env__
    if is_error(r24) goto L489 (error at coroutine:147) else goto L474
L3:
    r25 = load_address _Py_NoneStruct
    r26 = type != r25
    if r26 goto L490 else goto L6 :: bool
L4:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L486 (error at coroutine:147) else goto L5 :: bool
L5:
    unreachable
L6:
    r27 = r22.override
    if is_error(r27) goto L491 (error at coroutine:154) else goto L7
L7:
    r28 = load_address _Py_NoneStruct
    r29 = r27 != r28
    if r29 goto L8 else goto L492 :: bool
L8:
    r30 = cast(dict, r27)
    if is_error(r30) goto L491 (error at coroutine:154) else goto L9
L9:
    r31 = PyDict_Size(r30)
    dec_ref r30
    r32 = r31 << 1
    r33 = r32 != 0
    if r33 goto L493 else goto L14 :: bool
L10:
    r34 = 'Cannot use state override with `coroutine`.'
    r35 = builtins :: module
    r36 = 'ValueError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L486 (error at coroutine:155) else goto L11
L11:
    r38 = [r34]
    r39 = load_address r38
    r40 = _PyObject_Vectorcall(r37, r39, 1, 0)
    dec_ref r37
    if is_error(r40) goto L486 (error at coroutine:155) else goto L12
L12:
    CPy_Raise(r40)
    dec_ref r40
    if not 0 goto L486 (error at coroutine:155) else goto L13 :: bool
L13:
    unreachable
L14:
    r41 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_ENCODER_SEMAPHORE :: static
    if is_error(r41) goto L494 else goto L17
L15:
    r42 = raise NameError('value for final name "BROWNIE_ENCODER_SEMAPHORE" was not set')
    if not r42 goto L486 (error at coroutine:156) else goto L16 :: bool
L16:
    unreachable
L17:
    r43 = r22.block_identifier
    if is_error(r43) goto L491 (error at coroutine:156) else goto L18
L18:
    r44 = PyObject_GetItem(r41, r43)
    dec_ref r43
    if is_error(r44) goto L491 (error at coroutine:156) else goto L19
L19:
    r45 = PyObject_Type(r44)
    r46 = '__aexit__'
    r47 = CPyObject_GetAttr(r45, r46)
    if is_error(r47) goto L495 (error at coroutine:156) else goto L20
L20:
    r22.__mypyc_temp__0 = r47; r48 = is_error
    if not r48 goto L495 (error at coroutine:-1) else goto L21 :: bool
L21:
    r49 = '__aenter__'
    r50 = CPyObject_GetAttr(r45, r49)
    dec_ref r45
    if is_error(r50) goto L496 (error at coroutine:156) else goto L22
L22:
    r51 = [r44]
    r52 = load_address r51
    r53 = _PyObject_Vectorcall(r50, r52, 1, 0)
    dec_ref r50
    if is_error(r53) goto L496 (error at coroutine:156) else goto L23
L23:
    r22.__mypyc_temp__1 = r44; r54 = is_error
    if not r54 goto L497 (error at coroutine:-1) else goto L24 :: bool
L24:
    r22.__mypyc_temp__2 = 1; r55 = is_error
    if not r55 goto L497 (error at coroutine:-1) else goto L25 :: bool
L25:
    r56 = CPy_GetCoro(r53)
    dec_ref r53
    if is_error(r56) goto L491 (error at coroutine:156) else goto L26
L26:
    r22.__mypyc_temp__3 = r56; r57 = is_error
    if not r57 goto L491 (error at coroutine:-1) else goto L27 :: bool
L27:
    r58 = r22.__mypyc_temp__3
    if is_error(r58) goto L491 (error at coroutine:-1) else goto L28
L28:
    r59 = CPyIter_Next(r58)
    dec_ref r58
    if is_error(r59) goto L498 else goto L31
L29:
    r60 = CPy_FetchStopIterationValue()
    if is_error(r60) goto L499 (error at coroutine:156) else goto L30
L30:
    r61 = r60
    dec_ref r61
    goto L60
L31:
    r62 = r59
L32:
    r22.__mypyc_next_label__ = 2; r63 = is_error
    if not r63 goto L500 (error at coroutine:156) else goto L501 :: bool
L33:
    return r62
L34:
    r64 = load_address _Py_NoneStruct
    r65 = type != r64
    if r65 goto L35 else goto L37 :: bool
L35:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L38 (error at coroutine:156) else goto L502 :: bool
L36:
    unreachable
L37:
    inc_ref arg
    goto L55
L38:
    r66 = CPy_CatchError()
    r22.__mypyc_temp__4 = r66; r67 = is_error
    if not r67 goto L503 (error at coroutine:-1) else goto L39 :: bool
L39:
    r68 = load_address r1
    r69 = r22.__mypyc_temp__3
    if is_error(r69) goto L503 (error at coroutine:-1) else goto L40
L40:
    r70 = CPy_YieldFromErrorHandle(r69, r68)
    dec_ref r69
    if is_error(r70) goto L503 (error at coroutine:156) else goto L41
L41:
    if r70 goto L47 else goto L42 :: bool
L42:
    if is_error(r1) goto L504 else goto L45
L43:
    r71 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r71 goto L52 (error at coroutine:-1) else goto L505 :: bool
L44:
    unreachable
L45:
    inc_ref r1
    r62 = r1
    r72 = r22.__mypyc_temp__4
    if is_error(r72) goto L506 (error at coroutine:-1) else goto L46
L46:
    CPy_RestoreExcInfo(r72)
    dec_ref r72
    goto L32
L47:
    if is_error(r1) goto L507 else goto L50
L48:
    r73 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r73 goto L52 (error at coroutine:-1) else goto L508 :: bool
L49:
    unreachable
L50:
    r61 = r1
    dec_ref r61
    r74 = r22.__mypyc_temp__4
    if is_error(r74) goto L509 (error at coroutine:-1) else goto L51
L51:
    CPy_RestoreExcInfo(r74)
    dec_ref r74
    goto L60
L52:
    r75 = r22.__mypyc_temp__4
    dec_ref r22
    if is_error(r75) goto L486 (error at coroutine:-1) else goto L53
L53:
    CPy_RestoreExcInfo(r75)
    dec_ref r75
    r76 = CPy_KeepPropagating()
    if not r76 goto L486 else goto L54 :: bool
L54:
    unreachable
L55:
    r77 = r22.__mypyc_temp__3
    if is_error(r77) goto L510 (error at coroutine:-1) else goto L56
L56:
    r78 = CPyIter_Send(r77, arg)
    dec_ref r77
    dec_ref arg
    if is_error(r78) goto L511 else goto L57
L57:
    r62 = r78
    goto L32
L58:
    r79 = CPy_FetchStopIterationValue()
    if is_error(r79) goto L499 (error at coroutine:156) else goto L59
L59:
    r61 = r79
    dec_ref r61
L60:
    r80 = r22.self
    if is_error(r80) goto L512 (error at coroutine:157) else goto L61
L61:
    r81 = r24.len_inputs
    if is_error(r81) goto L513 (error at coroutine:157) else goto L62
L62:
    r82 = r24.get_request_data
    if is_error(r82) goto L514 (error at coroutine:157) else goto L63
L63:
    r83 = r22.args
    if is_error(r83) goto L515 (error at coroutine:157) else goto L64
L64:
    r84 = dank_mids.brownie_patch.call.globals :: static
    r85 = 'encode_input'
    r86 = CPyDict_GetItem(r84, r85)
    if is_error(r86) goto L516 (error at coroutine:157) else goto L65
L65:
    r87 = PyList_New(3)
    if is_error(r87) goto L517 (error at coroutine:157) else goto L66
L66:
    r88 = box(int, r81)
    r89 = get_element_ptr r87 ob_item :: PyListObject
    r90 = load_mem r89 :: ptr*
    set_mem r90, r80 :: builtins.object*
    r91 = r90 + 8
    set_mem r91, r88 :: builtins.object*
    r92 = r90 + 16
    set_mem r92, r82 :: builtins.object*
    r93 = CPyList_Extend(r87, r83)
    dec_ref r83
    if is_error(r93) goto L518 (error at coroutine:157) else goto L519
L67:
    r94 = PyList_AsTuple(r87)
    dec_ref r87
    if is_error(r94) goto L520 (error at coroutine:157) else goto L68
L68:
    r95 = PyDict_New()
    if is_error(r95) goto L521 (error at coroutine:157) else goto L69
L69:
    r96 = PyObject_Call(r86, r94, r95)
    dec_ref r86
    dec_ref r94
    dec_ref r95
    if is_error(r96) goto L512 (error at coroutine:157) else goto L70
L70:
    r97 = CPy_GetCoro(r96)
    dec_ref r96
    if is_error(r97) goto L512 (error at coroutine:157) else goto L71
L71:
    r22.__mypyc_temp__5 = r97; r98 = is_error
    if not r98 goto L512 (error at coroutine:-1) else goto L72 :: bool
L72:
    r99 = r22.__mypyc_temp__5
    if is_error(r99) goto L512 (error at coroutine:-1) else goto L73
L73:
    r100 = CPyIter_Next(r99)
    dec_ref r99
    if is_error(r100) goto L522 else goto L76
L74:
    r101 = CPy_FetchStopIterationValue()
    if is_error(r101) goto L523 (error at coroutine:157) else goto L75
L75:
    r102 = r101
    goto L105
L76:
    r103 = r100
L77:
    r22.__mypyc_next_label__ = 4; r104 = is_error
    if not r104 goto L524 (error at coroutine:157) else goto L525 :: bool
L78:
    return r103
L79:
    r105 = load_address _Py_NoneStruct
    r106 = type != r105
    if r106 goto L80 else goto L82 :: bool
L80:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L83 (error at coroutine:157) else goto L526 :: bool
L81:
    unreachable
L82:
    inc_ref arg
    goto L100
L83:
    r107 = CPy_CatchError()
    r22.__mypyc_temp__6 = r107; r108 = is_error
    if not r108 goto L527 (error at coroutine:-1) else goto L84 :: bool
L84:
    r109 = load_address r3
    r110 = r22.__mypyc_temp__5
    if is_error(r110) goto L527 (error at coroutine:-1) else goto L85
L85:
    r111 = CPy_YieldFromErrorHandle(r110, r109)
    dec_ref r110
    if is_error(r111) goto L527 (error at coroutine:157) else goto L86
L86:
    if r111 goto L92 else goto L87 :: bool
L87:
    if is_error(r3) goto L528 else goto L90
L88:
    r112 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r112 goto L97 (error at coroutine:-1) else goto L529 :: bool
L89:
    unreachable
L90:
    inc_ref r3
    r103 = r3
    r113 = r22.__mypyc_temp__6
    if is_error(r113) goto L530 (error at coroutine:-1) else goto L91
L91:
    CPy_RestoreExcInfo(r113)
    dec_ref r113
    goto L77
L92:
    if is_error(r3) goto L531 else goto L95
L93:
    r114 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r114 goto L97 (error at coroutine:-1) else goto L532 :: bool
L94:
    unreachable
L95:
    r102 = r3
    r115 = r22.__mypyc_temp__6
    if is_error(r115) goto L533 (error at coroutine:-1) else goto L96
L96:
    CPy_RestoreExcInfo(r115)
    dec_ref r115
    goto L105
L97:
    r116 = r22.__mypyc_temp__6
    if is_error(r116) goto L297 (error at coroutine:-1) else goto L98
L98:
    CPy_RestoreExcInfo(r116)
    dec_ref r116
    r117 = CPy_KeepPropagating()
    if not r117 goto L297 else goto L534 :: bool
L99:
    unreachable
L100:
    r118 = r22.__mypyc_temp__5
    if is_error(r118) goto L535 (error at coroutine:-1) else goto L101
L101:
    r119 = CPyIter_Send(r118, arg)
    dec_ref r118
    dec_ref arg
    if is_error(r119) goto L536 else goto L102
L102:
    r103 = r119
    goto L77
L103:
    r120 = CPy_FetchStopIterationValue()
    if is_error(r120) goto L523 (error at coroutine:157) else goto L104
L104:
    r102 = r120
L105:
    r22.data = r102; r121 = is_error
    if not r121 goto L523 (error at coroutine:157) else goto L106 :: bool
L106:
    r122 = dank_mids.ENVIRONMENT_VARIABLES.BROWNIE_CALL_SEMAPHORE :: static
    if is_error(r122) goto L537 else goto L109
L107:
    r123 = raise NameError('value for final name "BROWNIE_CALL_SEMAPHORE" was not set')
    if not r123 goto L297 (error at coroutine:158) else goto L538 :: bool
L108:
    unreachable
L109:
    r124 = r22.block_identifier
    if is_error(r124) goto L523 (error at coroutine:158) else goto L110
L110:
    r125 = PyObject_GetItem(r122, r124)
    dec_ref r124
    if is_error(r125) goto L523 (error at coroutine:158) else goto L111
L111:
    r126 = PyObject_Type(r125)
    r127 = '__aexit__'
    r128 = CPyObject_GetAttr(r126, r127)
    if is_error(r128) goto L539 (error at coroutine:158) else goto L112
L112:
    r22.__mypyc_temp__7 = r128; r129 = is_error
    if not r129 goto L539 (error at coroutine:-1) else goto L113 :: bool
L113:
    r130 = '__aenter__'
    r131 = CPyObject_GetAttr(r126, r130)
    dec_ref r126
    if is_error(r131) goto L540 (error at coroutine:158) else goto L114
L114:
    r132 = [r125]
    r133 = load_address r132
    r134 = _PyObject_Vectorcall(r131, r133, 1, 0)
    dec_ref r131
    if is_error(r134) goto L540 (error at coroutine:158) else goto L115
L115:
    r22.__mypyc_temp__8 = r125; r135 = is_error
    if not r135 goto L541 (error at coroutine:-1) else goto L116 :: bool
L116:
    r22.__mypyc_temp__9 = 1; r136 = is_error
    if not r136 goto L541 (error at coroutine:-1) else goto L117 :: bool
L117:
    r137 = CPy_GetCoro(r134)
    dec_ref r134
    if is_error(r137) goto L523 (error at coroutine:158) else goto L118
L118:
    r22.__mypyc_temp__10 = r137; r138 = is_error
    if not r138 goto L523 (error at coroutine:-1) else goto L119 :: bool
L119:
    r139 = r22.__mypyc_temp__10
    if is_error(r139) goto L523 (error at coroutine:-1) else goto L120
L120:
    r140 = CPyIter_Next(r139)
    dec_ref r139
    if is_error(r140) goto L542 else goto L123
L121:
    r141 = CPy_FetchStopIterationValue()
    if is_error(r141) goto L543 (error at coroutine:158) else goto L122
L122:
    r142 = r141
    dec_ref r142
    goto L152
L123:
    r143 = r140
L124:
    r22.__mypyc_next_label__ = 6; r144 = is_error
    if not r144 goto L544 (error at coroutine:158) else goto L545 :: bool
L125:
    return r143
L126:
    r145 = load_address _Py_NoneStruct
    r146 = type != r145
    if r146 goto L127 else goto L129 :: bool
L127:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L130 (error at coroutine:158) else goto L546 :: bool
L128:
    unreachable
L129:
    inc_ref arg
    goto L147
L130:
    r147 = CPy_CatchError()
    r22.__mypyc_temp__11 = r147; r148 = is_error
    if not r148 goto L547 (error at coroutine:-1) else goto L131 :: bool
L131:
    r149 = load_address r5
    r150 = r22.__mypyc_temp__10
    if is_error(r150) goto L547 (error at coroutine:-1) else goto L132
L132:
    r151 = CPy_YieldFromErrorHandle(r150, r149)
    dec_ref r150
    if is_error(r151) goto L547 (error at coroutine:158) else goto L133
L133:
    if r151 goto L139 else goto L134 :: bool
L134:
    if is_error(r5) goto L548 else goto L137
L135:
    r152 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r152 goto L144 (error at coroutine:-1) else goto L549 :: bool
L136:
    unreachable
L137:
    inc_ref r5
    r143 = r5
    r153 = r22.__mypyc_temp__11
    if is_error(r153) goto L550 (error at coroutine:-1) else goto L138
L138:
    CPy_RestoreExcInfo(r153)
    dec_ref r153
    goto L124
L139:
    if is_error(r5) goto L551 else goto L142
L140:
    r154 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r154 goto L144 (error at coroutine:-1) else goto L552 :: bool
L141:
    unreachable
L142:
    r142 = r5
    dec_ref r142
    r155 = r22.__mypyc_temp__11
    if is_error(r155) goto L553 (error at coroutine:-1) else goto L143
L143:
    CPy_RestoreExcInfo(r155)
    dec_ref r155
    goto L152
L144:
    r156 = r22.__mypyc_temp__11
    if is_error(r156) goto L297 (error at coroutine:-1) else goto L145
L145:
    CPy_RestoreExcInfo(r156)
    dec_ref r156
    r157 = CPy_KeepPropagating()
    if not r157 goto L297 else goto L554 :: bool
L146:
    unreachable
L147:
    r158 = r22.__mypyc_temp__10
    if is_error(r158) goto L555 (error at coroutine:-1) else goto L148
L148:
    r159 = CPyIter_Send(r158, arg)
    dec_ref r158
    dec_ref arg
    if is_error(r159) goto L556 else goto L149
L149:
    r143 = r159
    goto L124
L150:
    r160 = CPy_FetchStopIterationValue()
    if is_error(r160) goto L543 (error at coroutine:158) else goto L151
L151:
    r142 = r160
    dec_ref r142
L152:
    r161 = r24.w3
    dec_ref r24
    if is_error(r161) goto L557 (error at coroutine:159) else goto L153
L153:
    r162 = 'eth'
    r163 = CPyObject_GetAttr(r161, r162)
    dec_ref r161
    if is_error(r163) goto L557 (error at coroutine:159) else goto L154
L154:
    r164 = 'to'
    r165 = r22.self
    if is_error(r165) goto L558 (error at coroutine:159) else goto L155
L155:
    r166 = '_address'
    r167 = CPyObject_GetAttr(r165, r166)
    dec_ref r165
    if is_error(r167) goto L558 (error at coroutine:159) else goto L156
L156:
    r168 = 'data'
    r169 = r22.data
    if is_error(r169) goto L559 (error at coroutine:159) else goto L157
L157:
    r170 = CPyDict_Build(2, r164, r167, r168, r169)
    dec_ref r167
    dec_ref r169
    if is_error(r170) goto L558 (error at coroutine:159) else goto L158
L158:
    r171 = r22.block_identifier
    if is_error(r171) goto L560 (error at coroutine:159) else goto L159
L159:
    r172 = 'call'
    r173 = [r163, r170, r171]
    r174 = load_address r173
    r175 = PyObject_VectorcallMethod(r172, r174, 9223372036854775811, 0)
    if is_error(r175) goto L561 (error at coroutine:159) else goto L160
L160:
    dec_ref r163
    dec_ref r170
    dec_ref r171
    r176 = CPy_GetCoro(r175)
    dec_ref r175
    if is_error(r176) goto L557 (error at coroutine:159) else goto L161
L161:
    r22.__mypyc_temp__12 = r176; r177 = is_error
    if not r177 goto L557 (error at coroutine:-1) else goto L162 :: bool
L162:
    r178 = r22.__mypyc_temp__12
    if is_error(r178) goto L557 (error at coroutine:-1) else goto L163
L163:
    r179 = CPyIter_Next(r178)
    dec_ref r178
    if is_error(r179) goto L562 else goto L166
L164:
    r180 = CPy_FetchStopIterationValue()
    if is_error(r180) goto L196 (error at coroutine:159) else goto L165
L165:
    r181 = r180
    goto L195
L166:
    r182 = r179
L167:
    r22.__mypyc_next_label__ = 8; r183 = is_error
    if not r183 goto L563 (error at coroutine:159) else goto L564 :: bool
L168:
    return r182
L169:
    r184 = load_address _Py_NoneStruct
    r185 = type != r184
    if r185 goto L170 else goto L172 :: bool
L170:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L173 (error at coroutine:159) else goto L565 :: bool
L171:
    unreachable
L172:
    inc_ref arg
    goto L190
L173:
    r186 = CPy_CatchError()
    r22.__mypyc_temp__13 = r186; r187 = is_error
    if not r187 goto L566 (error at coroutine:-1) else goto L174 :: bool
L174:
    r188 = load_address r7
    r189 = r22.__mypyc_temp__12
    if is_error(r189) goto L566 (error at coroutine:-1) else goto L175
L175:
    r190 = CPy_YieldFromErrorHandle(r189, r188)
    dec_ref r189
    if is_error(r190) goto L566 (error at coroutine:159) else goto L176
L176:
    if r190 goto L182 else goto L177 :: bool
L177:
    if is_error(r7) goto L178 else goto L180
L178:
    r191 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r191 goto L187 (error at coroutine:-1) else goto L567 :: bool
L179:
    unreachable
L180:
    inc_ref r7
    r182 = r7
    r192 = r22.__mypyc_temp__13
    if is_error(r192) goto L568 (error at coroutine:-1) else goto L181
L181:
    CPy_RestoreExcInfo(r192)
    dec_ref r192
    goto L167
L182:
    if is_error(r7) goto L183 else goto L185
L183:
    r193 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r193 goto L187 (error at coroutine:-1) else goto L569 :: bool
L184:
    unreachable
L185:
    r181 = r7
    r194 = r22.__mypyc_temp__13
    if is_error(r194) goto L570 (error at coroutine:-1) else goto L186
L186:
    CPy_RestoreExcInfo(r194)
    dec_ref r194
    goto L195
L187:
    r195 = r22.__mypyc_temp__13
    if is_error(r195) goto L196 (error at coroutine:-1) else goto L188
L188:
    CPy_RestoreExcInfo(r195)
    dec_ref r195
    r196 = CPy_KeepPropagating()
    if not r196 goto L196 else goto L571 :: bool
L189:
    unreachable
L190:
    r197 = r22.__mypyc_temp__12
    if is_error(r197) goto L572 (error at coroutine:-1) else goto L191
L191:
    r198 = CPyIter_Send(r197, arg)
    dec_ref r197
    dec_ref arg
    if is_error(r198) goto L573 else goto L192
L192:
    r182 = r198
    goto L167
L193:
    r199 = CPy_FetchStopIterationValue()
    if is_error(r199) goto L196 (error at coroutine:159) else goto L194
L194:
    r181 = r199
L195:
    r22.output = r181; r200 = is_error
    if not r200 goto L196 (error at coroutine:159) else goto L574 :: bool
L196:
    r201 = CPy_CatchError()
    r22.__mypyc_temp__14 = r201; r202 = is_error
    if not r202 goto L575 (error at coroutine:-1) else goto L197 :: bool
L197:
    r22.__mypyc_temp__9 = 0; r203 = is_error
    if not r203 goto L575 (error at coroutine:158) else goto L198 :: bool
L198:
    r204 = CPy_GetExcInfo()
    r205 = r204[0]
    r206 = r204[1]
    r207 = r204[2]
    dec_ref r204
    r208 = r22.__mypyc_temp__7
    if is_error(r208) goto L576 (error at coroutine:-1) else goto L199
L199:
    r209 = r22.__mypyc_temp__8
    if is_error(r209) goto L577 (error at coroutine:-1) else goto L200
L200:
    r210 = [r209, r205, r206, r207]
    r211 = load_address r210
    r212 = _PyObject_Vectorcall(r208, r211, 4, 0)
    dec_ref r208
    if is_error(r212) goto L578 (error at coroutine:158) else goto L201
L201:
    dec_ref r209
    dec_ref r205
    dec_ref r206
    dec_ref r207
    r213 = CPy_GetCoro(r212)
    dec_ref r212
    if is_error(r213) goto L575 (error at coroutine:158) else goto L202
L202:
    r22.__mypyc_temp__15 = r213; r214 = is_error
    if not r214 goto L575 (error at coroutine:-1) else goto L203 :: bool
L203:
    r215 = r22.__mypyc_temp__15
    if is_error(r215) goto L575 (error at coroutine:-1) else goto L204
L204:
    r216 = CPyIter_Next(r215)
    dec_ref r215
    if is_error(r216) goto L579 else goto L207
L205:
    r217 = CPy_FetchStopIterationValue()
    if is_error(r217) goto L242 (error at coroutine:158) else goto L206
L206:
    r218 = r217
    goto L236
L207:
    r219 = r216
L208:
    r22.__mypyc_next_label__ = 10; r220 = is_error
    if not r220 goto L580 (error at coroutine:158) else goto L581 :: bool
L209:
    return r219
L210:
    r221 = load_address _Py_NoneStruct
    r222 = type != r221
    if r222 goto L211 else goto L213 :: bool
L211:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L214 (error at coroutine:158) else goto L582 :: bool
L212:
    unreachable
L213:
    inc_ref arg
    goto L231
L214:
    r223 = CPy_CatchError()
    r22.__mypyc_temp__16 = r223; r224 = is_error
    if not r224 goto L583 (error at coroutine:-1) else goto L215 :: bool
L215:
    r225 = load_address r9
    r226 = r22.__mypyc_temp__15
    if is_error(r226) goto L583 (error at coroutine:-1) else goto L216
L216:
    r227 = CPy_YieldFromErrorHandle(r226, r225)
    dec_ref r226
    if is_error(r227) goto L583 (error at coroutine:158) else goto L217
L217:
    if r227 goto L223 else goto L218 :: bool
L218:
    if is_error(r9) goto L219 else goto L221
L219:
    r228 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r228 goto L228 (error at coroutine:-1) else goto L584 :: bool
L220:
    unreachable
L221:
    inc_ref r9
    r219 = r9
    r229 = r22.__mypyc_temp__16
    if is_error(r229) goto L585 (error at coroutine:-1) else goto L222
L222:
    CPy_RestoreExcInfo(r229)
    dec_ref r229
    goto L208
L223:
    if is_error(r9) goto L224 else goto L226
L224:
    r230 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r230 goto L228 (error at coroutine:-1) else goto L586 :: bool
L225:
    unreachable
L226:
    r218 = r9
    r231 = r22.__mypyc_temp__16
    if is_error(r231) goto L587 (error at coroutine:-1) else goto L227
L227:
    CPy_RestoreExcInfo(r231)
    dec_ref r231
    goto L236
L228:
    r232 = r22.__mypyc_temp__16
    if is_error(r232) goto L242 (error at coroutine:-1) else goto L229
L229:
    CPy_RestoreExcInfo(r232)
    dec_ref r232
    r233 = CPy_KeepPropagating()
    if not r233 goto L242 else goto L588 :: bool
L230:
    unreachable
L231:
    r234 = r22.__mypyc_temp__15
    if is_error(r234) goto L589 (error at coroutine:-1) else goto L232
L232:
    r235 = CPyIter_Send(r234, arg)
    dec_ref r234
    dec_ref arg
    if is_error(r235) goto L590 else goto L233
L233:
    r219 = r235
    goto L208
L234:
    r236 = CPy_FetchStopIterationValue()
    if is_error(r236) goto L242 (error at coroutine:158) else goto L235
L235:
    r218 = r236
L236:
    r237 = PyObject_IsTrue(r218)
    dec_ref r218
    r238 = r237 >= 0 :: signed
    if not r238 goto L242 (error at coroutine:-1) else goto L237 :: bool
L237:
    r239 = truncate r237: i32 to builtins.bool
    if r239 goto L240 else goto L238 :: bool
L238:
    CPy_Reraise()
    if not 0 goto L242 else goto L591 :: bool
L239:
    unreachable
L240:
    r240 = r22.__mypyc_temp__14
    if is_error(r240) goto L246 (error at coroutine:-1) else goto L241
L241:
    CPy_RestoreExcInfo(r240)
    dec_ref r240
    goto L245
L242:
    r241 = r22.__mypyc_temp__14
    if is_error(r241) goto L246 (error at coroutine:-1) else goto L243
L243:
    CPy_RestoreExcInfo(r241)
    dec_ref r241
    r242 = CPy_KeepPropagating()
    if not r242 goto L246 else goto L592 :: bool
L244:
    unreachable
L245:
    r243 = <error> :: tuple[object, object, object]
    r13 = r243
    goto L247
L246:
    r244 = CPy_CatchError()
    r13 = r244
L247:
    r245 = r22.__mypyc_temp__9
    if is_error(r245) goto L593 (error at coroutine:-1) else goto L248
L248:
    if r245 goto L249 else goto L594 :: bool
L249:
    r246 = load_address _Py_NoneStruct
    r247 = r22.__mypyc_temp__7
    if is_error(r247) goto L593 (error at coroutine:-1) else goto L250
L250:
    r248 = r22.__mypyc_temp__8
    if is_error(r248) goto L595 (error at coroutine:-1) else goto L251
L251:
    r249 = [r248, r246, r246, r246]
    r250 = load_address r249
    r251 = _PyObject_Vectorcall(r247, r250, 4, 0)
    dec_ref r247
    if is_error(r251) goto L596 (error at coroutine:158) else goto L252
L252:
    dec_ref r248
    r252 = CPy_GetCoro(r251)
    dec_ref r251
    if is_error(r252) goto L593 (error at coroutine:158) else goto L253
L253:
    r22.__mypyc_temp__17 = r252; r253 = is_error
    if not r253 goto L593 (error at coroutine:-1) else goto L254 :: bool
L254:
    r254 = r22.__mypyc_temp__17
    if is_error(r254) goto L593 (error at coroutine:-1) else goto L255
L255:
    r255 = CPyIter_Next(r254)
    dec_ref r254
    if is_error(r255) goto L597 else goto L258
L256:
    r256 = CPy_FetchStopIterationValue()
    if is_error(r256) goto L290 (error at coroutine:158) else goto L257
L257:
    r257 = r256
    dec_ref r257
    goto L287
L258:
    r258 = r255
L259:
    r22.__mypyc_next_label__ = 12; r259 = is_error
    if not r259 goto L598 (error at coroutine:158) else goto L599 :: bool
L260:
    return r258
L261:
    r260 = load_address _Py_NoneStruct
    r261 = type != r260
    if r261 goto L262 else goto L264 :: bool
L262:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L265 (error at coroutine:158) else goto L600 :: bool
L263:
    unreachable
L264:
    inc_ref arg
    goto L282
L265:
    r262 = CPy_CatchError()
    r22.__mypyc_temp__18 = r262; r263 = is_error
    if not r263 goto L601 (error at coroutine:-1) else goto L266 :: bool
L266:
    r264 = load_address r11
    r265 = r22.__mypyc_temp__17
    if is_error(r265) goto L601 (error at coroutine:-1) else goto L267
L267:
    r266 = CPy_YieldFromErrorHandle(r265, r264)
    dec_ref r265
    if is_error(r266) goto L601 (error at coroutine:158) else goto L268
L268:
    if r266 goto L274 else goto L269 :: bool
L269:
    if is_error(r11) goto L270 else goto L272
L270:
    r267 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r267 goto L279 (error at coroutine:-1) else goto L602 :: bool
L271:
    unreachable
L272:
    inc_ref r11
    r258 = r11
    r268 = r22.__mypyc_temp__18
    if is_error(r268) goto L603 (error at coroutine:-1) else goto L273
L273:
    CPy_RestoreExcInfo(r268)
    dec_ref r268
    goto L259
L274:
    if is_error(r11) goto L275 else goto L277
L275:
    r269 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r269 goto L279 (error at coroutine:-1) else goto L604 :: bool
L276:
    unreachable
L277:
    r257 = r11
    dec_ref r257
    r270 = r22.__mypyc_temp__18
    if is_error(r270) goto L279 (error at coroutine:-1) else goto L278
L278:
    CPy_RestoreExcInfo(r270)
    dec_ref r270
    goto L287
L279:
    r271 = r22.__mypyc_temp__18
    if is_error(r271) goto L290 (error at coroutine:-1) else goto L280
L280:
    CPy_RestoreExcInfo(r271)
    dec_ref r271
    r272 = CPy_KeepPropagating()
    if not r272 goto L290 else goto L605 :: bool
L281:
    unreachable
L282:
    r273 = r22.__mypyc_temp__17
    if is_error(r273) goto L606 (error at coroutine:-1) else goto L283
L283:
    r274 = CPyIter_Send(r273, arg)
    dec_ref r273
    dec_ref arg
    if is_error(r274) goto L607 else goto L284
L284:
    r258 = r274
    goto L259
L285:
    r275 = CPy_FetchStopIterationValue()
    if is_error(r275) goto L290 (error at coroutine:158) else goto L286
L286:
    r257 = r275
    dec_ref r257
L287:
    if is_error(r13) goto L608 else goto L288
L288:
    CPy_Reraise()
    if not 0 goto L290 else goto L609 :: bool
L289:
    unreachable
L290:
    if is_error(r13) goto L295 else goto L291
L291:
    if is_error(r13) goto L292 else goto L294
L292:
    r276 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r276 goto L297 (error at coroutine:-1) else goto L610 :: bool
L293:
    unreachable
L294:
    CPy_RestoreExcInfo(r13)
    xdec_ref r13
L295:
    r277 = CPy_KeepPropagating()
    if not r277 goto L297 else goto L611 :: bool
L296:
    unreachable
L297:
    r278 = CPy_CatchError()
    r22.__mypyc_temp__19 = r278; r279 = is_error
    if not r279 goto L612 (error at coroutine:-1) else goto L298 :: bool
L298:
    r22.__mypyc_temp__2 = 0; r280 = is_error
    if not r280 goto L612 (error at coroutine:156) else goto L299 :: bool
L299:
    r281 = CPy_GetExcInfo()
    r282 = r281[0]
    r283 = r281[1]
    r284 = r281[2]
    dec_ref r281
    r285 = r22.__mypyc_temp__0
    if is_error(r285) goto L613 (error at coroutine:-1) else goto L300
L300:
    r286 = r22.__mypyc_temp__1
    if is_error(r286) goto L614 (error at coroutine:-1) else goto L301
L301:
    r287 = [r286, r282, r283, r284]
    r288 = load_address r287
    r289 = _PyObject_Vectorcall(r285, r288, 4, 0)
    dec_ref r285
    if is_error(r289) goto L615 (error at coroutine:156) else goto L302
L302:
    dec_ref r286
    dec_ref r282
    dec_ref r283
    dec_ref r284
    r290 = CPy_GetCoro(r289)
    dec_ref r289
    if is_error(r290) goto L612 (error at coroutine:156) else goto L303
L303:
    r22.__mypyc_temp__20 = r290; r291 = is_error
    if not r291 goto L612 (error at coroutine:-1) else goto L304 :: bool
L304:
    r292 = r22.__mypyc_temp__20
    if is_error(r292) goto L612 (error at coroutine:-1) else goto L305
L305:
    r293 = CPyIter_Next(r292)
    dec_ref r292
    if is_error(r293) goto L616 else goto L308
L306:
    r294 = CPy_FetchStopIterationValue()
    if is_error(r294) goto L343 (error at coroutine:156) else goto L307
L307:
    r295 = r294
    goto L337
L308:
    r296 = r293
L309:
    r22.__mypyc_next_label__ = 14; r297 = is_error
    if not r297 goto L617 (error at coroutine:156) else goto L618 :: bool
L310:
    return r296
L311:
    r298 = load_address _Py_NoneStruct
    r299 = type != r298
    if r299 goto L312 else goto L314 :: bool
L312:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L315 (error at coroutine:156) else goto L619 :: bool
L313:
    unreachable
L314:
    inc_ref arg
    goto L332
L315:
    r300 = CPy_CatchError()
    r22.__mypyc_temp__21 = r300; r301 = is_error
    if not r301 goto L620 (error at coroutine:-1) else goto L316 :: bool
L316:
    r302 = load_address r15
    r303 = r22.__mypyc_temp__20
    if is_error(r303) goto L620 (error at coroutine:-1) else goto L317
L317:
    r304 = CPy_YieldFromErrorHandle(r303, r302)
    dec_ref r303
    if is_error(r304) goto L620 (error at coroutine:156) else goto L318
L318:
    if r304 goto L324 else goto L319 :: bool
L319:
    if is_error(r15) goto L320 else goto L322
L320:
    r305 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r305 goto L329 (error at coroutine:-1) else goto L621 :: bool
L321:
    unreachable
L322:
    inc_ref r15
    r296 = r15
    r306 = r22.__mypyc_temp__21
    if is_error(r306) goto L622 (error at coroutine:-1) else goto L323
L323:
    CPy_RestoreExcInfo(r306)
    dec_ref r306
    goto L309
L324:
    if is_error(r15) goto L325 else goto L327
L325:
    r307 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r307 goto L329 (error at coroutine:-1) else goto L623 :: bool
L326:
    unreachable
L327:
    r295 = r15
    r308 = r22.__mypyc_temp__21
    if is_error(r308) goto L624 (error at coroutine:-1) else goto L328
L328:
    CPy_RestoreExcInfo(r308)
    dec_ref r308
    goto L337
L329:
    r309 = r22.__mypyc_temp__21
    if is_error(r309) goto L343 (error at coroutine:-1) else goto L330
L330:
    CPy_RestoreExcInfo(r309)
    dec_ref r309
    r310 = CPy_KeepPropagating()
    if not r310 goto L343 else goto L625 :: bool
L331:
    unreachable
L332:
    r311 = r22.__mypyc_temp__20
    if is_error(r311) goto L626 (error at coroutine:-1) else goto L333
L333:
    r312 = CPyIter_Send(r311, arg)
    dec_ref r311
    dec_ref arg
    if is_error(r312) goto L627 else goto L334
L334:
    r296 = r312
    goto L309
L335:
    r313 = CPy_FetchStopIterationValue()
    if is_error(r313) goto L343 (error at coroutine:156) else goto L336
L336:
    r295 = r313
L337:
    r314 = PyObject_IsTrue(r295)
    dec_ref r295
    r315 = r314 >= 0 :: signed
    if not r315 goto L343 (error at coroutine:-1) else goto L338 :: bool
L338:
    r316 = truncate r314: i32 to builtins.bool
    if r316 goto L341 else goto L339 :: bool
L339:
    CPy_Reraise()
    if not 0 goto L343 else goto L628 :: bool
L340:
    unreachable
L341:
    r317 = r22.__mypyc_temp__19
    if is_error(r317) goto L347 (error at coroutine:-1) else goto L342
L342:
    CPy_RestoreExcInfo(r317)
    dec_ref r317
    goto L346
L343:
    r318 = r22.__mypyc_temp__19
    if is_error(r318) goto L347 (error at coroutine:-1) else goto L344
L344:
    CPy_RestoreExcInfo(r318)
    dec_ref r318
    r319 = CPy_KeepPropagating()
    if not r319 goto L347 else goto L629 :: bool
L345:
    unreachable
L346:
    r320 = <error> :: tuple[object, object, object]
    r19 = r320
    goto L348
L347:
    r321 = CPy_CatchError()
    r19 = r321
L348:
    r322 = r22.__mypyc_temp__2
    if is_error(r322) goto L630 (error at coroutine:-1) else goto L349
L349:
    if r322 goto L350 else goto L631 :: bool
L350:
    r323 = load_address _Py_NoneStruct
    r324 = r22.__mypyc_temp__0
    if is_error(r324) goto L630 (error at coroutine:-1) else goto L351
L351:
    r325 = r22.__mypyc_temp__1
    if is_error(r325) goto L632 (error at coroutine:-1) else goto L352
L352:
    r326 = [r325, r323, r323, r323]
    r327 = load_address r326
    r328 = _PyObject_Vectorcall(r324, r327, 4, 0)
    dec_ref r324
    if is_error(r328) goto L633 (error at coroutine:156) else goto L353
L353:
    dec_ref r325
    r329 = CPy_GetCoro(r328)
    dec_ref r328
    if is_error(r329) goto L630 (error at coroutine:156) else goto L354
L354:
    r22.__mypyc_temp__22 = r329; r330 = is_error
    if not r330 goto L630 (error at coroutine:-1) else goto L355 :: bool
L355:
    r331 = r22.__mypyc_temp__22
    if is_error(r331) goto L630 (error at coroutine:-1) else goto L356
L356:
    r332 = CPyIter_Next(r331)
    dec_ref r331
    if is_error(r332) goto L634 else goto L359
L357:
    r333 = CPy_FetchStopIterationValue()
    if is_error(r333) goto L635 (error at coroutine:156) else goto L358
L358:
    r334 = r333
    dec_ref r334
    goto L388
L359:
    r335 = r332
L360:
    r22.__mypyc_next_label__ = 16; r336 = is_error
    if not r336 goto L636 (error at coroutine:156) else goto L637 :: bool
L361:
    return r335
L362:
    r337 = load_address _Py_NoneStruct
    r338 = type != r337
    if r338 goto L363 else goto L365 :: bool
L363:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L366 (error at coroutine:156) else goto L638 :: bool
L364:
    unreachable
L365:
    inc_ref arg
    goto L383
L366:
    r339 = CPy_CatchError()
    r22.__mypyc_temp__23 = r339; r340 = is_error
    if not r340 goto L639 (error at coroutine:-1) else goto L367 :: bool
L367:
    r341 = load_address r17
    r342 = r22.__mypyc_temp__22
    if is_error(r342) goto L639 (error at coroutine:-1) else goto L368
L368:
    r343 = CPy_YieldFromErrorHandle(r342, r341)
    dec_ref r342
    if is_error(r343) goto L639 (error at coroutine:156) else goto L369
L369:
    if r343 goto L375 else goto L370 :: bool
L370:
    if is_error(r17) goto L640 else goto L373
L371:
    r344 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r344 goto L380 (error at coroutine:-1) else goto L641 :: bool
L372:
    unreachable
L373:
    inc_ref r17
    r335 = r17
    r345 = r22.__mypyc_temp__23
    if is_error(r345) goto L642 (error at coroutine:-1) else goto L374
L374:
    CPy_RestoreExcInfo(r345)
    dec_ref r345
    goto L360
L375:
    if is_error(r17) goto L643 else goto L378
L376:
    r346 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r346 goto L380 (error at coroutine:-1) else goto L644 :: bool
L377:
    unreachable
L378:
    r334 = r17
    dec_ref r334
    r347 = r22.__mypyc_temp__23
    if is_error(r347) goto L645 (error at coroutine:-1) else goto L379
L379:
    CPy_RestoreExcInfo(r347)
    dec_ref r347
    goto L388
L380:
    r348 = r22.__mypyc_temp__23
    dec_ref r22
    if is_error(r348) goto L391 (error at coroutine:-1) else goto L381
L381:
    CPy_RestoreExcInfo(r348)
    dec_ref r348
    r349 = CPy_KeepPropagating()
    if not r349 goto L391 else goto L646 :: bool
L382:
    unreachable
L383:
    r350 = r22.__mypyc_temp__22
    if is_error(r350) goto L647 (error at coroutine:-1) else goto L384
L384:
    r351 = CPyIter_Send(r350, arg)
    dec_ref r350
    dec_ref arg
    if is_error(r351) goto L648 else goto L385
L385:
    r335 = r351
    goto L360
L386:
    r352 = CPy_FetchStopIterationValue()
    if is_error(r352) goto L635 (error at coroutine:156) else goto L387
L387:
    r334 = r352
    dec_ref r334
L388:
    if is_error(r19) goto L398 else goto L649
L389:
    CPy_Reraise()
    if not 0 goto L391 else goto L650 :: bool
L390:
    unreachable
L391:
    if is_error(r19) goto L396 else goto L392
L392:
    if is_error(r19) goto L393 else goto L395
L393:
    r353 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r353 goto L486 (error at coroutine:-1) else goto L394 :: bool
L394:
    unreachable
L395:
    CPy_RestoreExcInfo(r19)
    xdec_ref r19
L396:
    r354 = CPy_KeepPropagating()
    if not r354 goto L486 else goto L397 :: bool
L397:
    unreachable
L398:
    r355 = r22.self
    if is_error(r355) goto L651 (error at coroutine:161) else goto L399
L399:
    r356 = r22.output
    if is_error(r356) goto L652 (error at coroutine:161) else goto L400
L400:
    r357 = cast(bytes, r356)
    if is_error(r357) goto L652 (error at coroutine:161) else goto L401
L401:
    r358 = decode_output(r355, r357)
    dec_ref r355
    dec_ref r357
    if is_error(r358) goto L651 (error at coroutine:161) else goto L402
L402:
    r359 = CPy_GetCoro(r358)
    dec_ref r358
    if is_error(r359) goto L651 (error at coroutine:161) else goto L403
L403:
    r22.__mypyc_temp__24 = r359; r360 = is_error
    if not r360 goto L651 (error at coroutine:-1) else goto L404 :: bool
L404:
    r361 = r22.__mypyc_temp__24
    if is_error(r361) goto L651 (error at coroutine:-1) else goto L405
L405:
    r362 = CPyIter_Next(r361)
    dec_ref r361
    if is_error(r362) goto L653 else goto L408
L406:
    r363 = CPy_FetchStopIterationValue()
    if is_error(r363) goto L438 (error at coroutine:161) else goto L407
L407:
    r364 = r363
    goto L437
L408:
    r365 = r362
L409:
    r22.__mypyc_next_label__ = 18; r366 = is_error
    if not r366 goto L654 (error at coroutine:161) else goto L655 :: bool
L410:
    return r365
L411:
    r367 = load_address _Py_NoneStruct
    r368 = type != r367
    if r368 goto L412 else goto L414 :: bool
L412:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L415 (error at coroutine:161) else goto L656 :: bool
L413:
    unreachable
L414:
    inc_ref arg
    goto L432
L415:
    r369 = CPy_CatchError()
    r22.__mypyc_temp__25 = r369; r370 = is_error
    if not r370 goto L657 (error at coroutine:-1) else goto L416 :: bool
L416:
    r371 = load_address r21
    r372 = r22.__mypyc_temp__24
    if is_error(r372) goto L657 (error at coroutine:-1) else goto L417
L417:
    r373 = CPy_YieldFromErrorHandle(r372, r371)
    dec_ref r372
    if is_error(r373) goto L657 (error at coroutine:161) else goto L418
L418:
    if r373 goto L424 else goto L419 :: bool
L419:
    if is_error(r21) goto L420 else goto L422
L420:
    r374 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r374 goto L429 (error at coroutine:-1) else goto L658 :: bool
L421:
    unreachable
L422:
    inc_ref r21
    r365 = r21
    r375 = r22.__mypyc_temp__25
    if is_error(r375) goto L659 (error at coroutine:-1) else goto L423
L423:
    CPy_RestoreExcInfo(r375)
    dec_ref r375
    goto L409
L424:
    if is_error(r21) goto L425 else goto L427
L425:
    r376 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r376 goto L429 (error at coroutine:-1) else goto L660 :: bool
L426:
    unreachable
L427:
    r364 = r21
    r377 = r22.__mypyc_temp__25
    if is_error(r377) goto L661 (error at coroutine:-1) else goto L428
L428:
    CPy_RestoreExcInfo(r377)
    dec_ref r377
    goto L437
L429:
    r378 = r22.__mypyc_temp__25
    if is_error(r378) goto L438 (error at coroutine:-1) else goto L430
L430:
    CPy_RestoreExcInfo(r378)
    dec_ref r378
    r379 = CPy_KeepPropagating()
    if not r379 goto L438 else goto L662 :: bool
L431:
    unreachable
L432:
    r380 = r22.__mypyc_temp__24
    if is_error(r380) goto L663 (error at coroutine:-1) else goto L433
L433:
    r381 = CPyIter_Send(r380, arg)
    dec_ref r380
    dec_ref arg
    if is_error(r381) goto L664 else goto L434
L434:
    r365 = r381
    goto L409
L435:
    r382 = CPy_FetchStopIterationValue()
    if is_error(r382) goto L438 (error at coroutine:161) else goto L436
L436:
    r364 = r382
L437:
    r22.decoded = r364; r383 = is_error
    if not r383 goto L438 (error at coroutine:161) else goto L457 :: bool
L438:
    r384 = CPy_CatchError()
    r22.__mypyc_temp__26 = r384; r385 = is_error
    if not r385 goto L454 (error at coroutine:-1) else goto L439 :: bool
L439:
    r386 = dank_mids.brownie_patch.call.globals :: static
    r387 = 'InsufficientDataBytes'
    r388 = CPyDict_GetItem(r386, r387)
    if is_error(r388) goto L454 (error at coroutine:162) else goto L440
L440:
    r389 = CPy_ExceptionMatches(r388)
    dec_ref r388
    if r389 goto L441 else goto L452 :: bool
L441:
    r390 = CPy_GetExcValue()
    r22.e = r390; r391 = is_error
    if not r391 goto L454 (error at coroutine:162) else goto L442 :: bool
L442:
    r392 = r22.e
    if is_error(r392) goto L454 (error at coroutine:163) else goto L443
L443:
    r393 = PyObject_Str(r392)
    dec_ref r392
    if is_error(r393) goto L454 (error at coroutine:163) else goto L444
L444:
    r394 = r22.self
    if is_error(r394) goto L665 (error at coroutine:163) else goto L445
L445:
    r395 = r22.self
    if is_error(r395) goto L666 (error at coroutine:163) else goto L446
L446:
    r396 = '_address'
    r397 = CPyObject_GetAttr(r395, r396)
    dec_ref r395
    if is_error(r397) goto L666 (error at coroutine:163) else goto L447
L447:
    r398 = r22.output
    if is_error(r398) goto L667 (error at coroutine:163) else goto L448
L448:
    r399 = dank_mids.brownie_patch.call.globals :: static
    r400 = 'InsufficientDataBytes'
    r401 = CPyDict_GetItem(r399, r400)
    if is_error(r401) goto L668 (error at coroutine:163) else goto L449
L449:
    r402 = [r393, r394, r397, r398]
    r403 = load_address r402
    r404 = _PyObject_Vectorcall(r401, r403, 4, 0)
    dec_ref r401
    if is_error(r404) goto L668 (error at coroutine:163) else goto L450
L450:
    dec_ref r393
    dec_ref r394
    dec_ref r397
    dec_ref r398
    CPy_Raise(r404)
    dec_ref r404
    if not 0 goto L454 (error at coroutine:163) else goto L669 :: bool
L451:
    unreachable
L452:
    CPy_Reraise()
    if not 0 goto L454 else goto L670 :: bool
L453:
    unreachable
L454:
    r405 = r22.__mypyc_temp__26
    dec_ref r22
    if is_error(r405) goto L486 (error at coroutine:-1) else goto L455
L455:
    CPy_RestoreExcInfo(r405)
    dec_ref r405
    r406 = CPy_KeepPropagating()
    if not r406 goto L486 else goto L456 :: bool
L456:
    unreachable
L457:
    r407 = r22.decimals
    if is_error(r407) goto L671 (error at coroutine:165) else goto L458
L458:
    r408 = load_address _Py_NoneStruct
    r409 = r407 == r408
    dec_ref r407
    if r409 goto L459 else goto L461 :: bool
L459:
    r410 = r22.decoded
    if is_error(r410) goto L671 (error at coroutine:165) else goto L460
L460:
    r411 = r410
    goto L471
L461:
    r412 = r22.decoded
    if is_error(r412) goto L671 (error at coroutine:165) else goto L462
L462:
    r413 = r22.decimals
    if is_error(r413) goto L672 (error at coroutine:165) else goto L463
L463:
    r414 = unbox(int, r413)
    dec_ref r413
    if is_error(r414) goto L672 (error at coroutine:165) else goto L464
L464:
    r415 = dank_mids.brownie_patch.call.Decimal :: static
    if is_error(r415) goto L673 else goto L467
L465:
    r416 = raise NameError('value for final name "Decimal" was not set')
    if not r416 goto L486 (error at coroutine:165) else goto L466 :: bool
L466:
    unreachable
L467:
    r417 = box(int, r414)
    r418 = [r417]
    r419 = load_address r418
    r420 = _PyObject_Vectorcall(r415, r419, 1, 0)
    if is_error(r420) goto L674 (error at coroutine:165) else goto L468
L468:
    dec_ref r417
    r421 = object 10
    r422 = CPyNumber_Power(r421, r420)
    dec_ref r420
    if is_error(r422) goto L672 (error at coroutine:165) else goto L469
L469:
    r423 = PyNumber_TrueDivide(r412, r422)
    dec_ref r412
    dec_ref r422
    if is_error(r423) goto L671 (error at coroutine:165) else goto L470
L470:
    r411 = r423
L471:
    r22.__mypyc_next_label__ = -2; r424 = is_error
    dec_ref r22
    if not r424 goto L675 (error at coroutine:165) else goto L472 :: bool
L472:
    CPyGen_SetStopIterationValue(r411)
    dec_ref r411
    if not 0 goto L486 else goto L473 :: bool
L473:
    unreachable
L474:
    r425 = r23 == 0
    if r425 goto L676 else goto L475 :: bool
L475:
    r426 = r23 == 2
    if r426 goto L677 else goto L678 :: bool
L476:
    r427 = r23 == 4
    if r427 goto L679 else goto L680 :: bool
L477:
    r428 = r23 == 6
    if r428 goto L681 else goto L682 :: bool
L478:
    r429 = r23 == 8
    if r429 goto L683 else goto L684 :: bool
L479:
    r430 = r23 == 10
    if r430 goto L685 else goto L686 :: bool
L480:
    r431 = r23 == 12
    if r431 goto L687 else goto L688 :: bool
L481:
    r432 = r23 == 14
    if r432 goto L689 else goto L690 :: bool
L482:
    r433 = r23 == 16
    if r433 goto L691 else goto L692 :: bool
L483:
    r434 = r23 == 18
    dec_ref r23 :: int
    if r434 goto L411 else goto L693 :: bool
L484:
    r435 = raise StopIteration
    if not r435 goto L486 (error at coroutine:147) else goto L485 :: bool
L485:
    unreachable
L486:
    r436 = <error> :: object
    return r436
L487:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    goto L486
L488:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    dec_ref r22
    goto L486
L489:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    dec_ref r22
    dec_ref r23 :: int
    goto L486
L490:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L4
L491:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L486
L492:
    dec_ref r27
    goto L14
L493:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L10
L494:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L15
L495:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    dec_ref r44
    dec_ref r45
    goto L486
L496:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    dec_ref r44
    goto L486
L497:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    dec_ref r53
    goto L486
L498:
    xdec_ref r1
    goto L29
L499:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L486
L500:
    dec_ref r62
    goto L38
L501:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L33
L502:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L36
L503:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r24
    goto L52
L504:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r24
    goto L43
L505:
    dec_ref r22
    goto L44
L506:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r24
    dec_ref r62
    goto L52
L507:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r24
    goto L48
L508:
    dec_ref r22
    goto L49
L509:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r24
    goto L52
L510:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    dec_ref arg
    goto L486
L511:
    xdec_ref r1
    goto L58
L512:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L297
L513:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r80
    goto L297
L514:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r80
    dec_ref r81 :: int
    goto L297
L515:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r80
    dec_ref r81 :: int
    dec_ref r82
    goto L297
L516:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r80
    dec_ref r81 :: int
    dec_ref r82
    dec_ref r83
    goto L297
L517:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r80
    dec_ref r81 :: int
    dec_ref r82
    dec_ref r83
    dec_ref r86
    goto L297
L518:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r86
    dec_ref r87
    goto L297
L519:
    dec_ref r93
    goto L67
L520:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r86
    goto L297
L521:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r86
    dec_ref r94
    goto L297
L522:
    xdec_ref r3
    goto L74
L523:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L297
L524:
    dec_ref r103
    goto L83
L525:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L78
L526:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L81
L527:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L97
L528:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L88
L529:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L89
L530:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r103
    goto L97
L531:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L93
L532:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L94
L533:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r102
    goto L97
L534:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L99
L535:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref arg
    goto L297
L536:
    xdec_ref r3
    goto L103
L537:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L107
L538:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L108
L539:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r125
    dec_ref r126
    goto L297
L540:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r125
    goto L297
L541:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r134
    goto L297
L542:
    xdec_ref r5
    goto L121
L543:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L297
L544:
    dec_ref r143
    goto L130
L545:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L125
L546:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r24
    goto L128
L547:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L144
L548:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L135
L549:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L136
L550:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref r143
    goto L144
L551:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L140
L552:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L141
L553:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    goto L144
L554:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L146
L555:
    xdec_ref r5
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    dec_ref r24
    dec_ref arg
    goto L297
L556:
    xdec_ref r5
    goto L150
L557:
    xdec_ref r7
    goto L196
L558:
    xdec_ref r7
    dec_ref r163
    goto L196
L559:
    xdec_ref r7
    dec_ref r163
    dec_ref r167
    goto L196
L560:
    xdec_ref r7
    dec_ref r163
    dec_ref r170
    goto L196
L561:
    xdec_ref r7
    dec_ref r163
    dec_ref r170
    dec_ref r171
    goto L196
L562:
    xdec_ref r7
    goto L164
L563:
    dec_ref r182
    goto L173
L564:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L168
L565:
    xdec_ref r7
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L171
L566:
    xdec_ref r7
    goto L187
L567:
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L179
L568:
    xdec_ref r7
    dec_ref r182
    goto L187
L569:
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L184
L570:
    dec_ref r181
    goto L187
L571:
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L189
L572:
    xdec_ref r7
    dec_ref arg
    goto L196
L573:
    xdec_ref r7
    goto L193
L574:
    xdec_ref r9
    goto L245
L575:
    xdec_ref r9
    goto L242
L576:
    xdec_ref r9
    dec_ref r205
    dec_ref r206
    dec_ref r207
    goto L242
L577:
    xdec_ref r9
    dec_ref r205
    dec_ref r206
    dec_ref r207
    dec_ref r208
    goto L242
L578:
    xdec_ref r9
    dec_ref r205
    dec_ref r206
    dec_ref r207
    dec_ref r209
    goto L242
L579:
    xdec_ref r9
    goto L205
L580:
    dec_ref r219
    goto L214
L581:
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L209
L582:
    xdec_ref r9
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L212
L583:
    xdec_ref r9
    goto L228
L584:
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L220
L585:
    xdec_ref r9
    dec_ref r219
    goto L228
L586:
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L225
L587:
    dec_ref r218
    goto L228
L588:
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L230
L589:
    xdec_ref r9
    dec_ref arg
    goto L242
L590:
    xdec_ref r9
    goto L234
L591:
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L239
L592:
    xdec_ref r11
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L244
L593:
    xdec_ref r11
    goto L290
L594:
    xdec_ref r11
    goto L287
L595:
    xdec_ref r11
    dec_ref r247
    goto L290
L596:
    xdec_ref r11
    dec_ref r248
    goto L290
L597:
    xdec_ref r11
    goto L256
L598:
    dec_ref r258
    goto L265
L599:
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L260
L600:
    xdec_ref r11
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L263
L601:
    xdec_ref r11
    goto L279
L602:
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L271
L603:
    xdec_ref r11
    dec_ref r258
    goto L279
L604:
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L276
L605:
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L281
L606:
    xdec_ref r11
    dec_ref arg
    goto L290
L607:
    xdec_ref r11
    goto L285
L608:
    xdec_ref r15
    goto L346
L609:
    xdec_ref r13
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L289
L610:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L293
L611:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L296
L612:
    xdec_ref r15
    goto L343
L613:
    xdec_ref r15
    dec_ref r282
    dec_ref r283
    dec_ref r284
    goto L343
L614:
    xdec_ref r15
    dec_ref r282
    dec_ref r283
    dec_ref r284
    dec_ref r285
    goto L343
L615:
    xdec_ref r15
    dec_ref r282
    dec_ref r283
    dec_ref r284
    dec_ref r286
    goto L343
L616:
    xdec_ref r15
    goto L306
L617:
    dec_ref r296
    goto L315
L618:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L310
L619:
    xdec_ref r15
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L313
L620:
    xdec_ref r15
    goto L329
L621:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L321
L622:
    xdec_ref r15
    dec_ref r296
    goto L329
L623:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L326
L624:
    dec_ref r295
    goto L329
L625:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L331
L626:
    xdec_ref r15
    dec_ref arg
    goto L343
L627:
    xdec_ref r15
    goto L335
L628:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L340
L629:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L345
L630:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    goto L391
L631:
    xdec_ref r17
    goto L388
L632:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r324
    goto L391
L633:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref r325
    goto L391
L634:
    xdec_ref r17
    goto L357
L635:
    xdec_ref r21
    dec_ref r22
    goto L391
L636:
    dec_ref r335
    goto L366
L637:
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    dec_ref r22
    goto L361
L638:
    xdec_ref r17
    xdec_ref r19
    xdec_ref r21
    dec_ref r22
    goto L364
L639:
    xdec_ref r17
    xdec_ref r21
    goto L380
L640:
    xdec_ref r21
    goto L371
L641:
    xdec_ref r19
    dec_ref r22
    goto L372
L642:
    xdec_ref r17
    xdec_ref r21
    dec_ref r335
    goto L380
L643:
    xdec_ref r21
    goto L376
L644:
    xdec_ref r19
    dec_ref r22
    goto L377
L645:
    xdec_ref r21
    goto L380
L646:
    xdec_ref r19
    goto L382
L647:
    xdec_ref r17
    xdec_ref r21
    dec_ref r22
    dec_ref arg
    goto L391
L648:
    xdec_ref r17
    goto L386
L649:
    xdec_ref r21
    dec_ref r22
    goto L389
L650:
    xdec_ref r19
    goto L390
L651:
    xdec_ref r21
    goto L438
L652:
    xdec_ref r21
    dec_ref r355
    goto L438
L653:
    xdec_ref r21
    goto L406
L654:
    dec_ref r365
    goto L415
L655:
    xdec_ref r21
    dec_ref r22
    goto L410
L656:
    xdec_ref r21
    dec_ref r22
    goto L413
L657:
    xdec_ref r21
    goto L429
L658:
    dec_ref r22
    goto L421
L659:
    xdec_ref r21
    dec_ref r365
    goto L429
L660:
    dec_ref r22
    goto L426
L661:
    dec_ref r364
    goto L429
L662:
    dec_ref r22
    goto L431
L663:
    xdec_ref r21
    dec_ref arg
    goto L438
L664:
    xdec_ref r21
    goto L435
L665:
    dec_ref r393
    goto L454
L666:
    dec_ref r393
    dec_ref r394
    goto L454
L667:
    dec_ref r393
    dec_ref r394
    dec_ref r397
    goto L454
L668:
    dec_ref r393
    dec_ref r394
    dec_ref r397
    dec_ref r398
    goto L454
L669:
    dec_ref r22
    goto L451
L670:
    dec_ref r22
    goto L453
L671:
    dec_ref r22
    goto L486
L672:
    dec_ref r22
    dec_ref r412
    goto L486
L673:
    dec_ref r22
    dec_ref r412
    dec_ref r414 :: int
    goto L465
L674:
    dec_ref r22
    dec_ref r412
    dec_ref r417
    goto L486
L675:
    dec_ref r411
    goto L486
L676:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L3
L677:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L34
L678:
    xdec_ref r1
    goto L476
L679:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L79
L680:
    xdec_ref r3
    goto L477
L681:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L126
L682:
    xdec_ref r5
    dec_ref r24
    goto L478
L683:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L169
L684:
    xdec_ref r7
    goto L479
L685:
    xdec_ref r13
    xdec_ref r19
    dec_ref r23 :: int
    goto L210
L686:
    xdec_ref r9
    goto L480
L687:
    xdec_ref r19
    dec_ref r23 :: int
    goto L261
L688:
    xdec_ref r11
    xdec_ref r13
    goto L481
L689:
    xdec_ref r19
    dec_ref r23 :: int
    goto L311
L690:
    xdec_ref r15
    goto L482
L691:
    dec_ref r23 :: int
    goto L362
L692:
    xdec_ref r17
    xdec_ref r19
    goto L483
L693:
    xdec_ref r21
    dec_ref r22
    goto L484

def coroutine__get_coroutine_fn_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine__get_coroutine_fn_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine__get_coroutine_fn_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine__get_coroutine_fn_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine__get_coroutine_fn_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine__get_coroutine_fn_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutine__get_coroutine_fn_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutine__get_coroutine_fn_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def coroutine__get_coroutine_fn_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine__get_coroutine_fn_obj.__call__(__mypyc_self__, self, args, block_identifier, decimals, override):
    __mypyc_self__ :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_obj
    self :: object
    args :: tuple
    block_identifier :: union[object, None]
    decimals :: union[int, None]
    override :: union[dict, None]
    r0 :: dank_mids.brownie_patch.call._get_coroutine_fn_env
    r1, r2, r3 :: object
    r4 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_env
    r5, r6, r7, r8, r9, r10 :: bool
    r11 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_gen
    r12, r13 :: bool
    r14 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L18 (error at coroutine:147) else goto L1
L1:
    if is_error(block_identifier) goto L2 else goto L19
L2:
    r1 = box(None, 1)
    inc_ref r1
    block_identifier = r1
L3:
    if is_error(decimals) goto L4 else goto L20
L4:
    r2 = box(None, 1)
    inc_ref r2
    decimals = r2
L5:
    if is_error(override) goto L6 else goto L21
L6:
    r3 = box(None, 1)
    inc_ref r3
    override = r3
L7:
    r4 = coroutine__get_coroutine_fn_env()
    if is_error(r4) goto L22 (error at coroutine:147) else goto L8
L8:
    r4.__mypyc_env__ = r0; r5 = is_error
    if not r5 goto L23 (error at coroutine:147) else goto L9 :: bool
L9:
    inc_ref self
    r4.self = self; r6 = is_error
    if not r6 goto L23 (error at coroutine:147) else goto L10 :: bool
L10:
    inc_ref args
    r4.args = args; r7 = is_error
    if not r7 goto L23 (error at coroutine:147) else goto L11 :: bool
L11:
    r4.block_identifier = block_identifier; r8 = is_error
    if not r8 goto L24 (error at coroutine:147) else goto L12 :: bool
L12:
    r4.decimals = decimals; r9 = is_error
    if not r9 goto L25 (error at coroutine:147) else goto L13 :: bool
L13:
    r4.override = override; r10 = is_error
    if not r10 goto L26 (error at coroutine:147) else goto L14 :: bool
L14:
    r11 = coroutine__get_coroutine_fn_gen()
    if is_error(r11) goto L26 (error at coroutine:147) else goto L15
L15:
    inc_ref r4
    r11.__mypyc_env__ = r4; r12 = is_error
    if not r12 goto L27 (error at coroutine:147) else goto L16 :: bool
L16:
    r4.__mypyc_next_label__ = 0; r13 = is_error
    dec_ref r4
    if not r13 goto L28 (error at coroutine:147) else goto L17 :: bool
L17:
    return r11
L18:
    r14 = <error> :: object
    return r14
L19:
    inc_ref block_identifier
    goto L3
L20:
    inc_ref decimals
    goto L5
L21:
    inc_ref override
    goto L7
L22:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r0
    goto L18
L23:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L18
L24:
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L18
L25:
    dec_ref override
    dec_ref r4
    goto L18
L26:
    dec_ref r4
    goto L18
L27:
    dec_ref r4
    dec_ref r11
    goto L18
L28:
    dec_ref r11
    goto L18

def _get_coroutine_fn(w3, len_inputs):
    w3 :: object
    len_inputs :: int
    r0 :: dank_mids.brownie_patch.call._get_coroutine_fn_env
    r1, r2, r3, r4 :: bool
    r5 :: int
    r6 :: bit
    r7 :: object
    r8, r9 :: bool
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: bool
    r14 :: dank_mids.brownie_patch.call.coroutine__get_coroutine_fn_obj
    r15 :: bool
    coroutine, r16 :: object
L0:
    r0 = _get_coroutine_fn_env()
    if is_error(r0) goto L18 (error at _get_coroutine_fn:141) else goto L1
L1:
    inc_ref w3
    r0.w3 = w3; r1 = is_error
    if not r1 goto L19 (error at _get_coroutine_fn:141) else goto L2 :: bool
L2:
    inc_ref len_inputs :: int
    r0.len_inputs = len_inputs; r2 = is_error
    if not r2 goto L19 (error at _get_coroutine_fn:141) else goto L3 :: bool
L3:
    r3 = dank_mids.brownie_patch.call.APPLICATION_MODE :: static
    if is_error(r3) goto L20 else goto L6
L4:
    r4 = raise NameError('value for final name "APPLICATION_MODE" was not set')
    if not r4 goto L18 (error at _get_coroutine_fn:142) else goto L5 :: bool
L5:
    unreachable
L6:
    if r3 goto L9 else goto L7 :: bool
L7:
    r5 = r0.len_inputs
    if is_error(r5) goto L19 (error at _get_coroutine_fn:142) else goto L8
L8:
    r6 = r5 != 0
    dec_ref r5 :: int
    if r6 goto L9 else goto L13 :: bool
L9:
    r7 = dank_mids.brownie_patch.call.encode :: static
    if is_error(r7) goto L21 else goto L12
L10:
    r8 = raise NameError('value for final name "encode" was not set')
    if not r8 goto L18 (error at _get_coroutine_fn:143) else goto L11 :: bool
L11:
    unreachable
L12:
    inc_ref r7
    r0.get_request_data = r7; r9 = is_error
    if not r9 goto L19 (error at _get_coroutine_fn:143) else goto L15 :: bool
L13:
    r10 = dank_mids.brownie_patch.call.globals :: static
    r11 = '_request_data_no_args'
    r12 = CPyDict_GetItem(r10, r11)
    if is_error(r12) goto L19 (error at _get_coroutine_fn:145) else goto L14
L14:
    r0.get_request_data = r12; r13 = is_error
    if not r13 goto L19 (error at _get_coroutine_fn:145) else goto L15 :: bool
L15:
    r14 = coroutine__get_coroutine_fn_obj()
    if is_error(r14) goto L19 (error at _get_coroutine_fn:147) else goto L16
L16:
    r14.__mypyc_env__ = r0; r15 = is_error
    if not r15 goto L22 (error at _get_coroutine_fn:147) else goto L17 :: bool
L17:
    coroutine = r14
    return coroutine
L18:
    r16 = <error> :: object
    return r16
L19:
    dec_ref r0
    goto L18
L20:
    dec_ref r0
    goto L4
L21:
    dec_ref r0
    goto L10
L22:
    dec_ref r14
    goto L18

def _call_no_args(self):
    self :: object
    r0 :: str
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4 :: str
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
L0:
    r0 = 'coroutine'
    r1 = [self]
    r2 = load_address r1
    r3 = PyObject_VectorcallMethod(r0, r2, 9223372036854775809, 0)
    if is_error(r3) goto L3 (error at _call_no_args:172) else goto L1
L1:
    r4 = '__await__'
    r5 = [r3]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r4, r6, 9223372036854775809, 0)
    if is_error(r7) goto L4 (error at _call_no_args:172) else goto L2
L2:
    dec_ref r3
    return r7
L3:
    r8 = <error> :: object
    return r8
L4:
    dec_ref r3
    goto L3

def encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    type, value, traceback, arg, r0, r1 :: object
    r2 :: dank_mids.brownie_patch.call.encode_input_env
    r3 :: int
    r4 :: object
    r5 :: bit
    r6 :: bool
    r7 :: tuple
    r8, r9 :: bool
    r10 :: tuple
    r11 :: ptr
    r12 :: native_int
    r13, r14 :: short_int
    r15 :: bit
    r16 :: tuple
    r17 :: short_int
    r18 :: object
    r19 :: bool
    r20, r21 :: object
    r22 :: bool
    r23 :: i32
    r24 :: bit
    r25 :: bool
    r26 :: object
    r27 :: str
    r28 :: bool
    r29, r30 :: short_int
    r31 :: bool
    r32 :: object
    r33 :: str
    r34, r35 :: object
    r36 :: str
    r37 :: object
    r38 :: tuple
    r39 :: dict
    r40 :: str
    r41 :: object
    r42 :: list
    r43, r44, r45 :: ptr
    r46 :: object
    r47 :: tuple
    r48 :: dict
    r49 :: object
    r50 :: bool
    r51 :: object
    r52 :: tuple
    r53 :: object
    r54 :: list
    r55, r56 :: ptr
    r57 :: object
    r58 :: tuple
    r59 :: dict
    r60, r61 :: object
    r62 :: bool
    r63, r64, r65, r66, r67 :: object
    r68 :: bool
    r69 :: object
    r70 :: bit
    r71 :: tuple[object, object, object]
    r72 :: bool
    r73 :: object_ptr
    r74 :: object
    r75, r76 :: bool
    r77 :: tuple[object, object, object]
    r78 :: bool
    r79, r80 :: tuple[object, object, object]
    r81 :: bit
    r82, r83, r84 :: object
    r85 :: bool
    r86 :: tuple[object, object, object]
    r87 :: bool
    r88 :: object
    r89 :: str
    r90, r91 :: object
    r92 :: str
    r93 :: object
    r94 :: tuple[object, object]
    r95 :: object
    r96 :: bit
    r97 :: object
    r98 :: str
    r99, r100 :: object
    r101 :: str
    r102 :: object
    r103 :: tuple
    r104 :: dict
    r105 :: str
    r106 :: object
    r107 :: list
    r108, r109, r110 :: ptr
    r111 :: object
    r112 :: tuple
    r113 :: dict
    r114 :: object
    r115 :: bool
    r116 :: dict
    r117 :: str
    r118 :: object
    r119 :: bit
    r120 :: object
    r121 :: bool
    r122 :: str
    r123 :: dict
    r124 :: str
    r125 :: object
    r126 :: str
    r127, r128, r129 :: object
    r130 :: str
    r131 :: object
    r132 :: str
    r133 :: object[5]
    r134 :: object_ptr
    r135 :: object
    r136 :: dict
    r137 :: str
    r138 :: object
    r139 :: str
    r140 :: object
    r141 :: str
    r142 :: object
    r143 :: dict
    r144 :: str
    r145 :: object
    r146 :: object[1]
    r147 :: object_ptr
    r148 :: object
    r149 :: dict
    r150 :: str
    r151 :: object
    r152 :: str
    r153 :: i32
    r154 :: bit
    r155 :: int
    r156 :: bit
    r157 :: object
    r158 :: str
    r159, r160 :: object
    r161 :: str
    r162 :: object
    r163 :: tuple
    r164 :: dict
    r165 :: str
    r166 :: object
    r167 :: list
    r168, r169, r170 :: ptr
    r171 :: object
    r172 :: tuple
    r173 :: dict
    r174, r175, r176 :: object
    r177 :: str
    r178 :: object
    r179 :: bool
    r180 :: dict
    r181 :: str
    r182 :: object
    r183 :: bit
    r184 :: int
    r185 :: bit
    r186 :: object
    r187 :: str
    r188, r189 :: object
    r190 :: str
    r191 :: object
    r192 :: tuple
    r193 :: dict
    r194 :: str
    r195 :: object
    r196 :: list
    r197, r198, r199 :: ptr
    r200 :: object
    r201 :: tuple
    r202 :: dict
    r203, r204, r205 :: object
    r206 :: str
    r207 :: object
    r208 :: bool
    r209, r210 :: tuple[object, object, object]
    r211 :: bit
    r212, r213 :: object
    r214 :: str
    r215 :: object
    r216 :: i32
    r217 :: bit
    r218 :: bool
    r219 :: object
    r220 :: str
    r221 :: object
    r222 :: tuple
    r223 :: ptr
    r224 :: native_int
    r225 :: short_int
    r226 :: bit
    r227, r228 :: object
    r229 :: str
    r230 :: bool
    r231 :: str
    r232 :: object
    r233 :: str
    r234 :: object
    r235 :: str
    r236 :: object[2]
    r237 :: object_ptr
    r238 :: object
    r239 :: bool
    r240, r241 :: str
    r242 :: list
    r243 :: object
    r244 :: str
    r245 :: bool
    r246, r247, r248 :: str
    r249 :: bool
    r250, r251 :: object
    r252 :: str
    r253 :: object
    r254 :: str
    r255 :: object
    r256, r257 :: str
    r258 :: object
    r259 :: str
    r260 :: object
    r261, r262, r263, r264 :: str
    r265 :: object[1]
    r266 :: object_ptr
    r267, r268 :: object
    r269 :: bool
    r270, r271 :: bit
    r272 :: bool
    r273 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_env__
    if is_error(r2) goto L212 (error at encode_input:175) else goto L1
L1:
    r3 = r2.__mypyc_next_label__
    if is_error(r3) goto L213 (error at encode_input:175) else goto L207
L2:
    r4 = load_address _Py_NoneStruct
    r5 = type != r4
    if r5 goto L214 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L211 (error at encode_input:175) else goto L4 :: bool
L4:
    unreachable
L5:
    r6 = 0
    r7 = r2.args
    if is_error(r7) goto L213 (error at encode_input:177) else goto L6
L6:
    r2.__mypyc_temp__27 = r7; r8 = is_error
    if not r8 goto L213 (error at encode_input:-1) else goto L7 :: bool
L7:
    r2.__mypyc_temp__28 = 0; r9 = is_error
    if not r9 goto L213 (error at encode_input:-1) else goto L8 :: bool
L8:
    r10 = r2.__mypyc_temp__27
    if is_error(r10) goto L213 (error at encode_input:177) else goto L9
L9:
    r11 = get_element_ptr r10 ob_size :: PyVarObject
    r12 = load_mem r11 :: native_int*
    dec_ref r10
    r13 = r12 << 1
    r14 = r2.__mypyc_temp__28
    if is_error(r14) goto L213 (error at encode_input:177) else goto L10
L10:
    r15 = r14 < r13 :: signed
    if r15 goto L11 else goto L27 :: bool
L11:
    r16 = r2.__mypyc_temp__27
    if is_error(r16) goto L213 (error at encode_input:177) else goto L12
L12:
    r17 = r2.__mypyc_temp__28
    if is_error(r17) goto L215 (error at encode_input:177) else goto L13
L13:
    r18 = CPySequenceTuple_GetItem(r16, r17)
    dec_ref r16
    if is_error(r18) goto L213 (error at encode_input:177) else goto L14
L14:
    r2.arg = r18; r19 = is_error
    if not r19 goto L213 (error at encode_input:177) else goto L15 :: bool
L15:
    r20 = r2.arg
    if is_error(r20) goto L213 (error at encode_input:177) else goto L16
L16:
    r21 = dank_mids.brownie_patch.call.Contract :: static
    if is_error(r21) goto L216 else goto L19
L17:
    r22 = raise NameError('value for final name "Contract" was not set')
    if not r22 goto L211 (error at encode_input:177) else goto L18 :: bool
L18:
    unreachable
L19:
    r23 = PyObject_IsInstance(r20, r21)
    dec_ref r20
    r24 = r23 >= 0 :: signed
    if not r24 goto L213 (error at encode_input:177) else goto L20 :: bool
L20:
    r25 = truncate r23: i32 to builtins.bool
    if r25 goto L21 else goto L22 :: bool
L21:
    if r25 goto L24 else goto L25 :: bool
L22:
    r26 = r2.arg
    if is_error(r26) goto L213 (error at encode_input:177) else goto L23
L23:
    r27 = '__contains__'
    r28 = PyObject_HasAttr(r26, r27)
    dec_ref r26
    if r28 goto L24 else goto L25 :: bool
L24:
    r6 = 1
    goto L27
L25:
    r29 = r2.__mypyc_temp__28
    if is_error(r29) goto L213 (error at encode_input:177) else goto L26
L26:
    r30 = r29 + 2
    r2.__mypyc_temp__28 = r30; r31 = is_error
    if not r31 goto L213 (error at encode_input:177) else goto L8 :: bool
L27:
    if r6 goto L217 else goto L40 :: bool
L28:
    r32 = r2.call
    if is_error(r32) goto L218 (error at encode_input:179) else goto L29
L29:
    r33 = 'abi'
    r34 = CPyObject_GetAttr(r32, r33)
    dec_ref r32
    if is_error(r34) goto L218 (error at encode_input:179) else goto L30
L30:
    r35 = r2.call
    if is_error(r35) goto L219 (error at encode_input:179) else goto L31
L31:
    r36 = 'signature'
    r37 = CPyObject_GetAttr(r35, r36)
    dec_ref r35
    if is_error(r37) goto L219 (error at encode_input:179) else goto L32
L32:
    r38 = r2.args
    if is_error(r38) goto L220 (error at encode_input:179) else goto L33
L33:
    r39 = dank_mids.brownie_patch.call.globals :: static
    r40 = '__encode_input'
    r41 = CPyDict_GetItem(r39, r40)
    if is_error(r41) goto L221 (error at encode_input:179) else goto L34
L34:
    r42 = PyList_New(2)
    if is_error(r42) goto L222 (error at encode_input:179) else goto L35
L35:
    r43 = get_element_ptr r42 ob_item :: PyListObject
    r44 = load_mem r43 :: ptr*
    set_mem r44, r34 :: builtins.object*
    r45 = r44 + 8
    set_mem r45, r37 :: builtins.object*
    r46 = CPyList_Extend(r42, r38)
    dec_ref r38
    if is_error(r46) goto L223 (error at encode_input:179) else goto L224
L36:
    r47 = PyList_AsTuple(r42)
    dec_ref r42
    if is_error(r47) goto L225 (error at encode_input:179) else goto L37
L37:
    r48 = PyDict_New()
    if is_error(r48) goto L226 (error at encode_input:179) else goto L38
L38:
    r49 = PyObject_Call(r41, r47, r48)
    dec_ref r41
    dec_ref r47
    dec_ref r48
    if is_error(r49) goto L218 (error at encode_input:179) else goto L39
L39:
    r2.data = r49; r50 = is_error
    if not r50 goto L218 (error at encode_input:179) else goto L163 :: bool
L40:
    r51 = r2.call
    if is_error(r51) goto L227 (error at encode_input:182) else goto L41
L41:
    r52 = r2.args
    if is_error(r52) goto L228 (error at encode_input:182) else goto L42
L42:
    r53 = r2.get_request_data
    if is_error(r53) goto L229 (error at encode_input:182) else goto L43
L43:
    r54 = PyList_New(1)
    if is_error(r54) goto L230 (error at encode_input:182) else goto L44
L44:
    r55 = get_element_ptr r54 ob_item :: PyListObject
    r56 = load_mem r55 :: ptr*
    set_mem r56, r51 :: builtins.object*
    r57 = CPyList_Extend(r54, r52)
    dec_ref r52
    if is_error(r57) goto L231 (error at encode_input:182) else goto L232
L45:
    r58 = PyList_AsTuple(r54)
    dec_ref r54
    if is_error(r58) goto L233 (error at encode_input:182) else goto L46
L46:
    r59 = PyDict_New()
    if is_error(r59) goto L234 (error at encode_input:182) else goto L47
L47:
    r60 = PyObject_Call(r53, r58, r59)
    dec_ref r53
    dec_ref r58
    dec_ref r59
    if is_error(r60) goto L227 (error at encode_input:182) else goto L48
L48:
    r61 = CPy_GetCoro(r60)
    dec_ref r60
    if is_error(r61) goto L227 (error at encode_input:182) else goto L49
L49:
    r2.__mypyc_temp__29 = r61; r62 = is_error
    if not r62 goto L227 (error at encode_input:-1) else goto L50 :: bool
L50:
    r63 = r2.__mypyc_temp__29
    if is_error(r63) goto L227 (error at encode_input:-1) else goto L51
L51:
    r64 = CPyIter_Next(r63)
    dec_ref r63
    if is_error(r64) goto L235 else goto L54
L52:
    r65 = CPy_FetchStopIterationValue()
    if is_error(r65) goto L84 (error at encode_input:182) else goto L53
L53:
    r66 = r65
    goto L83
L54:
    r67 = r64
L55:
    r2.__mypyc_next_label__ = 2; r68 = is_error
    if not r68 goto L236 (error at encode_input:182) else goto L237 :: bool
L56:
    return r67
L57:
    r69 = load_address _Py_NoneStruct
    r70 = type != r69
    if r70 goto L58 else goto L60 :: bool
L58:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L61 (error at encode_input:182) else goto L238 :: bool
L59:
    unreachable
L60:
    inc_ref arg
    goto L78
L61:
    r71 = CPy_CatchError()
    r2.__mypyc_temp__30 = r71; r72 = is_error
    if not r72 goto L239 (error at encode_input:-1) else goto L62 :: bool
L62:
    r73 = load_address r1
    r74 = r2.__mypyc_temp__29
    if is_error(r74) goto L239 (error at encode_input:-1) else goto L63
L63:
    r75 = CPy_YieldFromErrorHandle(r74, r73)
    dec_ref r74
    if is_error(r75) goto L239 (error at encode_input:182) else goto L64
L64:
    if r75 goto L70 else goto L65 :: bool
L65:
    if is_error(r1) goto L66 else goto L68
L66:
    r76 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r76 goto L75 (error at encode_input:-1) else goto L240 :: bool
L67:
    unreachable
L68:
    inc_ref r1
    r67 = r1
    r77 = r2.__mypyc_temp__30
    if is_error(r77) goto L241 (error at encode_input:-1) else goto L69
L69:
    CPy_RestoreExcInfo(r77)
    dec_ref r77
    goto L55
L70:
    if is_error(r1) goto L71 else goto L73
L71:
    r78 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r78 goto L75 (error at encode_input:-1) else goto L242 :: bool
L72:
    unreachable
L73:
    r66 = r1
    r79 = r2.__mypyc_temp__30
    if is_error(r79) goto L243 (error at encode_input:-1) else goto L74
L74:
    CPy_RestoreExcInfo(r79)
    dec_ref r79
    goto L83
L75:
    r80 = r2.__mypyc_temp__30
    if is_error(r80) goto L84 (error at encode_input:-1) else goto L76
L76:
    CPy_RestoreExcInfo(r80)
    dec_ref r80
    r81 = CPy_KeepPropagating()
    if not r81 goto L84 else goto L244 :: bool
L77:
    unreachable
L78:
    r82 = r2.__mypyc_temp__29
    if is_error(r82) goto L245 (error at encode_input:-1) else goto L79
L79:
    r83 = CPyIter_Send(r82, arg)
    dec_ref r82
    dec_ref arg
    if is_error(r83) goto L246 else goto L80
L80:
    r67 = r83
    goto L55
L81:
    r84 = CPy_FetchStopIterationValue()
    if is_error(r84) goto L84 (error at encode_input:182) else goto L82
L82:
    r66 = r84
L83:
    r2.data = r66; r85 = is_error
    if not r85 goto L84 (error at encode_input:182) else goto L163 :: bool
L84:
    r86 = CPy_CatchError()
    r2.__mypyc_temp__31 = r86; r87 = is_error
    if not r87 goto L160 (error at encode_input:-1) else goto L85 :: bool
L85:
    r88 = builtins :: module
    r89 = 'AttributeError'
    r90 = CPyObject_GetAttr(r88, r89)
    if is_error(r90) goto L160 (error at encode_input:183) else goto L86
L86:
    r91 = builtins :: module
    r92 = 'TypeError'
    r93 = CPyObject_GetAttr(r91, r92)
    if is_error(r93) goto L247 (error at encode_input:183) else goto L87
L87:
    r94 = (r90, r93)
    r95 = box(tuple[object, object], r94)
    r96 = CPy_ExceptionMatches(r95)
    dec_ref r95
    if r96 goto L88 else goto L100 :: bool
L88:
    r97 = r2.call
    if is_error(r97) goto L160 (error at encode_input:185) else goto L89
L89:
    r98 = 'abi'
    r99 = CPyObject_GetAttr(r97, r98)
    dec_ref r97
    if is_error(r99) goto L160 (error at encode_input:185) else goto L90
L90:
    r100 = r2.call
    if is_error(r100) goto L248 (error at encode_input:185) else goto L91
L91:
    r101 = 'signature'
    r102 = CPyObject_GetAttr(r100, r101)
    dec_ref r100
    if is_error(r102) goto L248 (error at encode_input:185) else goto L92
L92:
    r103 = r2.args
    if is_error(r103) goto L249 (error at encode_input:185) else goto L93
L93:
    r104 = dank_mids.brownie_patch.call.globals :: static
    r105 = '__encode_input'
    r106 = CPyDict_GetItem(r104, r105)
    if is_error(r106) goto L250 (error at encode_input:185) else goto L94
L94:
    r107 = PyList_New(2)
    if is_error(r107) goto L251 (error at encode_input:185) else goto L95
L95:
    r108 = get_element_ptr r107 ob_item :: PyListObject
    r109 = load_mem r108 :: ptr*
    set_mem r109, r99 :: builtins.object*
    r110 = r109 + 8
    set_mem r110, r102 :: builtins.object*
    r111 = CPyList_Extend(r107, r103)
    dec_ref r103
    if is_error(r111) goto L252 (error at encode_input:185) else goto L253
L96:
    r112 = PyList_AsTuple(r107)
    dec_ref r107
    if is_error(r112) goto L254 (error at encode_input:185) else goto L97
L97:
    r113 = PyDict_New()
    if is_error(r113) goto L255 (error at encode_input:185) else goto L98
L98:
    r114 = PyObject_Call(r106, r112, r113)
    dec_ref r106
    dec_ref r112
    dec_ref r113
    if is_error(r114) goto L160 (error at encode_input:185) else goto L99
L99:
    r2.data = r114; r115 = is_error
    if not r115 goto L160 (error at encode_input:185) else goto L158 :: bool
L100:
    r116 = dank_mids.brownie_patch.call.globals :: static
    r117 = 'BrokenProcessPool'
    r118 = CPyDict_GetItem(r116, r117)
    if is_error(r118) goto L160 (error at encode_input:187) else goto L101
L101:
    r119 = CPy_ExceptionMatches(r118)
    dec_ref r118
    if r119 goto L102 else goto L136 :: bool
L102:
    r120 = dank_mids.brownie_patch.call.logger :: static
    if is_error(r120) goto L103 else goto L105
L103:
    r121 = raise NameError('value for final name "logger" was not set')
    if not r121 goto L160 (error at encode_input:188) else goto L256 :: bool
L104:
    unreachable
L105:
    r122 = 'Oh fuck, you broke the %s while decoding %s with abi %s'
    r123 = dank_mids.brownie_patch.call.globals :: static
    r124 = 'ENVS'
    r125 = CPyDict_GetItem(r123, r124)
    if is_error(r125) goto L160 (error at encode_input:188) else goto L106
L106:
    r126 = 'BROWNIE_ENCODER_PROCESSES'
    r127 = CPyObject_GetAttr(r125, r126)
    dec_ref r125
    if is_error(r127) goto L160 (error at encode_input:188) else goto L107
L107:
    r128 = r2.data
    if is_error(r128) goto L257 (error at encode_input:188) else goto L108
L108:
    r129 = r2.call
    if is_error(r129) goto L258 (error at encode_input:188) else goto L109
L109:
    r130 = 'abi'
    r131 = CPyObject_GetAttr(r129, r130)
    dec_ref r129
    if is_error(r131) goto L258 (error at encode_input:188) else goto L110
L110:
    r132 = 'critical'
    r133 = [r120, r122, r127, r128, r131]
    r134 = load_address r133
    r135 = PyObject_VectorcallMethod(r132, r134, 9223372036854775813, 0)
    if is_error(r135) goto L259 (error at encode_input:188) else goto L260
L111:
    dec_ref r127
    dec_ref r128
    dec_ref r131
    r136 = dank_mids.brownie_patch.call.globals :: static
    r137 = 'ENVS'
    r138 = CPyDict_GetItem(r136, r137)
    if is_error(r138) goto L160 (error at encode_input:190) else goto L112
L112:
    r139 = 'BROWNIE_ENCODER_PROCESSES'
    r140 = CPyObject_GetAttr(r138, r139)
    dec_ref r138
    if is_error(r140) goto L160 (error at encode_input:190) else goto L113
L113:
    r141 = '_max_workers'
    r142 = CPyObject_GetAttr(r140, r141)
    dec_ref r140
    if is_error(r142) goto L160 (error at encode_input:190) else goto L114
L114:
    r143 = dank_mids.brownie_patch.call.globals :: static
    r144 = 'AsyncProcessPoolExecutor'
    r145 = CPyDict_GetItem(r143, r144)
    if is_error(r145) goto L261 (error at encode_input:190) else goto L115
L115:
    r146 = [r142]
    r147 = load_address r146
    r148 = _PyObject_Vectorcall(r145, r147, 1, 0)
    dec_ref r145
    if is_error(r148) goto L261 (error at encode_input:190) else goto L116
L116:
    dec_ref r142
    r149 = dank_mids.brownie_patch.call.globals :: static
    r150 = 'ENVS'
    r151 = CPyDict_GetItem(r149, r150)
    if is_error(r151) goto L262 (error at encode_input:190) else goto L117
L117:
    r152 = 'BROWNIE_ENCODER_PROCESSES'
    r153 = PyObject_SetAttr(r151, r152, r148)
    dec_ref r151
    dec_ref r148
    r154 = r153 >= 0 :: signed
    if not r154 goto L160 (error at encode_input:190) else goto L118 :: bool
L118:
    r155 = r2.len_inputs
    if is_error(r155) goto L160 (error at encode_input:191) else goto L119
L119:
    r156 = r155 != 0
    dec_ref r155 :: int
    if r156 goto L120 else goto L132 :: bool
L120:
    r157 = r2.call
    if is_error(r157) goto L160 (error at encode_input:191) else goto L121
L121:
    r158 = 'abi'
    r159 = CPyObject_GetAttr(r157, r158)
    dec_ref r157
    if is_error(r159) goto L160 (error at encode_input:191) else goto L122
L122:
    r160 = r2.call
    if is_error(r160) goto L263 (error at encode_input:191) else goto L123
L123:
    r161 = 'signature'
    r162 = CPyObject_GetAttr(r160, r161)
    dec_ref r160
    if is_error(r162) goto L263 (error at encode_input:191) else goto L124
L124:
    r163 = r2.args
    if is_error(r163) goto L264 (error at encode_input:191) else goto L125
L125:
    r164 = dank_mids.brownie_patch.call.globals :: static
    r165 = '__encode_input'
    r166 = CPyDict_GetItem(r164, r165)
    if is_error(r166) goto L265 (error at encode_input:191) else goto L126
L126:
    r167 = PyList_New(2)
    if is_error(r167) goto L266 (error at encode_input:191) else goto L127
L127:
    r168 = get_element_ptr r167 ob_item :: PyListObject
    r169 = load_mem r168 :: ptr*
    set_mem r169, r159 :: builtins.object*
    r170 = r169 + 8
    set_mem r170, r162 :: builtins.object*
    r171 = CPyList_Extend(r167, r163)
    dec_ref r163
    if is_error(r171) goto L267 (error at encode_input:191) else goto L268
L128:
    r172 = PyList_AsTuple(r167)
    dec_ref r167
    if is_error(r172) goto L269 (error at encode_input:191) else goto L129
L129:
    r173 = PyDict_New()
    if is_error(r173) goto L270 (error at encode_input:191) else goto L130
L130:
    r174 = PyObject_Call(r166, r172, r173)
    dec_ref r166
    dec_ref r172
    dec_ref r173
    if is_error(r174) goto L160 (error at encode_input:191) else goto L131
L131:
    r175 = r174
    goto L135
L132:
    r176 = r2.call
    if is_error(r176) goto L160 (error at encode_input:191) else goto L133
L133:
    r177 = 'signature'
    r178 = CPyObject_GetAttr(r176, r177)
    dec_ref r176
    if is_error(r178) goto L160 (error at encode_input:191) else goto L134
L134:
    r175 = r178
L135:
    r2.data = r175; r179 = is_error
    if not r179 goto L160 (error at encode_input:191) else goto L158 :: bool
L136:
    r180 = dank_mids.brownie_patch.call.globals :: static
    r181 = 'PicklingError'
    r182 = CPyDict_GetItem(r180, r181)
    if is_error(r182) goto L160 (error at encode_input:192) else goto L137
L137:
    r183 = CPy_ExceptionMatches(r182)
    dec_ref r182
    if r183 goto L138 else goto L156 :: bool
L138:
    r184 = r2.len_inputs
    if is_error(r184) goto L160 (error at encode_input:193) else goto L139
L139:
    r185 = r184 != 0
    dec_ref r184 :: int
    if r185 goto L140 else goto L152 :: bool
L140:
    r186 = r2.call
    if is_error(r186) goto L160 (error at encode_input:193) else goto L141
L141:
    r187 = 'abi'
    r188 = CPyObject_GetAttr(r186, r187)
    dec_ref r186
    if is_error(r188) goto L160 (error at encode_input:193) else goto L142
L142:
    r189 = r2.call
    if is_error(r189) goto L271 (error at encode_input:193) else goto L143
L143:
    r190 = 'signature'
    r191 = CPyObject_GetAttr(r189, r190)
    dec_ref r189
    if is_error(r191) goto L271 (error at encode_input:193) else goto L144
L144:
    r192 = r2.args
    if is_error(r192) goto L272 (error at encode_input:193) else goto L145
L145:
    r193 = dank_mids.brownie_patch.call.globals :: static
    r194 = '__encode_input'
    r195 = CPyDict_GetItem(r193, r194)
    if is_error(r195) goto L273 (error at encode_input:193) else goto L146
L146:
    r196 = PyList_New(2)
    if is_error(r196) goto L274 (error at encode_input:193) else goto L147
L147:
    r197 = get_element_ptr r196 ob_item :: PyListObject
    r198 = load_mem r197 :: ptr*
    set_mem r198, r188 :: builtins.object*
    r199 = r198 + 8
    set_mem r199, r191 :: builtins.object*
    r200 = CPyList_Extend(r196, r192)
    dec_ref r192
    if is_error(r200) goto L275 (error at encode_input:193) else goto L276
L148:
    r201 = PyList_AsTuple(r196)
    dec_ref r196
    if is_error(r201) goto L277 (error at encode_input:193) else goto L149
L149:
    r202 = PyDict_New()
    if is_error(r202) goto L278 (error at encode_input:193) else goto L150
L150:
    r203 = PyObject_Call(r195, r201, r202)
    dec_ref r195
    dec_ref r201
    dec_ref r202
    if is_error(r203) goto L160 (error at encode_input:193) else goto L151
L151:
    r204 = r203
    goto L155
L152:
    r205 = r2.call
    if is_error(r205) goto L160 (error at encode_input:193) else goto L153
L153:
    r206 = 'signature'
    r207 = CPyObject_GetAttr(r205, r206)
    dec_ref r205
    if is_error(r207) goto L160 (error at encode_input:193) else goto L154
L154:
    r204 = r207
L155:
    r2.data = r204; r208 = is_error
    if not r208 goto L160 (error at encode_input:193) else goto L158 :: bool
L156:
    CPy_Reraise()
    if not 0 goto L160 else goto L279 :: bool
L157:
    unreachable
L158:
    r209 = r2.__mypyc_temp__31
    if is_error(r209) goto L218 (error at encode_input:-1) else goto L159
L159:
    CPy_RestoreExcInfo(r209)
    dec_ref r209
    goto L163
L160:
    r210 = r2.__mypyc_temp__31
    dec_ref r2
    if is_error(r210) goto L211 (error at encode_input:-1) else goto L161
L161:
    CPy_RestoreExcInfo(r210)
    dec_ref r210
    r211 = CPy_KeepPropagating()
    if not r211 goto L211 else goto L162 :: bool
L162:
    unreachable
L163:
    r212 = r2.data
    if is_error(r212) goto L218 (error at encode_input:195) else goto L164
L164:
    r213 = builtins :: module
    r214 = 'Exception'
    r215 = CPyObject_GetAttr(r213, r214)
    if is_error(r215) goto L280 (error at encode_input:195) else goto L165
L165:
    r216 = PyObject_IsInstance(r212, r215)
    dec_ref r212
    dec_ref r215
    r217 = r216 >= 0 :: signed
    if not r217 goto L218 (error at encode_input:195) else goto L166 :: bool
L166:
    r218 = truncate r216: i32 to builtins.bool
    if r218 goto L167 else goto L203 :: bool
L167:
    r219 = r2.data
    if is_error(r219) goto L218 (error at encode_input:196) else goto L168
L168:
    r220 = 'args'
    r221 = CPyObject_GetAttr(r219, r220)
    dec_ref r219
    if is_error(r221) goto L218 (error at encode_input:196) else goto L169
L169:
    r222 = cast(tuple, r221)
    if is_error(r222) goto L218 (error at encode_input:196) else goto L170
L170:
    r223 = get_element_ptr r222 ob_size :: PyVarObject
    r224 = load_mem r223 :: native_int*
    dec_ref r222
    r225 = r224 << 1
    r226 = r225 != 2
    if r226 goto L171 else goto L174 :: bool
L171:
    r227 = r2.data
    dec_ref r2
    if is_error(r227) goto L211 (error at encode_input:197) else goto L172
L172:
    CPy_Raise(r227)
    dec_ref r227
    if not 0 goto L211 (error at encode_input:197) else goto L173 :: bool
L173:
    unreachable
L174:
    r228 = r2.data
    if is_error(r228) goto L218 (error at encode_input:198) else goto L175
L175:
    r229 = PyObject_Str(r228)
    dec_ref r228
    if is_error(r229) goto L218 (error at encode_input:198) else goto L176
L176:
    r2.exc_str = r229; r230 = is_error
    if not r230 goto L218 (error at encode_input:198) else goto L177 :: bool
L177:
    r231 = r2.exc_str
    if is_error(r231) goto L218 (error at encode_input:199) else goto L178
L178:
    r232 = r2.call
    if is_error(r232) goto L281 (error at encode_input:199) else goto L179
L179:
    r233 = '_name'
    r234 = CPyObject_GetAttr(r232, r233)
    dec_ref r232
    if is_error(r234) goto L281 (error at encode_input:199) else goto L180
L180:
    r235 = 'startswith'
    r236 = [r231, r234]
    r237 = load_address r236
    r238 = PyObject_VectorcallMethod(r235, r237, 9223372036854775810, 0)
    if is_error(r238) goto L282 (error at encode_input:199) else goto L181
L181:
    dec_ref r231
    dec_ref r234
    r239 = unbox(bool, r238)
    dec_ref r238
    if is_error(r239) goto L218 (error at encode_input:199) else goto L182
L182:
    if r239 goto L183 else goto L188 :: bool
L183:
    r240 = r2.exc_str
    if is_error(r240) goto L218 (error at encode_input:200) else goto L184
L184:
    r241 = ' '
    r242 = CPyStr_Split(r240, r241, 2)
    dec_ref r240
    if is_error(r242) goto L218 (error at encode_input:200) else goto L185
L185:
    r243 = CPyList_GetItemShort(r242, 2)
    dec_ref r242
    if is_error(r243) goto L218 (error at encode_input:200) else goto L186
L186:
    r244 = cast(str, r243)
    if is_error(r244) goto L218 (error at encode_input:200) else goto L187
L187:
    r2.exc_str = r244; r245 = is_error
    if not r245 goto L218 (error at encode_input:200) else goto L191 :: bool
L188:
    r246 = ': '
    r247 = r2.exc_str
    if is_error(r247) goto L218 (error at encode_input:202) else goto L189
L189:
    r248 = CPyStr_Build(2, r246, r247)
    dec_ref r247
    if is_error(r248) goto L218 (error at encode_input:202) else goto L190
L190:
    r2.exc_str = r248; r249 = is_error
    if not r249 goto L218 (error at encode_input:202) else goto L191 :: bool
L191:
    r250 = r2.data
    if is_error(r250) goto L218 (error at encode_input:203) else goto L192
L192:
    r251 = PyObject_Type(r250)
    dec_ref r250
    r252 = "Contract('"
    r253 = r2.call
    if is_error(r253) goto L283 (error at encode_input:203) else goto L193
L193:
    r254 = '_address'
    r255 = CPyObject_GetAttr(r253, r254)
    dec_ref r253
    if is_error(r255) goto L283 (error at encode_input:203) else goto L194
L194:
    r256 = PyObject_Str(r255)
    dec_ref r255
    if is_error(r256) goto L283 (error at encode_input:203) else goto L195
L195:
    r257 = "')."
    r258 = r2.call
    if is_error(r258) goto L284 (error at encode_input:203) else goto L196
L196:
    r259 = '_name'
    r260 = CPyObject_GetAttr(r258, r259)
    dec_ref r258
    if is_error(r260) goto L284 (error at encode_input:203) else goto L197
L197:
    r261 = PyObject_Str(r260)
    dec_ref r260
    if is_error(r261) goto L284 (error at encode_input:203) else goto L198
L198:
    r262 = ': '
    r263 = r2.exc_str
    dec_ref r2
    if is_error(r263) goto L285 (error at encode_input:203) else goto L199
L199:
    r264 = CPyStr_Build(6, r252, r256, r257, r261, r262, r263)
    dec_ref r256
    dec_ref r261
    dec_ref r263
    if is_error(r264) goto L286 (error at encode_input:203) else goto L200
L200:
    r265 = [r264]
    r266 = load_address r265
    r267 = _PyObject_Vectorcall(r251, r266, 1, 0)
    dec_ref r251
    if is_error(r267) goto L287 (error at encode_input:203) else goto L201
L201:
    dec_ref r264
    CPy_Raise(r267)
    dec_ref r267
    if not 0 goto L211 (error at encode_input:203) else goto L202 :: bool
L202:
    unreachable
L203:
    r268 = r2.data
    if is_error(r268) goto L218 (error at encode_input:204) else goto L204
L204:
    r2.__mypyc_next_label__ = -2; r269 = is_error
    dec_ref r2
    if not r269 goto L288 (error at encode_input:204) else goto L205 :: bool
L205:
    CPyGen_SetStopIterationValue(r268)
    dec_ref r268
    if not 0 goto L211 else goto L206 :: bool
L206:
    unreachable
L207:
    r270 = r3 == 0
    if r270 goto L289 else goto L208 :: bool
L208:
    r271 = r3 == 2
    dec_ref r3 :: int
    if r271 goto L57 else goto L290 :: bool
L209:
    r272 = raise StopIteration
    if not r272 goto L211 (error at encode_input:175) else goto L210 :: bool
L210:
    unreachable
L211:
    r273 = <error> :: object
    return r273
L212:
    xdec_ref r1
    goto L211
L213:
    xdec_ref r1
    dec_ref r2
    goto L211
L214:
    xdec_ref r1
    dec_ref r2
    goto L3
L215:
    xdec_ref r1
    dec_ref r2
    dec_ref r16
    goto L211
L216:
    xdec_ref r1
    dec_ref r2
    dec_ref r20
    goto L17
L217:
    xdec_ref r1
    goto L28
L218:
    dec_ref r2
    goto L211
L219:
    dec_ref r2
    dec_ref r34
    goto L211
L220:
    dec_ref r2
    dec_ref r34
    dec_ref r37
    goto L211
L221:
    dec_ref r2
    dec_ref r34
    dec_ref r37
    dec_ref r38
    goto L211
L222:
    dec_ref r2
    dec_ref r34
    dec_ref r37
    dec_ref r38
    dec_ref r41
    goto L211
L223:
    dec_ref r2
    dec_ref r41
    dec_ref r42
    goto L211
L224:
    dec_ref r46
    goto L36
L225:
    dec_ref r2
    dec_ref r41
    goto L211
L226:
    dec_ref r2
    dec_ref r41
    dec_ref r47
    goto L211
L227:
    xdec_ref r1
    goto L84
L228:
    xdec_ref r1
    dec_ref r51
    goto L84
L229:
    xdec_ref r1
    dec_ref r51
    dec_ref r52
    goto L84
L230:
    xdec_ref r1
    dec_ref r51
    dec_ref r52
    dec_ref r53
    goto L84
L231:
    xdec_ref r1
    dec_ref r53
    dec_ref r54
    goto L84
L232:
    dec_ref r57
    goto L45
L233:
    xdec_ref r1
    dec_ref r53
    goto L84
L234:
    xdec_ref r1
    dec_ref r53
    dec_ref r58
    goto L84
L235:
    xdec_ref r1
    goto L52
L236:
    dec_ref r67
    goto L61
L237:
    xdec_ref r1
    dec_ref r2
    goto L56
L238:
    xdec_ref r1
    dec_ref r2
    goto L59
L239:
    xdec_ref r1
    goto L75
L240:
    dec_ref r2
    goto L67
L241:
    xdec_ref r1
    dec_ref r67
    goto L75
L242:
    dec_ref r2
    goto L72
L243:
    dec_ref r66
    goto L75
L244:
    dec_ref r2
    goto L77
L245:
    xdec_ref r1
    dec_ref arg
    goto L84
L246:
    xdec_ref r1
    goto L81
L247:
    dec_ref r90
    goto L160
L248:
    dec_ref r99
    goto L160
L249:
    dec_ref r99
    dec_ref r102
    goto L160
L250:
    dec_ref r99
    dec_ref r102
    dec_ref r103
    goto L160
L251:
    dec_ref r99
    dec_ref r102
    dec_ref r103
    dec_ref r106
    goto L160
L252:
    dec_ref r106
    dec_ref r107
    goto L160
L253:
    dec_ref r111
    goto L96
L254:
    dec_ref r106
    goto L160
L255:
    dec_ref r106
    dec_ref r112
    goto L160
L256:
    dec_ref r2
    goto L104
L257:
    dec_ref r127
    goto L160
L258:
    dec_ref r127
    dec_ref r128
    goto L160
L259:
    dec_ref r127
    dec_ref r128
    dec_ref r131
    goto L160
L260:
    dec_ref r135
    goto L111
L261:
    dec_ref r142
    goto L160
L262:
    dec_ref r148
    goto L160
L263:
    dec_ref r159
    goto L160
L264:
    dec_ref r159
    dec_ref r162
    goto L160
L265:
    dec_ref r159
    dec_ref r162
    dec_ref r163
    goto L160
L266:
    dec_ref r159
    dec_ref r162
    dec_ref r163
    dec_ref r166
    goto L160
L267:
    dec_ref r166
    dec_ref r167
    goto L160
L268:
    dec_ref r171
    goto L128
L269:
    dec_ref r166
    goto L160
L270:
    dec_ref r166
    dec_ref r172
    goto L160
L271:
    dec_ref r188
    goto L160
L272:
    dec_ref r188
    dec_ref r191
    goto L160
L273:
    dec_ref r188
    dec_ref r191
    dec_ref r192
    goto L160
L274:
    dec_ref r188
    dec_ref r191
    dec_ref r192
    dec_ref r195
    goto L160
L275:
    dec_ref r195
    dec_ref r196
    goto L160
L276:
    dec_ref r200
    goto L148
L277:
    dec_ref r195
    goto L160
L278:
    dec_ref r195
    dec_ref r201
    goto L160
L279:
    dec_ref r2
    goto L157
L280:
    dec_ref r2
    dec_ref r212
    goto L211
L281:
    dec_ref r2
    dec_ref r231
    goto L211
L282:
    dec_ref r2
    dec_ref r231
    dec_ref r234
    goto L211
L283:
    dec_ref r2
    dec_ref r251
    goto L211
L284:
    dec_ref r2
    dec_ref r251
    dec_ref r256
    goto L211
L285:
    dec_ref r251
    dec_ref r256
    dec_ref r261
    goto L211
L286:
    dec_ref r251
    goto L211
L287:
    dec_ref r264
    goto L211
L288:
    dec_ref r268
    goto L211
L289:
    dec_ref r3 :: int
    goto L2
L290:
    xdec_ref r1
    dec_ref r2
    goto L209

def encode_input_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def encode_input_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def encode_input_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def encode_input_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = encode_input_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def encode_input_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def encode_input_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.encode_input_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def encode_input(call, len_inputs, get_request_data, args):
    call :: object
    len_inputs :: int
    get_request_data :: object
    args :: tuple
    r0 :: dank_mids.brownie_patch.call.encode_input_env
    r1, r2, r3, r4 :: bool
    r5 :: dank_mids.brownie_patch.call.encode_input_gen
    r6, r7 :: bool
    r8 :: object
L0:
    r0 = encode_input_env()
    if is_error(r0) goto L9 (error at encode_input:175) else goto L1
L1:
    inc_ref call
    r0.call = call; r1 = is_error
    if not r1 goto L10 (error at encode_input:175) else goto L2 :: bool
L2:
    inc_ref len_inputs :: int
    r0.len_inputs = len_inputs; r2 = is_error
    if not r2 goto L10 (error at encode_input:175) else goto L3 :: bool
L3:
    inc_ref get_request_data
    r0.get_request_data = get_request_data; r3 = is_error
    if not r3 goto L10 (error at encode_input:175) else goto L4 :: bool
L4:
    inc_ref args
    r0.args = args; r4 = is_error
    if not r4 goto L10 (error at encode_input:175) else goto L5 :: bool
L5:
    r5 = encode_input_gen()
    if is_error(r5) goto L10 (error at encode_input:175) else goto L6
L6:
    inc_ref r0
    r5.__mypyc_env__ = r0; r6 = is_error
    if not r6 goto L11 (error at encode_input:175) else goto L7 :: bool
L7:
    r0.__mypyc_next_label__ = 0; r7 = is_error
    dec_ref r0
    if not r7 goto L12 (error at encode_input:175) else goto L8 :: bool
L8:
    return r5
L9:
    r8 = <error> :: object
    return r8
L10:
    dec_ref r0
    goto L9
L11:
    dec_ref r0
    dec_ref r5
    goto L9
L12:
    dec_ref r5
    goto L9

def decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    type, value, traceback, arg, r0, r1, r2, r3 :: object
    r4 :: dank_mids.brownie_patch.call.decode_output_env
    r5 :: int
    r6 :: object
    r7 :: bit
    r8 :: object
    r9 :: str
    r10 :: object
    r11 :: bytes
    r12 :: dict
    r13 :: None
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: i32
    r18 :: bit
    r19 :: bool
    r20, r21 :: bytes
    r22 :: i32
    r23 :: bit
    r24 :: bool
    r25 :: bytes
    r26 :: object
    r27 :: str
    r28 :: object
    r29 :: dict
    r30 :: object
    r31 :: bool
    r32 :: object
    r33 :: bytes
    r34 :: object
    r35 :: bool
    r36 :: object[2]
    r37 :: object_ptr
    r38, r39 :: object
    r40 :: bool
    r41, r42, r43, r44, r45 :: object
    r46 :: bool
    r47 :: object
    r48 :: bit
    r49 :: tuple[object, object, object]
    r50 :: bool
    r51 :: object_ptr
    r52 :: object
    r53, r54 :: bool
    r55 :: tuple[object, object, object]
    r56 :: bool
    r57, r58 :: tuple[object, object, object]
    r59 :: bit
    r60, r61, r62 :: object
    r63 :: bool
    r64 :: tuple[object, object, object]
    r65 :: bool
    r66 :: dict
    r67 :: str
    r68 :: object
    r69 :: bit
    r70 :: object
    r71 :: bool
    r72 :: str
    r73 :: dict
    r74 :: str
    r75 :: object
    r76 :: str
    r77 :: object
    r78 :: bytes
    r79 :: object
    r80 :: str
    r81 :: object
    r82 :: str
    r83 :: object[5]
    r84 :: object_ptr
    r85 :: object
    r86 :: dict
    r87 :: str
    r88 :: object
    r89 :: str
    r90 :: object
    r91 :: str
    r92 :: object
    r93 :: dict
    r94 :: str
    r95 :: object
    r96 :: object[1]
    r97 :: object_ptr
    r98 :: object
    r99 :: dict
    r100 :: str
    r101 :: object
    r102 :: str
    r103 :: i32
    r104 :: bit
    r105 :: bytes
    r106 :: object
    r107 :: str
    r108 :: object
    r109 :: dict
    r110 :: object
    r111 :: bool
    r112, r113 :: tuple[object, object, object]
    r114 :: bit
    r115, r116 :: object
    r117 :: str
    r118 :: object
    r119 :: i32
    r120 :: bit
    r121 :: bool
    r122, r123 :: object
    r124 :: bool
    r125 :: tuple[object, object, object]
    r126 :: bool
    r127 :: dict
    r128 :: str
    r129 :: object
    r130 :: bit
    r131 :: object
    r132 :: bool
    r133 :: object
    r134 :: str
    r135, r136, r137 :: object
    r138 :: str
    r139 :: object
    r140 :: bytes
    r141 :: list
    r142 :: object
    r143 :: i32
    r144 :: bit
    r145 :: i32
    r146 :: bit
    r147 :: i32
    r148 :: bit
    r149 :: tuple
    r150 :: object
    r151 :: str
    r152 :: i32
    r153 :: bit
    r154 :: object
    r155 :: str
    r156 :: object
    r157 :: bit
    r158 :: object
    r159 :: bool
    r160 :: object
    r161, r162 :: str
    r163 :: bool
    r164 :: object
    r165 :: bool
    r166 :: str
    r167 :: object
    r168 :: str
    r169 :: object[3]
    r170 :: object_ptr
    r171, r172 :: object
    r173 :: str
    r174 :: object
    r175 :: dict
    r176 :: str
    r177 :: object
    r178 :: set
    r179 :: i32
    r180 :: bit
    r181 :: bool
    r182 :: object
    r183 :: str
    r184 :: object
    r185 :: i32
    r186 :: bit
    r187 :: object
    r188 :: bytes
    r189, r190 :: object
    r191 :: bool
    r192, r193, r194, r195, r196 :: object
    r197 :: bool
    r198 :: object
    r199 :: bit
    r200 :: tuple[object, object, object]
    r201 :: bool
    r202 :: object_ptr
    r203 :: object
    r204, r205 :: bool
    r206 :: tuple[object, object, object]
    r207 :: bool
    r208, r209 :: tuple[object, object, object]
    r210 :: bit
    r211, r212, r213 :: object
    r214 :: tuple[object, object, object]
    r215 :: bool
    r216 :: tuple[object, object, object]
    r217, r218, r219, r220 :: bit
    r221 :: bool
    r222 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = __mypyc_self__.__mypyc_env__
    if is_error(r4) goto L201 (error at decode_output:207) else goto L1
L1:
    r5 = r4.__mypyc_next_label__
    if is_error(r5) goto L202 (error at decode_output:207) else goto L195
L2:
    r6 = load_address _Py_NoneStruct
    r7 = type != r6
    if r7 goto L203 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L200 (error at decode_output:207) else goto L4 :: bool
L4:
    unreachable
L5:
    r8 = r4.call
    if is_error(r8) goto L202 (error at decode_output:208) else goto L6
L6:
    r9 = 'abi'
    r10 = CPyObject_GetAttr(r8, r9)
    dec_ref r8
    if is_error(r10) goto L202 (error at decode_output:208) else goto L7
L7:
    r11 = r4.data
    if is_error(r11) goto L204 (error at decode_output:208) else goto L8
L8:
    r12 = cast(dict, r10)
    if is_error(r12) goto L205 (error at decode_output:208) else goto L9
L9:
    r13 = __validate_output(r12, r11)
    dec_ref r12
    dec_ref r11
    if is_error(r13) goto L202 (error at decode_output:208) else goto L10
L10:
    r14 = r4.call
    if is_error(r14) goto L206 (error at decode_output:210) else goto L11
L11:
    r15 = '_skip_decoder_proc_pool'
    r16 = CPyObject_GetAttr(r14, r15)
    dec_ref r14
    if is_error(r16) goto L206 (error at decode_output:210) else goto L12
L12:
    r17 = PyObject_IsTrue(r16)
    dec_ref r16
    r18 = r17 >= 0 :: signed
    if not r18 goto L206 (error at decode_output:210) else goto L13 :: bool
L13:
    r19 = truncate r17: i32 to builtins.bool
    if r19 goto L207 else goto L14 :: bool
L14:
    r20 = b'Unexpected error'
    r21 = r4.data
    if is_error(r21) goto L206 (error at decode_output:210) else goto L15
L15:
    r22 = PySequence_Contains(r21, r20)
    dec_ref r21
    r23 = r22 >= 0 :: signed
    if not r23 goto L206 (error at decode_output:210) else goto L16 :: bool
L16:
    r24 = truncate r22: i32 to builtins.bool
    if r24 goto L207 else goto L23 :: bool
L17:
    r25 = r4.data
    if is_error(r25) goto L108 (error at decode_output:212) else goto L18
L18:
    r26 = r4.call
    if is_error(r26) goto L208 (error at decode_output:212) else goto L19
L19:
    r27 = 'abi'
    r28 = CPyObject_GetAttr(r26, r27)
    dec_ref r26
    if is_error(r28) goto L208 (error at decode_output:212) else goto L20
L20:
    r29 = cast(dict, r28)
    if is_error(r29) goto L208 (error at decode_output:212) else goto L21
L21:
    r30 = __decode_output(r25, r29)
    dec_ref r25
    dec_ref r29
    if is_error(r30) goto L108 (error at decode_output:212) else goto L22
L22:
    r4.decoded = r30; r31 = is_error
    if not r31 goto L108 (error at decode_output:212) else goto L97 :: bool
L23:
    r32 = r4.call
    if is_error(r32) goto L209 (error at decode_output:215) else goto L24
L24:
    r33 = r4.data
    if is_error(r33) goto L210 (error at decode_output:215) else goto L25
L25:
    r34 = dank_mids.brownie_patch.call.decode :: static
    if is_error(r34) goto L211 else goto L28
L26:
    r35 = raise NameError('value for final name "decode" was not set')
    if not r35 goto L65 (error at decode_output:215) else goto L212 :: bool
L27:
    unreachable
L28:
    r36 = [r32, r33]
    r37 = load_address r36
    r38 = _PyObject_Vectorcall(r34, r37, 2, 0)
    if is_error(r38) goto L213 (error at decode_output:215) else goto L29
L29:
    dec_ref r32
    dec_ref r33
    r39 = CPy_GetCoro(r38)
    dec_ref r38
    if is_error(r39) goto L209 (error at decode_output:215) else goto L30
L30:
    r4.__mypyc_temp__32 = r39; r40 = is_error
    if not r40 goto L209 (error at decode_output:-1) else goto L31 :: bool
L31:
    r41 = r4.__mypyc_temp__32
    if is_error(r41) goto L209 (error at decode_output:-1) else goto L32
L32:
    r42 = CPyIter_Next(r41)
    dec_ref r41
    if is_error(r42) goto L214 else goto L35
L33:
    r43 = CPy_FetchStopIterationValue()
    if is_error(r43) goto L65 (error at decode_output:215) else goto L34
L34:
    r44 = r43
    goto L64
L35:
    r45 = r42
L36:
    r4.__mypyc_next_label__ = 2; r46 = is_error
    if not r46 goto L215 (error at decode_output:215) else goto L216 :: bool
L37:
    return r45
L38:
    r47 = load_address _Py_NoneStruct
    r48 = type != r47
    if r48 goto L39 else goto L41 :: bool
L39:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L42 (error at decode_output:215) else goto L217 :: bool
L40:
    unreachable
L41:
    inc_ref arg
    goto L59
L42:
    r49 = CPy_CatchError()
    r4.__mypyc_temp__33 = r49; r50 = is_error
    if not r50 goto L218 (error at decode_output:-1) else goto L43 :: bool
L43:
    r51 = load_address r1
    r52 = r4.__mypyc_temp__32
    if is_error(r52) goto L218 (error at decode_output:-1) else goto L44
L44:
    r53 = CPy_YieldFromErrorHandle(r52, r51)
    dec_ref r52
    if is_error(r53) goto L218 (error at decode_output:215) else goto L45
L45:
    if r53 goto L51 else goto L46 :: bool
L46:
    if is_error(r1) goto L47 else goto L49
L47:
    r54 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r54 goto L56 (error at decode_output:-1) else goto L219 :: bool
L48:
    unreachable
L49:
    inc_ref r1
    r45 = r1
    r55 = r4.__mypyc_temp__33
    if is_error(r55) goto L220 (error at decode_output:-1) else goto L50
L50:
    CPy_RestoreExcInfo(r55)
    dec_ref r55
    goto L36
L51:
    if is_error(r1) goto L52 else goto L54
L52:
    r56 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r56 goto L56 (error at decode_output:-1) else goto L221 :: bool
L53:
    unreachable
L54:
    r44 = r1
    r57 = r4.__mypyc_temp__33
    if is_error(r57) goto L222 (error at decode_output:-1) else goto L55
L55:
    CPy_RestoreExcInfo(r57)
    dec_ref r57
    goto L64
L56:
    r58 = r4.__mypyc_temp__33
    if is_error(r58) goto L65 (error at decode_output:-1) else goto L57
L57:
    CPy_RestoreExcInfo(r58)
    dec_ref r58
    r59 = CPy_KeepPropagating()
    if not r59 goto L65 else goto L223 :: bool
L58:
    unreachable
L59:
    r60 = r4.__mypyc_temp__32
    if is_error(r60) goto L224 (error at decode_output:-1) else goto L60
L60:
    r61 = CPyIter_Send(r60, arg)
    dec_ref r60
    dec_ref arg
    if is_error(r61) goto L225 else goto L61
L61:
    r45 = r61
    goto L36
L62:
    r62 = CPy_FetchStopIterationValue()
    if is_error(r62) goto L65 (error at decode_output:215) else goto L63
L63:
    r44 = r62
L64:
    r4.decoded = r44; r63 = is_error
    if not r63 goto L65 (error at decode_output:215) else goto L97 :: bool
L65:
    r64 = CPy_CatchError()
    r4.__mypyc_temp__34 = r64; r65 = is_error
    if not r65 goto L94 (error at decode_output:-1) else goto L66 :: bool
L66:
    r66 = dank_mids.brownie_patch.call.globals :: static
    r67 = 'BrokenProcessPool'
    r68 = CPyDict_GetItem(r66, r67)
    if is_error(r68) goto L94 (error at decode_output:217) else goto L67
L67:
    r69 = CPy_ExceptionMatches(r68)
    dec_ref r68
    if r69 goto L68 else goto L90 :: bool
L68:
    r70 = dank_mids.brownie_patch.call.logger :: static
    if is_error(r70) goto L69 else goto L71
L69:
    r71 = raise NameError('value for final name "logger" was not set')
    if not r71 goto L94 (error at decode_output:219) else goto L226 :: bool
L70:
    unreachable
L71:
    r72 = 'Oh fuck, you broke the %s while decoding %s with abi %s'
    r73 = dank_mids.brownie_patch.call.globals :: static
    r74 = 'ENVS'
    r75 = CPyDict_GetItem(r73, r74)
    if is_error(r75) goto L94 (error at decode_output:219) else goto L72
L72:
    r76 = 'BROWNIE_DECODER_PROCESSES'
    r77 = CPyObject_GetAttr(r75, r76)
    dec_ref r75
    if is_error(r77) goto L94 (error at decode_output:219) else goto L73
L73:
    r78 = r4.data
    if is_error(r78) goto L227 (error at decode_output:219) else goto L74
L74:
    r79 = r4.call
    if is_error(r79) goto L228 (error at decode_output:219) else goto L75
L75:
    r80 = 'abi'
    r81 = CPyObject_GetAttr(r79, r80)
    dec_ref r79
    if is_error(r81) goto L228 (error at decode_output:219) else goto L76
L76:
    r82 = 'critical'
    r83 = [r70, r72, r77, r78, r81]
    r84 = load_address r83
    r85 = PyObject_VectorcallMethod(r82, r84, 9223372036854775813, 0)
    if is_error(r85) goto L229 (error at decode_output:219) else goto L230
L77:
    dec_ref r77
    dec_ref r78
    dec_ref r81
    r86 = dank_mids.brownie_patch.call.globals :: static
    r87 = 'ENVS'
    r88 = CPyDict_GetItem(r86, r87)
    if is_error(r88) goto L94 (error at decode_output:220) else goto L78
L78:
    r89 = 'BROWNIE_DECODER_PROCESSES'
    r90 = CPyObject_GetAttr(r88, r89)
    dec_ref r88
    if is_error(r90) goto L94 (error at decode_output:220) else goto L79
L79:
    r91 = '_max_workers'
    r92 = CPyObject_GetAttr(r90, r91)
    dec_ref r90
    if is_error(r92) goto L94 (error at decode_output:220) else goto L80
L80:
    r93 = dank_mids.brownie_patch.call.globals :: static
    r94 = 'AsyncProcessPoolExecutor'
    r95 = CPyDict_GetItem(r93, r94)
    if is_error(r95) goto L231 (error at decode_output:220) else goto L81
L81:
    r96 = [r92]
    r97 = load_address r96
    r98 = _PyObject_Vectorcall(r95, r97, 1, 0)
    dec_ref r95
    if is_error(r98) goto L231 (error at decode_output:220) else goto L82
L82:
    dec_ref r92
    r99 = dank_mids.brownie_patch.call.globals :: static
    r100 = 'ENVS'
    r101 = CPyDict_GetItem(r99, r100)
    if is_error(r101) goto L232 (error at decode_output:220) else goto L83
L83:
    r102 = 'BROWNIE_DECODER_PROCESSES'
    r103 = PyObject_SetAttr(r101, r102, r98)
    dec_ref r101
    dec_ref r98
    r104 = r103 >= 0 :: signed
    if not r104 goto L94 (error at decode_output:220) else goto L84 :: bool
L84:
    r105 = r4.data
    if is_error(r105) goto L94 (error at decode_output:221) else goto L85
L85:
    r106 = r4.call
    if is_error(r106) goto L233 (error at decode_output:221) else goto L86
L86:
    r107 = 'abi'
    r108 = CPyObject_GetAttr(r106, r107)
    dec_ref r106
    if is_error(r108) goto L233 (error at decode_output:221) else goto L87
L87:
    r109 = cast(dict, r108)
    if is_error(r109) goto L233 (error at decode_output:221) else goto L88
L88:
    r110 = __decode_output(r105, r109)
    dec_ref r105
    dec_ref r109
    if is_error(r110) goto L94 (error at decode_output:221) else goto L89
L89:
    r4.decoded = r110; r111 = is_error
    if not r111 goto L94 (error at decode_output:221) else goto L92 :: bool
L90:
    CPy_Reraise()
    if not 0 goto L94 else goto L234 :: bool
L91:
    unreachable
L92:
    r112 = r4.__mypyc_temp__34
    if is_error(r112) goto L108 (error at decode_output:-1) else goto L93
L93:
    CPy_RestoreExcInfo(r112)
    dec_ref r112
    goto L97
L94:
    r113 = r4.__mypyc_temp__34
    if is_error(r113) goto L108 (error at decode_output:-1) else goto L95
L95:
    CPy_RestoreExcInfo(r113)
    dec_ref r113
    r114 = CPy_KeepPropagating()
    if not r114 goto L108 else goto L235 :: bool
L96:
    unreachable
L97:
    r115 = r4.decoded
    if is_error(r115) goto L108 (error at decode_output:223) else goto L98
L98:
    r116 = builtins :: module
    r117 = 'Exception'
    r118 = CPyObject_GetAttr(r116, r117)
    if is_error(r118) goto L236 (error at decode_output:223) else goto L99
L99:
    r119 = PyObject_IsInstance(r115, r118)
    dec_ref r115
    dec_ref r118
    r120 = r119 >= 0 :: signed
    if not r120 goto L108 (error at decode_output:223) else goto L100 :: bool
L100:
    r121 = truncate r119: i32 to builtins.bool
    if r121 goto L101 else goto L104 :: bool
L101:
    r122 = r4.decoded
    if is_error(r122) goto L108 (error at decode_output:224) else goto L102
L102:
    CPy_Raise(r122)
    dec_ref r122
    if not 0 goto L108 (error at decode_output:224) else goto L237 :: bool
L103:
    unreachable
L104:
    r123 = r4.decoded
    if is_error(r123) goto L108 (error at decode_output:225) else goto L105
L105:
    r4.__mypyc_next_label__ = -2; r124 = is_error
    if not r124 goto L238 (error at decode_output:225) else goto L239 :: bool
L106:
    CPyGen_SetStopIterationValue(r123)
    dec_ref r123
    if not 0 goto L200 else goto L107 :: bool
L107:
    unreachable
L108:
    r125 = CPy_CatchError()
    r4.__mypyc_temp__35 = r125; r126 = is_error
    if not r126 goto L240 (error at decode_output:-1) else goto L109 :: bool
L109:
    r127 = dank_mids.brownie_patch.call.globals :: static
    r128 = 'InsufficientDataBytes'
    r129 = CPyDict_GetItem(r127, r128)
    if is_error(r129) goto L240 (error at decode_output:226) else goto L110
L110:
    r130 = CPy_ExceptionMatches(r129)
    dec_ref r129
    if r130 goto L241 else goto L128 :: bool
L111:
    r131 = CPy_GetExcValue()
    r4.e = r131; r132 = is_error
    if not r132 goto L192 (error at decode_output:226) else goto L112 :: bool
L112:
    r133 = r4.e
    if is_error(r133) goto L192 (error at decode_output:228) else goto L113
L113:
    r134 = 'args'
    r135 = CPyObject_GetAttr(r133, r134)
    dec_ref r133
    if is_error(r135) goto L192 (error at decode_output:228) else goto L114
L114:
    r136 = r4.call
    if is_error(r136) goto L242 (error at decode_output:228) else goto L115
L115:
    r137 = r4.call
    if is_error(r137) goto L243 (error at decode_output:228) else goto L116
L116:
    r138 = '_address'
    r139 = CPyObject_GetAttr(r137, r138)
    dec_ref r137
    if is_error(r139) goto L243 (error at decode_output:228) else goto L117
L117:
    r140 = r4.data
    if is_error(r140) goto L244 (error at decode_output:228) else goto L118
L118:
    r141 = PyList_New(0)
    if is_error(r141) goto L245 (error at decode_output:228) else goto L119
L119:
    r142 = CPyList_Extend(r141, r135)
    dec_ref r135
    if is_error(r142) goto L246 (error at decode_output:228) else goto L247
L120:
    r143 = PyList_Append(r141, r136)
    dec_ref r136
    r144 = r143 >= 0 :: signed
    if not r144 goto L248 (error at decode_output:228) else goto L121 :: bool
L121:
    r145 = PyList_Append(r141, r139)
    dec_ref r139
    r146 = r145 >= 0 :: signed
    if not r146 goto L249 (error at decode_output:228) else goto L122 :: bool
L122:
    r147 = PyList_Append(r141, r140)
    dec_ref r140
    r148 = r147 >= 0 :: signed
    if not r148 goto L250 (error at decode_output:228) else goto L123 :: bool
L123:
    r149 = PyList_AsTuple(r141)
    dec_ref r141
    if is_error(r149) goto L192 (error at decode_output:228) else goto L124
L124:
    r150 = r4.e
    if is_error(r150) goto L251 (error at decode_output:228) else goto L125
L125:
    r151 = 'args'
    r152 = PyObject_SetAttr(r150, r151, r149)
    dec_ref r150
    dec_ref r149
    r153 = r152 >= 0 :: signed
    if not r153 goto L192 (error at decode_output:228) else goto L126 :: bool
L126:
    CPy_Reraise()
    if not 0 goto L192 else goto L252 :: bool
L127:
    unreachable
L128:
    r154 = builtins :: module
    r155 = 'AttributeError'
    r156 = CPyObject_GetAttr(r154, r155)
    if is_error(r156) goto L240 (error at decode_output:230) else goto L129
L129:
    r157 = CPy_ExceptionMatches(r156)
    dec_ref r156
    if r157 goto L130 else goto L253 :: bool
L130:
    r158 = CPy_GetExcValue()
    r4.e = r158; r159 = is_error
    if not r159 goto L240 (error at decode_output:230) else goto L131 :: bool
L131:
    r160 = r4.e
    if is_error(r160) goto L240 (error at decode_output:232) else goto L132
L132:
    r161 = PyObject_Str(r160)
    dec_ref r160
    if is_error(r161) goto L240 (error at decode_output:232) else goto L133
L133:
    r162 = " object has no attribute '_skip_decoder_proc_pool'"
    r163 = CPyStr_Endswith(r161, r162)
    dec_ref r161
    if r163 goto L136 else goto L254 :: bool
L134:
    CPy_Reraise()
    if not 0 goto L192 else goto L255 :: bool
L135:
    unreachable
L136:
    r164 = dank_mids.brownie_patch.call.logger :: static
    if is_error(r164) goto L256 else goto L139
L137:
    r165 = raise NameError('value for final name "logger" was not set')
    if not r165 goto L192 (error at decode_output:234) else goto L257 :: bool
L138:
    unreachable
L139:
    r166 = 'DEBUG ME BRO: %s'
    r167 = r4.e
    if is_error(r167) goto L240 (error at decode_output:234) else goto L140
L140:
    r168 = 'debug'
    r169 = [r164, r166, r167]
    r170 = load_address r169
    r171 = PyObject_VectorcallMethod(r168, r170, 9223372036854775811, 0)
    if is_error(r171) goto L258 (error at decode_output:234) else goto L259
L141:
    dec_ref r167
    r172 = r4.call
    if is_error(r172) goto L240 (error at decode_output:235) else goto L142
L142:
    r173 = '_address'
    r174 = CPyObject_GetAttr(r172, r173)
    dec_ref r172
    if is_error(r174) goto L240 (error at decode_output:235) else goto L143
L143:
    r175 = dank_mids.brownie_patch.call.globals :: static
    r176 = '_skip_proc_pool'
    r177 = CPyDict_GetItem(r175, r176)
    if is_error(r177) goto L260 (error at decode_output:235) else goto L144
L144:
    r178 = cast(set, r177)
    if is_error(r178) goto L260 (error at decode_output:235) else goto L145
L145:
    r179 = PySet_Contains(r178, r174)
    dec_ref r178
    dec_ref r174
    r180 = r179 >= 0 :: signed
    if not r180 goto L240 (error at decode_output:235) else goto L146 :: bool
L146:
    r181 = truncate r179: i32 to builtins.bool
    r182 = r4.call
    if is_error(r182) goto L240 (error at decode_output:235) else goto L147
L147:
    r183 = '_skip_decoder_proc_pool'
    r184 = box(bool, r181)
    r185 = PyObject_SetAttr(r182, r183, r184)
    dec_ref r182
    r186 = r185 >= 0 :: signed
    if not r186 goto L240 (error at decode_output:235) else goto L148 :: bool
L148:
    r187 = r4.call
    if is_error(r187) goto L240 (error at decode_output:236) else goto L149
L149:
    r188 = r4.data
    if is_error(r188) goto L261 (error at decode_output:236) else goto L150
L150:
    r189 = decode_output(r187, r188)
    dec_ref r187
    dec_ref r188
    if is_error(r189) goto L240 (error at decode_output:236) else goto L151
L151:
    r190 = CPy_GetCoro(r189)
    dec_ref r189
    if is_error(r190) goto L240 (error at decode_output:236) else goto L152
L152:
    r4.__mypyc_temp__36 = r190; r191 = is_error
    if not r191 goto L240 (error at decode_output:-1) else goto L153 :: bool
L153:
    r192 = r4.__mypyc_temp__36
    if is_error(r192) goto L240 (error at decode_output:-1) else goto L154
L154:
    r193 = CPyIter_Next(r192)
    dec_ref r192
    if is_error(r193) goto L262 else goto L157
L155:
    r194 = CPy_FetchStopIterationValue()
    if is_error(r194) goto L192 (error at decode_output:236) else goto L156
L156:
    r195 = r194
    goto L186
L157:
    r196 = r193
L158:
    r4.__mypyc_next_label__ = 4; r197 = is_error
    if not r197 goto L263 (error at decode_output:236) else goto L264 :: bool
L159:
    return r196
L160:
    r198 = load_address _Py_NoneStruct
    r199 = type != r198
    if r199 goto L161 else goto L163 :: bool
L161:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L164 (error at decode_output:236) else goto L265 :: bool
L162:
    unreachable
L163:
    inc_ref arg
    goto L181
L164:
    r200 = CPy_CatchError()
    r4.__mypyc_temp__37 = r200; r201 = is_error
    if not r201 goto L266 (error at decode_output:-1) else goto L165 :: bool
L165:
    r202 = load_address r3
    r203 = r4.__mypyc_temp__36
    if is_error(r203) goto L266 (error at decode_output:-1) else goto L166
L166:
    r204 = CPy_YieldFromErrorHandle(r203, r202)
    dec_ref r203
    if is_error(r204) goto L266 (error at decode_output:236) else goto L167
L167:
    if r204 goto L173 else goto L168 :: bool
L168:
    if is_error(r3) goto L169 else goto L171
L169:
    r205 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r205 goto L178 (error at decode_output:-1) else goto L267 :: bool
L170:
    unreachable
L171:
    inc_ref r3
    r196 = r3
    r206 = r4.__mypyc_temp__37
    if is_error(r206) goto L268 (error at decode_output:-1) else goto L172
L172:
    CPy_RestoreExcInfo(r206)
    dec_ref r206
    goto L158
L173:
    if is_error(r3) goto L174 else goto L176
L174:
    r207 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r207 goto L178 (error at decode_output:-1) else goto L269 :: bool
L175:
    unreachable
L176:
    r195 = r3
    r208 = r4.__mypyc_temp__37
    if is_error(r208) goto L270 (error at decode_output:-1) else goto L177
L177:
    CPy_RestoreExcInfo(r208)
    dec_ref r208
    goto L186
L178:
    r209 = r4.__mypyc_temp__37
    if is_error(r209) goto L192 (error at decode_output:-1) else goto L179
L179:
    CPy_RestoreExcInfo(r209)
    dec_ref r209
    r210 = CPy_KeepPropagating()
    if not r210 goto L192 else goto L271 :: bool
L180:
    unreachable
L181:
    r211 = r4.__mypyc_temp__36
    if is_error(r211) goto L272 (error at decode_output:-1) else goto L182
L182:
    r212 = CPyIter_Send(r211, arg)
    dec_ref r211
    dec_ref arg
    if is_error(r212) goto L273 else goto L183
L183:
    r196 = r212
    goto L158
L184:
    r213 = CPy_FetchStopIterationValue()
    if is_error(r213) goto L192 (error at decode_output:236) else goto L185
L185:
    r195 = r213
L186:
    r214 = r4.__mypyc_temp__35
    if is_error(r214) goto L274 (error at decode_output:-1) else goto L187
L187:
    CPy_RestoreExcInfo(r214)
    dec_ref r214
    r4.__mypyc_next_label__ = -2; r215 = is_error
    if not r215 goto L274 (error at decode_output:236) else goto L275 :: bool
L188:
    CPyGen_SetStopIterationValue(r195)
    dec_ref r195
    if not 0 goto L200 else goto L189 :: bool
L189:
    unreachable
L190:
    CPy_Reraise()
    if not 0 goto L192 else goto L276 :: bool
L191:
    unreachable
L192:
    r216 = r4.__mypyc_temp__35
    dec_ref r4
    if is_error(r216) goto L200 (error at decode_output:-1) else goto L193
L193:
    CPy_RestoreExcInfo(r216)
    dec_ref r216
    r217 = CPy_KeepPropagating()
    if not r217 goto L200 else goto L194 :: bool
L194:
    unreachable
L195:
    r218 = r5 == 0
    if r218 goto L277 else goto L196 :: bool
L196:
    r219 = r5 == 2
    if r219 goto L278 else goto L279 :: bool
L197:
    r220 = r5 == 4
    dec_ref r5 :: int
    if r220 goto L160 else goto L280 :: bool
L198:
    r221 = raise StopIteration
    if not r221 goto L200 (error at decode_output:207) else goto L199 :: bool
L199:
    unreachable
L200:
    r222 = <error> :: object
    return r222
L201:
    xdec_ref r1
    xdec_ref r3
    goto L200
L202:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L200
L203:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L3
L204:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r10
    goto L200
L205:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r11
    goto L200
L206:
    xdec_ref r1
    goto L108
L207:
    xdec_ref r1
    goto L17
L208:
    dec_ref r25
    goto L108
L209:
    xdec_ref r1
    goto L65
L210:
    xdec_ref r1
    dec_ref r32
    goto L65
L211:
    xdec_ref r1
    dec_ref r32
    dec_ref r33
    goto L26
L212:
    xdec_ref r3
    dec_ref r4
    goto L27
L213:
    xdec_ref r1
    dec_ref r32
    dec_ref r33
    goto L65
L214:
    xdec_ref r1
    goto L33
L215:
    dec_ref r45
    goto L42
L216:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L37
L217:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L40
L218:
    xdec_ref r1
    goto L56
L219:
    xdec_ref r3
    dec_ref r4
    goto L48
L220:
    xdec_ref r1
    dec_ref r45
    goto L56
L221:
    xdec_ref r3
    dec_ref r4
    goto L53
L222:
    dec_ref r44
    goto L56
L223:
    xdec_ref r3
    dec_ref r4
    goto L58
L224:
    xdec_ref r1
    dec_ref arg
    goto L65
L225:
    xdec_ref r1
    goto L62
L226:
    xdec_ref r3
    dec_ref r4
    goto L70
L227:
    dec_ref r77
    goto L94
L228:
    dec_ref r77
    dec_ref r78
    goto L94
L229:
    dec_ref r77
    dec_ref r78
    dec_ref r81
    goto L94
L230:
    dec_ref r85
    goto L77
L231:
    dec_ref r92
    goto L94
L232:
    dec_ref r98
    goto L94
L233:
    dec_ref r105
    goto L94
L234:
    xdec_ref r3
    dec_ref r4
    goto L91
L235:
    xdec_ref r3
    dec_ref r4
    goto L96
L236:
    dec_ref r115
    goto L108
L237:
    xdec_ref r3
    dec_ref r4
    goto L103
L238:
    dec_ref r123
    goto L108
L239:
    xdec_ref r3
    dec_ref r4
    goto L106
L240:
    xdec_ref r3
    goto L192
L241:
    xdec_ref r3
    goto L111
L242:
    dec_ref r135
    goto L192
L243:
    dec_ref r135
    dec_ref r136
    goto L192
L244:
    dec_ref r135
    dec_ref r136
    dec_ref r139
    goto L192
L245:
    dec_ref r135
    dec_ref r136
    dec_ref r139
    dec_ref r140
    goto L192
L246:
    dec_ref r136
    dec_ref r139
    dec_ref r140
    dec_ref r141
    goto L192
L247:
    dec_ref r142
    goto L120
L248:
    dec_ref r139
    dec_ref r140
    dec_ref r141
    goto L192
L249:
    dec_ref r140
    dec_ref r141
    goto L192
L250:
    dec_ref r141
    goto L192
L251:
    dec_ref r149
    goto L192
L252:
    dec_ref r4
    goto L127
L253:
    xdec_ref r3
    goto L190
L254:
    xdec_ref r3
    goto L134
L255:
    dec_ref r4
    goto L135
L256:
    xdec_ref r3
    goto L137
L257:
    dec_ref r4
    goto L138
L258:
    xdec_ref r3
    dec_ref r167
    goto L192
L259:
    dec_ref r171
    goto L141
L260:
    xdec_ref r3
    dec_ref r174
    goto L192
L261:
    xdec_ref r3
    dec_ref r187
    goto L192
L262:
    xdec_ref r3
    goto L155
L263:
    dec_ref r196
    goto L164
L264:
    xdec_ref r3
    dec_ref r4
    goto L159
L265:
    xdec_ref r3
    dec_ref r4
    goto L162
L266:
    xdec_ref r3
    goto L178
L267:
    dec_ref r4
    goto L170
L268:
    xdec_ref r3
    dec_ref r196
    goto L178
L269:
    dec_ref r4
    goto L175
L270:
    dec_ref r195
    goto L178
L271:
    dec_ref r4
    goto L180
L272:
    xdec_ref r3
    dec_ref arg
    goto L192
L273:
    xdec_ref r3
    goto L184
L274:
    dec_ref r195
    goto L192
L275:
    dec_ref r4
    goto L188
L276:
    dec_ref r4
    goto L191
L277:
    dec_ref r5 :: int
    goto L2
L278:
    dec_ref r5 :: int
    goto L38
L279:
    xdec_ref r1
    goto L197
L280:
    xdec_ref r3
    dec_ref r4
    goto L198

def decode_output_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def decode_output_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def decode_output_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def decode_output_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = decode_output_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def decode_output_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def decode_output_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call.decode_output_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def decode_output(call, data):
    call :: object
    data :: bytes
    r0 :: dank_mids.brownie_patch.call.decode_output_env
    r1, r2 :: bool
    r3 :: dank_mids.brownie_patch.call.decode_output_gen
    r4, r5 :: bool
    r6 :: object
L0:
    r0 = decode_output_env()
    if is_error(r0) goto L7 (error at decode_output:207) else goto L1
L1:
    inc_ref call
    r0.call = call; r1 = is_error
    if not r1 goto L8 (error at decode_output:207) else goto L2 :: bool
L2:
    inc_ref data
    r0.data = data; r2 = is_error
    if not r2 goto L8 (error at decode_output:207) else goto L3 :: bool
L3:
    r3 = decode_output_gen()
    if is_error(r3) goto L8 (error at decode_output:207) else goto L4
L4:
    inc_ref r0
    r3.__mypyc_env__ = r0; r4 = is_error
    if not r4 goto L9 (error at decode_output:207) else goto L5 :: bool
L5:
    r0.__mypyc_next_label__ = 0; r5 = is_error
    dec_ref r0
    if not r5 goto L10 (error at decode_output:207) else goto L6 :: bool
L6:
    return r3
L7:
    r6 = <error> :: object
    return r6
L8:
    dec_ref r0
    goto L7
L9:
    dec_ref r0
    dec_ref r3
    goto L7
L10:
    dec_ref r3
    goto L7

def _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    type, value, traceback, arg :: object
    r0 :: dank_mids.brownie_patch.call._request_data_no_args_env
    r1 :: int
    r2 :: object
    r3 :: bit
    r4 :: object
    r5 :: str
    r6 :: object
    r7 :: bool
    r8 :: bit
    r9 :: bool
    r10 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L13 (error at _request_data_no_args:239) else goto L1
L1:
    r1 = r0.__mypyc_next_label__
    if is_error(r1) goto L14 (error at _request_data_no_args:239) else goto L10
L2:
    r2 = load_address _Py_NoneStruct
    r3 = type != r2
    if r3 goto L15 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L13 (error at _request_data_no_args:239) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = r0.call
    if is_error(r4) goto L14 (error at _request_data_no_args:240) else goto L6
L6:
    r5 = 'signature'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L14 (error at _request_data_no_args:240) else goto L7
L7:
    r0.__mypyc_next_label__ = -2; r7 = is_error
    dec_ref r0
    if not r7 goto L16 (error at _request_data_no_args:240) else goto L8 :: bool
L8:
    CPyGen_SetStopIterationValue(r6)
    dec_ref r6
    if not 0 goto L13 else goto L9 :: bool
L9:
    unreachable
L10:
    r8 = r1 == 0
    dec_ref r1 :: int
    if r8 goto L2 else goto L17 :: bool
L11:
    r9 = raise StopIteration
    if not r9 goto L13 (error at _request_data_no_args:239) else goto L12 :: bool
L12:
    unreachable
L13:
    r10 = <error> :: object
    return r10
L14:
    dec_ref r0
    goto L13
L15:
    dec_ref r0
    goto L3
L16:
    dec_ref r6
    goto L13
L17:
    dec_ref r0
    goto L11

def _request_data_no_args_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _request_data_no_args_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _request_data_no_args_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _request_data_no_args_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = _request_data_no_args_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def _request_data_no_args_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def _request_data_no_args_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.call._request_data_no_args_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _request_data_no_args(call):
    call :: object
    r0 :: dank_mids.brownie_patch.call._request_data_no_args_env
    r1 :: bool
    r2 :: dank_mids.brownie_patch.call._request_data_no_args_gen
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = _request_data_no_args_env()
    if is_error(r0) goto L6 (error at _request_data_no_args:239) else goto L1
L1:
    inc_ref call
    r0.call = call; r1 = is_error
    if not r1 goto L7 (error at _request_data_no_args:239) else goto L2 :: bool
L2:
    r2 = _request_data_no_args_gen()
    if is_error(r2) goto L7 (error at _request_data_no_args:239) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L8 (error at _request_data_no_args:239) else goto L4 :: bool
L4:
    r0.__mypyc_next_label__ = 0; r4 = is_error
    dec_ref r0
    if not r4 goto L9 (error at _request_data_no_args:239) else goto L5 :: bool
L5:
    return r2
L6:
    r5 = <error> :: object
    return r5
L7:
    dec_ref r0
    goto L6
L8:
    dec_ref r0
    dec_ref r2
    goto L6
L9:
    dec_ref r2
    goto L6

def __encode_input(abi, signature, args):
    abi :: dict
    signature :: str
    args :: tuple
    r0 :: list
    r1 :: str
    r2 :: object
    r3 :: dict
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8, r9 :: object
    r10 :: bool
    r11 :: object[2]
    r12 :: object_ptr
    r13 :: object
    r14 :: bytes
    r15 :: str
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19, r20 :: str
    r21 :: tuple[object, object, object]
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: bit
    r26 :: object
    r27 :: bit
    r28 :: object
L0:
L1:
    r0 = format_input_but_cache_checksums(abi, args)
    if is_error(r0) goto L14 (error at __encode_input:254) else goto L2
L2:
    r1 = 'inputs'
    r2 = CPyDict_GetItem(abi, r1)
    if is_error(r2) goto L22 (error at __encode_input:255) else goto L3
L3:
    r3 = dank_mids.brownie_patch.call.globals :: static
    r4 = 'get_type_strings'
    r5 = CPyDict_GetItem(r3, r4)
    if is_error(r5) goto L23 (error at __encode_input:255) else goto L4
L4:
    r6 = [r2]
    r7 = load_address r6
    r8 = _PyObject_Vectorcall(r5, r7, 1, 0)
    dec_ref r5
    if is_error(r8) goto L23 (error at __encode_input:255) else goto L5
L5:
    dec_ref r2
    r9 = dank_mids.brownie_patch.call.__eth_abi_encode :: static
    if is_error(r9) goto L24 else goto L8
L6:
    r10 = raise NameError('value for final name "__eth_abi_encode" was not set')
    if not r10 goto L14 (error at __encode_input:256) else goto L7 :: bool
L7:
    unreachable
L8:
    r11 = [r8, r0]
    r12 = load_address r11
    r13 = _PyObject_Vectorcall(r9, r12, 2, 0)
    if is_error(r13) goto L25 (error at __encode_input:256) else goto L9
L9:
    dec_ref r8
    dec_ref r0
    r14 = cast(bytes, r13)
    if is_error(r14) goto L14 (error at __encode_input:256) else goto L10
L10:
    r15 = 'hex'
    r16 = [r14]
    r17 = load_address r16
    r18 = PyObject_VectorcallMethod(r15, r17, 9223372036854775809, 0)
    if is_error(r18) goto L26 (error at __encode_input:256) else goto L11
L11:
    dec_ref r14
    r19 = cast(str, r18)
    if is_error(r19) goto L14 (error at __encode_input:256) else goto L12
L12:
    r20 = PyUnicode_Concat(signature, r19)
    dec_ref r19
    if is_error(r20) goto L14 (error at __encode_input:256) else goto L13
L13:
    return r20
L14:
    r21 = CPy_CatchError()
    r22 = builtins :: module
    r23 = 'Exception'
    r24 = CPyObject_GetAttr(r22, r23)
    if is_error(r24) goto L19 (error at __encode_input:257) else goto L15
L15:
    r25 = CPy_ExceptionMatches(r24)
    dec_ref r24
    if r25 goto L16 else goto L17 :: bool
L16:
    r26 = CPy_GetExcValue()
    CPy_RestoreExcInfo(r21)
    dec_ref r21
    return r26
L17:
    CPy_Reraise()
    if not 0 goto L19 else goto L27 :: bool
L18:
    unreachable
L19:
    CPy_RestoreExcInfo(r21)
    dec_ref r21
    r27 = CPy_KeepPropagating()
    if not r27 goto L21 else goto L20 :: bool
L20:
    unreachable
L21:
    r28 = <error> :: object
    return r28
L22:
    dec_ref r0
    goto L14
L23:
    dec_ref r0
    dec_ref r2
    goto L14
L24:
    dec_ref r0
    dec_ref r8
    goto L6
L25:
    dec_ref r0
    dec_ref r8
    goto L14
L26:
    dec_ref r14
    goto L14
L27:
    dec_ref r21
    goto L18

def __decode_output(hexstr, abi):
    hexstr :: object
    abi :: dict
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7, r8 :: object
    r9 :: bool
    r10 :: object[1]
    r11 :: object_ptr
    r12, r13 :: object
    r14 :: bool
    r15 :: object[2]
    r16 :: object_ptr
    r17 :: object
    r18, result :: tuple
    r19 :: object
    r20 :: tuple
    r21 :: ptr
    r22 :: native_int
    r23 :: short_int
    r24 :: bit
    r25 :: tuple[object]
    r26 :: object
    r27 :: union[object, tuple]
    r28 :: tuple[object, object, object]
    r29 :: object
    r30 :: str
    r31 :: object
    r32 :: bit
    r33 :: object
    r34 :: bit
    r35 :: object
L0:
L1:
    r0 = 'outputs'
    r1 = CPyDict_GetItem(abi, r0)
    if is_error(r1) goto L20 (error at __decode_output:276) else goto L2
L2:
    r2 = dank_mids.brownie_patch.call.globals :: static
    r3 = 'get_type_strings'
    r4 = CPyDict_GetItem(r2, r3)
    if is_error(r4) goto L28 (error at __decode_output:276) else goto L3
L3:
    r5 = [r1]
    r6 = load_address r5
    r7 = _PyObject_Vectorcall(r4, r6, 1, 0)
    dec_ref r4
    if is_error(r7) goto L28 (error at __decode_output:276) else goto L4
L4:
    dec_ref r1
    r8 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r8) goto L29 else goto L7
L5:
    r9 = raise NameError('value for final name "HexBytes" was not set')
    if not r9 goto L20 (error at __decode_output:277) else goto L6 :: bool
L6:
    unreachable
L7:
    r10 = [hexstr]
    r11 = load_address r10
    r12 = _PyObject_Vectorcall(r8, r11, 1, 0)
    if is_error(r12) goto L30 (error at __decode_output:277) else goto L8
L8:
    r13 = dank_mids.brownie_patch.call.__eth_abi_decode :: static
    if is_error(r13) goto L31 else goto L11
L9:
    r14 = raise NameError('value for final name "__eth_abi_decode" was not set')
    if not r14 goto L20 (error at __decode_output:277) else goto L10 :: bool
L10:
    unreachable
L11:
    r15 = [r7, r12]
    r16 = load_address r15
    r17 = _PyObject_Vectorcall(r13, r16, 2, 0)
    if is_error(r17) goto L32 (error at __decode_output:277) else goto L12
L12:
    dec_ref r7
    dec_ref r12
    r18 = cast(tuple, r17)
    if is_error(r18) goto L20 (error at __decode_output:277) else goto L13
L13:
    result = r18
    r19 = format_output_but_cache_checksums(abi, result)
    dec_ref result
    if is_error(r19) goto L20 (error at __decode_output:278) else goto L14
L14:
    r20 = cast(tuple, r19)
    if is_error(r20) goto L20 (error at __decode_output:278) else goto L15
L15:
    result = r20
    r21 = get_element_ptr result ob_size :: PyVarObject
    r22 = load_mem r21 :: native_int*
    r23 = r22 << 1
    r24 = r23 == 2
    if r24 goto L16 else goto L18 :: bool
L16:
    r25 = unbox(tuple[object], result)
    dec_ref result
    if is_error(r25) goto L20 (error at __decode_output:279) else goto L17
L17:
    r26 = r25[0]
    dec_ref r25
    r27 = r26
    goto L19
L18:
    r27 = result
L19:
    return r27
L20:
    r28 = CPy_CatchError()
    r29 = builtins :: module
    r30 = 'Exception'
    r31 = CPyObject_GetAttr(r29, r30)
    if is_error(r31) goto L25 (error at __decode_output:280) else goto L21
L21:
    r32 = CPy_ExceptionMatches(r31)
    dec_ref r31
    if r32 goto L22 else goto L23 :: bool
L22:
    r33 = CPy_GetExcValue()
    CPy_RestoreExcInfo(r28)
    dec_ref r28
    return r33
L23:
    CPy_Reraise()
    if not 0 goto L25 else goto L33 :: bool
L24:
    unreachable
L25:
    CPy_RestoreExcInfo(r28)
    dec_ref r28
    r34 = CPy_KeepPropagating()
    if not r34 goto L27 else goto L26 :: bool
L26:
    unreachable
L27:
    r35 = <error> :: object
    return r35
L28:
    dec_ref r1
    goto L20
L29:
    dec_ref r7
    goto L5
L30:
    dec_ref r7
    goto L20
L31:
    dec_ref r7
    dec_ref r12
    goto L9
L32:
    dec_ref r7
    dec_ref r12
    goto L20
L33:
    dec_ref r28
    goto L24

def __validate_output(abi, hexstr):
    abi :: dict
    hexstr, r0 :: object
    r1 :: bool
    r2 :: object[1]
    r3 :: object_ptr
    r4, r5, r6, r7, r8, r9 :: object
    r10 :: str
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: str
    r15 :: object
    r16 :: i32
    r17 :: bit
    r18 :: bool
    r19 :: dict
    r20 :: str
    r21 :: object
    r22 :: str
    r23 :: list
    r24, r25 :: ptr
    r26 :: object
    r27 :: bool
    r28 :: object[1]
    r29 :: object_ptr
    r30, r31, r32, r33, r34, r35 :: object
    r36 :: str
    r37 :: object[3]
    r38 :: object_ptr
    r39, r40, r41, revert_str :: object
    r42, r43, r44 :: str
    r45 :: object
    r46 :: bool
    r47 :: object[1]
    r48 :: object_ptr
    r49 :: object
    r50 :: str
    r51 :: object
    r52 :: i32
    r53 :: bit
    r54 :: bool
    r55 :: object
    r56 :: bool
    r57 :: object[1]
    r58 :: object_ptr
    r59, r60, r61, r62, r63, r64 :: object
    r65 :: str
    r66 :: object[1]
    r67 :: object_ptr
    r68, r69, r70 :: object
    r71 :: object[2]
    r72 :: object_ptr
    r73 :: object
    r74 :: int
    r75 :: dict
    r76 :: str
    r77, r78 :: object
    r79 :: i32
    r80 :: bit
    r81 :: bool
    r82 :: dict
    r83 :: str
    r84, r85, r86 :: object
    r87, r88, r89, r90, r91, r92, r93 :: str
    r94 :: object
    r95 :: bool
    r96 :: object[1]
    r97 :: object_ptr
    r98 :: object
    r99 :: str
    r100 :: object
    r101 :: i32
    r102 :: bit
    r103 :: bool
    r104 :: str
    r105 :: object
    r106 :: bool
    r107 :: object[1]
    r108 :: object_ptr
    r109 :: object
    r110 :: str
    r111 :: object
    r112 :: i32
    r113 :: bit
    r114 :: bool
    r115 :: i32
    r116 :: bit
    r117 :: bool
    r118 :: str
    r119 :: object
    r120 :: bool
    r121 :: object[1]
    r122 :: object_ptr
    r123 :: object
    r124 :: tuple[object, object, object]
    r125 :: object
    r126 :: str
    r127 :: object
    r128 :: bit
    r129 :: object
    r130 :: dict
    r131 :: str
    r132 :: object
    r133 :: object[1]
    r134 :: object_ptr
    r135 :: object
    r136 :: tuple[object, object, object]
    r137, r138 :: bit
    r139 :: None
L0:
L1:
    r0 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r0) goto L2 else goto L4
L2:
    r1 = raise NameError('value for final name "HexBytes" was not set')
    if not r1 goto L78 (error at __validate_output:286) else goto L3 :: bool
L3:
    unreachable
L4:
    r2 = [hexstr]
    r3 = load_address r2
    r4 = _PyObject_Vectorcall(r0, r3, 1, 0)
    if is_error(r4) goto L78 (error at __validate_output:286) else goto L5
L5:
    r5 = load_address _Py_NoneStruct
    r6 = load_address _Py_NoneStruct
    r7 = object 4
    r8 = PySlice_New(r5, r7, r6)
    if is_error(r8) goto L95 (error at __validate_output:286) else goto L6
L6:
    r9 = PyObject_GetItem(r4, r8)
    dec_ref r4
    dec_ref r8
    if is_error(r9) goto L78 (error at __validate_output:286) else goto L7
L7:
    r10 = 'hex'
    r11 = [r9]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775809, 0)
    if is_error(r13) goto L96 (error at __validate_output:286) else goto L8
L8:
    dec_ref r9
    r14 = '0x08c379a0'
    r15 = PyObject_RichCompare(r13, r14, 2)
    if is_error(r15) goto L97 (error at __validate_output:287) else goto L9
L9:
    r16 = PyObject_IsTrue(r15)
    dec_ref r15
    r17 = r16 >= 0 :: signed
    if not r17 goto L97 (error at __validate_output:287) else goto L10 :: bool
L10:
    r18 = truncate r16: i32 to builtins.bool
    if r18 goto L98 else goto L29 :: bool
L11:
    r19 = dank_mids.brownie_patch.call.globals :: static
    r20 = 'eth_abi'
    r21 = CPyDict_GetItem(r19, r20)
    if is_error(r21) goto L78 (error at __validate_output:288) else goto L12
L12:
    r22 = 'string'
    r23 = PyList_New(1)
    if is_error(r23) goto L99 (error at __validate_output:288) else goto L13
L13:
    r24 = get_element_ptr r23 ob_item :: PyListObject
    r25 = load_mem r24 :: ptr*
    inc_ref r22
    set_mem r25, r22 :: builtins.object*
    r26 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r26) goto L100 else goto L16
L14:
    r27 = raise NameError('value for final name "HexBytes" was not set')
    if not r27 goto L78 (error at __validate_output:288) else goto L15 :: bool
L15:
    unreachable
L16:
    r28 = [hexstr]
    r29 = load_address r28
    r30 = _PyObject_Vectorcall(r26, r29, 1, 0)
    if is_error(r30) goto L101 (error at __validate_output:288) else goto L17
L17:
    r31 = load_address _Py_NoneStruct
    r32 = load_address _Py_NoneStruct
    r33 = object 4
    r34 = PySlice_New(r33, r31, r32)
    if is_error(r34) goto L102 (error at __validate_output:288) else goto L18
L18:
    r35 = PyObject_GetItem(r30, r34)
    dec_ref r30
    dec_ref r34
    if is_error(r35) goto L101 (error at __validate_output:288) else goto L19
L19:
    r36 = 'decode_abi'
    r37 = [r21, r23, r35]
    r38 = load_address r37
    r39 = PyObject_VectorcallMethod(r36, r38, 9223372036854775811, 0)
    if is_error(r39) goto L103 (error at __validate_output:288) else goto L20
L20:
    dec_ref r21
    dec_ref r23
    dec_ref r35
    r40 = object 0
    r41 = PyObject_GetItem(r39, r40)
    dec_ref r39
    if is_error(r41) goto L78 (error at __validate_output:288) else goto L21
L21:
    revert_str = r41
    r42 = 'Call reverted: '
    r43 = PyObject_Str(revert_str)
    dec_ref revert_str
    if is_error(r43) goto L78 (error at __validate_output:289) else goto L22
L22:
    r44 = CPyStr_Build(2, r42, r43)
    dec_ref r43
    if is_error(r44) goto L78 (error at __validate_output:289) else goto L23
L23:
    r45 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r45) goto L104 else goto L26
L24:
    r46 = raise NameError('value for final name "Revert" was not set')
    if not r46 goto L78 (error at __validate_output:289) else goto L25 :: bool
L25:
    unreachable
L26:
    r47 = [r44]
    r48 = load_address r47
    r49 = _PyObject_Vectorcall(r45, r48, 1, 0)
    if is_error(r49) goto L105 (error at __validate_output:289) else goto L27
L27:
    dec_ref r44
    CPy_Raise(r49)
    dec_ref r49
    if not 0 goto L78 (error at __validate_output:289) else goto L28 :: bool
L28:
    unreachable
L29:
    r50 = '0x4e487b71'
    r51 = PyObject_RichCompare(r13, r50, 2)
    if is_error(r51) goto L97 (error at __validate_output:290) else goto L30
L30:
    r52 = PyObject_IsTrue(r51)
    dec_ref r51
    r53 = r52 >= 0 :: signed
    if not r53 goto L97 (error at __validate_output:290) else goto L31 :: bool
L31:
    r54 = truncate r52: i32 to builtins.bool
    if r54 goto L106 else goto L58 :: bool
L32:
    r55 = dank_mids.brownie_patch.call.HexBytes :: static
    if is_error(r55) goto L33 else goto L35
L33:
    r56 = raise NameError('value for final name "HexBytes" was not set')
    if not r56 goto L78 (error at __validate_output:291) else goto L34 :: bool
L34:
    unreachable
L35:
    r57 = [hexstr]
    r58 = load_address r57
    r59 = _PyObject_Vectorcall(r55, r58, 1, 0)
    if is_error(r59) goto L78 (error at __validate_output:291) else goto L36
L36:
    r60 = load_address _Py_NoneStruct
    r61 = load_address _Py_NoneStruct
    r62 = object 4
    r63 = PySlice_New(r62, r60, r61)
    if is_error(r63) goto L107 (error at __validate_output:291) else goto L37
L37:
    r64 = PyObject_GetItem(r59, r63)
    dec_ref r59
    dec_ref r63
    if is_error(r64) goto L78 (error at __validate_output:291) else goto L38
L38:
    r65 = 'hex'
    r66 = [r64]
    r67 = load_address r66
    r68 = PyObject_VectorcallMethod(r65, r67, 9223372036854775809, 0)
    if is_error(r68) goto L108 (error at __validate_output:291) else goto L39
L39:
    dec_ref r64
    r69 = load_address PyLong_Type
    r70 = object 16
    r71 = [r68, r70]
    r72 = load_address r71
    r73 = _PyObject_Vectorcall(r69, r72, 2, 0)
    if is_error(r73) goto L109 (error at __validate_output:291) else goto L40
L40:
    dec_ref r68
    r74 = unbox(int, r73)
    dec_ref r73
    if is_error(r74) goto L78 (error at __validate_output:291) else goto L41
L41:
    r75 = dank_mids.brownie_patch.call.globals :: static
    r76 = 'SOLIDITY_ERROR_CODES'
    r77 = CPyDict_GetItem(r75, r76)
    if is_error(r77) goto L110 (error at __validate_output:292) else goto L42
L42:
    inc_ref r74 :: int
    r78 = box(int, r74)
    r79 = PySequence_Contains(r77, r78)
    dec_ref r77
    dec_ref r78
    r80 = r79 >= 0 :: signed
    if not r80 goto L110 (error at __validate_output:292) else goto L43 :: bool
L43:
    r81 = truncate r79: i32 to builtins.bool
    if r81 goto L44 else goto L47 :: bool
L44:
    r82 = dank_mids.brownie_patch.call.globals :: static
    r83 = 'SOLIDITY_ERROR_CODES'
    r84 = CPyDict_GetItem(r82, r83)
    if is_error(r84) goto L110 (error at __validate_output:293) else goto L45
L45:
    r85 = box(int, r74)
    r86 = PyObject_GetItem(r84, r85)
    dec_ref r84
    dec_ref r85
    if is_error(r86) goto L78 (error at __validate_output:293) else goto L46
L46:
    revert_str = r86
    goto L50
L47:
    r87 = 'Panic (error code: '
    r88 = CPyTagged_Str(r74)
    dec_ref r74 :: int
    if is_error(r88) goto L78 (error at __validate_output:295) else goto L48
L48:
    r89 = ')'
    r90 = CPyStr_Build(3, r87, r88, r89)
    dec_ref r88
    if is_error(r90) goto L78 (error at __validate_output:295) else goto L49
L49:
    revert_str = r90
L50:
    r91 = 'Call reverted: '
    r92 = PyObject_Str(revert_str)
    dec_ref revert_str
    if is_error(r92) goto L78 (error at __validate_output:296) else goto L51
L51:
    r93 = CPyStr_Build(2, r91, r92)
    dec_ref r92
    if is_error(r93) goto L78 (error at __validate_output:296) else goto L52
L52:
    r94 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r94) goto L111 else goto L55
L53:
    r95 = raise NameError('value for final name "Revert" was not set')
    if not r95 goto L78 (error at __validate_output:296) else goto L54 :: bool
L54:
    unreachable
L55:
    r96 = [r93]
    r97 = load_address r96
    r98 = _PyObject_Vectorcall(r94, r97, 1, 0)
    if is_error(r98) goto L112 (error at __validate_output:296) else goto L56
L56:
    dec_ref r93
    CPy_Raise(r98)
    dec_ref r98
    if not 0 goto L78 (error at __validate_output:296) else goto L57 :: bool
L57:
    unreachable
L58:
    r99 = '0xc1b84b2f'
    r100 = PyObject_RichCompare(r13, r99, 2)
    dec_ref r13
    if is_error(r100) goto L78 (error at __validate_output:297) else goto L59
L59:
    r101 = PyObject_IsTrue(r100)
    dec_ref r100
    r102 = r101 >= 0 :: signed
    if not r102 goto L78 (error at __validate_output:297) else goto L60 :: bool
L60:
    r103 = truncate r101: i32 to builtins.bool
    if r103 goto L61 else goto L67 :: bool
L61:
    r104 = 'Call reverted: execution reverted'
    r105 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r105) goto L62 else goto L64
L62:
    r106 = raise NameError('value for final name "Revert" was not set')
    if not r106 goto L78 (error at __validate_output:298) else goto L63 :: bool
L63:
    unreachable
L64:
    r107 = [r104]
    r108 = load_address r107
    r109 = _PyObject_Vectorcall(r105, r108, 1, 0)
    if is_error(r109) goto L78 (error at __validate_output:298) else goto L65
L65:
    CPy_Raise(r109)
    dec_ref r109
    if not 0 goto L78 (error at __validate_output:298) else goto L66 :: bool
L66:
    unreachable
L67:
    r110 = 'outputs'
    r111 = CPyDict_GetItem(abi, r110)
    if is_error(r111) goto L78 (error at __validate_output:299) else goto L68
L68:
    r112 = PyObject_IsTrue(r111)
    dec_ref r111
    r113 = r112 >= 0 :: signed
    if not r113 goto L78 (error at __validate_output:299) else goto L69 :: bool
L69:
    r114 = truncate r112: i32 to builtins.bool
    if r114 goto L70 else goto L93 :: bool
L70:
    r115 = PyObject_IsTrue(hexstr)
    r116 = r115 >= 0 :: signed
    if not r116 goto L78 (error at __validate_output:284) else goto L71 :: bool
L71:
    r117 = truncate r115: i32 to builtins.bool
    if r117 goto L93 else goto L72 :: bool
L72:
    r118 = 'No data was returned - the call likely reverted'
    r119 = dank_mids.brownie_patch.call.Revert :: static
    if is_error(r119) goto L73 else goto L75
L73:
    r120 = raise NameError('value for final name "Revert" was not set')
    if not r120 goto L78 (error at __validate_output:300) else goto L74 :: bool
L74:
    unreachable
L75:
    r121 = [r118]
    r122 = load_address r121
    r123 = _PyObject_Vectorcall(r119, r122, 1, 0)
    if is_error(r123) goto L78 (error at __validate_output:300) else goto L76
L76:
    CPy_Raise(r123)
    dec_ref r123
    if not 0 goto L78 (error at __validate_output:300) else goto L77 :: bool
L77:
    unreachable
L78:
    r124 = CPy_CatchError()
    r125 = builtins :: module
    r126 = 'ValueError'
    r127 = CPyObject_GetAttr(r125, r126)
    if is_error(r127) goto L91 (error at __validate_output:301) else goto L79
L79:
    r128 = CPy_ExceptionMatches(r127)
    dec_ref r127
    if r128 goto L80 else goto L89 :: bool
L80:
    r129 = CPy_GetExcValue()
L81:
    r130 = dank_mids.brownie_patch.call.globals :: static
    r131 = 'VirtualMachineError'
    r132 = CPyDict_GetItem(r130, r131)
    if is_error(r132) goto L85 (error at __validate_output:303) else goto L82
L82:
    r133 = [r129]
    r134 = load_address r133
    r135 = _PyObject_Vectorcall(r132, r134, 1, 0)
    dec_ref r132
    if is_error(r135) goto L85 (error at __validate_output:303) else goto L83
L83:
    CPy_Raise(r135)
    dec_ref r135
    if not 0 goto L85 (error at __validate_output:303) else goto L113 :: bool
L84:
    unreachable
L85:
    r136 = CPy_CatchError()
    CPy_Raise(r129)
    dec_ref r129
    if not 0 goto L87 (error at __validate_output:305) else goto L114 :: bool
L86:
    unreachable
L87:
    CPy_RestoreExcInfo(r136)
    dec_ref r136
    r137 = CPy_KeepPropagating()
    if not r137 goto L91 else goto L115 :: bool
L88:
    unreachable
L89:
    CPy_Reraise()
    if not 0 goto L91 else goto L116 :: bool
L90:
    unreachable
L91:
    CPy_RestoreExcInfo(r124)
    dec_ref r124
    r138 = CPy_KeepPropagating()
    if not r138 goto L94 else goto L92 :: bool
L92:
    unreachable
L93:
    return 1
L94:
    r139 = <error> :: None
    return r139
L95:
    dec_ref r4
    goto L78
L96:
    dec_ref r9
    goto L78
L97:
    dec_ref r13
    goto L78
L98:
    dec_ref r13
    goto L11
L99:
    dec_ref r21
    goto L78
L100:
    dec_ref r21
    dec_ref r23
    goto L14
L101:
    dec_ref r21
    dec_ref r23
    goto L78
L102:
    dec_ref r21
    dec_ref r23
    dec_ref r30
    goto L78
L103:
    dec_ref r21
    dec_ref r23
    dec_ref r35
    goto L78
L104:
    dec_ref r44
    goto L24
L105:
    dec_ref r44
    goto L78
L106:
    dec_ref r13
    goto L32
L107:
    dec_ref r59
    goto L78
L108:
    dec_ref r64
    goto L78
L109:
    dec_ref r68
    goto L78
L110:
    dec_ref r74 :: int
    goto L78
L111:
    dec_ref r93
    goto L53
L112:
    dec_ref r93
    goto L78
L113:
    dec_ref r124
    dec_ref r129
    goto L84
L114:
    dec_ref r124
    dec_ref r136
    goto L86
L115:
    dec_ref r124
    goto L88
L116:
    dec_ref r124
    goto L90

def format_input_but_cache_checksums(abi, inputs):
    abi :: dict
    inputs :: union[list, tuple]
    r0 :: int
    r1 :: bit
    r2 :: str
    r3 :: object
    r4 :: int
    r5 :: bit
    r6 :: str
    r7 :: object
    r8, r9, r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: object[1]
    r15 :: object_ptr
    r16 :: object
    r17 :: str
    r18, r19 :: object
    r20 :: bool
    r21 :: object[1]
    r22 :: object_ptr
    r23 :: object
    r24 :: list
    r25 :: tuple[object, object, object]
    r26 :: object
    r27 :: str
    r28 :: object
    r29 :: bit
    r30, r31 :: object
    r32 :: str
    r33 :: object
    r34, r35, r36, r37 :: str
    r38 :: object[1]
    r39 :: object_ptr
    r40 :: object
    r41 :: bit
    r42 :: list
L0:
    r0 = CPyObject_Size(inputs)
    if is_error(r0) goto L33 (error at format_input_but_cache_checksums:313) else goto L1
L1:
    r1 = r0 != 0
    dec_ref r0 :: int
    if r1 goto L2 else goto L12 :: bool
L2:
    r2 = 'inputs'
    r3 = CPyDict_GetItem(abi, r2)
    if is_error(r3) goto L33 (error at format_input_but_cache_checksums:313) else goto L3
L3:
    r4 = CPyObject_Size(r3)
    dec_ref r3
    if is_error(r4) goto L33 (error at format_input_but_cache_checksums:313) else goto L4
L4:
    r5 = r4 != 0
    dec_ref r4 :: int
    if r5 goto L12 else goto L5 :: bool
L5:
    r6 = 'name'
    r7 = CPyDict_GetItem(abi, r6)
    if is_error(r7) goto L33 (error at format_input_but_cache_checksums:314) else goto L6
L6:
    r8 = PyObject_Str(r7)
    dec_ref r7
    if is_error(r8) goto L33 (error at format_input_but_cache_checksums:314) else goto L7
L7:
    r9 = ' requires no arguments'
    r10 = CPyStr_Build(2, r8, r9)
    dec_ref r8
    if is_error(r10) goto L33 (error at format_input_but_cache_checksums:314) else goto L8
L8:
    r11 = builtins :: module
    r12 = 'TypeError'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L34 (error at format_input_but_cache_checksums:314) else goto L9
L9:
    r14 = [r10]
    r15 = load_address r14
    r16 = _PyObject_Vectorcall(r13, r15, 1, 0)
    dec_ref r13
    if is_error(r16) goto L34 (error at format_input_but_cache_checksums:314) else goto L10
L10:
    dec_ref r10
    CPy_Raise(r16)
    dec_ref r16
    if not 0 goto L33 (error at format_input_but_cache_checksums:314) else goto L11 :: bool
L11:
    unreachable
L12:
    r17 = 'inputs'
    r18 = CPyDict_GetItem(abi, r17)
    if is_error(r18) goto L33 (error at format_input_but_cache_checksums:315) else goto L13
L13:
    r19 = dank_mids.brownie_patch.call._get_abi_types :: static
    if is_error(r19) goto L35 else goto L16
L14:
    r20 = raise NameError('value for final name "_get_abi_types" was not set')
    if not r20 goto L33 (error at format_input_but_cache_checksums:315) else goto L15 :: bool
L15:
    unreachable
L16:
    r21 = [r18]
    r22 = load_address r21
    r23 = _PyObject_Vectorcall(r19, r22, 1, 0)
    if is_error(r23) goto L36 (error at format_input_but_cache_checksums:315) else goto L17
L17:
    dec_ref r18
L18:
    r24 = _format_tuple_but_cache_checksums(r23, inputs)
    dec_ref r23
    if is_error(r24) goto L20 (error at format_input_but_cache_checksums:317) else goto L19
L19:
    return r24
L20:
    r25 = CPy_CatchError()
    r26 = builtins :: module
    r27 = 'Exception'
    r28 = CPyObject_GetAttr(r26, r27)
    if is_error(r28) goto L31 (error at format_input_but_cache_checksums:318) else goto L21
L21:
    r29 = CPy_ExceptionMatches(r28)
    dec_ref r28
    if r29 goto L22 else goto L29 :: bool
L22:
    r30 = CPy_GetExcValue()
    r31 = PyObject_Type(r30)
    r32 = 'name'
    r33 = CPyDict_GetItem(abi, r32)
    if is_error(r33) goto L37 (error at format_input_but_cache_checksums:319) else goto L23
L23:
    r34 = PyObject_Str(r33)
    dec_ref r33
    if is_error(r34) goto L37 (error at format_input_but_cache_checksums:319) else goto L24
L24:
    r35 = ' '
    r36 = PyObject_Str(r30)
    dec_ref r30
    if is_error(r36) goto L38 (error at format_input_but_cache_checksums:319) else goto L25
L25:
    r37 = CPyStr_Build(3, r34, r35, r36)
    dec_ref r34
    dec_ref r36
    if is_error(r37) goto L39 (error at format_input_but_cache_checksums:319) else goto L26
L26:
    r38 = [r37]
    r39 = load_address r38
    r40 = _PyObject_Vectorcall(r31, r39, 1, 0)
    dec_ref r31
    if is_error(r40) goto L40 (error at format_input_but_cache_checksums:319) else goto L27
L27:
    dec_ref r37
    CPy_Raise(r40)
    dec_ref r40
    if not 0 goto L31 (error at format_input_but_cache_checksums:319) else goto L41 :: bool
L28:
    unreachable
L29:
    CPy_Reraise()
    if not 0 goto L31 else goto L42 :: bool
L30:
    unreachable
L31:
    CPy_RestoreExcInfo(r25)
    dec_ref r25
    r41 = CPy_KeepPropagating()
    if not r41 goto L33 else goto L32 :: bool
L32:
    unreachable
L33:
    r42 = <error> :: list
    return r42
L34:
    dec_ref r10
    goto L33
L35:
    dec_ref r18
    goto L14
L36:
    dec_ref r18
    goto L33
L37:
    dec_ref r30
    dec_ref r31
    goto L31
L38:
    dec_ref r31
    dec_ref r34
    goto L31
L39:
    dec_ref r31
    goto L31
L40:
    dec_ref r37
    goto L31
L41:
    dec_ref r25
    goto L28
L42:
    dec_ref r25
    goto L30

def format_output_but_cache_checksums(abi, outputs):
    abi :: dict
    outputs :: union[list, tuple]
    r0 :: str
    r1, r2 :: object
    r3 :: bool
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7 :: list
    r8 :: str
    r9, r10 :: object
    r11 :: bool
    r12 :: object[2]
    r13 :: object_ptr
    r14, r15 :: object
L0:
    r0 = 'outputs'
    r1 = CPyDict_GetItem(abi, r0)
    if is_error(r1) goto L12 (error at format_output_but_cache_checksums:326) else goto L1
L1:
    r2 = dank_mids.brownie_patch.call._get_abi_types :: static
    if is_error(r2) goto L13 else goto L4
L2:
    r3 = raise NameError('value for final name "_get_abi_types" was not set')
    if not r3 goto L12 (error at format_output_but_cache_checksums:326) else goto L3 :: bool
L3:
    unreachable
L4:
    r4 = [r1]
    r5 = load_address r4
    r6 = _PyObject_Vectorcall(r2, r5, 1, 0)
    if is_error(r6) goto L14 (error at format_output_but_cache_checksums:326) else goto L5
L5:
    dec_ref r1
    r7 = _format_tuple_but_cache_checksums(r6, outputs)
    dec_ref r6
    if is_error(r7) goto L12 (error at format_output_but_cache_checksums:327) else goto L6
L6:
    r8 = 'outputs'
    r9 = CPyDict_GetItem(abi, r8)
    if is_error(r9) goto L15 (error at format_output_but_cache_checksums:328) else goto L7
L7:
    r10 = dank_mids.brownie_patch.call.ReturnValue :: static
    if is_error(r10) goto L16 else goto L10
L8:
    r11 = raise NameError('value for final name "ReturnValue" was not set')
    if not r11 goto L12 (error at format_output_but_cache_checksums:328) else goto L9 :: bool
L9:
    unreachable
L10:
    r12 = [r7, r9]
    r13 = load_address r12
    r14 = _PyObject_Vectorcall(r10, r13, 2, 0)
    if is_error(r14) goto L17 (error at format_output_but_cache_checksums:328) else goto L11
L11:
    dec_ref r7
    dec_ref r9
    return r14
L12:
    r15 = <error> :: object
    return r15
L13:
    dec_ref r1
    goto L2
L14:
    dec_ref r1
    goto L12
L15:
    dec_ref r7
    goto L12
L16:
    dec_ref r7
    dec_ref r9
    goto L8
L17:
    dec_ref r7
    dec_ref r9
    goto L12

def _format_tuple_but_cache_checksums(abi_types, values):
    abi_types :: object
    values :: union[list, tuple]
    r0 :: list
    r1 :: int
    r2 :: object
    r3 :: bool
    r4 :: object
    r5 :: object[2]
    r6 :: object_ptr
    r7, r8, r9, r10, r11 :: object
    r12 :: str
    r13 :: object
    r14 :: i32
    r15 :: bit
    r16 :: bool
    r17 :: union[list, tuple]
    r18 :: list
    r19 :: i32
    r20 :: bit
    r21 :: object
    r22 :: bool
    r23 :: i32
    r24 :: bit
    r25 :: bool
    r26 :: str
    r27 :: object
    r28 :: union[list, tuple]
    r29 :: list
    r30 :: i32
    r31 :: bit
    r32 :: str
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: i32
    r39 :: bit
    r40 :: tuple[object, object, object]
    r41 :: object
    r42 :: str
    r43 :: object
    r44 :: bit
    r45, r46 :: object
    r47, r48, r49, r50, r51 :: str
    r52 :: object[1]
    r53 :: object_ptr
    r54 :: object
    r55, r56, r57 :: bit
    r58 :: list
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L45 (error at _format_tuple_but_cache_checksums:338) else goto L1
L1:
    r1 = CPyObject_Size(abi_types)
    if is_error(r1) goto L46 (error at _format_tuple_but_cache_checksums:339) else goto L2
L2:
    r2 = dank_mids.brownie_patch.call._check_array :: static
    if is_error(r2) goto L47 else goto L5
L3:
    r3 = raise NameError('value for final name "_check_array" was not set')
    if not r3 goto L45 (error at _format_tuple_but_cache_checksums:339) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = box(int, r1)
    r5 = [values, r4]
    r6 = load_address r5
    r7 = _PyObject_Vectorcall(r2, r6, 2, 0)
    if is_error(r7) goto L48 (error at _format_tuple_but_cache_checksums:339) else goto L49
L6:
    dec_ref r4
    r8 = PyObject_GetIter(abi_types)
    if is_error(r8) goto L46 (error at _format_tuple_but_cache_checksums:340) else goto L7
L7:
    r9 = PyObject_GetIter(values)
    if is_error(r9) goto L50 (error at _format_tuple_but_cache_checksums:340) else goto L8
L8:
    r10 = PyIter_Next(r8)
    if is_error(r10) goto L51 else goto L9
L9:
    r11 = PyIter_Next(r9)
    if is_error(r11) goto L52 else goto L10
L10:
L11:
    r12 = 'is_array'
    r13 = CPyObject_GetAttr(r10, r12)
    if is_error(r13) goto L53 (error at _format_tuple_but_cache_checksums:342) else goto L12
L12:
    r14 = PyObject_IsTrue(r13)
    dec_ref r13
    r15 = r14 >= 0 :: signed
    if not r15 goto L53 (error at _format_tuple_but_cache_checksums:342) else goto L13 :: bool
L13:
    r16 = truncate r14: i32 to builtins.bool
    if r16 goto L14 else goto L17 :: bool
L14:
    inc_ref r11
    r17 = cast(union[list, tuple], r11)
    if is_error(r17) goto L53 (error at _format_tuple_but_cache_checksums:343) else goto L15
L15:
    r18 = _format_array_but_cache_checksums(r10, r17)
    dec_ref r10
    dec_ref r17
    if is_error(r18) goto L54 (error at _format_tuple_but_cache_checksums:343) else goto L16
L16:
    r19 = PyList_Append(r0, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L54 (error at _format_tuple_but_cache_checksums:343) else goto L55 :: bool
L17:
    r21 = dank_mids.brownie_patch.call.TupleType :: static
    if is_error(r21) goto L56 else goto L20
L18:
    r22 = raise NameError('value for final name "TupleType" was not set')
    if not r22 goto L30 (error at _format_tuple_but_cache_checksums:344) else goto L57 :: bool
L19:
    unreachable
L20:
    r23 = PyObject_IsInstance(r10, r21)
    r24 = r23 >= 0 :: signed
    if not r24 goto L53 (error at _format_tuple_but_cache_checksums:344) else goto L21 :: bool
L21:
    r25 = truncate r23: i32 to builtins.bool
    if r25 goto L22 else goto L26 :: bool
L22:
    r26 = 'components'
    r27 = CPyObject_GetAttr(r10, r26)
    dec_ref r10
    if is_error(r27) goto L54 (error at _format_tuple_but_cache_checksums:345) else goto L23
L23:
    inc_ref r11
    r28 = cast(union[list, tuple], r11)
    if is_error(r28) goto L58 (error at _format_tuple_but_cache_checksums:345) else goto L24
L24:
    r29 = _format_tuple_but_cache_checksums(r27, r28)
    dec_ref r27
    dec_ref r28
    if is_error(r29) goto L54 (error at _format_tuple_but_cache_checksums:345) else goto L25
L25:
    r30 = PyList_Append(r0, r29)
    dec_ref r29
    r31 = r30 >= 0 :: signed
    if not r31 goto L54 (error at _format_tuple_but_cache_checksums:345) else goto L59 :: bool
L26:
    r32 = 'to_type_str'
    r33 = [r10]
    r34 = load_address r33
    r35 = PyObject_VectorcallMethod(r32, r34, 9223372036854775809, 0)
    if is_error(r35) goto L53 (error at _format_tuple_but_cache_checksums:347) else goto L27
L27:
    dec_ref r10
    r36 = cast(str, r35)
    if is_error(r36) goto L54 (error at _format_tuple_but_cache_checksums:347) else goto L28
L28:
    r37 = _format_single_but_cache_checksums(r36, r11)
    dec_ref r36
    if is_error(r37) goto L54 (error at _format_tuple_but_cache_checksums:347) else goto L29
L29:
    r38 = PyList_Append(r0, r37)
    dec_ref r37
    r39 = r38 >= 0 :: signed
    if not r39 goto L54 (error at _format_tuple_but_cache_checksums:347) else goto L60 :: bool
L30:
    r40 = CPy_CatchError()
    r41 = builtins :: module
    r42 = 'Exception'
    r43 = CPyObject_GetAttr(r41, r42)
    if is_error(r43) goto L61 (error at _format_tuple_but_cache_checksums:348) else goto L31
L31:
    r44 = CPy_ExceptionMatches(r43)
    dec_ref r43
    if r44 goto L32 else goto L62 :: bool
L32:
    r45 = CPy_GetExcValue()
    r46 = PyObject_Type(r45)
    r47 = "'"
    r48 = PyObject_Str(r11)
    dec_ref r11
    if is_error(r48) goto L63 (error at _format_tuple_but_cache_checksums:349) else goto L33
L33:
    r49 = "' - "
    r50 = PyObject_Str(r45)
    dec_ref r45
    if is_error(r50) goto L64 (error at _format_tuple_but_cache_checksums:349) else goto L34
L34:
    r51 = CPyStr_Build(4, r47, r48, r49, r50)
    dec_ref r48
    dec_ref r50
    if is_error(r51) goto L65 (error at _format_tuple_but_cache_checksums:349) else goto L35
L35:
    r52 = [r51]
    r53 = load_address r52
    r54 = _PyObject_Vectorcall(r46, r53, 1, 0)
    dec_ref r46
    if is_error(r54) goto L66 (error at _format_tuple_but_cache_checksums:349) else goto L36
L36:
    dec_ref r51
    CPy_Raise(r54)
    dec_ref r54
    if not 0 goto L40 (error at _format_tuple_but_cache_checksums:349) else goto L67 :: bool
L37:
    unreachable
L38:
    CPy_Reraise()
    if not 0 goto L40 else goto L68 :: bool
L39:
    unreachable
L40:
    CPy_RestoreExcInfo(r40)
    dec_ref r40
    r55 = CPy_KeepPropagating()
    if not r55 goto L45 else goto L41 :: bool
L41:
    unreachable
L42:
    r56 = CPy_NoErrOccurred()
    if not r56 goto L46 (error at _format_tuple_but_cache_checksums:340) else goto L43 :: bool
L43:
    r57 = CPy_NoErrOccurred()
    if not r57 goto L46 (error at _format_tuple_but_cache_checksums:340) else goto L44 :: bool
L44:
    return r0
L45:
    r58 = <error> :: list
    return r58
L46:
    dec_ref r0
    goto L45
L47:
    dec_ref r0
    dec_ref r1 :: int
    goto L3
L48:
    dec_ref r0
    dec_ref r4
    goto L45
L49:
    dec_ref r7
    goto L6
L50:
    dec_ref r0
    dec_ref r8
    goto L45
L51:
    dec_ref r8
    dec_ref r9
    goto L42
L52:
    dec_ref r8
    dec_ref r9
    dec_ref r10
    goto L42
L53:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    dec_ref r10
    goto L30
L54:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    goto L30
L55:
    dec_ref r11
    goto L8
L56:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    dec_ref r10
    goto L18
L57:
    dec_ref r11
    goto L19
L58:
    dec_ref r0
    dec_ref r8
    dec_ref r9
    dec_ref r27
    goto L30
L59:
    dec_ref r11
    goto L8
L60:
    dec_ref r11
    goto L8
L61:
    dec_ref r11
    goto L40
L62:
    dec_ref r11
    goto L38
L63:
    dec_ref r45
    dec_ref r46
    goto L40
L64:
    dec_ref r46
    dec_ref r48
    goto L40
L65:
    dec_ref r46
    goto L40
L66:
    dec_ref r51
    goto L40
L67:
    dec_ref r40
    goto L37
L68:
    dec_ref r40
    goto L39

def _format_array_but_cache_checksums(abi_type, values):
    abi_type :: object
    values :: union[list, tuple]
    r0 :: str
    r1, r2, r3 :: object
    r4 :: int
    r5 :: bit
    r6 :: str
    r7, r8, r9, r10, r11 :: object
    r12 :: union[object, None]
    r13, r14 :: object
    r15 :: bool
    r16 :: object[2]
    r17 :: object_ptr
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: i32
    r24 :: bit
    r25 :: bool
    r26 :: list
    r27, r28 :: object
    r29 :: union[list, tuple]
    r30 :: list
    r31 :: i32
    r32, r33 :: bit
    r34 :: object
    r35 :: bool
    r36 :: i32
    r37 :: bit
    r38 :: bool
    r39 :: str
    r40 :: object
    r41 :: list
    r42, r43 :: object
    r44 :: union[list, tuple]
    r45 :: list
    r46 :: i32
    r47, r48 :: bit
    r49 :: str
    r50 :: object[1]
    r51 :: object_ptr
    r52 :: object
    r53 :: str
    r54 :: list
    r55, r56, r57 :: object
    r58 :: i32
    r59, r60 :: bit
    r61 :: list
L0:
    r0 = 'arrlist'
    r1 = CPyObject_GetAttr(abi_type, r0)
    if is_error(r1) goto L48 (error at _format_array_but_cache_checksums:354) else goto L1
L1:
    r2 = object -1
    r3 = PyObject_GetItem(r1, r2)
    dec_ref r1
    if is_error(r3) goto L48 (error at _format_array_but_cache_checksums:354) else goto L2
L2:
    r4 = CPyObject_Size(r3)
    dec_ref r3
    if is_error(r4) goto L48 (error at _format_array_but_cache_checksums:354) else goto L3
L3:
    r5 = r4 != 0
    dec_ref r4 :: int
    if r5 goto L4 else goto L8 :: bool
L4:
    r6 = 'arrlist'
    r7 = CPyObject_GetAttr(abi_type, r6)
    if is_error(r7) goto L48 (error at _format_array_but_cache_checksums:354) else goto L5
L5:
    r8 = object -1
    r9 = PyObject_GetItem(r7, r8)
    dec_ref r7
    if is_error(r9) goto L48 (error at _format_array_but_cache_checksums:354) else goto L6
L6:
    r10 = object 0
    r11 = PyObject_GetItem(r9, r10)
    dec_ref r9
    if is_error(r11) goto L48 (error at _format_array_but_cache_checksums:354) else goto L7
L7:
    r12 = r11
    goto L9
L8:
    r13 = box(None, 1)
    inc_ref r13
    r12 = r13
L9:
    r14 = dank_mids.brownie_patch.call._check_array :: static
    if is_error(r14) goto L49 else goto L12
L10:
    r15 = raise NameError('value for final name "_check_array" was not set')
    if not r15 goto L48 (error at _format_array_but_cache_checksums:354) else goto L11 :: bool
L11:
    unreachable
L12:
    r16 = [values, r12]
    r17 = load_address r16
    r18 = _PyObject_Vectorcall(r14, r17, 2, 0)
    if is_error(r18) goto L50 (error at _format_array_but_cache_checksums:354) else goto L51
L13:
    dec_ref r12
    r19 = 'item_type'
    r20 = CPyObject_GetAttr(abi_type, r19)
    if is_error(r20) goto L48 (error at _format_array_but_cache_checksums:355) else goto L14
L14:
    r21 = 'is_array'
    r22 = CPyObject_GetAttr(r20, r21)
    if is_error(r22) goto L52 (error at _format_array_but_cache_checksums:356) else goto L15
L15:
    r23 = PyObject_IsTrue(r22)
    dec_ref r22
    r24 = r23 >= 0 :: signed
    if not r24 goto L52 (error at _format_array_but_cache_checksums:356) else goto L16 :: bool
L16:
    r25 = truncate r23: i32 to builtins.bool
    if r25 goto L17 else goto L25 :: bool
L17:
    r26 = PyList_New(0)
    if is_error(r26) goto L52 (error at _format_array_but_cache_checksums:357) else goto L18
L18:
    r27 = PyObject_GetIter(values)
    if is_error(r27) goto L53 (error at _format_array_but_cache_checksums:357) else goto L19
L19:
    r28 = PyIter_Next(r27)
    if is_error(r28) goto L54 else goto L20
L20:
    r29 = cast(union[list, tuple], r28)
    if is_error(r29) goto L55 (error at _format_array_but_cache_checksums:357) else goto L21
L21:
    r30 = _format_array_but_cache_checksums(r20, r29)
    dec_ref r29
    if is_error(r30) goto L55 (error at _format_array_but_cache_checksums:357) else goto L22
L22:
    r31 = PyList_Append(r26, r30)
    dec_ref r30
    r32 = r31 >= 0 :: signed
    if not r32 goto L55 (error at _format_array_but_cache_checksums:357) else goto L19 :: bool
L23:
    r33 = CPy_NoErrOccurred()
    if not r33 goto L56 (error at _format_array_but_cache_checksums:357) else goto L24 :: bool
L24:
    return r26
L25:
    r34 = dank_mids.brownie_patch.call.TupleType :: static
    if is_error(r34) goto L57 else goto L28
L26:
    r35 = raise NameError('value for final name "TupleType" was not set')
    if not r35 goto L48 (error at _format_array_but_cache_checksums:358) else goto L27 :: bool
L27:
    unreachable
L28:
    r36 = PyObject_IsInstance(r20, r34)
    r37 = r36 >= 0 :: signed
    if not r37 goto L52 (error at _format_array_but_cache_checksums:358) else goto L29 :: bool
L29:
    r38 = truncate r36: i32 to builtins.bool
    if r38 goto L30 else goto L39 :: bool
L30:
    r39 = 'components'
    r40 = CPyObject_GetAttr(r20, r39)
    dec_ref r20
    if is_error(r40) goto L48 (error at _format_array_but_cache_checksums:359) else goto L31
L31:
    r41 = PyList_New(0)
    if is_error(r41) goto L58 (error at _format_array_but_cache_checksums:360) else goto L32
L32:
    r42 = PyObject_GetIter(values)
    if is_error(r42) goto L59 (error at _format_array_but_cache_checksums:360) else goto L33
L33:
    r43 = PyIter_Next(r42)
    if is_error(r43) goto L60 else goto L34
L34:
    r44 = cast(union[list, tuple], r43)
    if is_error(r44) goto L61 (error at _format_array_but_cache_checksums:360) else goto L35
L35:
    r45 = _format_tuple_but_cache_checksums(r40, r44)
    dec_ref r44
    if is_error(r45) goto L61 (error at _format_array_but_cache_checksums:360) else goto L36
L36:
    r46 = PyList_Append(r41, r45)
    dec_ref r45
    r47 = r46 >= 0 :: signed
    if not r47 goto L61 (error at _format_array_but_cache_checksums:360) else goto L33 :: bool
L37:
    r48 = CPy_NoErrOccurred()
    if not r48 goto L62 (error at _format_array_but_cache_checksums:360) else goto L38 :: bool
L38:
    return r41
L39:
    r49 = 'to_type_str'
    r50 = [r20]
    r51 = load_address r50
    r52 = PyObject_VectorcallMethod(r49, r51, 9223372036854775809, 0)
    if is_error(r52) goto L52 (error at _format_array_but_cache_checksums:362) else goto L40
L40:
    dec_ref r20
    r53 = cast(str, r52)
    if is_error(r53) goto L48 (error at _format_array_but_cache_checksums:362) else goto L41
L41:
    r54 = PyList_New(0)
    if is_error(r54) goto L63 (error at _format_array_but_cache_checksums:363) else goto L42
L42:
    r55 = PyObject_GetIter(values)
    if is_error(r55) goto L64 (error at _format_array_but_cache_checksums:363) else goto L43
L43:
    r56 = PyIter_Next(r55)
    if is_error(r56) goto L65 else goto L44
L44:
    r57 = _format_single_but_cache_checksums(r53, r56)
    dec_ref r56
    if is_error(r57) goto L66 (error at _format_array_but_cache_checksums:363) else goto L45
L45:
    r58 = PyList_Append(r54, r57)
    dec_ref r57
    r59 = r58 >= 0 :: signed
    if not r59 goto L66 (error at _format_array_but_cache_checksums:363) else goto L43 :: bool
L46:
    r60 = CPy_NoErrOccurred()
    if not r60 goto L67 (error at _format_array_but_cache_checksums:363) else goto L47 :: bool
L47:
    return r54
L48:
    r61 = <error> :: list
    return r61
L49:
    dec_ref r12
    goto L10
L50:
    dec_ref r12
    goto L48
L51:
    dec_ref r18
    goto L13
L52:
    dec_ref r20
    goto L48
L53:
    dec_ref r20
    dec_ref r26
    goto L48
L54:
    dec_ref r20
    dec_ref r27
    goto L23
L55:
    dec_ref r20
    dec_ref r26
    dec_ref r27
    goto L48
L56:
    dec_ref r26
    goto L48
L57:
    dec_ref r20
    goto L26
L58:
    dec_ref r40
    goto L48
L59:
    dec_ref r40
    dec_ref r41
    goto L48
L60:
    dec_ref r40
    dec_ref r42
    goto L37
L61:
    dec_ref r40
    dec_ref r41
    dec_ref r42
    goto L48
L62:
    dec_ref r41
    goto L48
L63:
    dec_ref r53
    goto L48
L64:
    dec_ref r53
    dec_ref r54
    goto L48
L65:
    dec_ref r53
    dec_ref r55
    goto L46
L66:
    dec_ref r53
    dec_ref r54
    dec_ref r55
    goto L48
L67:
    dec_ref r54
    goto L48

def _format_single_but_cache_checksums(type_str, value):
    type_str :: str
    value :: object
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4 :: object
    r5 :: bool
    r6 :: object[2]
    r7 :: object_ptr
    r8 :: object
    r9 :: str
    r10 :: i32
    r11 :: bit
    r12 :: bool
    r13 :: object
    r14 :: bool
    r15 :: object[2]
    r16 :: object_ptr
    r17 :: object
    r18 :: str
    r19 :: i32
    r20 :: bit
    r21 :: object
    r22, r23, r24 :: bit
    r25 :: object
    r26 :: bool
    r27 :: object[1]
    r28 :: object_ptr
    r29 :: object
    r30 :: str
    r31 :: i32
    r32 :: bit
    r33 :: object
    r34, r35, r36 :: bit
    r37 :: object
    r38 :: bool
    r39 :: object[1]
    r40 :: object_ptr
    r41 :: object
    r42 :: str
    r43 :: i32
    r44 :: bit
    r45 :: object
    r46, r47, r48 :: bit
    r49, r50, r51 :: object
    r52 :: str
    r53, r54, r55 :: object
    r56 :: tuple[object, object, object, object, object]
    r57 :: object
    r58 :: i32
    r59 :: bit
    r60 :: bool
    r61 :: union[str, bytes, object, int]
    r62 :: str
    r63 :: object
    r64 :: bool
    r65 :: object[1]
    r66 :: object_ptr
    r67 :: object
    r68 :: str
    r69 :: i32
    r70 :: bit
    r71 :: bool
    r72 :: object
    r73 :: bool
    r74 :: object[2]
    r75 :: object_ptr
    r76 :: object
    r77 :: str
    r78 :: i32
    r79 :: bit
    r80 :: bool
    r81 :: object
    r82 :: bool
    r83 :: object[1]
    r84 :: object_ptr
    r85 :: object
    r86, r87 :: str
    r88 :: object
    r89 :: str
    r90 :: object
    r91 :: object[1]
    r92 :: object_ptr
    r93, r94 :: object
L0:
    r0 = 'uint'
    r1 = PySequence_Contains(type_str, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L66 (error at _format_single_but_cache_checksums:368) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L2 else goto L7 :: bool
L2:
    r4 = dank_mids.brownie_patch.call.to_uint :: static
    if is_error(r4) goto L3 else goto L5
L3:
    r5 = raise NameError('value for final name "to_uint" was not set')
    if not r5 goto L66 (error at _format_single_but_cache_checksums:369) else goto L4 :: bool
L4:
    unreachable
L5:
    r6 = [value, type_str]
    r7 = load_address r6
    r8 = _PyObject_Vectorcall(r4, r7, 2, 0)
    if is_error(r8) goto L66 (error at _format_single_but_cache_checksums:369) else goto L6
L6:
    return r8
L7:
    r9 = 'int'
    r10 = PySequence_Contains(type_str, r9)
    r11 = r10 >= 0 :: signed
    if not r11 goto L66 (error at _format_single_but_cache_checksums:370) else goto L8 :: bool
L8:
    r12 = truncate r10: i32 to builtins.bool
    if r12 goto L9 else goto L14 :: bool
L9:
    r13 = dank_mids.brownie_patch.call.to_int :: static
    if is_error(r13) goto L10 else goto L12
L10:
    r14 = raise NameError('value for final name "to_int" was not set')
    if not r14 goto L66 (error at _format_single_but_cache_checksums:371) else goto L11 :: bool
L11:
    unreachable
L12:
    r15 = [value, type_str]
    r16 = load_address r15
    r17 = _PyObject_Vectorcall(r13, r16, 2, 0)
    if is_error(r17) goto L66 (error at _format_single_but_cache_checksums:371) else goto L13
L13:
    return r17
L14:
    r18 = 'fixed168x10'
    r19 = PyUnicode_Compare(type_str, r18)
    r20 = r19 == -1
    if r20 goto L15 else goto L17 :: bool
L15:
    r21 = PyErr_Occurred()
    r22 = r21 != 0
    if r22 goto L16 else goto L17 :: bool
L16:
    r23 = CPy_KeepPropagating()
    if not r23 goto L66 (error at _format_single_but_cache_checksums:372) else goto L17 :: bool
L17:
    r24 = r19 == 0
    if r24 goto L18 else goto L23 :: bool
L18:
    r25 = dank_mids.brownie_patch.call.to_decimal :: static
    if is_error(r25) goto L19 else goto L21
L19:
    r26 = raise NameError('value for final name "to_decimal" was not set')
    if not r26 goto L66 (error at _format_single_but_cache_checksums:373) else goto L20 :: bool
L20:
    unreachable
L21:
    r27 = [value]
    r28 = load_address r27
    r29 = _PyObject_Vectorcall(r25, r28, 1, 0)
    if is_error(r29) goto L66 (error at _format_single_but_cache_checksums:373) else goto L22
L22:
    return r29
L23:
    r30 = 'bool'
    r31 = PyUnicode_Compare(type_str, r30)
    r32 = r31 == -1
    if r32 goto L24 else goto L26 :: bool
L24:
    r33 = PyErr_Occurred()
    r34 = r33 != 0
    if r34 goto L25 else goto L26 :: bool
L25:
    r35 = CPy_KeepPropagating()
    if not r35 goto L66 (error at _format_single_but_cache_checksums:374) else goto L26 :: bool
L26:
    r36 = r31 == 0
    if r36 goto L27 else goto L32 :: bool
L27:
    r37 = dank_mids.brownie_patch.call.to_bool :: static
    if is_error(r37) goto L28 else goto L30
L28:
    r38 = raise NameError('value for final name "to_bool" was not set')
    if not r38 goto L66 (error at _format_single_but_cache_checksums:375) else goto L29 :: bool
L29:
    unreachable
L30:
    r39 = [value]
    r40 = load_address r39
    r41 = _PyObject_Vectorcall(r37, r40, 1, 0)
    if is_error(r41) goto L66 (error at _format_single_but_cache_checksums:375) else goto L31
L31:
    return r41
L32:
    r42 = 'address'
    r43 = PyUnicode_Compare(type_str, r42)
    r44 = r43 == -1
    if r44 goto L33 else goto L35 :: bool
L33:
    r45 = PyErr_Occurred()
    r46 = r45 != 0
    if r46 goto L34 else goto L35 :: bool
L34:
    r47 = CPy_KeepPropagating()
    if not r47 goto L66 (error at _format_single_but_cache_checksums:376) else goto L35 :: bool
L35:
    r48 = r43 == 0
    if r48 goto L36 else goto L47 :: bool
L36:
    r49 = load_address PyUnicode_Type
    r50 = load_address PyBytes_Type
    r51 = builtins :: module
    r52 = 'bytearray'
    r53 = CPyObject_GetAttr(r51, r52)
    if is_error(r53) goto L66 (error at _format_single_but_cache_checksums:379) else goto L37
L37:
    r54 = load_address PyLong_Type
    r55 = load_address PyBool_Type
    inc_ref r49
    inc_ref r50
    inc_ref r54
    inc_ref r55
    r56 = (r49, r50, r53, r54, r55)
    r57 = box(tuple[object, object, object, object, object], r56)
    r58 = PyObject_IsInstance(value, r57)
    dec_ref r57
    r59 = r58 >= 0 :: signed
    if not r59 goto L66 (error at _format_single_but_cache_checksums:379) else goto L38 :: bool
L38:
    r60 = truncate r58: i32 to builtins.bool
    if r60 goto L39 else goto L40 :: bool
L39:
    inc_ref value
    r61 = value
    goto L42
L40:
    r62 = PyObject_Str(value)
    if is_error(r62) goto L66 (error at _format_single_but_cache_checksums:379) else goto L41
L41:
    r61 = r62
L42:
    r63 = dank_mids.brownie_patch.call.to_checksum_address :: static
    if is_error(r63) goto L67 else goto L45
L43:
    r64 = raise NameError('value for final name "to_checksum_address" was not set')
    if not r64 goto L66 (error at _format_single_but_cache_checksums:378) else goto L44 :: bool
L44:
    unreachable
L45:
    r65 = [r61]
    r66 = load_address r65
    r67 = _PyObject_Vectorcall(r63, r66, 1, 0)
    if is_error(r67) goto L68 (error at _format_single_but_cache_checksums:378) else goto L46
L46:
    dec_ref r61
    return r67
L47:
    r68 = 'byte'
    r69 = PySequence_Contains(type_str, r68)
    r70 = r69 >= 0 :: signed
    if not r70 goto L66 (error at _format_single_but_cache_checksums:381) else goto L48 :: bool
L48:
    r71 = truncate r69: i32 to builtins.bool
    if r71 goto L49 else goto L54 :: bool
L49:
    r72 = dank_mids.brownie_patch.call.HexString :: static
    if is_error(r72) goto L50 else goto L52
L50:
    r73 = raise NameError('value for final name "HexString" was not set')
    if not r73 goto L66 (error at _format_single_but_cache_checksums:382) else goto L51 :: bool
L51:
    unreachable
L52:
    r74 = [value, type_str]
    r75 = load_address r74
    r76 = _PyObject_Vectorcall(r72, r75, 2, 0)
    if is_error(r76) goto L66 (error at _format_single_but_cache_checksums:382) else goto L53
L53:
    return r76
L54:
    r77 = 'string'
    r78 = PySequence_Contains(type_str, r77)
    r79 = r78 >= 0 :: signed
    if not r79 goto L66 (error at _format_single_but_cache_checksums:383) else goto L55 :: bool
L55:
    r80 = truncate r78: i32 to builtins.bool
    if r80 goto L56 else goto L61 :: bool
L56:
    r81 = dank_mids.brownie_patch.call.to_string :: static
    if is_error(r81) goto L57 else goto L59
L57:
    r82 = raise NameError('value for final name "to_string" was not set')
    if not r82 goto L66 (error at _format_single_but_cache_checksums:384) else goto L58 :: bool
L58:
    unreachable
L59:
    r83 = [value]
    r84 = load_address r83
    r85 = _PyObject_Vectorcall(r81, r84, 1, 0)
    if is_error(r85) goto L66 (error at _format_single_but_cache_checksums:384) else goto L60
L60:
    return r85
L61:
    r86 = 'Unknown type: '
    r87 = CPyStr_Build(2, r86, type_str)
    if is_error(r87) goto L66 (error at _format_single_but_cache_checksums:385) else goto L62
L62:
    r88 = builtins :: module
    r89 = 'TypeError'
    r90 = CPyObject_GetAttr(r88, r89)
    if is_error(r90) goto L69 (error at _format_single_but_cache_checksums:385) else goto L63
L63:
    r91 = [r87]
    r92 = load_address r91
    r93 = _PyObject_Vectorcall(r90, r92, 1, 0)
    dec_ref r90
    if is_error(r93) goto L69 (error at _format_single_but_cache_checksums:385) else goto L64
L64:
    dec_ref r87
    CPy_Raise(r93)
    dec_ref r93
    if not 0 goto L66 (error at _format_single_but_cache_checksums:385) else goto L65 :: bool
L65:
    unreachable
L66:
    r94 = <error> :: object
    return r94
L67:
    dec_ref r61
    goto L43
L68:
    dec_ref r61
    goto L66
L69:
    dec_ref r87
    goto L66

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: dict
    r30, r31 :: object
    r32 :: str
    r33 :: dict
    r34 :: object
    r35, r36, r37, r38, r39 :: object_ptr
    r40 :: object_ptr[5]
    r41 :: c_ptr
    r42 :: native_int[5]
    r43 :: c_ptr
    r44 :: object
    r45 :: dict
    r46, r47 :: str
    r48 :: bit
    r49 :: object
    r50 :: str
    r51 :: dict
    r52, r53 :: object
    r54 :: str
    r55 :: dict
    r56, r57 :: object
    r58 :: str
    r59 :: dict
    r60, r61 :: object
    r62 :: str
    r63 :: dict
    r64, r65 :: object
    r66 :: str
    r67 :: dict
    r68, r69 :: object
    r70 :: str
    r71 :: dict
    r72, r73 :: object
    r74 :: str
    r75 :: dict
    r76, r77 :: object
    r78 :: str
    r79 :: dict
    r80, r81 :: object
    r82 :: str
    r83 :: dict
    r84, r85 :: object
    r86 :: str
    r87 :: dict
    r88, r89 :: object
    r90 :: str
    r91 :: dict
    r92, r93 :: object
    r94 :: str
    r95 :: dict
    r96, r97 :: object
    r98 :: str
    r99 :: dict
    r100, r101, r102 :: object
    r103 :: str
    r104 :: dict
    r105, r106 :: object
    r107 :: str
    r108 :: dict
    r109, r110 :: object
    r111 :: str
    r112 :: dict
    r113, r114 :: object
    r115 :: str
    r116 :: dict
    r117, r118 :: object
    r119 :: str
    r120 :: dict
    r121, r122 :: object
    r123 :: bool
    r124 :: str
    r125 :: object
    r126 :: bool
    r127 :: dict
    r128 :: str
    r129 :: i32
    r130 :: bit
    r131 :: str
    r132 :: dict
    r133 :: str
    r134 :: object
    r135 :: object[1]
    r136 :: object_ptr
    r137 :: object
    r138 :: dict
    r139 :: str
    r140 :: i32
    r141 :: bit
    r142 :: str
    r143 :: object
    r144 :: dict
    r145 :: str
    r146 :: object
    r147 :: object[2]
    r148 :: object_ptr
    r149 :: object
    r150 :: dict
    r151 :: str
    r152 :: i32
    r153 :: bit
    r154 :: dict
    r155 :: str
    r156 :: object
    r157 :: dict
    r158 :: str
    r159, r160 :: object
    r161 :: dict
    r162 :: str
    r163 :: i32
    r164 :: bit
    r165 :: dict
    r166 :: str
    r167 :: object
    r168 :: dict
    r169 :: str
    r170 :: object
    r171 :: dict
    r172 :: str
    r173, r174 :: object
    r175 :: dict
    r176 :: str
    r177 :: object
    r178 :: dict
    r179 :: str
    r180, r181 :: object
    r182 :: tuple[object, object]
    r183, r184 :: object
    r185 :: tuple[object, object]
    r186, r187 :: object
    r188 :: dict
    r189 :: str
    r190 :: i32
    r191 :: bit
    r192 :: str
    r193 :: dict
    r194 :: str
    r195, r196 :: object
    r197 :: dict
    r198 :: str
    r199 :: object
    r200 :: tuple[object, object]
    r201, r202 :: object
    r203 :: dict
    r204 :: str
    r205 :: object
    r206 :: object[2]
    r207 :: object_ptr
    r208 :: object
    r209 :: dict
    r210 :: str
    r211 :: i32
    r212 :: bit
    r213 :: object
    r214 :: str
    r215 :: object
    r216 :: dict
    r217 :: str
    r218 :: i32
    r219 :: bit
    r220 :: dict
    r221 :: str
    r222 :: object
    r223 :: str
    r224 :: object
    r225 :: dict
    r226 :: str
    r227 :: i32
    r228 :: bit
    r229 :: dict
    r230 :: str
    r231 :: object
    r232 :: str
    r233 :: object
    r234 :: str
    r235 :: object
    r236 :: str
    r237 :: object
    r238 :: dict
    r239 :: str
    r240 :: i32
    r241 :: bit
    r242 :: dict
    r243 :: str
    r244 :: object
    r245 :: str
    r246 :: object
    r247 :: str
    r248 :: object
    r249 :: str
    r250 :: object
    r251 :: dict
    r252 :: str
    r253 :: i32
    r254 :: bit
    r255 :: dict
    r256 :: str
    r257 :: object
    r258 :: str
    r259 :: object
    r260 :: str
    r261 :: object
    r262 :: str
    r263 :: object
    r264 :: dict
    r265 :: str
    r266 :: i32
    r267 :: bit
    r268 :: dict
    r269 :: str
    r270 :: object
    r271 :: str
    r272 :: object
    r273 :: str
    r274 :: object
    r275 :: str
    r276 :: object
    r277 :: dict
    r278 :: str
    r279 :: i32
    r280 :: bit
    r281 :: dict
    r282 :: str
    r283 :: object
    r284 :: str
    r285 :: object
    r286 :: dict
    r287 :: str
    r288 :: i32
    r289 :: bit
    r290 :: dict
    r291 :: str
    r292 :: object
    r293 :: str
    r294 :: object
    r295 :: str
    r296 :: object
    r297 :: str
    r298 :: object
    r299 :: dict
    r300 :: str
    r301 :: i32
    r302 :: bit
    r303 :: dict
    r304 :: str
    r305 :: object
    r306 :: str
    r307 :: object
    r308 :: str
    r309 :: object
    r310 :: str
    r311 :: object
    r312 :: dict
    r313 :: str
    r314 :: i32
    r315 :: bit
    r316 :: dict
    r317 :: str
    r318 :: object
    r319 :: str
    r320 :: object
    r321 :: str
    r322 :: object
    r323 :: str
    r324 :: object
    r325 :: dict
    r326 :: str
    r327 :: i32
    r328 :: bit
    r329 :: dict
    r330 :: str
    r331 :: object
    r332 :: str
    r333 :: object
    r334 :: str
    r335 :: object
    r336 :: str
    r337 :: object
    r338 :: dict
    r339 :: str
    r340 :: i32
    r341 :: bit
    r342 :: dict
    r343 :: str
    r344 :: object
    r345 :: str
    r346 :: object
    r347 :: str
    r348 :: object
    r349 :: str
    r350 :: object
    r351 :: dict
    r352 :: str
    r353 :: i32
    r354 :: bit
    r355 :: dict
    r356 :: str
    r357 :: object
    r358 :: str
    r359 :: object
    r360 :: str
    r361 :: object
    r362 :: str
    r363 :: object
    r364 :: dict
    r365 :: str
    r366 :: i32
    r367 :: bit
    r368 :: dict
    r369 :: str
    r370 :: object
    r371 :: str
    r372 :: object
    r373 :: str
    r374 :: object
    r375 :: str
    r376 :: object
    r377 :: dict
    r378 :: str
    r379 :: i32
    r380 :: bit
    r381 :: dict
    r382 :: str
    r383 :: object
    r384 :: str
    r385 :: object
    r386 :: bool
    r387 :: object[1]
    r388 :: object_ptr
    r389 :: object
    r390 :: dict
    r391 :: str
    r392 :: i32
    r393 :: bit
    r394 :: dank_mids.brownie_patch.call.__mypyc_lambda__0_obj
    r395 :: dict
    r396 :: str
    r397 :: i32
    r398 :: bit
    r399 :: dank_mids.brownie_patch.call.__mypyc_lambda__1_obj
    r400 :: dict
    r401 :: str
    r402 :: i32
    r403 :: bit
    r404 :: dict
    r405 :: str
    r406 :: object
    r407 :: str
    r408 :: object
    r409 :: dict
    r410 :: str
    r411 :: i32
    r412 :: bit
    r413 :: dict
    r414 :: str
    r415 :: object
    r416 :: dict
    r417 :: str
    r418 :: object
    r419 :: object[1]
    r420 :: object_ptr
    r421 :: object
    r422 :: dict
    r423 :: str
    r424 :: i32
    r425 :: bit
    r426 :: dict
    r427 :: str
    r428 :: object
    r429 :: str
    r430 :: bool
    r431 :: dict
    r432 :: str
    r433 :: object
    r434 :: str
    r435, r436 :: object
    r437 :: dict
    r438 :: str
    r439 :: object
    r440 :: str
    r441 :: object
    r442 :: dict
    r443 :: str
    r444 :: i32
    r445 :: bit
    r446 :: dict
    r447 :: str
    r448 :: object
    r449 :: str
    r450 :: bool
    r451 :: dict
    r452 :: str
    r453 :: object
    r454 :: str
    r455, r456 :: object
    r457 :: dict
    r458 :: str
    r459 :: object
    r460 :: str
    r461 :: object
    r462 :: dict
    r463 :: str
    r464 :: i32
    r465 :: bit
    r466 :: str
    r467 :: set
    r468 :: i32
    r469 :: bit
    r470 :: dict
    r471 :: str
    r472 :: i32
    r473 :: bit
    r474 :: dict
    r475 :: str
    r476 :: object
    r477 :: str
    r478 :: object
    r479 :: dict
    r480 :: str
    r481 :: i32
    r482 :: bit
    r483 :: tuple[object, object, object]
    r484 :: object
    r485 :: str
    r486 :: object
    r487 :: bit
    r488 :: dict
    r489 :: str
    r490 :: object
    r491 :: i32
    r492 :: bit
    r493 :: str
    r494 :: dict
    r495 :: str
    r496 :: object
    r497 :: str
    r498 :: i32
    r499 :: bit
    r500, r501 :: bool
    r502 :: bit
    r503 :: dict
    r504 :: str
    r505 :: object
    r506 :: dict
    r507 :: str
    r508 :: object
    r509 :: str
    r510 :: object
    r511 :: object[3]
    r512 :: object_ptr
    r513 :: object
    r514 :: dict
    r515 :: str
    r516 :: i32
    r517 :: bit
    r518 :: i32
    r519 :: bit
    r520 :: bool
    r521 :: dict
    r522 :: str
    r523 :: object
    r524 :: set
    r525 :: dict
    r526 :: str
    r527, r528 :: object
    r529 :: bool
    r530 :: object[1]
    r531 :: object_ptr
    r532 :: object
    r533 :: i32
    r534 :: bit
    r535 :: dict
    r536 :: str
    r537 :: object
    r538 :: dict
    r539 :: str
    r540 :: object
    r541 :: str
    r542 :: object
    r543 :: str
    r544 :: object
    r545 :: str
    r546 :: i32
    r547 :: bit
    r548 :: dict
    r549 :: str
    r550 :: object
    r551 :: dict
    r552 :: str
    r553 :: object
    r554 :: str
    r555 :: object
    r556 :: str
    r557 :: object
    r558 :: str
    r559 :: i32
    r560 :: bit
    r561 :: dict
    r562 :: str
    r563 :: object
    r564 :: dict
    r565 :: str
    r566 :: object
    r567 :: str
    r568 :: object
    r569 :: str
    r570 :: object
    r571 :: str
    r572 :: i32
    r573 :: bit
    r574 :: dict
    r575 :: str
    r576 :: object
    r577 :: dict
    r578 :: str
    r579 :: object
    r580 :: str
    r581 :: object
    r582 :: str
    r583 :: object
    r584 :: str
    r585 :: i32
    r586 :: bit
    r587 :: dict
    r588 :: str
    r589 :: object
    r590 :: dict
    r591 :: str
    r592 :: object
    r593 :: str
    r594 :: object
    r595 :: str
    r596 :: object
    r597 :: str
    r598 :: i32
    r599 :: bit
    r600 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L220 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address decimal :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('decimal', 'decimal', 'decimal'),)
    r11 = dank_mids.brownie_patch.call.globals :: static
    r12 = 'dank_mids\\brownie_patch\\call.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L220 else goto L4 :: bool
L4:
    r15 = ('BrokenProcessPool',)
    r16 = 'concurrent.futures.process'
    r17 = dank_mids.brownie_patch.call.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L220 (error at <module>:2) else goto L5
L5:
    concurrent.futures.process = r18 :: module
    dec_ref r18
    r19 = ('Logger',)
    r20 = 'logging'
    r21 = dank_mids.brownie_patch.call.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L220 (error at <module>:3) else goto L6
L6:
    logging = r22 :: module
    dec_ref r22
    r23 = ('PicklingError',)
    r24 = 'pickle'
    r25 = dank_mids.brownie_patch.call.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L220 (error at <module>:4) else goto L7
L7:
    pickle = r26 :: module
    dec_ref r26
    r27 = ('MethodType',)
    r28 = 'types'
    r29 = dank_mids.brownie_patch.call.globals :: static
    r30 = CPyImport_ImportFromMany(r28, r27, r27, r29)
    if is_error(r30) goto L220 (error at <module>:5) else goto L8
L8:
    types = r30 :: module
    dec_ref r30
    r31 = ('TYPE_CHECKING', 'Any', 'Callable', 'Dict', 'Final', 'List', 'NewType', 'Optional', 'Sequence', 'Tuple', 'TypeVar', 'Union')
    r32 = 'typing'
    r33 = dank_mids.brownie_patch.call.globals :: static
    r34 = CPyImport_ImportFromMany(r32, r31, r31, r33)
    if is_error(r34) goto L220 (error at <module>:6) else goto L9
L9:
    typing = r34 :: module
    dec_ref r34
    r35 = load_address brownie.convert.datatypes :: module
    r36 = load_address brownie.convert.normalize :: module
    r37 = load_address brownie.network.contract :: module
    r38 = load_address eth_abi :: module
    r39 = load_address hexbytes :: module
    r40 = [r35, r36, r37, r38, r39]
    r41 = load_address r40
    r42 = [21, 22, 23, 24, 25]
    r43 = load_address r42
    r44 = (('brownie.convert.datatypes', 'brownie', 'brownie'), ('brownie.convert.normalize', 'brownie', 'brownie'), ('brownie.network.contract', 'brownie', 'brownie'), ('eth_abi', 'eth_abi', 'eth_abi'), ('hexbytes', 'hexbytes', 'hexbytes'))
    r45 = dank_mids.brownie_patch.call.globals :: static
    r46 = 'dank_mids\\brownie_patch\\call.py'
    r47 = '<module>'
    r48 = CPyImport_ImportMany(r44, r41, r45, r46, r47, r43)
    if not r48 goto L220 else goto L10 :: bool
L10:
    r49 = ('AsyncProcessPoolExecutor',)
    r50 = 'a_sync'
    r51 = dank_mids.brownie_patch.call.globals :: static
    r52 = CPyImport_ImportFromMany(r50, r49, r49, r51)
    if is_error(r52) goto L220 (error at <module>:26) else goto L11
L11:
    a_sync = r52 :: module
    dec_ref r52
    r53 = ('chain',)
    r54 = 'brownie'
    r55 = dank_mids.brownie_patch.call.globals :: static
    r56 = CPyImport_ImportFromMany(r54, r53, r53, r55)
    if is_error(r56) goto L220 (error at <module>:27) else goto L12
L12:
    brownie = r56 :: module
    dec_ref r56
    r57 = ('ABIType',)
    r58 = 'brownie.convert.normalize'
    r59 = dank_mids.brownie_patch.call.globals :: static
    r60 = CPyImport_ImportFromMany(r58, r57, r57, r59)
    if is_error(r60) goto L220 (error at <module>:28) else goto L13
L13:
    brownie.convert.normalize = r60 :: module
    dec_ref r60
    r61 = ('get_type_strings',)
    r62 = 'brownie.convert.utils'
    r63 = dank_mids.brownie_patch.call.globals :: static
    r64 = CPyImport_ImportFromMany(r62, r61, r61, r63)
    if is_error(r64) goto L220 (error at <module>:29) else goto L14
L14:
    brownie.convert.utils = r64 :: module
    dec_ref r64
    r65 = ('VirtualMachineError',)
    r66 = 'brownie.exceptions'
    r67 = dank_mids.brownie_patch.call.globals :: static
    r68 = CPyImport_ImportFromMany(r66, r65, r65, r67)
    if is_error(r68) goto L220 (error at <module>:30) else goto L15
L15:
    brownie.exceptions = r68 :: module
    dec_ref r68
    r69 = ('ContractCall',)
    r70 = 'brownie.network.contract'
    r71 = dank_mids.brownie_patch.call.globals :: static
    r72 = CPyImport_ImportFromMany(r70, r69, r69, r71)
    if is_error(r72) goto L220 (error at <module>:31) else goto L16
L16:
    brownie.network.contract = r72 :: module
    dec_ref r72
    r73 = ('SOLIDITY_ERROR_CODES',)
    r74 = 'brownie.project.compiler.solidity'
    r75 = dank_mids.brownie_patch.call.globals :: static
    r76 = CPyImport_ImportFromMany(r74, r73, r73, r75)
    if is_error(r76) goto L220 (error at <module>:32) else goto L17
L17:
    brownie.project.compiler.solidity = r76 :: module
    dec_ref r76
    r77 = ('InsufficientDataBytes',)
    r78 = 'eth_abi.exceptions'
    r79 = dank_mids.brownie_patch.call.globals :: static
    r80 = CPyImport_ImportFromMany(r78, r77, r77, r79)
    if is_error(r80) goto L220 (error at <module>:33) else goto L18
L18:
    eth_abi.exceptions = r80 :: module
    dec_ref r80
    r81 = ('HexStr',)
    r82 = 'eth_typing'
    r83 = dank_mids.brownie_patch.call.globals :: static
    r84 = CPyImport_ImportFromMany(r82, r81, r81, r83)
    if is_error(r84) goto L220 (error at <module>:34) else goto L19
L19:
    eth_typing = r84 :: module
    dec_ref r84
    r85 = ('Address',)
    r86 = 'evmspec.data'
    r87 = dank_mids.brownie_patch.call.globals :: static
    r88 = CPyImport_ImportFromMany(r86, r85, r85, r87)
    if is_error(r88) goto L220 (error at <module>:35) else goto L20
L20:
    evmspec.data = r88 :: module
    dec_ref r88
    r89 = ('BytesLike',)
    r90 = 'hexbytes.main'
    r91 = dank_mids.brownie_patch.call.globals :: static
    r92 = CPyImport_ImportFromMany(r90, r89, r89, r91)
    if is_error(r92) goto L220 (error at <module>:36) else goto L21
L21:
    hexbytes.main = r92 :: module
    dec_ref r92
    r93 = ('MULTICALL2_ADDRESSES',)
    r94 = 'multicall.constants'
    r95 = dank_mids.brownie_patch.call.globals :: static
    r96 = CPyImport_ImportFromMany(r94, r93, r93, r95)
    if is_error(r96) goto L220 (error at <module>:37) else goto L22
L22:
    multicall.constants = r96 :: module
    dec_ref r96
    r97 = ('BlockIdentifier',)
    r98 = 'web3.types'
    r99 = dank_mids.brownie_patch.call.globals :: static
    r100 = CPyImport_ImportFromMany(r98, r97, r97, r99)
    if is_error(r100) goto L220 (error at <module>:38) else goto L23
L23:
    web3.types = r100 :: module
    dec_ref r100
    r101 = ('ENVIRONMENT_VARIABLES',)
    r102 = ('ENVS',)
    r103 = 'dank_mids'
    r104 = dank_mids.brownie_patch.call.globals :: static
    r105 = CPyImport_ImportFromMany(r103, r101, r102, r104)
    if is_error(r105) goto L220 (error at <module>:40) else goto L24
L24:
    dank_mids = r105 :: module
    dec_ref r105
    r106 = ('exceptions',)
    r107 = 'dank_mids'
    r108 = dank_mids.brownie_patch.call.globals :: static
    r109 = CPyImport_ImportFromMany(r107, r106, r106, r108)
    if is_error(r109) goto L220 (error at <module>:41) else goto L25
L25:
    dank_mids = r109 :: module
    dec_ref r109
    r110 = ('getLogger',)
    r111 = 'dank_mids._logging'
    r112 = dank_mids.brownie_patch.call.globals :: static
    r113 = CPyImport_ImportFromMany(r111, r110, r110, r112)
    if is_error(r113) goto L220 (error at <module>:42) else goto L26
L26:
    dank_mids._logging = r113 :: module
    dec_ref r113
    r114 = ('lru_cache_lite_nonull',)
    r115 = 'dank_mids.helpers.lru_cache'
    r116 = dank_mids.brownie_patch.call.globals :: static
    r117 = CPyImport_ImportFromMany(r115, r114, r114, r116)
    if is_error(r117) goto L220 (error at <module>:43) else goto L27
L27:
    dank_mids.helpers.lru_cache = r117 :: module
    dec_ref r117
    r118 = ('DankWeb3',)
    r119 = 'dank_mids.helpers._helpers'
    r120 = dank_mids.brownie_patch.call.globals :: static
    r121 = CPyImport_ImportFromMany(r119, r118, r118, r120)
    if is_error(r121) goto L220 (error at <module>:44) else goto L28
L28:
    dank_mids.helpers._helpers = r121 :: module
    dec_ref r121
    if 0 goto L29 else goto L29 :: bool
L29:
    r122 = dank_mids.ENVIRONMENT_VARIABLES.OPERATION_MODE :: static
    if is_error(r122) goto L30 else goto L32
L30:
    r123 = raise NameError('value for final name "OPERATION_MODE" was not set')
    if not r123 goto L220 (error at <module>:50) else goto L31 :: bool
L31:
    unreachable
L32:
    r124 = 'application'
    r125 = CPyObject_GetAttr(r122, r124)
    if is_error(r125) goto L220 (error at <module>:50) else goto L33
L33:
    r126 = unbox(bool, r125)
    if is_error(r126) goto L221 (error at <module>:50) else goto L34
L34:
    dank_mids.brownie_patch.call.APPLICATION_MODE = r126 :: static
    r127 = dank_mids.brownie_patch.call.globals :: static
    r128 = 'APPLICATION_MODE'
    r129 = CPyDict_SetItem(r127, r128, r125)
    dec_ref r125
    r130 = r129 >= 0 :: signed
    if not r130 goto L220 (error at <module>:50) else goto L35 :: bool
L35:
    r131 = '_T'
    r132 = dank_mids.brownie_patch.call.globals :: static
    r133 = 'TypeVar'
    r134 = CPyDict_GetItem(r132, r133)
    if is_error(r134) goto L220 (error at <module>:53) else goto L36
L36:
    r135 = [r131]
    r136 = load_address r135
    r137 = _PyObject_Vectorcall(r134, r136, 1, 0)
    dec_ref r134
    if is_error(r137) goto L220 (error at <module>:53) else goto L37
L37:
    r138 = dank_mids.brownie_patch.call.globals :: static
    r139 = '_T'
    r140 = CPyDict_SetItem(r138, r139, r137)
    dec_ref r137
    r141 = r140 >= 0 :: signed
    if not r141 goto L220 (error at <module>:53) else goto L38 :: bool
L38:
    r142 = 'TypeStr'
    r143 = load_address PyUnicode_Type
    r144 = dank_mids.brownie_patch.call.globals :: static
    r145 = 'NewType'
    r146 = CPyDict_GetItem(r144, r145)
    if is_error(r146) goto L220 (error at <module>:54) else goto L39
L39:
    r147 = [r142, r143]
    r148 = load_address r147
    r149 = _PyObject_Vectorcall(r146, r148, 2, 0)
    dec_ref r146
    if is_error(r149) goto L220 (error at <module>:54) else goto L40
L40:
    r150 = dank_mids.brownie_patch.call.globals :: static
    r151 = 'TypeStr'
    r152 = CPyDict_SetItem(r150, r151, r149)
    dec_ref r149
    r153 = r152 >= 0 :: signed
    if not r153 goto L220 (error at <module>:54) else goto L41 :: bool
L41:
    r154 = dank_mids.brownie_patch.call.globals :: static
    r155 = 'List'
    r156 = CPyDict_GetItem(r154, r155)
    if is_error(r156) goto L220 (error at <module>:55) else goto L42
L42:
    r157 = dank_mids.brownie_patch.call.globals :: static
    r158 = 'TypeStr'
    r159 = CPyDict_GetItem(r157, r158)
    if is_error(r159) goto L222 (error at <module>:55) else goto L43
L43:
    r160 = PyObject_GetItem(r156, r159)
    dec_ref r156
    dec_ref r159
    if is_error(r160) goto L220 (error at <module>:55) else goto L44
L44:
    r161 = dank_mids.brownie_patch.call.globals :: static
    r162 = 'TypeStrs'
    r163 = CPyDict_SetItem(r161, r162, r160)
    dec_ref r160
    r164 = r163 >= 0 :: signed
    if not r164 goto L220 (error at <module>:55) else goto L45 :: bool
L45:
    r165 = dank_mids.brownie_patch.call.globals :: static
    r166 = 'Union'
    r167 = CPyDict_GetItem(r165, r166)
    if is_error(r167) goto L220 (error at <module>:56) else goto L46
L46:
    r168 = dank_mids.brownie_patch.call.globals :: static
    r169 = 'List'
    r170 = CPyDict_GetItem(r168, r169)
    if is_error(r170) goto L223 (error at <module>:56) else goto L47
L47:
    r171 = dank_mids.brownie_patch.call.globals :: static
    r172 = '_T'
    r173 = CPyDict_GetItem(r171, r172)
    if is_error(r173) goto L224 (error at <module>:56) else goto L48
L48:
    r174 = PyObject_GetItem(r170, r173)
    dec_ref r170
    dec_ref r173
    if is_error(r174) goto L223 (error at <module>:56) else goto L49
L49:
    r175 = dank_mids.brownie_patch.call.globals :: static
    r176 = 'Tuple'
    r177 = CPyDict_GetItem(r175, r176)
    if is_error(r177) goto L225 (error at <module>:56) else goto L50
L50:
    r178 = dank_mids.brownie_patch.call.globals :: static
    r179 = '_T'
    r180 = CPyDict_GetItem(r178, r179)
    if is_error(r180) goto L226 (error at <module>:56) else goto L51
L51:
    r181 = load_address _Py_EllipsisObject
    inc_ref r181
    r182 = (r180, r181)
    r183 = box(tuple[object, object], r182)
    r184 = PyObject_GetItem(r177, r183)
    dec_ref r177
    dec_ref r183
    if is_error(r184) goto L225 (error at <module>:56) else goto L52
L52:
    r185 = (r174, r184)
    r186 = box(tuple[object, object], r185)
    r187 = PyObject_GetItem(r167, r186)
    dec_ref r167
    dec_ref r186
    if is_error(r187) goto L220 (error at <module>:56) else goto L53
L53:
    r188 = dank_mids.brownie_patch.call.globals :: static
    r189 = 'ListOrTuple'
    r190 = CPyDict_SetItem(r188, r189, r187)
    dec_ref r187
    r191 = r190 >= 0 :: signed
    if not r191 goto L220 (error at <module>:56) else goto L54 :: bool
L54:
    r192 = 'AbiDict'
    r193 = dank_mids.brownie_patch.call.globals :: static
    r194 = 'Dict'
    r195 = CPyDict_GetItem(r193, r194)
    if is_error(r195) goto L220 (error at <module>:57) else goto L55
L55:
    r196 = load_address PyUnicode_Type
    r197 = dank_mids.brownie_patch.call.globals :: static
    r198 = 'Any'
    r199 = CPyDict_GetItem(r197, r198)
    if is_error(r199) goto L227 (error at <module>:57) else goto L56
L56:
    inc_ref r196
    r200 = (r196, r199)
    r201 = box(tuple[object, object], r200)
    r202 = PyObject_GetItem(r195, r201)
    dec_ref r195
    dec_ref r201
    if is_error(r202) goto L220 (error at <module>:57) else goto L57
L57:
    r203 = dank_mids.brownie_patch.call.globals :: static
    r204 = 'NewType'
    r205 = CPyDict_GetItem(r203, r204)
    if is_error(r205) goto L228 (error at <module>:57) else goto L58
L58:
    r206 = [r192, r202]
    r207 = load_address r206
    r208 = _PyObject_Vectorcall(r205, r207, 2, 0)
    dec_ref r205
    if is_error(r208) goto L228 (error at <module>:57) else goto L59
L59:
    dec_ref r202
    r209 = dank_mids.brownie_patch.call.globals :: static
    r210 = 'AbiDict'
    r211 = CPyDict_SetItem(r209, r210, r208)
    dec_ref r208
    r212 = r211 >= 0 :: signed
    if not r212 goto L220 (error at <module>:57) else goto L60 :: bool
L60:
    r213 = decimal :: module
    r214 = 'Decimal'
    r215 = CPyObject_GetAttr(r213, r214)
    if is_error(r215) goto L220 (error at <module>:61) else goto L61
L61:
    dank_mids.brownie_patch.call.Decimal = r215 :: static
    r216 = dank_mids.brownie_patch.call.globals :: static
    r217 = 'Decimal'
    r218 = CPyDict_SetItem(r216, r217, r215)
    dec_ref r215
    r219 = r218 >= 0 :: signed
    if not r219 goto L220 (error at <module>:61) else goto L62 :: bool
L62:
    r220 = dank_mids.brownie_patch.call.globals :: static
    r221 = 'hexbytes'
    r222 = CPyDict_GetItem(r220, r221)
    if is_error(r222) goto L220 (error at <module>:62) else goto L63
L63:
    r223 = 'HexBytes'
    r224 = CPyObject_GetAttr(r222, r223)
    dec_ref r222
    if is_error(r224) goto L220 (error at <module>:62) else goto L64
L64:
    dank_mids.brownie_patch.call.HexBytes = r224 :: static
    r225 = dank_mids.brownie_patch.call.globals :: static
    r226 = 'HexBytes'
    r227 = CPyDict_SetItem(r225, r226, r224)
    dec_ref r224
    r228 = r227 >= 0 :: signed
    if not r228 goto L220 (error at <module>:62) else goto L65 :: bool
L65:
    r229 = dank_mids.brownie_patch.call.globals :: static
    r230 = 'brownie'
    r231 = CPyDict_GetItem(r229, r230)
    if is_error(r231) goto L220 (error at <module>:63) else goto L66
L66:
    r232 = 'network'
    r233 = CPyObject_GetAttr(r231, r232)
    dec_ref r231
    if is_error(r233) goto L220 (error at <module>:63) else goto L67
L67:
    r234 = 'contract'
    r235 = CPyObject_GetAttr(r233, r234)
    dec_ref r233
    if is_error(r235) goto L220 (error at <module>:63) else goto L68
L68:
    r236 = 'Contract'
    r237 = CPyObject_GetAttr(r235, r236)
    dec_ref r235
    if is_error(r237) goto L220 (error at <module>:63) else goto L69
L69:
    dank_mids.brownie_patch.call.Contract = r237 :: static
    r238 = dank_mids.brownie_patch.call.globals :: static
    r239 = 'Contract'
    r240 = CPyDict_SetItem(r238, r239, r237)
    dec_ref r237
    r241 = r240 >= 0 :: signed
    if not r241 goto L220 (error at <module>:63) else goto L70 :: bool
L70:
    r242 = dank_mids.brownie_patch.call.globals :: static
    r243 = 'brownie'
    r244 = CPyDict_GetItem(r242, r243)
    if is_error(r244) goto L220 (error at <module>:64) else goto L71
L71:
    r245 = 'convert'
    r246 = CPyObject_GetAttr(r244, r245)
    dec_ref r244
    if is_error(r246) goto L220 (error at <module>:64) else goto L72
L72:
    r247 = 'datatypes'
    r248 = CPyObject_GetAttr(r246, r247)
    dec_ref r246
    if is_error(r248) goto L220 (error at <module>:64) else goto L73
L73:
    r249 = 'ReturnValue'
    r250 = CPyObject_GetAttr(r248, r249)
    dec_ref r248
    if is_error(r250) goto L220 (error at <module>:64) else goto L74
L74:
    dank_mids.brownie_patch.call.ReturnValue = r250 :: static
    r251 = dank_mids.brownie_patch.call.globals :: static
    r252 = 'ReturnValue'
    r253 = CPyDict_SetItem(r251, r252, r250)
    dec_ref r250
    r254 = r253 >= 0 :: signed
    if not r254 goto L220 (error at <module>:64) else goto L75 :: bool
L75:
    r255 = dank_mids.brownie_patch.call.globals :: static
    r256 = 'brownie'
    r257 = CPyDict_GetItem(r255, r256)
    if is_error(r257) goto L220 (error at <module>:65) else goto L76
L76:
    r258 = 'convert'
    r259 = CPyObject_GetAttr(r257, r258)
    dec_ref r257
    if is_error(r259) goto L220 (error at <module>:65) else goto L77
L77:
    r260 = 'normalize'
    r261 = CPyObject_GetAttr(r259, r260)
    dec_ref r259
    if is_error(r261) goto L220 (error at <module>:65) else goto L78
L78:
    r262 = 'HexString'
    r263 = CPyObject_GetAttr(r261, r262)
    dec_ref r261
    if is_error(r263) goto L220 (error at <module>:65) else goto L79
L79:
    dank_mids.brownie_patch.call.HexString = r263 :: static
    r264 = dank_mids.brownie_patch.call.globals :: static
    r265 = 'HexString'
    r266 = CPyDict_SetItem(r264, r265, r263)
    dec_ref r263
    r267 = r266 >= 0 :: signed
    if not r267 goto L220 (error at <module>:65) else goto L80 :: bool
L80:
    r268 = dank_mids.brownie_patch.call.globals :: static
    r269 = 'brownie'
    r270 = CPyDict_GetItem(r268, r269)
    if is_error(r270) goto L220 (error at <module>:66) else goto L81
L81:
    r271 = 'convert'
    r272 = CPyObject_GetAttr(r270, r271)
    dec_ref r270
    if is_error(r272) goto L220 (error at <module>:66) else goto L82
L82:
    r273 = 'normalize'
    r274 = CPyObject_GetAttr(r272, r273)
    dec_ref r272
    if is_error(r274) goto L220 (error at <module>:66) else goto L83
L83:
    r275 = 'TupleType'
    r276 = CPyObject_GetAttr(r274, r275)
    dec_ref r274
    if is_error(r276) goto L220 (error at <module>:66) else goto L84
L84:
    dank_mids.brownie_patch.call.TupleType = r276 :: static
    r277 = dank_mids.brownie_patch.call.globals :: static
    r278 = 'TupleType'
    r279 = CPyDict_SetItem(r277, r278, r276)
    dec_ref r276
    r280 = r279 >= 0 :: signed
    if not r280 goto L220 (error at <module>:66) else goto L85 :: bool
L85:
    r281 = dank_mids.brownie_patch.call.globals :: static
    r282 = 'exceptions'
    r283 = CPyDict_GetItem(r281, r282)
    if is_error(r283) goto L220 (error at <module>:68) else goto L86
L86:
    r284 = 'Revert'
    r285 = CPyObject_GetAttr(r283, r284)
    dec_ref r283
    if is_error(r285) goto L220 (error at <module>:68) else goto L87
L87:
    dank_mids.brownie_patch.call.Revert = r285 :: static
    r286 = dank_mids.brownie_patch.call.globals :: static
    r287 = 'Revert'
    r288 = CPyDict_SetItem(r286, r287, r285)
    dec_ref r285
    r289 = r288 >= 0 :: signed
    if not r289 goto L220 (error at <module>:68) else goto L88 :: bool
L88:
    r290 = dank_mids.brownie_patch.call.globals :: static
    r291 = 'brownie'
    r292 = CPyDict_GetItem(r290, r291)
    if is_error(r292) goto L220 (error at <module>:70) else goto L89
L89:
    r293 = 'convert'
    r294 = CPyObject_GetAttr(r292, r293)
    dec_ref r292
    if is_error(r294) goto L220 (error at <module>:70) else goto L90
L90:
    r295 = 'normalize'
    r296 = CPyObject_GetAttr(r294, r295)
    dec_ref r294
    if is_error(r296) goto L220 (error at <module>:70) else goto L91
L91:
    r297 = 'to_bool'
    r298 = CPyObject_GetAttr(r296, r297)
    dec_ref r296
    if is_error(r298) goto L220 (error at <module>:70) else goto L92
L92:
    dank_mids.brownie_patch.call.to_bool = r298 :: static
    r299 = dank_mids.brownie_patch.call.globals :: static
    r300 = 'to_bool'
    r301 = CPyDict_SetItem(r299, r300, r298)
    dec_ref r298
    r302 = r301 >= 0 :: signed
    if not r302 goto L220 (error at <module>:70) else goto L93 :: bool
L93:
    r303 = dank_mids.brownie_patch.call.globals :: static
    r304 = 'brownie'
    r305 = CPyDict_GetItem(r303, r304)
    if is_error(r305) goto L220 (error at <module>:71) else goto L94
L94:
    r306 = 'convert'
    r307 = CPyObject_GetAttr(r305, r306)
    dec_ref r305
    if is_error(r307) goto L220 (error at <module>:71) else goto L95
L95:
    r308 = 'normalize'
    r309 = CPyObject_GetAttr(r307, r308)
    dec_ref r307
    if is_error(r309) goto L220 (error at <module>:71) else goto L96
L96:
    r310 = 'to_decimal'
    r311 = CPyObject_GetAttr(r309, r310)
    dec_ref r309
    if is_error(r311) goto L220 (error at <module>:71) else goto L97
L97:
    dank_mids.brownie_patch.call.to_decimal = r311 :: static
    r312 = dank_mids.brownie_patch.call.globals :: static
    r313 = 'to_decimal'
    r314 = CPyDict_SetItem(r312, r313, r311)
    dec_ref r311
    r315 = r314 >= 0 :: signed
    if not r315 goto L220 (error at <module>:71) else goto L98 :: bool
L98:
    r316 = dank_mids.brownie_patch.call.globals :: static
    r317 = 'brownie'
    r318 = CPyDict_GetItem(r316, r317)
    if is_error(r318) goto L220 (error at <module>:72) else goto L99
L99:
    r319 = 'convert'
    r320 = CPyObject_GetAttr(r318, r319)
    dec_ref r318
    if is_error(r320) goto L220 (error at <module>:72) else goto L100
L100:
    r321 = 'normalize'
    r322 = CPyObject_GetAttr(r320, r321)
    dec_ref r320
    if is_error(r322) goto L220 (error at <module>:72) else goto L101
L101:
    r323 = 'to_int'
    r324 = CPyObject_GetAttr(r322, r323)
    dec_ref r322
    if is_error(r324) goto L220 (error at <module>:72) else goto L102
L102:
    dank_mids.brownie_patch.call.to_int = r324 :: static
    r325 = dank_mids.brownie_patch.call.globals :: static
    r326 = 'to_int'
    r327 = CPyDict_SetItem(r325, r326, r324)
    dec_ref r324
    r328 = r327 >= 0 :: signed
    if not r328 goto L220 (error at <module>:72) else goto L103 :: bool
L103:
    r329 = dank_mids.brownie_patch.call.globals :: static
    r330 = 'brownie'
    r331 = CPyDict_GetItem(r329, r330)
    if is_error(r331) goto L220 (error at <module>:73) else goto L104
L104:
    r332 = 'convert'
    r333 = CPyObject_GetAttr(r331, r332)
    dec_ref r331
    if is_error(r333) goto L220 (error at <module>:73) else goto L105
L105:
    r334 = 'normalize'
    r335 = CPyObject_GetAttr(r333, r334)
    dec_ref r333
    if is_error(r335) goto L220 (error at <module>:73) else goto L106
L106:
    r336 = 'to_string'
    r337 = CPyObject_GetAttr(r335, r336)
    dec_ref r335
    if is_error(r337) goto L220 (error at <module>:73) else goto L107
L107:
    dank_mids.brownie_patch.call.to_string = r337 :: static
    r338 = dank_mids.brownie_patch.call.globals :: static
    r339 = 'to_string'
    r340 = CPyDict_SetItem(r338, r339, r337)
    dec_ref r337
    r341 = r340 >= 0 :: signed
    if not r341 goto L220 (error at <module>:73) else goto L108 :: bool
L108:
    r342 = dank_mids.brownie_patch.call.globals :: static
    r343 = 'brownie'
    r344 = CPyDict_GetItem(r342, r343)
    if is_error(r344) goto L220 (error at <module>:74) else goto L109
L109:
    r345 = 'convert'
    r346 = CPyObject_GetAttr(r344, r345)
    dec_ref r344
    if is_error(r346) goto L220 (error at <module>:74) else goto L110
L110:
    r347 = 'normalize'
    r348 = CPyObject_GetAttr(r346, r347)
    dec_ref r346
    if is_error(r348) goto L220 (error at <module>:74) else goto L111
L111:
    r349 = 'to_uint'
    r350 = CPyObject_GetAttr(r348, r349)
    dec_ref r348
    if is_error(r350) goto L220 (error at <module>:74) else goto L112
L112:
    dank_mids.brownie_patch.call.to_uint = r350 :: static
    r351 = dank_mids.brownie_patch.call.globals :: static
    r352 = 'to_uint'
    r353 = CPyDict_SetItem(r351, r352, r350)
    dec_ref r350
    r354 = r353 >= 0 :: signed
    if not r354 goto L220 (error at <module>:74) else goto L113 :: bool
L113:
    r355 = dank_mids.brownie_patch.call.globals :: static
    r356 = 'brownie'
    r357 = CPyDict_GetItem(r355, r356)
    if is_error(r357) goto L220 (error at <module>:75) else goto L114
L114:
    r358 = 'convert'
    r359 = CPyObject_GetAttr(r357, r358)
    dec_ref r357
    if is_error(r359) goto L220 (error at <module>:75) else goto L115
L115:
    r360 = 'normalize'
    r361 = CPyObject_GetAttr(r359, r360)
    dec_ref r359
    if is_error(r361) goto L220 (error at <module>:75) else goto L116
L116:
    r362 = '_check_array'
    r363 = CPyObject_GetAttr(r361, r362)
    dec_ref r361
    if is_error(r363) goto L220 (error at <module>:75) else goto L117
L117:
    dank_mids.brownie_patch.call._check_array = r363 :: static
    r364 = dank_mids.brownie_patch.call.globals :: static
    r365 = '_check_array'
    r366 = CPyDict_SetItem(r364, r365, r363)
    dec_ref r363
    r367 = r366 >= 0 :: signed
    if not r367 goto L220 (error at <module>:75) else goto L118 :: bool
L118:
    r368 = dank_mids.brownie_patch.call.globals :: static
    r369 = 'brownie'
    r370 = CPyDict_GetItem(r368, r369)
    if is_error(r370) goto L220 (error at <module>:76) else goto L119
L119:
    r371 = 'convert'
    r372 = CPyObject_GetAttr(r370, r371)
    dec_ref r370
    if is_error(r372) goto L220 (error at <module>:76) else goto L120
L120:
    r373 = 'normalize'
    r374 = CPyObject_GetAttr(r372, r373)
    dec_ref r372
    if is_error(r374) goto L220 (error at <module>:76) else goto L121
L121:
    r375 = '_get_abi_types'
    r376 = CPyObject_GetAttr(r374, r375)
    dec_ref r374
    if is_error(r376) goto L220 (error at <module>:76) else goto L122
L122:
    dank_mids.brownie_patch.call._get_abi_types = r376 :: static
    r377 = dank_mids.brownie_patch.call.globals :: static
    r378 = '_get_abi_types'
    r379 = CPyDict_SetItem(r377, r378, r376)
    dec_ref r376
    r380 = r379 >= 0 :: signed
    if not r380 goto L220 (error at <module>:76) else goto L123 :: bool
L123:
    r381 = dank_mids.brownie_patch.call.globals :: static
    r382 = '__name__'
    r383 = CPyDict_GetItem(r381, r382)
    if is_error(r383) goto L220 (error at <module>:79) else goto L124
L124:
    r384 = cast(str, r383)
    if is_error(r384) goto L220 (error at <module>:79) else goto L125
L125:
    r385 = dank_mids._logging.getLogger :: static
    if is_error(r385) goto L229 else goto L128
L126:
    r386 = raise NameError('value for final name "getLogger" was not set')
    if not r386 goto L220 (error at <module>:79) else goto L127 :: bool
L127:
    unreachable
L128:
    r387 = [r384]
    r388 = load_address r387
    r389 = _PyObject_Vectorcall(r385, r388, 1, 0)
    if is_error(r389) goto L230 (error at <module>:79) else goto L129
L129:
    dec_ref r384
    dank_mids.brownie_patch.call.logger = r389 :: static
    r390 = dank_mids.brownie_patch.call.globals :: static
    r391 = 'logger'
    r392 = CPyDict_SetItem(r390, r391, r389)
    dec_ref r389
    r393 = r392 >= 0 :: signed
    if not r393 goto L220 (error at <module>:79) else goto L130 :: bool
L130:
    r394 = __mypyc_lambda__0_obj()
    if is_error(r394) goto L220 (error at <module>:82) else goto L131
L131:
    dank_mids.brownie_patch.call.encode = r394 :: static
    r395 = dank_mids.brownie_patch.call.globals :: static
    r396 = 'encode'
    r397 = CPyDict_SetItem(r395, r396, r394)
    dec_ref r394
    r398 = r397 >= 0 :: signed
    if not r398 goto L220 (error at <module>:82) else goto L132 :: bool
L132:
    r399 = __mypyc_lambda__1_obj()
    if is_error(r399) goto L220 (error at <module>:101) else goto L133
L133:
    dank_mids.brownie_patch.call.decode = r399 :: static
    r400 = dank_mids.brownie_patch.call.globals :: static
    r401 = 'decode'
    r402 = CPyDict_SetItem(r400, r401, r399)
    dec_ref r399
    r403 = r402 >= 0 :: signed
    if not r403 goto L220 (error at <module>:101) else goto L134 :: bool
L134:
    r404 = dank_mids.brownie_patch.call.globals :: static
    r405 = 'Address'
    r406 = CPyDict_GetItem(r404, r405)
    if is_error(r406) goto L220 (error at <module>:122) else goto L135
L135:
    r407 = 'checksum'
    r408 = CPyObject_GetAttr(r406, r407)
    dec_ref r406
    if is_error(r408) goto L220 (error at <module>:122) else goto L136
L136:
    dank_mids.brownie_patch.call.to_checksum_address = r408 :: static
    r409 = dank_mids.brownie_patch.call.globals :: static
    r410 = 'to_checksum_address'
    r411 = CPyDict_SetItem(r409, r410, r408)
    dec_ref r408
    r412 = r411 >= 0 :: signed
    if not r412 goto L220 (error at <module>:122) else goto L137 :: bool
L137:
    r413 = dank_mids.brownie_patch.call.globals :: static
    r414 = '_get_coroutine_fn'
    r415 = CPyDict_GetItem(r413, r414)
    if is_error(r415) goto L220 (error at <module>:140) else goto L138
L138:
    r416 = dank_mids.brownie_patch.call.globals :: static
    r417 = 'lru_cache_lite_nonull'
    r418 = CPyDict_GetItem(r416, r417)
    if is_error(r418) goto L231 (error at <module>:140) else goto L139
L139:
    r419 = [r415]
    r420 = load_address r419
    r421 = _PyObject_Vectorcall(r418, r420, 1, 0)
    dec_ref r418
    if is_error(r421) goto L231 (error at <module>:140) else goto L140
L140:
    dec_ref r415
    r422 = dank_mids.brownie_patch.call.globals :: static
    r423 = '_get_coroutine_fn'
    r424 = CPyDict_SetItem(r422, r423, r421)
    dec_ref r421
    r425 = r424 >= 0 :: signed
    if not r425 goto L220 (error at <module>:140) else goto L141 :: bool
L141:
    r426 = dank_mids.brownie_patch.call.globals :: static
    r427 = 'eth_abi'
    r428 = CPyDict_GetItem(r426, r427)
    if is_error(r428) goto L220 (error at <module>:245) else goto L142
L142:
    r429 = 'encode'
    r430 = PyObject_HasAttr(r428, r429)
    dec_ref r428
    if r430 goto L143 else goto L146 :: bool
L143:
    r431 = dank_mids.brownie_patch.call.globals :: static
    r432 = 'eth_abi'
    r433 = CPyDict_GetItem(r431, r432)
    if is_error(r433) goto L220 (error at <module>:245) else goto L144
L144:
    r434 = 'encode'
    r435 = CPyObject_GetAttr(r433, r434)
    dec_ref r433
    if is_error(r435) goto L220 (error at <module>:245) else goto L145
L145:
    r436 = r435
    goto L149
L146:
    r437 = dank_mids.brownie_patch.call.globals :: static
    r438 = 'eth_abi'
    r439 = CPyDict_GetItem(r437, r438)
    if is_error(r439) goto L220 (error at <module>:245) else goto L147
L147:
    r440 = 'encode_abi'
    r441 = CPyObject_GetAttr(r439, r440)
    dec_ref r439
    if is_error(r441) goto L220 (error at <module>:245) else goto L148
L148:
    r436 = r441
L149:
    dank_mids.brownie_patch.call.__eth_abi_encode = r436 :: static
    r442 = dank_mids.brownie_patch.call.globals :: static
    r443 = '__eth_abi_encode'
    r444 = CPyDict_SetItem(r442, r443, r436)
    dec_ref r436
    r445 = r444 >= 0 :: signed
    if not r445 goto L220 (error at <module>:245) else goto L150 :: bool
L150:
    r446 = dank_mids.brownie_patch.call.globals :: static
    r447 = 'eth_abi'
    r448 = CPyDict_GetItem(r446, r447)
    if is_error(r448) goto L220 (error at <module>:248) else goto L151
L151:
    r449 = 'decode'
    r450 = PyObject_HasAttr(r448, r449)
    dec_ref r448
    if r450 goto L152 else goto L155 :: bool
L152:
    r451 = dank_mids.brownie_patch.call.globals :: static
    r452 = 'eth_abi'
    r453 = CPyDict_GetItem(r451, r452)
    if is_error(r453) goto L220 (error at <module>:248) else goto L153
L153:
    r454 = 'decode'
    r455 = CPyObject_GetAttr(r453, r454)
    dec_ref r453
    if is_error(r455) goto L220 (error at <module>:248) else goto L154
L154:
    r456 = r455
    goto L158
L155:
    r457 = dank_mids.brownie_patch.call.globals :: static
    r458 = 'eth_abi'
    r459 = CPyDict_GetItem(r457, r458)
    if is_error(r459) goto L220 (error at <module>:248) else goto L156
L156:
    r460 = 'decode_abi'
    r461 = CPyObject_GetAttr(r459, r460)
    dec_ref r459
    if is_error(r461) goto L220 (error at <module>:248) else goto L157
L157:
    r456 = r461
L158:
    dank_mids.brownie_patch.call.__eth_abi_decode = r456 :: static
    r462 = dank_mids.brownie_patch.call.globals :: static
    r463 = '__eth_abi_decode'
    r464 = CPyDict_SetItem(r462, r463, r456)
    dec_ref r456
    r465 = r464 >= 0 :: signed
    if not r465 goto L220 (error at <module>:248) else goto L159 :: bool
L159:
    r466 = '0xcA11bde05977b3631167028862bE2a173976CA11'
    r467 = PySet_New(0)
    if is_error(r467) goto L220 (error at <module>:261) else goto L160
L160:
    r468 = PySet_Add(r467, r466)
    r469 = r468 >= 0 :: signed
    if not r469 goto L232 (error at <module>:261) else goto L161 :: bool
L161:
    r470 = dank_mids.brownie_patch.call.globals :: static
    r471 = '_skip_proc_pool'
    r472 = CPyDict_SetItem(r470, r471, r467)
    dec_ref r467
    r473 = r472 >= 0 :: signed
    if not r473 goto L220 (error at <module>:261) else goto L162 :: bool
L162:
    if 1 goto L163 else goto L180 :: bool
L163:
    r474 = dank_mids.brownie_patch.call.globals :: static
    r475 = 'chain'
    r476 = CPyDict_GetItem(r474, r475)
    if is_error(r476) goto L166 (error at <module>:265) else goto L164
L164:
    r477 = 'id'
    r478 = CPyObject_GetAttr(r476, r477)
    dec_ref r476
    if is_error(r478) goto L166 (error at <module>:265) else goto L165
L165:
    r479 = dank_mids.brownie_patch.call.globals :: static
    r480 = 'chainid'
    r481 = CPyDict_SetItem(r479, r480, r478)
    dec_ref r478
    r482 = r481 >= 0 :: signed
    if not r482 goto L166 (error at <module>:265) else goto L180 :: bool
L166:
    r483 = CPy_CatchError()
    r484 = builtins :: module
    r485 = 'Exception'
    r486 = CPyObject_GetAttr(r484, r485)
    if is_error(r486) goto L178 (error at <module>:267) else goto L167
L167:
    r487 = CPy_ExceptionMatches(r486)
    dec_ref r486
    if r487 goto L168 else goto L175 :: bool
L168:
    r488 = dank_mids.brownie_patch.call.globals :: static
    r489 = 'e'
    r490 = CPy_GetExcValue()
    r491 = CPyDict_SetItem(r488, r489, r490)
    dec_ref r490
    r492 = r491 >= 0 :: signed
    if not r492 goto L178 (error at <module>:267) else goto L169 :: bool
L169:
    r493 = '429'
    r494 = dank_mids.brownie_patch.call.globals :: static
    r495 = 'e'
    r496 = CPyDict_GetItem(r494, r495)
    if is_error(r496) goto L178 (error at <module>:268) else goto L170
L170:
    r497 = PyObject_Str(r496)
    dec_ref r496
    if is_error(r497) goto L178 (error at <module>:268) else goto L171
L171:
    r498 = PySequence_Contains(r497, r493)
    dec_ref r497
    r499 = r498 >= 0 :: signed
    if not r499 goto L178 (error at <module>:268) else goto L172 :: bool
L172:
    r500 = truncate r498: i32 to builtins.bool
    r501 = r500 ^ 1
    if r501 goto L173 else goto L177 :: bool
L173:
    CPy_Reraise()
    if not 0 goto L178 else goto L233 :: bool
L174:
    unreachable
L175:
    CPy_Reraise()
    if not 0 goto L178 else goto L234 :: bool
L176:
    unreachable
L177:
    CPy_RestoreExcInfo(r483)
    dec_ref r483
    goto L162
L178:
    CPy_RestoreExcInfo(r483)
    dec_ref r483
    r502 = CPy_KeepPropagating()
    if not r502 goto L220 else goto L179 :: bool
L179:
    unreachable
L180:
    r503 = dank_mids.brownie_patch.call.globals :: static
    r504 = 'MULTICALL2_ADDRESSES'
    r505 = CPyDict_GetItem(r503, r504)
    if is_error(r505) goto L220 (error at <module>:270) else goto L181
L181:
    r506 = dank_mids.brownie_patch.call.globals :: static
    r507 = 'chainid'
    r508 = CPyDict_GetItem(r506, r507)
    if is_error(r508) goto L235 (error at <module>:270) else goto L182
L182:
    r509 = 'get'
    r510 = box(None, 1)
    r511 = [r505, r508, r510]
    r512 = load_address r511
    r513 = PyObject_VectorcallMethod(r509, r512, 9223372036854775811, 0)
    if is_error(r513) goto L236 (error at <module>:270) else goto L183
L183:
    dec_ref r505
    dec_ref r508
    r514 = dank_mids.brownie_patch.call.globals :: static
    r515 = 'multicall2'
    r516 = CPyDict_SetItem(r514, r515, r513)
    r517 = r516 >= 0 :: signed
    if not r517 goto L237 (error at <module>:270) else goto L184 :: bool
L184:
    r518 = PyObject_IsTrue(r513)
    dec_ref r513
    r519 = r518 >= 0 :: signed
    if not r519 goto L220 (error at <module>:270) else goto L185 :: bool
L185:
    r520 = truncate r518: i32 to builtins.bool
    if r520 goto L186 else goto L194 :: bool
L186:
    r521 = dank_mids.brownie_patch.call.globals :: static
    r522 = '_skip_proc_pool'
    r523 = CPyDict_GetItem(r521, r522)
    if is_error(r523) goto L220 (error at <module>:271) else goto L187
L187:
    r524 = cast(set, r523)
    if is_error(r524) goto L220 (error at <module>:271) else goto L188
L188:
    r525 = dank_mids.brownie_patch.call.globals :: static
    r526 = 'multicall2'
    r527 = CPyDict_GetItem(r525, r526)
    if is_error(r527) goto L238 (error at <module>:271) else goto L189
L189:
    r528 = dank_mids.brownie_patch.call.to_checksum_address :: static
    if is_error(r528) goto L239 else goto L192
L190:
    r529 = raise NameError('value for final name "to_checksum_address" was not set')
    if not r529 goto L220 (error at <module>:271) else goto L191 :: bool
L191:
    unreachable
L192:
    r530 = [r527]
    r531 = load_address r530
    r532 = _PyObject_Vectorcall(r528, r531, 1, 0)
    if is_error(r532) goto L240 (error at <module>:271) else goto L193
L193:
    dec_ref r527
    r533 = PySet_Add(r524, r532)
    dec_ref r524
    dec_ref r532
    r534 = r533 >= 0 :: signed
    if not r534 goto L220 (error at <module>:271) else goto L194 :: bool
L194:
    r535 = dank_mids.brownie_patch.call.globals :: static
    r536 = 'format_input_but_cache_checksums'
    r537 = CPyDict_GetItem(r535, r536)
    if is_error(r537) goto L220 (error at <module>:331) else goto L195
L195:
    r538 = dank_mids.brownie_patch.call.globals :: static
    r539 = 'brownie'
    r540 = CPyDict_GetItem(r538, r539)
    if is_error(r540) goto L241 (error at <module>:331) else goto L196
L196:
    r541 = 'network'
    r542 = CPyObject_GetAttr(r540, r541)
    dec_ref r540
    if is_error(r542) goto L241 (error at <module>:331) else goto L197
L197:
    r543 = 'contract'
    r544 = CPyObject_GetAttr(r542, r543)
    dec_ref r542
    if is_error(r544) goto L241 (error at <module>:331) else goto L198
L198:
    r545 = 'format_input'
    r546 = PyObject_SetAttr(r544, r545, r537)
    dec_ref r544
    dec_ref r537
    r547 = r546 >= 0 :: signed
    if not r547 goto L220 (error at <module>:331) else goto L199 :: bool
L199:
    r548 = dank_mids.brownie_patch.call.globals :: static
    r549 = 'format_output_but_cache_checksums'
    r550 = CPyDict_GetItem(r548, r549)
    if is_error(r550) goto L220 (error at <module>:332) else goto L200
L200:
    r551 = dank_mids.brownie_patch.call.globals :: static
    r552 = 'brownie'
    r553 = CPyDict_GetItem(r551, r552)
    if is_error(r553) goto L242 (error at <module>:332) else goto L201
L201:
    r554 = 'network'
    r555 = CPyObject_GetAttr(r553, r554)
    dec_ref r553
    if is_error(r555) goto L242 (error at <module>:332) else goto L202
L202:
    r556 = 'contract'
    r557 = CPyObject_GetAttr(r555, r556)
    dec_ref r555
    if is_error(r557) goto L242 (error at <module>:332) else goto L203
L203:
    r558 = 'format_output'
    r559 = PyObject_SetAttr(r557, r558, r550)
    dec_ref r557
    dec_ref r550
    r560 = r559 >= 0 :: signed
    if not r560 goto L220 (error at <module>:332) else goto L204 :: bool
L204:
    r561 = dank_mids.brownie_patch.call.globals :: static
    r562 = '_format_array_but_cache_checksums'
    r563 = CPyDict_GetItem(r561, r562)
    if is_error(r563) goto L220 (error at <module>:389) else goto L205
L205:
    r564 = dank_mids.brownie_patch.call.globals :: static
    r565 = 'brownie'
    r566 = CPyDict_GetItem(r564, r565)
    if is_error(r566) goto L243 (error at <module>:389) else goto L206
L206:
    r567 = 'convert'
    r568 = CPyObject_GetAttr(r566, r567)
    dec_ref r566
    if is_error(r568) goto L243 (error at <module>:389) else goto L207
L207:
    r569 = 'normalize'
    r570 = CPyObject_GetAttr(r568, r569)
    dec_ref r568
    if is_error(r570) goto L243 (error at <module>:389) else goto L208
L208:
    r571 = '_format_array'
    r572 = PyObject_SetAttr(r570, r571, r563)
    dec_ref r570
    dec_ref r563
    r573 = r572 >= 0 :: signed
    if not r573 goto L220 (error at <module>:389) else goto L209 :: bool
L209:
    r574 = dank_mids.brownie_patch.call.globals :: static
    r575 = '_format_single_but_cache_checksums'
    r576 = CPyDict_GetItem(r574, r575)
    if is_error(r576) goto L220 (error at <module>:390) else goto L210
L210:
    r577 = dank_mids.brownie_patch.call.globals :: static
    r578 = 'brownie'
    r579 = CPyDict_GetItem(r577, r578)
    if is_error(r579) goto L244 (error at <module>:390) else goto L211
L211:
    r580 = 'convert'
    r581 = CPyObject_GetAttr(r579, r580)
    dec_ref r579
    if is_error(r581) goto L244 (error at <module>:390) else goto L212
L212:
    r582 = 'normalize'
    r583 = CPyObject_GetAttr(r581, r582)
    dec_ref r581
    if is_error(r583) goto L244 (error at <module>:390) else goto L213
L213:
    r584 = '_format_single'
    r585 = PyObject_SetAttr(r583, r584, r576)
    dec_ref r583
    dec_ref r576
    r586 = r585 >= 0 :: signed
    if not r586 goto L220 (error at <module>:390) else goto L214 :: bool
L214:
    r587 = dank_mids.brownie_patch.call.globals :: static
    r588 = '_format_tuple_but_cache_checksums'
    r589 = CPyDict_GetItem(r587, r588)
    if is_error(r589) goto L220 (error at <module>:391) else goto L215
L215:
    r590 = dank_mids.brownie_patch.call.globals :: static
    r591 = 'brownie'
    r592 = CPyDict_GetItem(r590, r591)
    if is_error(r592) goto L245 (error at <module>:391) else goto L216
L216:
    r593 = 'convert'
    r594 = CPyObject_GetAttr(r592, r593)
    dec_ref r592
    if is_error(r594) goto L245 (error at <module>:391) else goto L217
L217:
    r595 = 'normalize'
    r596 = CPyObject_GetAttr(r594, r595)
    dec_ref r594
    if is_error(r596) goto L245 (error at <module>:391) else goto L218
L218:
    r597 = '_format_tuple'
    r598 = PyObject_SetAttr(r596, r597, r589)
    dec_ref r596
    dec_ref r589
    r599 = r598 >= 0 :: signed
    if not r599 goto L220 (error at <module>:391) else goto L219 :: bool
L219:
    return 1
L220:
    r600 = <error> :: None
    return r600
L221:
    dec_ref r125
    goto L220
L222:
    dec_ref r156
    goto L220
L223:
    dec_ref r167
    goto L220
L224:
    dec_ref r167
    dec_ref r170
    goto L220
L225:
    dec_ref r167
    dec_ref r174
    goto L220
L226:
    dec_ref r167
    dec_ref r174
    dec_ref r177
    goto L220
L227:
    dec_ref r195
    goto L220
L228:
    dec_ref r202
    goto L220
L229:
    dec_ref r384
    goto L126
L230:
    dec_ref r384
    goto L220
L231:
    dec_ref r415
    goto L220
L232:
    dec_ref r467
    goto L220
L233:
    dec_ref r483
    goto L174
L234:
    dec_ref r483
    goto L176
L235:
    dec_ref r505
    goto L220
L236:
    dec_ref r505
    dec_ref r508
    goto L220
L237:
    dec_ref r513
    goto L220
L238:
    dec_ref r524
    goto L220
L239:
    dec_ref r524
    dec_ref r527
    goto L190
L240:
    dec_ref r524
    dec_ref r527
    goto L220
L241:
    dec_ref r537
    goto L220
L242:
    dec_ref r550
    goto L220
L243:
    dec_ref r563
    goto L220
L244:
    dec_ref r576
    goto L220
L245:
    dec_ref r589
    goto L220

def RawResponse.__init__(self, raw):
    self :: dank_mids.helpers._codec.RawResponse
    raw :: object
L0:
    inc_ref raw
    self._raw = raw
    return 1

def RawResponse.decode(self, partial):
    self :: dank_mids.helpers._codec.RawResponse
    partial :: bool
    r0 :: dict
    r1 :: str
    r2, r3 :: object
    r4 :: bit
    r5 :: None
    r6 :: object
    r7 :: dict
    r8 :: str
    r9 :: object
    r10 :: union[object, None]
    r11 :: dict
    r12 :: str
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: object
    r17 :: object[2]
    r18 :: object_ptr
    r19, r20, r21 :: object
L0:
    if is_error(partial) goto L1 else goto L2
L1:
    partial = 0
L2:
    r0 = dank_mids.helpers._codec.globals :: static
    r1 = 'better_decode'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L13 (error at decode:91) else goto L3
L3:
    r3 = load_address _Py_NoneStruct
    r4 = r2 == r3
    dec_ref r2
    if r4 goto L4 else goto L5 :: bool
L4:
    r5 = __import_from_types()
    if is_error(r5) goto L13 (error at decode:92) else goto L5
L5:
    r6 = self._raw
    if partial goto L6 else goto L8 :: bool
L6:
    r7 = dank_mids.helpers._codec.globals :: static
    r8 = 'PartialResponse'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L14 (error at decode:93) else goto L7
L7:
    r10 = r9
    goto L10
L8:
    r11 = dank_mids.helpers._codec.globals :: static
    r12 = 'Response'
    r13 = CPyDict_GetItem(r11, r12)
    if is_error(r13) goto L14 (error at decode:93) else goto L9
L9:
    r10 = r13
L10:
    r14 = dank_mids.helpers._codec.globals :: static
    r15 = 'better_decode'
    r16 = CPyDict_GetItem(r14, r15)
    if is_error(r16) goto L15 (error at decode:93) else goto L11
L11:
    r17 = [r6, r10]
    r18 = load_address r17
    r19 = ('type',)
    r20 = _PyObject_Vectorcall(r16, r18, 1, r19)
    dec_ref r16
    if is_error(r20) goto L15 (error at decode:93) else goto L12
L12:
    dec_ref r6
    dec_ref r10
    return r20
L13:
    r21 = <error> :: object
    return r21
L14:
    dec_ref r6
    goto L13
L15:
    dec_ref r6
    dec_ref r10
    goto L13

def decode_raw(data):
    data, r0 :: object
    r1 :: bool
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5 :: dank_mids.helpers._codec.RawResponse
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: bool
    r9 :: bit
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: list
    r14 :: object
    r15 :: i32
    r16 :: bit
    r17 :: tuple
    r18 :: str
    r19 :: i32
    r20, r21 :: bit
    r22 :: dank_mids.helpers._codec.RawResponse
L0:
L1:
    r0 = dank_mids.helpers._codec._decode_raw :: static
    if is_error(r0) goto L2 else goto L4
L2:
    r1 = raise NameError('value for final name "_decode_raw" was not set')
    if not r1 goto L7 (error at decode_raw:109) else goto L3 :: bool
L3:
    unreachable
L4:
    r2 = [data]
    r3 = load_address r2
    r4 = _PyObject_Vectorcall(r0, r3, 1, 0)
    if is_error(r4) goto L7 (error at decode_raw:109) else goto L5
L5:
    r5 = RawResponse(r4)
    dec_ref r4
    if is_error(r5) goto L7 (error at decode_raw:109) else goto L6
L6:
    return r5
L7:
    r6 = CPy_CatchError()
    r7 = dank_mids.helpers._codec.DecodeError :: static
    if is_error(r7) goto L8 else goto L10
L8:
    r8 = raise NameError('value for final name "DecodeError" was not set')
    if not r8 goto L21 (error at decode_raw:110) else goto L24 :: bool
L9:
    unreachable
L10:
    r9 = CPy_ExceptionMatches(r7)
    if r9 goto L11 else goto L19 :: bool
L11:
    r10 = CPy_GetExcValue()
    r11 = 'args'
    r12 = CPyObject_GetAttr(r10, r11)
    if is_error(r12) goto L25 (error at decode_raw:111) else goto L12
L12:
    r13 = PyList_New(0)
    if is_error(r13) goto L26 (error at decode_raw:111) else goto L13
L13:
    r14 = CPyList_Extend(r13, r12)
    dec_ref r12
    if is_error(r14) goto L27 (error at decode_raw:111) else goto L28
L14:
    r15 = PyList_Append(r13, data)
    r16 = r15 >= 0 :: signed
    if not r16 goto L27 (error at decode_raw:111) else goto L15 :: bool
L15:
    r17 = PyList_AsTuple(r13)
    dec_ref r13
    if is_error(r17) goto L25 (error at decode_raw:111) else goto L16
L16:
    r18 = 'args'
    r19 = PyObject_SetAttr(r10, r18, r17)
    dec_ref r10
    dec_ref r17
    r20 = r19 >= 0 :: signed
    if not r20 goto L21 (error at decode_raw:111) else goto L17 :: bool
L17:
    CPy_Reraise()
    if not 0 goto L21 else goto L29 :: bool
L18:
    unreachable
L19:
    CPy_Reraise()
    if not 0 goto L21 else goto L30 :: bool
L20:
    unreachable
L21:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r21 = CPy_KeepPropagating()
    if not r21 goto L23 else goto L22 :: bool
L22:
    unreachable
L23:
    r22 = <error> :: dank_mids.helpers._codec.RawResponse
    return r22
L24:
    dec_ref r6
    goto L9
L25:
    dec_ref r10
    goto L21
L26:
    dec_ref r10
    dec_ref r12
    goto L21
L27:
    dec_ref r10
    dec_ref r13
    goto L21
L28:
    dec_ref r14
    goto L14
L29:
    dec_ref r6
    goto L18
L30:
    dec_ref r6
    goto L20

def decode_jsonrpc_batch(data):
    data :: object
    r0 :: dict
    r1 :: str
    r2, r3 :: object
    r4 :: bit
    r5 :: None
    r6 :: dict
    r7 :: str
    r8 :: object
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    decoded :: union[list, object]
    r12 :: object
    r13 :: i32
    r14 :: bit
    r15 :: bool
    r16 :: list
    r17, r18 :: object
    r19 :: dank_mids.helpers._codec.RawResponse
    r20 :: i32
    r21, r22 :: bit
    r23, r24 :: union[list, object]
L0:
    r0 = dank_mids.helpers._codec.globals :: static
    r1 = '_decode_batch'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L16 (error at decode_jsonrpc_batch:125) else goto L1
L1:
    r3 = load_address _Py_NoneStruct
    r4 = r2 == r3
    dec_ref r2
    if r4 goto L2 else goto L3 :: bool
L2:
    r5 = __make_decode_batch()
    if is_error(r5) goto L16 (error at decode_jsonrpc_batch:126) else goto L3
L3:
    r6 = dank_mids.helpers._codec.globals :: static
    r7 = '_decode_batch'
    r8 = CPyDict_GetItem(r6, r7)
    if is_error(r8) goto L16 (error at decode_jsonrpc_batch:128) else goto L4
L4:
    r9 = [data]
    r10 = load_address r9
    r11 = _PyObject_Vectorcall(r8, r10, 1, 0)
    dec_ref r8
    if is_error(r11) goto L16 (error at decode_jsonrpc_batch:128) else goto L5
L5:
    decoded = r11
    r12 = load_address PyList_Type
    r13 = PyObject_IsInstance(decoded, r12)
    r14 = r13 >= 0 :: signed
    if not r14 goto L17 (error at decode_jsonrpc_batch:129) else goto L6 :: bool
L6:
    r15 = truncate r13: i32 to builtins.bool
    if r15 goto L7 else goto L14 :: bool
L7:
    r16 = PyList_New(0)
    if is_error(r16) goto L17 (error at decode_jsonrpc_batch:129) else goto L8
L8:
    r17 = PyObject_GetIter(decoded)
    dec_ref decoded
    if is_error(r17) goto L18 (error at decode_jsonrpc_batch:129) else goto L9
L9:
    r18 = PyIter_Next(r17)
    if is_error(r18) goto L19 else goto L10
L10:
    r19 = RawResponse(r18)
    dec_ref r18
    if is_error(r19) goto L20 (error at decode_jsonrpc_batch:129) else goto L11
L11:
    r20 = PyList_Append(r16, r19)
    dec_ref r19
    r21 = r20 >= 0 :: signed
    if not r21 goto L20 (error at decode_jsonrpc_batch:129) else goto L9 :: bool
L12:
    r22 = CPy_NoErrOccurred()
    if not r22 goto L18 (error at decode_jsonrpc_batch:129) else goto L13 :: bool
L13:
    r23 = r16
    goto L15
L14:
    r23 = decoded
L15:
    return r23
L16:
    r24 = <error> :: union[object, list]
    return r24
L17:
    dec_ref decoded
    goto L16
L18:
    dec_ref r16
    goto L16
L19:
    dec_ref r17
    goto L12
L20:
    dec_ref r16
    dec_ref r17
    goto L16

def _encode_hook(obj):
    obj :: union[int, object, bytes]
    r0 :: object
    r1 :: object[1]
    r2 :: object_ptr
    r3 :: object
    r4 :: int
    r5 :: object
    r6 :: str
    r7, r8 :: object
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    r12 :: str
    r13 :: tuple[object, object, object]
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: bit
    r18, e :: object
    r19 :: dict
    r20 :: str
    r21 :: object
    r22 :: i32
    r23 :: bit
    r24 :: bool
    r25 :: dict
    r26 :: object
    r27 :: str
    r28 :: object[1]
    r29 :: object_ptr
    r30, r31, r32 :: object
    r33 :: tuple[object, object]
    r34, r35, r36 :: object
    r37 :: i32
    r38, r39 :: bit
    r40, r41 :: object
    r42 :: str
    r43 :: object
    r44 :: object[2]
    r45 :: object_ptr
    r46, r47 :: object
    r48 :: str
    r49 :: object
    r50 :: bit
    r51, r52 :: object
    r53 :: bool
    r54 :: i32
    r55 :: bit
    r56 :: bool
    r57 :: object
    r58 :: str
    r59 :: object[1]
    r60 :: object_ptr
    r61 :: object
    r62 :: str
    r63 :: object
    r64 :: tuple
    r65 :: object
    r66 :: list
    r67 :: object
    r68 :: i32
    r69 :: bit
    r70 :: i32
    r71 :: bit
    r72 :: tuple
    r73 :: str
    r74 :: i32
    r75 :: bit
    r76, r77 :: object
    r78 :: str
    r79 :: object
    r80 :: object[2]
    r81 :: object_ptr
    r82 :: object
    r83 :: bit
    r84 :: union[object, list, dict]
L0:
L1:
    r0 = load_address PyLong_Type
    r1 = [obj]
    r2 = load_address r1
    r3 = _PyObject_Vectorcall(r0, r2, 1, 0)
    if is_error(r3) goto L7 (error at _encode_hook:147) else goto L2
L2:
    r4 = unbox(int, r3)
    dec_ref r3
    if is_error(r4) goto L7 (error at _encode_hook:147) else goto L3
L3:
    r5 = builtins :: module
    r6 = 'hex'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L53 (error at _encode_hook:147) else goto L4
L4:
    r8 = box(int, r4)
    r9 = [r8]
    r10 = load_address r9
    r11 = _PyObject_Vectorcall(r7, r10, 1, 0)
    dec_ref r7
    if is_error(r11) goto L54 (error at _encode_hook:147) else goto L5
L5:
    dec_ref r8
    r12 = cast(str, r11)
    if is_error(r12) goto L7 (error at _encode_hook:147) else goto L6
L6:
    return r12
L7:
    r13 = CPy_CatchError()
    r14 = builtins :: module
    r15 = 'TypeError'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L50 (error at _encode_hook:148) else goto L8
L8:
    r17 = CPy_ExceptionMatches(r16)
    dec_ref r16
    if r17 goto L9 else goto L26 :: bool
L9:
    r18 = CPy_GetExcValue()
    e = r18
    dec_ref e
    r19 = dank_mids.helpers._codec.globals :: static
    r20 = 'Mapping'
    r21 = CPyDict_GetItem(r19, r20)
    if is_error(r21) goto L50 (error at _encode_hook:151) else goto L10
L10:
    r22 = PyObject_IsInstance(obj, r21)
    dec_ref r21
    r23 = r22 >= 0 :: signed
    if not r23 goto L50 (error at _encode_hook:151) else goto L11 :: bool
L11:
    r24 = truncate r22: i32 to builtins.bool
    if r24 goto L12 else goto L22 :: bool
L12:
    r25 = PyDict_New()
    if is_error(r25) goto L50 (error at _encode_hook:152) else goto L13
L13:
    inc_ref obj
    r26 = obj
    r27 = 'items'
    r28 = [r26]
    r29 = load_address r28
    r30 = PyObject_VectorcallMethod(r27, r29, 9223372036854775809, 0)
    if is_error(r30) goto L55 (error at _encode_hook:152) else goto L14
L14:
    dec_ref r26
L15:
    r31 = PyObject_GetIter(r30)
    dec_ref r30
    if is_error(r31) goto L56 (error at _encode_hook:152) else goto L16
L16:
    r32 = PyIter_Next(r31)
    if is_error(r32) goto L57 else goto L17
L17:
    r33 = unbox(tuple[object, object], r32)
    dec_ref r32
    if is_error(r33) goto L58 (error at _encode_hook:152) else goto L18
L18:
    r34 = r33[0]
    r35 = r33[1]
    dec_ref r33
    r36 = _rudimentary_encode_dict_value(r35)
    dec_ref r35
    if is_error(r36) goto L59 (error at _encode_hook:152) else goto L19
L19:
    r37 = CPyDict_SetItem(r25, r34, r36)
    dec_ref r34
    dec_ref r36
    r38 = r37 >= 0 :: signed
    if not r38 goto L58 (error at _encode_hook:152) else goto L16 :: bool
L20:
    r39 = CPy_NoErrOccurred()
    if not r39 goto L56 (error at _encode_hook:152) else goto L21 :: bool
L21:
    CPy_RestoreExcInfo(r13)
    dec_ref r13
    return r25
L22:
    r40 = PyObject_Type(obj)
    r41 = builtins :: module
    r42 = 'TypeError'
    r43 = CPyObject_GetAttr(r41, r42)
    if is_error(r43) goto L60 (error at _encode_hook:154) else goto L23
L23:
    r44 = [obj, r40]
    r45 = load_address r44
    r46 = _PyObject_Vectorcall(r43, r45, 2, 0)
    dec_ref r43
    if is_error(r46) goto L60 (error at _encode_hook:154) else goto L24
L24:
    dec_ref r40
    CPy_Raise(r46)
    dec_ref r46
    if not 0 goto L50 (error at _encode_hook:154) else goto L61 :: bool
L25:
    unreachable
L26:
    r47 = builtins :: module
    r48 = 'ValueError'
    r49 = CPyObject_GetAttr(r47, r48)
    if is_error(r49) goto L50 (error at _encode_hook:155) else goto L27
L27:
    r50 = CPy_ExceptionMatches(r49)
    dec_ref r49
    if r50 goto L28 else goto L48 :: bool
L28:
    r51 = CPy_GetExcValue()
    e = r51
    r52 = dank_mids.helpers._codec.HexBytes :: static
    if is_error(r52) goto L62 else goto L31
L29:
    r53 = raise NameError('value for final name "HexBytes" was not set')
    if not r53 goto L50 (error at _encode_hook:158) else goto L63 :: bool
L30:
    unreachable
L31:
    r54 = PyObject_IsInstance(obj, r52)
    r55 = r54 >= 0 :: signed
    if not r55 goto L64 (error at _encode_hook:158) else goto L32 :: bool
L32:
    r56 = truncate r54: i32 to builtins.bool
    if r56 goto L65 else goto L36 :: bool
L33:
    inc_ref obj
    r57 = obj
    r58 = 'hex'
    r59 = [r57]
    r60 = load_address r59
    r61 = PyObject_VectorcallMethod(r58, r60, 9223372036854775809, 0)
    if is_error(r61) goto L66 (error at _encode_hook:159) else goto L34
L34:
    dec_ref r57
L35:
    CPy_RestoreExcInfo(r13)
    dec_ref r13
    return r61
L36:
    r62 = 'args'
    r63 = CPyObject_GetAttr(e, r62)
    if is_error(r63) goto L64 (error at _encode_hook:161) else goto L37
L37:
    r64 = cast(tuple, r63)
    if is_error(r64) goto L64 (error at _encode_hook:161) else goto L38
L38:
    r65 = PyObject_Type(obj)
    r66 = PyList_New(0)
    if is_error(r66) goto L67 (error at _encode_hook:161) else goto L39
L39:
    r67 = CPyList_Extend(r66, r64)
    dec_ref r64
    if is_error(r67) goto L68 (error at _encode_hook:161) else goto L69
L40:
    r68 = PyList_Append(r66, obj)
    r69 = r68 >= 0 :: signed
    if not r69 goto L68 (error at _encode_hook:161) else goto L41 :: bool
L41:
    r70 = PyList_Append(r66, r65)
    dec_ref r65
    r71 = r70 >= 0 :: signed
    if not r71 goto L70 (error at _encode_hook:161) else goto L42 :: bool
L42:
    r72 = PyList_AsTuple(r66)
    dec_ref r66
    if is_error(r72) goto L64 (error at _encode_hook:161) else goto L43
L43:
    r73 = 'args'
    r74 = PyObject_SetAttr(e, r73, r72)
    dec_ref e
    dec_ref r72
    r75 = r74 >= 0 :: signed
    if not r75 goto L50 (error at _encode_hook:161) else goto L44 :: bool
L44:
    r76 = PyObject_Type(obj)
    r77 = builtins :: module
    r78 = 'ValueError'
    r79 = CPyObject_GetAttr(r77, r78)
    if is_error(r79) goto L71 (error at _encode_hook:162) else goto L45
L45:
    r80 = [obj, r76]
    r81 = load_address r80
    r82 = _PyObject_Vectorcall(r79, r81, 2, 0)
    dec_ref r79
    if is_error(r82) goto L71 (error at _encode_hook:162) else goto L46
L46:
    dec_ref r76
    CPy_Raise(r82)
    dec_ref r82
    if not 0 goto L50 (error at _encode_hook:162) else goto L72 :: bool
L47:
    unreachable
L48:
    CPy_Reraise()
    if not 0 goto L50 else goto L73 :: bool
L49:
    unreachable
L50:
    CPy_RestoreExcInfo(r13)
    dec_ref r13
    r83 = CPy_KeepPropagating()
    if not r83 goto L52 else goto L51 :: bool
L51:
    unreachable
L52:
    r84 = <error> :: union[object, list, dict]
    return r84
L53:
    dec_ref r4 :: int
    goto L7
L54:
    dec_ref r8
    goto L7
L55:
    dec_ref r25
    dec_ref r26
    goto L50
L56:
    dec_ref r25
    goto L50
L57:
    dec_ref r31
    goto L20
L58:
    dec_ref r25
    dec_ref r31
    goto L50
L59:
    dec_ref r25
    dec_ref r31
    dec_ref r34
    goto L50
L60:
    dec_ref r40
    goto L50
L61:
    dec_ref r13
    goto L25
L62:
    dec_ref e
    goto L29
L63:
    dec_ref r13
    goto L30
L64:
    dec_ref e
    goto L50
L65:
    dec_ref e
    goto L33
L66:
    dec_ref r57
    goto L50
L67:
    dec_ref e
    dec_ref r64
    dec_ref r65
    goto L50
L68:
    dec_ref e
    dec_ref r65
    dec_ref r66
    goto L50
L69:
    dec_ref r67
    goto L40
L70:
    dec_ref e
    dec_ref r66
    goto L50
L71:
    dec_ref r76
    goto L50
L72:
    dec_ref r13
    goto L47
L73:
    dec_ref r13
    goto L49

def _rudimentary_encode_dict_value(value):
    value :: union[int, object]
    r0 :: object
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4 :: int
    r5 :: object
    r6 :: str
    r7, r8 :: object
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    r12 :: str
    r13 :: union[str, object]
    r14 :: object
L0:
    r0 = load_address PyLong_Type
    r1 = PyObject_IsInstance(value, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L9 (error at _rudimentary_encode_dict_value:171) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L2 else goto L7 :: bool
L2:
    r4 = unbox(int, value)
    if is_error(r4) goto L9 (error at _rudimentary_encode_dict_value:171) else goto L3
L3:
    r5 = builtins :: module
    r6 = 'hex'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L10 (error at _rudimentary_encode_dict_value:171) else goto L4
L4:
    r8 = box(int, r4)
    r9 = [r8]
    r10 = load_address r9
    r11 = _PyObject_Vectorcall(r7, r10, 1, 0)
    dec_ref r7
    if is_error(r11) goto L11 (error at _rudimentary_encode_dict_value:171) else goto L5
L5:
    dec_ref r8
    r12 = cast(str, r11)
    if is_error(r12) goto L9 (error at _rudimentary_encode_dict_value:171) else goto L6
L6:
    r13 = r12
    goto L8
L7:
    inc_ref value
    r13 = value
L8:
    return r13
L9:
    r14 = <error> :: object
    return r14
L10:
    dec_ref r4 :: int
    goto L9
L11:
    dec_ref r8
    goto L9

def __mypyc_lambda__0_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def __mypyc_lambda__0_obj.__call__(__mypyc_self__, _):
    __mypyc_self__ :: dank_mids.helpers._codec.__mypyc_lambda__0_obj
    _, r0 :: object
L0:
    r0 = load_address _Py_EllipsisObject
    inc_ref r0
    return r0

def _int_to_big_endian(value):
    value :: int
    r0 :: str
    r1 :: object
    r2 :: object[1]
    r3 :: object_ptr
    r4 :: object
    r5, r6, r7 :: int
    r8 :: bit
    r9 :: int
    r10, r11 :: str
    r12, r13 :: object
    r14 :: object[3]
    r15 :: object_ptr
    r16 :: object
    r17, r18 :: bytes
L0:
    r0 = 'bit_length'
    inc_ref value :: int
    r1 = box(int, value)
    r2 = [r1]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r0, r3, 9223372036854775809, 0)
    if is_error(r4) goto L10 (error at _int_to_big_endian:204) else goto L1
L1:
    dec_ref r1
    r5 = unbox(int, r4)
    dec_ref r4
    if is_error(r5) goto L9 (error at _int_to_big_endian:204) else goto L2
L2:
    r6 = CPyTagged_Add(r5, 14)
    dec_ref r5 :: int
    r7 = CPyTagged_Rshift(r6, 6)
    dec_ref r6 :: int
    if is_error(r7) goto L9 (error at _int_to_big_endian:-1) else goto L3
L3:
    r8 = r7 != 0
    if r8 goto L4 else goto L11 :: bool
L4:
    r9 = r7
    goto L6
L5:
    r9 = 2
L6:
    r10 = 'big'
    r11 = 'to_bytes'
    inc_ref value :: int
    r12 = box(int, value)
    r13 = box(int, r9)
    r14 = [r12, r13, r10]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r11, r15, 9223372036854775811, 0)
    if is_error(r16) goto L12 (error at _int_to_big_endian:204) else goto L7
L7:
    dec_ref r12
    dec_ref r13
    r17 = cast(bytes, r16)
    if is_error(r17) goto L9 (error at _int_to_big_endian:204) else goto L8
L8:
    return r17
L9:
    r18 = <error> :: bytes
    return r18
L10:
    dec_ref r1
    goto L9
L11:
    dec_ref r7 :: int
    goto L5
L12:
    dec_ref r12
    dec_ref r13
    goto L9

def _encode_uint_256(i):
    i :: int
    r0, r1 :: bytes
    r2 :: str
    r3 :: object
    r4 :: object[3]
    r5 :: object_ptr
    r6 :: object
    r7, r8 :: bytes
L0:
    r0 = _int_to_big_endian(i)
    if is_error(r0) goto L4 (error at _encode_uint_256:208) else goto L1
L1:
    r1 = b'\x00'
    r2 = 'rjust'
    r3 = object 32
    r4 = [r0, r3, r1]
    r5 = load_address r4
    r6 = PyObject_VectorcallMethod(r2, r5, 9223372036854775811, 0)
    if is_error(r6) goto L5 (error at _encode_uint_256:209) else goto L2
L2:
    dec_ref r0
    r7 = cast(bytes, r6)
    if is_error(r7) goto L4 (error at _encode_uint_256:209) else goto L3
L3:
    return r7
L4:
    r8 = <error> :: bytes
    return r8
L5:
    dec_ref r0
    goto L4

def __encode_new(values):
    values :: object
    r0 :: tuple[bytes, int]
    r1, r2 :: bytes
    r3, r4 :: int
    r5, r6, r7 :: bytes
L0:
    r0 = __encode_elements_new(values)
    if is_error(r0) goto L4 (error at __encode_new:213) else goto L1
L1:
    r1 = borrow r0[0]
    r2 = unborrow r1
    r3 = borrow r0[1]
    r4 = unborrow r3
    r5 = _encode_uint_256(r4)
    dec_ref r4 :: int
    if is_error(r5) goto L5 (error at __encode_new:214) else goto L2
L2:
    r6 = CPyBytes_Concat(r5, r2)
    dec_ref r2
    if is_error(r6) goto L4 (error at __encode_new:214) else goto L3
L3:
    return r6
L4:
    r7 = <error> :: bytes
    return r7
L5:
    dec_ref r2
    goto L4

def __encode_elements_new(values):
    values :: object
    r0 :: list
    r1, r2 :: object
    r3 :: tuple[object, object]
    r4 :: object
    r5 :: bool
    r6 :: object
    r7 :: object[1]
    r8 :: object_ptr
    r9 :: object
    r10 :: i32
    r11, r12 :: bit
    r13 :: ptr
    r14 :: native_int
    r15 :: short_int
    count, r16 :: int
    r17 :: list
    r18 :: object
    r19, r20 :: ptr
    offset :: int
    r21 :: object
    r22 :: list
    r23 :: short_int
    r24 :: ptr
    r25 :: native_int
    r26 :: short_int
    r27 :: bit
    r28 :: native_int
    r29, r30 :: ptr
    r31 :: native_int
    r32 :: ptr
    r33 :: object
    r34, r35 :: int
    r36 :: object
    r37 :: i32
    r38 :: bit
    r39 :: short_int
    r40 :: ptr
    r41 :: native_int
    r42 :: list
    r43 :: short_int
    r44 :: ptr
    r45 :: native_int
    r46 :: short_int
    r47 :: bit
    r48 :: native_int
    r49, r50 :: ptr
    r51 :: native_int
    r52 :: ptr
    r53 :: object
    r54, r55 :: int
    r56 :: bytes
    r57 :: bit
    r58 :: short_int
    r59 :: object
    r60 :: bytes
    r61 :: list
    r62, r63 :: object
    r64 :: tuple
    r65 :: bytes
    r66, r67 :: tuple[bytes, int]
L0:
    r0 = PyList_New(0)
    if is_error(r0) goto L32 (error at __encode_elements_new:218) else goto L1
L1:
    r1 = PyObject_GetIter(values)
    if is_error(r1) goto L33 (error at __encode_elements_new:218) else goto L2
L2:
    r2 = PyIter_Next(r1)
    if is_error(r2) goto L34 else goto L3
L3:
    r3 = unbox(tuple[object, object], r2)
    dec_ref r2
    if is_error(r3) goto L35 (error at __encode_elements_new:218) else goto L4
L4:
    r4 = dank_mids.helpers._codec._item_encoder :: static
    if is_error(r4) goto L36 else goto L7
L5:
    r5 = raise NameError('value for final name "_item_encoder" was not set')
    if not r5 goto L32 (error at __encode_elements_new:218) else goto L6 :: bool
L6:
    unreachable
L7:
    r6 = box(tuple[object, object], r3)
    r7 = [r6]
    r8 = load_address r7
    r9 = _PyObject_Vectorcall(r4, r8, 1, 0)
    if is_error(r9) goto L37 (error at __encode_elements_new:218) else goto L8
L8:
    dec_ref r6
    r10 = PyList_Append(r0, r9)
    dec_ref r9
    r11 = r10 >= 0 :: signed
    if not r11 goto L35 (error at __encode_elements_new:218) else goto L2 :: bool
L9:
    r12 = CPy_NoErrOccurred()
    if not r12 goto L33 (error at __encode_elements_new:218) else goto L10 :: bool
L10:
    r13 = get_element_ptr r0 ob_size :: PyVarObject
    r14 = load_mem r13 :: native_int*
    r15 = r14 << 1
    count = r15
    r16 = CPyTagged_Multiply(64, count)
    r17 = PyList_New(1)
    if is_error(r17) goto L38 (error at __encode_elements_new:221) else goto L11
L11:
    r18 = object 0
    r19 = get_element_ptr r17 ob_item :: PyListObject
    r20 = load_mem r19 :: ptr*
    inc_ref r18
    set_mem r20, r18 :: builtins.object*
    offset = 0
    r21 = CPyList_GetSlice(r0, 0, -2)
    if is_error(r21) goto L39 (error at __encode_elements_new:223) else goto L12
L12:
    r22 = cast(list, r21)
    if is_error(r22) goto L39 (error at __encode_elements_new:223) else goto L13
L13:
    r23 = 0
L14:
    r24 = get_element_ptr r22 ob_size :: PyVarObject
    r25 = load_mem r24 :: native_int*
    r26 = r25 << 1
    r27 = r23 < r26 :: signed
    if r27 goto L15 else goto L40 :: bool
L15:
    r28 = r23 >> 1
    r29 = get_element_ptr r22 ob_item :: PyListObject
    r30 = load_mem r29 :: ptr*
    r31 = r28 * 8
    r32 = r30 + r31
    r33 = load_mem r32 :: builtins.object*
    inc_ref r33
    r34 = CPyObject_Size(r33)
    dec_ref r33
    if is_error(r34) goto L41 (error at __encode_elements_new:224) else goto L16
L16:
    r35 = CPyTagged_Add(offset, r34)
    dec_ref offset :: int
    dec_ref r34 :: int
    offset = r35
    inc_ref offset :: int
    r36 = box(int, offset)
    r37 = PyList_Append(r17, r36)
    dec_ref r36
    r38 = r37 >= 0 :: signed
    if not r38 goto L41 (error at __encode_elements_new:225) else goto L17 :: bool
L17:
    r39 = r23 + 2
    r23 = r39
    goto L14
L18:
    r40 = get_element_ptr r17 ob_size :: PyVarObject
    r41 = load_mem r40 :: native_int*
    r42 = PyList_New(r41)
    if is_error(r42) goto L42 (error at __encode_elements_new:226) else goto L19
L19:
    r43 = 0
L20:
    r44 = get_element_ptr r17 ob_size :: PyVarObject
    r45 = load_mem r44 :: native_int*
    r46 = r45 << 1
    r47 = r43 < r46 :: signed
    if r47 goto L21 else goto L43 :: bool
L21:
    r48 = r43 >> 1
    r49 = get_element_ptr r17 ob_item :: PyListObject
    r50 = load_mem r49 :: ptr*
    r51 = r48 * 8
    r52 = r50 + r51
    r53 = load_mem r52 :: builtins.object*
    inc_ref r53
    r54 = unbox(int, r53)
    dec_ref r53
    if is_error(r54) goto L44 (error at __encode_elements_new:226) else goto L22
L22:
    r55 = CPyTagged_Add(r16, r54)
    dec_ref r54 :: int
    r56 = _encode_uint_256(r55)
    dec_ref r55 :: int
    if is_error(r56) goto L44 (error at __encode_elements_new:226) else goto L23
L23:
    r57 = CPyList_SetItemUnsafe(r42, r43, r56)
    if not r57 goto L44 (error at __encode_elements_new:226) else goto L24 :: bool
L24:
    r58 = r43 + 2
    r43 = r58
    goto L20
L25:
    r59 = PyObject_GetIter(r42)
    dec_ref r42
    if is_error(r59) goto L45 (error at __encode_elements_new:226) else goto L26
L26:
    r60 = b''
    r61 = PyList_New(0)
    if is_error(r61) goto L46 (error at __encode_elements_new:227) else goto L27
L27:
    r62 = CPyList_Extend(r61, r59)
    dec_ref r59
    if is_error(r62) goto L47 (error at __encode_elements_new:227) else goto L48
L28:
    r63 = CPyList_Extend(r61, r0)
    dec_ref r0
    if is_error(r63) goto L49 (error at __encode_elements_new:227) else goto L50
L29:
    r64 = PyList_AsTuple(r61)
    dec_ref r61
    if is_error(r64) goto L51 (error at __encode_elements_new:227) else goto L30
L30:
    r65 = CPyBytes_Join(r60, r64)
    dec_ref r64
    if is_error(r65) goto L51 (error at __encode_elements_new:227) else goto L31
L31:
    r66 = (r65, count)
    return r66
L32:
    r67 = <error> :: tuple[bytes, int]
    return r67
L33:
    dec_ref r0
    goto L32
L34:
    dec_ref r1
    goto L9
L35:
    dec_ref r0
    dec_ref r1
    goto L32
L36:
    dec_ref r0
    dec_ref r1
    dec_ref r3
    goto L5
L37:
    dec_ref r0
    dec_ref r1
    dec_ref r6
    goto L32
L38:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    goto L32
L39:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r17
    dec_ref offset :: int
    goto L32
L40:
    dec_ref offset :: int
    dec_ref r22
    goto L18
L41:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r17
    dec_ref offset :: int
    dec_ref r22
    goto L32
L42:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r17
    goto L32
L43:
    dec_ref r16 :: int
    dec_ref r17
    goto L25
L44:
    dec_ref r0
    dec_ref count :: int
    dec_ref r16 :: int
    dec_ref r17
    dec_ref r42
    goto L32
L45:
    dec_ref r0
    dec_ref count :: int
    goto L32
L46:
    dec_ref r0
    dec_ref count :: int
    dec_ref r59
    goto L32
L47:
    dec_ref r0
    dec_ref count :: int
    dec_ref r61
    goto L32
L48:
    dec_ref r62
    goto L28
L49:
    dec_ref count :: int
    dec_ref r61
    goto L32
L50:
    dec_ref r63
    goto L29
L51:
    dec_ref count :: int
    goto L32

def mcall_encode(data):
    data :: object
    r0 :: tuple[bool, object]
    r1 :: object
    r2 :: bool
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6 :: object
    r7, r8 :: bytes
L0:
    inc_ref data
    r0 = (0, data)
    r1 = dank_mids.helpers._codec._mcall_encoder :: static
    if is_error(r1) goto L7 else goto L3
L1:
    r2 = raise NameError('value for final name "_mcall_encoder" was not set')
    if not r2 goto L6 (error at mcall_encode:240) else goto L2 :: bool
L2:
    unreachable
L3:
    r3 = box(tuple[bool, object], r0)
    r4 = [r3]
    r5 = load_address r4
    r6 = _PyObject_Vectorcall(r1, r5, 1, 0)
    if is_error(r6) goto L8 (error at mcall_encode:240) else goto L4
L4:
    dec_ref r3
    r7 = cast(bytes, r6)
    if is_error(r7) goto L6 (error at mcall_encode:240) else goto L5
L5:
    return r7
L6:
    r8 = <error> :: bytes
    return r8
L7:
    dec_ref r0
    goto L1
L8:
    dec_ref r3
    goto L6

def mcall_decode(data):
    data :: object
    r0, r1 :: str
    r2 :: object[2]
    r3 :: object_ptr
    r4, r5 :: object
    r6 :: bool
    r7 :: object[1]
    r8 :: object_ptr
    r9, r10 :: object
    r11 :: bool
    r12 :: object[1]
    r13 :: object_ptr
    r14 :: object
    r15 :: tuple[int, int, tuple]
    r16 :: tuple
    r17 :: tuple[object, object, object]
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: bit
    r22 :: object
    r23 :: dict
    r24 :: str
    r25, r26 :: object
    r27 :: bit
    r28 :: None
    r29 :: str
    r30 :: object
    r31 :: tuple
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: i32
    r36 :: bit
    r37 :: bool
    r38 :: str
    r39 :: object[1]
    r40 :: object_ptr
    r41 :: object
    r42 :: union[object, str]
    r43 :: list
    r44 :: object
    r45 :: i32
    r46 :: bit
    r47 :: tuple
    r48 :: str
    r49 :: i32
    r50, r51 :: bit
    r52 :: ptr
    r53 :: native_int
    r54 :: list
    r55 :: short_int
    r56 :: ptr
    r57 :: native_int
    r58 :: short_int
    r59 :: bit
    r60 :: object
    r61 :: tuple[bool, bytes]
    r62 :: bytes
    r63 :: bit
    r64 :: short_int
    r65 :: union[list, object]
L0:
L1:
    r0 = 'eth_call'
    r1 = 'decode_result'
    r2 = [data, r0]
    r3 = load_address r2
    r4 = PyObject_VectorcallMethod(r1, r3, 9223372036854775810, 0)
    if is_error(r4) goto L12 (error at mcall_decode:249) else goto L2
L2:
    r5 = dank_mids.helpers._codec.ContextFramesBytesIO :: static
    if is_error(r5) goto L44 else goto L5
L3:
    r6 = raise NameError('value for final name "ContextFramesBytesIO" was not set')
    if not r6 goto L12 (error at mcall_decode:249) else goto L4 :: bool
L4:
    unreachable
L5:
    r7 = [r4]
    r8 = load_address r7
    r9 = _PyObject_Vectorcall(r5, r8, 1, 0)
    if is_error(r9) goto L45 (error at mcall_decode:249) else goto L6
L6:
    dec_ref r4
    r10 = dank_mids.helpers._codec._mcall_decoder :: static
    if is_error(r10) goto L46 else goto L9
L7:
    r11 = raise NameError('value for final name "_mcall_decoder" was not set')
    if not r11 goto L12 (error at mcall_decode:249) else goto L8 :: bool
L8:
    unreachable
L9:
    r12 = [r9]
    r13 = load_address r12
    r14 = _PyObject_Vectorcall(r10, r13, 1, 0)
    if is_error(r14) goto L47 (error at mcall_decode:249) else goto L10
L10:
    dec_ref r9
    r15 = unbox(tuple[int, int, tuple], r14)
    dec_ref r14
    if is_error(r15) goto L12 (error at mcall_decode:249) else goto L11
L11:
    r16 = r15[2]
    dec_ref r15
    goto L35
L12:
    r17 = CPy_CatchError()
    r18 = builtins :: module
    r19 = 'Exception'
    r20 = CPyObject_GetAttr(r18, r19)
    if is_error(r20) goto L33 (error at mcall_decode:250) else goto L13
L13:
    r21 = CPy_ExceptionMatches(r20)
    dec_ref r20
    if r21 goto L14 else goto L31 :: bool
L14:
    r22 = CPy_GetExcValue()
    r23 = dank_mids.helpers._codec.globals :: static
    r24 = 'PartialResponse'
    r25 = CPyDict_GetItem(r23, r24)
    if is_error(r25) goto L48 (error at mcall_decode:251) else goto L15
L15:
    r26 = load_address _Py_NoneStruct
    r27 = r25 == r26
    dec_ref r25
    if r27 goto L16 else goto L17 :: bool
L16:
    r28 = __import_from_types()
    if is_error(r28) goto L48 (error at mcall_decode:252) else goto L17
L17:
    r29 = 'args'
    r30 = CPyObject_GetAttr(r22, r29)
    if is_error(r30) goto L48 (error at mcall_decode:254) else goto L18
L18:
    r31 = cast(tuple, r30)
    if is_error(r31) goto L48 (error at mcall_decode:254) else goto L19
L19:
    r32 = dank_mids.helpers._codec.globals :: static
    r33 = 'PartialResponse'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L49 (error at mcall_decode:254) else goto L20
L20:
    r35 = PyObject_IsInstance(data, r34)
    dec_ref r34
    r36 = r35 >= 0 :: signed
    if not r36 goto L49 (error at mcall_decode:254) else goto L21 :: bool
L21:
    r37 = truncate r35: i32 to builtins.bool
    if r37 goto L22 else goto L24 :: bool
L22:
    r38 = 'decode_result'
    r39 = [data]
    r40 = load_address r39
    r41 = PyObject_VectorcallMethod(r38, r40, 9223372036854775809, 0)
    if is_error(r41) goto L49 (error at mcall_decode:254) else goto L23
L23:
    r42 = r41
    goto L25
L24:
    inc_ref data
    r42 = data
L25:
    r43 = PyList_New(0)
    if is_error(r43) goto L50 (error at mcall_decode:254) else goto L26
L26:
    r44 = CPyList_Extend(r43, r31)
    dec_ref r31
    if is_error(r44) goto L51 (error at mcall_decode:254) else goto L52
L27:
    r45 = PyList_Append(r43, r42)
    dec_ref r42
    r46 = r45 >= 0 :: signed
    if not r46 goto L53 (error at mcall_decode:254) else goto L28 :: bool
L28:
    r47 = PyList_AsTuple(r43)
    dec_ref r43
    if is_error(r47) goto L48 (error at mcall_decode:254) else goto L29
L29:
    r48 = 'args'
    r49 = PyObject_SetAttr(r22, r48, r47)
    dec_ref r47
    r50 = r49 >= 0 :: signed
    if not r50 goto L48 (error at mcall_decode:254) else goto L30 :: bool
L30:
    CPy_RestoreExcInfo(r17)
    dec_ref r17
    return r22
L31:
    CPy_Reraise()
    if not 0 goto L33 else goto L54 :: bool
L32:
    unreachable
L33:
    CPy_RestoreExcInfo(r17)
    dec_ref r17
    r51 = CPy_KeepPropagating()
    if not r51 goto L43 else goto L34 :: bool
L34:
    unreachable
L35:
    r52 = get_element_ptr r16 ob_size :: PyVarObject
    r53 = load_mem r52 :: native_int*
    r54 = PyList_New(r53)
    if is_error(r54) goto L55 (error at mcall_decode:257) else goto L36
L36:
    r55 = 0
L37:
    r56 = get_element_ptr r16 ob_size :: PyVarObject
    r57 = load_mem r56 :: native_int*
    r58 = r57 << 1
    r59 = r55 < r58 :: signed
    if r59 goto L38 else goto L56 :: bool
L38:
    r60 = CPySequenceTuple_GetItem(r16, r55)
    if is_error(r60) goto L57 (error at mcall_decode:257) else goto L39
L39:
    r61 = unbox(tuple[bool, bytes], r60)
    dec_ref r60
    if is_error(r61) goto L57 (error at mcall_decode:257) else goto L40
L40:
    r62 = r61[1]
    dec_ref r61
    r63 = CPyList_SetItemUnsafe(r54, r55, r62)
    if not r63 goto L57 (error at mcall_decode:257) else goto L41 :: bool
L41:
    r64 = r55 + 2
    r55 = r64
    goto L37
L42:
    return r54
L43:
    r65 = <error> :: union[list, object]
    return r65
L44:
    dec_ref r4
    goto L3
L45:
    dec_ref r4
    goto L12
L46:
    dec_ref r9
    goto L7
L47:
    dec_ref r9
    goto L12
L48:
    dec_ref r22
    goto L33
L49:
    dec_ref r22
    dec_ref r31
    goto L33
L50:
    dec_ref r22
    dec_ref r31
    dec_ref r42
    goto L33
L51:
    dec_ref r22
    dec_ref r42
    dec_ref r43
    goto L33
L52:
    dec_ref r44
    goto L27
L53:
    dec_ref r22
    dec_ref r43
    goto L33
L54:
    dec_ref r17
    goto L32
L55:
    dec_ref r16
    goto L43
L56:
    dec_ref r16
    goto L42
L57:
    dec_ref r16
    dec_ref r54
    goto L43

def __import_from_types():
    r0 :: object
    r1 :: str
    r2 :: dict
    r3 :: object
    r4 :: None
L0:
    r0 = ('PartialResponse', 'Request', 'Response', 'better_decode')
    r1 = 'dank_mids.types'
    r2 = dank_mids.helpers._codec.globals :: static
    r3 = CPyImport_ImportFromMany(r1, r0, r0, r2)
    if is_error(r3) goto L2 (error at __import_from_types:263) else goto L1
L1:
    dank_mids.types = r3 :: module
    dec_ref r3
    return 1
L2:
    r4 = <error> :: None
    return r4

def __make_decode_batch():
    r0 :: object
    r1 :: str
    r2 :: dict
    r3 :: object
    r4 :: dict
    r5 :: str
    r6 :: object
    r7 :: dict
    r8 :: str
    r9 :: object
    r10 :: dict
    r11 :: str
    r12 :: object
    r13 :: str
    r14, r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: object
    r19 :: tuple[object, object]
    r20, r21 :: object
    r22 :: dict
    r23 :: str
    r24 :: object
    r25 :: object[1]
    r26 :: object_ptr
    r27, r28 :: object
    r29 :: str
    r30 :: object
    r31 :: dict
    r32 :: str
    r33 :: i32
    r34 :: bit
    r35 :: None
L0:
    r0 = ('PartialResponse',)
    r1 = 'dank_mids.types'
    r2 = dank_mids.helpers._codec.globals :: static
    r3 = CPyImport_ImportFromMany(r1, r0, r0, r2)
    if is_error(r3) goto L13 (error at __make_decode_batch:267) else goto L1
L1:
    dank_mids.types = r3 :: module
    dec_ref r3
    r4 = dank_mids.helpers._codec.globals :: static
    r5 = 'Union'
    r6 = CPyDict_GetItem(r4, r5)
    if is_error(r6) goto L13 (error at __make_decode_batch:270) else goto L2
L2:
    r7 = dank_mids.helpers._codec.globals :: static
    r8 = 'List'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L14 (error at __make_decode_batch:270) else goto L3
L3:
    r10 = dank_mids.helpers._codec.globals :: static
    r11 = 'msgspec'
    r12 = CPyDict_GetItem(r10, r11)
    if is_error(r12) goto L15 (error at __make_decode_batch:270) else goto L4
L4:
    r13 = 'Raw'
    r14 = CPyObject_GetAttr(r12, r13)
    dec_ref r12
    if is_error(r14) goto L15 (error at __make_decode_batch:270) else goto L5
L5:
    r15 = PyObject_GetItem(r9, r14)
    dec_ref r9
    dec_ref r14
    if is_error(r15) goto L14 (error at __make_decode_batch:270) else goto L6
L6:
    r16 = dank_mids.helpers._codec.globals :: static
    r17 = 'PartialResponse'
    r18 = CPyDict_GetItem(r16, r17)
    if is_error(r18) goto L16 (error at __make_decode_batch:270) else goto L7
L7:
    r19 = (r15, r18)
    r20 = box(tuple[object, object], r19)
    r21 = PyObject_GetItem(r6, r20)
    dec_ref r6
    dec_ref r20
    if is_error(r21) goto L13 (error at __make_decode_batch:270) else goto L8
L8:
    r22 = dank_mids.helpers._codec.globals :: static
    r23 = 'Decoder'
    r24 = CPyDict_GetItem(r22, r23)
    if is_error(r24) goto L17 (error at __make_decode_batch:270) else goto L9
L9:
    r25 = [r21]
    r26 = load_address r25
    r27 = ('type',)
    r28 = _PyObject_Vectorcall(r24, r26, 0, r27)
    dec_ref r24
    if is_error(r28) goto L17 (error at __make_decode_batch:270) else goto L10
L10:
    dec_ref r21
    r29 = 'decode'
    r30 = CPyObject_GetAttr(r28, r29)
    dec_ref r28
    if is_error(r30) goto L13 (error at __make_decode_batch:270) else goto L11
L11:
    r31 = dank_mids.helpers._codec.globals :: static
    r32 = '_decode_batch'
    r33 = CPyDict_SetItem(r31, r32, r30)
    dec_ref r30
    r34 = r33 >= 0 :: signed
    if not r34 goto L13 (error at __make_decode_batch:270) else goto L12 :: bool
L12:
    return 1
L13:
    r35 = <error> :: None
    return r35
L14:
    dec_ref r6
    goto L13
L15:
    dec_ref r6
    dec_ref r9
    goto L13
L16:
    dec_ref r6
    dec_ref r15
    goto L13
L17:
    dec_ref r21
    goto L13

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9, r10 :: object_ptr
    r11 :: object_ptr[2]
    r12 :: c_ptr
    r13 :: native_int[2]
    r14 :: c_ptr
    r15 :: object
    r16 :: dict
    r17, r18 :: str
    r19 :: bit
    r20 :: object
    r21 :: str
    r22 :: dict
    r23, r24 :: object
    r25 :: str
    r26 :: dict
    r27, r28 :: object
    r29 :: str
    r30 :: dict
    r31, r32 :: object
    r33 :: str
    r34 :: dict
    r35, r36 :: object
    r37 :: str
    r38 :: dict
    r39 :: object
    r40 :: dict
    r41 :: str
    r42 :: object
    r43 :: i32
    r44 :: bit
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: i32
    r49 :: bit
    r50 :: dict
    r51 :: str
    r52 :: object
    r53 :: i32
    r54 :: bit
    r55 :: dict
    r56 :: str
    r57 :: object
    r58 :: i32
    r59 :: bit
    r60 :: str
    r61 :: dict
    r62 :: str
    r63 :: object
    r64 :: object[1]
    r65 :: object_ptr
    r66 :: object
    r67 :: dict
    r68 :: str
    r69 :: i32
    r70 :: bit
    r71 :: dict
    r72 :: str
    r73 :: object
    r74 :: dict
    r75 :: str
    r76 :: object
    r77 :: dict
    r78 :: str
    r79 :: object
    r80 :: tuple[object, object]
    r81, r82 :: object
    r83 :: dict
    r84 :: str
    r85 :: i32
    r86 :: bit
    r87 :: dict
    r88 :: str
    r89, r90 :: object
    r91 :: dict
    r92 :: str
    r93 :: object
    r94 :: dict
    r95 :: str
    r96 :: object
    r97 :: str
    r98, r99 :: object
    r100 :: tuple[object, object, object, object]
    r101, r102 :: object
    r103 :: dict
    r104 :: str
    r105 :: i32
    r106 :: bit
    r107 :: dict
    r108 :: str
    r109 :: object
    r110 :: dict
    r111 :: str
    r112 :: object
    r113 :: dict
    r114 :: str
    r115 :: object
    r116 :: dict
    r117 :: str
    r118, r119 :: object
    r120 :: dict
    r121 :: str
    r122, r123 :: object
    r124 :: dict
    r125 :: str
    r126 :: object
    r127 :: tuple[object, object]
    r128, r129 :: object
    r130 :: tuple[object, object, object]
    r131, r132 :: object
    r133 :: dict
    r134 :: str
    r135 :: i32
    r136 :: bit
    r137 :: dict
    r138 :: str
    r139 :: object
    r140 :: dict
    r141 :: str
    r142 :: object
    r143 :: dict
    r144 :: str
    r145 :: object
    r146 :: str
    r147 :: object
    r148 :: tuple[object, object]
    r149, r150 :: object
    r151 :: dict
    r152 :: str
    r153 :: i32
    r154 :: bit
    r155 :: dict
    r156 :: str
    r157 :: object
    r158 :: dict
    r159 :: str
    r160, r161 :: object
    r162 :: dict
    r163 :: str
    r164 :: object
    r165 :: dict
    r166 :: str
    r167, r168 :: object
    r169 :: tuple[object, object]
    r170, r171 :: object
    r172 :: list
    r173, r174 :: ptr
    r175 :: object
    r176 :: tuple[list, object]
    r177, r178 :: object
    r179 :: dict
    r180 :: str
    r181 :: i32
    r182 :: bit
    r183 :: dict
    r184 :: str
    r185, r186, r187 :: object
    r188 :: dict
    r189 :: str
    r190 :: object
    r191 :: dict
    r192 :: str
    r193 :: object
    r194 :: str
    r195 :: object
    r196 :: tuple[str, object]
    r197, r198, r199 :: object
    r200 :: tuple[object, object]
    r201, r202 :: object
    r203 :: tuple[object, object, object]
    r204, r205 :: object
    r206 :: dict
    r207 :: str
    r208 :: i32
    r209 :: bit
    r210 :: dict
    r211 :: str
    r212, r213 :: object
    r214 :: dict
    r215 :: str
    r216 :: object
    r217 :: tuple[object, object]
    r218, r219 :: object
    r220 :: dict
    r221 :: str
    r222 :: i32
    r223 :: bit
    r224 :: dict
    r225 :: str
    r226 :: object
    r227 :: str
    r228 :: object
    r229 :: dict
    r230 :: str
    r231 :: i32
    r232 :: bit
    r233 :: dict
    r234 :: str
    r235 :: object
    r236 :: dict
    r237 :: str
    r238 :: object
    r239 :: str
    r240 :: object
    r241 :: str
    r242 :: tuple[object, str]
    r243, r244 :: object
    r245 :: dict
    r246 :: str
    r247 :: i32
    r248 :: bit
    r249 :: dict
    r250 :: str
    r251 :: object
    r252 :: dict
    r253 :: str
    r254, r255, r256 :: object
    r257 :: tuple[object, object]
    r258, r259 :: object
    r260 :: list
    r261, r262 :: ptr
    r263 :: dict
    r264 :: str
    r265 :: object
    r266 :: dict
    r267 :: str
    r268 :: object
    r269 :: dict
    r270 :: str
    r271 :: object
    r272 :: str
    r273, r274 :: object
    r275 :: str
    r276 :: tuple[object, str]
    r277, r278 :: object
    r279 :: tuple[list, object]
    r280, r281 :: object
    r282 :: dict
    r283 :: str
    r284 :: i32
    r285 :: bit
    r286 :: dict
    r287 :: str
    r288 :: object
    r289 :: str
    r290 :: object
    r291 :: dict
    r292 :: str
    r293 :: i32
    r294 :: bit
    r295 :: dict
    r296 :: str
    r297 :: object
    r298 :: str
    r299 :: object
    r300 :: dict
    r301 :: str
    r302 :: i32
    r303 :: bit
    r304 :: dict
    r305 :: str
    r306 :: object
    r307 :: str
    r308 :: object
    r309 :: dict
    r310 :: str
    r311 :: i32
    r312 :: bit
    r313 :: dict
    r314 :: str
    r315 :: object
    r316 :: str
    r317 :: object
    r318 :: dict
    r319 :: str
    r320 :: i32
    r321 :: bit
    r322 :: object
    r323 :: dict
    r324 :: str
    r325 :: object
    r326 :: object[1]
    r327 :: object_ptr
    r328, r329 :: object
    r330 :: str
    r331 :: object
    r332 :: dict
    r333 :: str
    r334 :: i32
    r335 :: bit
    r336 :: object
    r337 :: bool
    r338 :: dict
    r339 :: str
    r340 :: object
    r341 :: object[1]
    r342 :: object_ptr
    r343, r344 :: object
    r345 :: str
    r346 :: object
    r347 :: dict
    r348 :: str
    r349 :: i32
    r350 :: bit
    r351 :: dict
    r352 :: str
    r353 :: object
    r354 :: i32
    r355 :: bit
    r356 :: object
    r357 :: str
    r358, r359 :: object
    r360 :: bool
    r361, r362 :: str
    r363 :: tuple
    r364 :: i32
    r365 :: bit
    r366 :: dict
    r367 :: str
    r368 :: i32
    r369 :: bit
    r370 :: dict
    r371 :: str
    r372 :: object
    r373 :: dict
    r374 :: str
    r375 :: object
    r376 :: object[1]
    r377 :: object_ptr
    r378, r379 :: object
    r380 :: str
    r381 :: object
    r382 :: dict
    r383 :: str
    r384 :: i32
    r385 :: bit
    r386 :: dict
    r387 :: str
    r388 :: object
    r389 :: str
    r390 :: object
    r391, r392 :: str
    r393 :: object[2]
    r394 :: object_ptr
    r395 :: object
    r396 :: dict
    r397 :: str
    r398 :: i32
    r399 :: bit
    r400 :: object
    r401 :: bool
    r402 :: str
    r403, r404, r405 :: object
    r406 :: dict
    r407 :: str
    r408 :: i32
    r409 :: bit
    r410 :: object
    r411 :: bool
    r412 :: str
    r413 :: object
    r414 :: dict
    r415 :: str
    r416 :: i32
    r417 :: bit
    r418 :: dank_mids.helpers._codec.__mypyc_lambda__0_obj
    r419 :: object
    r420 :: bool
    r421 :: str
    r422 :: i32
    r423 :: bit
    r424 :: object
    r425 :: bool
    r426 :: str
    r427 :: i32
    r428 :: bit
    r429 :: object
    r430 :: bool
    r431 :: str
    r432 :: i32
    r433 :: bit
    r434 :: dict
    r435 :: str
    r436, r437 :: object
    r438 :: bool
    r439 :: str
    r440 :: i32
    r441 :: bit
    r442 :: dict
    r443 :: str
    r444, r445 :: object
    r446 :: bool
    r447 :: str
    r448 :: i32
    r449 :: bit
    r450 :: dict
    r451 :: str
    r452 :: object
    r453 :: str
    r454 :: object
    r455, r456 :: str
    r457 :: object[2]
    r458 :: object_ptr
    r459 :: object
    r460 :: str
    r461 :: object
    r462 :: dict
    r463 :: str
    r464 :: i32
    r465 :: bit
    r466 :: object
    r467 :: dict
    r468 :: str
    r469 :: i32
    r470 :: bit
    r471 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L164 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('TYPE_CHECKING', 'Any', 'AnyStr', 'Callable', 'Dict', 'Final', 'Iterable', 'List', 'Literal', 'Mapping', 'Optional', 'Union', 'Tuple', 'Type', 'TypeVar', 'final', 'overload')
    r6 = 'typing'
    r7 = dank_mids.helpers._codec.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L164 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address hexbytes :: module
    r10 = load_address msgspec :: module
    r11 = [r9, r10]
    r12 = load_address r11
    r13 = [21, 22]
    r14 = load_address r13
    r15 = (('hexbytes', 'hexbytes', 'hexbytes'), ('msgspec', 'msgspec', 'msgspec'))
    r16 = dank_mids.helpers._codec.globals :: static
    r17 = 'dank_mids\\helpers\\_codec.py'
    r18 = '<module>'
    r19 = CPyImport_ImportMany(r15, r12, r16, r17, r18, r14)
    if not r19 goto L164 else goto L5 :: bool
L5:
    r20 = ('decoding',)
    r21 = 'eth_abi'
    r22 = dank_mids.helpers._codec.globals :: static
    r23 = CPyImport_ImportFromMany(r21, r20, r20, r22)
    if is_error(r23) goto L164 (error at <module>:23) else goto L6
L6:
    eth_abi = r23 :: module
    dec_ref r23
    r24 = ('default_codec',)
    r25 = 'eth_abi.abi'
    r26 = dank_mids.helpers._codec.globals :: static
    r27 = CPyImport_ImportFromMany(r25, r24, r24, r26)
    if is_error(r27) goto L164 (error at <module>:24) else goto L7
L7:
    eth_abi.abi = r27 :: module
    dec_ref r27
    r28 = ('DynamicArrayEncoder', 'TupleEncoder')
    r29 = 'eth_abi.encoding'
    r30 = dank_mids.helpers._codec.globals :: static
    r31 = CPyImport_ImportFromMany(r29, r28, r28, r30)
    if is_error(r31) goto L164 (error at <module>:25) else goto L8
L8:
    eth_abi.encoding = r31 :: module
    dec_ref r31
    r32 = ('ChecksumAddress', 'HexStr')
    r33 = 'eth_typing'
    r34 = dank_mids.helpers._codec.globals :: static
    r35 = CPyImport_ImportFromMany(r33, r32, r32, r34)
    if is_error(r35) goto L164 (error at <module>:26) else goto L9
L9:
    eth_typing = r35 :: module
    dec_ref r35
    r36 = ('Decoder', 'Encoder')
    r37 = 'msgspec.json'
    r38 = dank_mids.helpers._codec.globals :: static
    r39 = CPyImport_ImportFromMany(r37, r36, r36, r38)
    if is_error(r39) goto L164 (error at <module>:27) else goto L10
L10:
    msgspec.json = r39 :: module
    dec_ref r39
    if 0 goto L11 else goto L11 :: bool
L11:
    r40 = dank_mids.helpers._codec.globals :: static
    r41 = 'PartialResponse'
    r42 = box(None, 1)
    r43 = CPyDict_SetItem(r40, r41, r42)
    r44 = r43 >= 0 :: signed
    if not r44 goto L164 (error at <module>:34) else goto L12 :: bool
L12:
    r45 = dank_mids.helpers._codec.globals :: static
    r46 = 'Request'
    r47 = box(None, 1)
    r48 = CPyDict_SetItem(r45, r46, r47)
    r49 = r48 >= 0 :: signed
    if not r49 goto L164 (error at <module>:35) else goto L13 :: bool
L13:
    r50 = dank_mids.helpers._codec.globals :: static
    r51 = 'Response'
    r52 = box(None, 1)
    r53 = CPyDict_SetItem(r50, r51, r52)
    r54 = r53 >= 0 :: signed
    if not r54 goto L164 (error at <module>:36) else goto L14 :: bool
L14:
    r55 = dank_mids.helpers._codec.globals :: static
    r56 = 'better_decode'
    r57 = box(None, 1)
    r58 = CPyDict_SetItem(r55, r56, r57)
    r59 = r58 >= 0 :: signed
    if not r59 goto L164 (error at <module>:37) else goto L15 :: bool
L15:
    r60 = '__T'
    r61 = dank_mids.helpers._codec.globals :: static
    r62 = 'TypeVar'
    r63 = CPyDict_GetItem(r61, r62)
    if is_error(r63) goto L164 (error at <module>:40) else goto L16
L16:
    r64 = [r60]
    r65 = load_address r64
    r66 = _PyObject_Vectorcall(r63, r65, 1, 0)
    dec_ref r63
    if is_error(r66) goto L164 (error at <module>:40) else goto L17
L17:
    r67 = dank_mids.helpers._codec.globals :: static
    r68 = '__T'
    r69 = CPyDict_SetItem(r67, r68, r66)
    dec_ref r66
    r70 = r69 >= 0 :: signed
    if not r70 goto L164 (error at <module>:40) else goto L18 :: bool
L18:
    r71 = dank_mids.helpers._codec.globals :: static
    r72 = 'Union'
    r73 = CPyDict_GetItem(r71, r72)
    if is_error(r73) goto L164 (error at <module>:43) else goto L19
L19:
    r74 = dank_mids.helpers._codec.globals :: static
    r75 = 'ChecksumAddress'
    r76 = CPyDict_GetItem(r74, r75)
    if is_error(r76) goto L165 (error at <module>:43) else goto L20
L20:
    r77 = dank_mids.helpers._codec.globals :: static
    r78 = 'HexStr'
    r79 = CPyDict_GetItem(r77, r78)
    if is_error(r79) goto L166 (error at <module>:43) else goto L21
L21:
    r80 = (r76, r79)
    r81 = box(tuple[object, object], r80)
    r82 = PyObject_GetItem(r73, r81)
    dec_ref r73
    dec_ref r81
    if is_error(r82) goto L164 (error at <module>:43) else goto L22
L22:
    r83 = dank_mids.helpers._codec.globals :: static
    r84 = 'StrEncodable'
    r85 = CPyDict_SetItem(r83, r84, r82)
    dec_ref r82
    r86 = r85 >= 0 :: signed
    if not r86 goto L164 (error at <module>:43) else goto L23 :: bool
L23:
    r87 = dank_mids.helpers._codec.globals :: static
    r88 = 'Union'
    r89 = CPyDict_GetItem(r87, r88)
    if is_error(r89) goto L164 (error at <module>:44) else goto L24
L24:
    r90 = load_address PyLong_Type
    r91 = dank_mids.helpers._codec.globals :: static
    r92 = 'StrEncodable'
    r93 = CPyDict_GetItem(r91, r92)
    if is_error(r93) goto L167 (error at <module>:44) else goto L25
L25:
    r94 = dank_mids.helpers._codec.globals :: static
    r95 = 'hexbytes'
    r96 = CPyDict_GetItem(r94, r95)
    if is_error(r96) goto L168 (error at <module>:44) else goto L26
L26:
    r97 = 'HexBytes'
    r98 = CPyObject_GetAttr(r96, r97)
    dec_ref r96
    if is_error(r98) goto L168 (error at <module>:44) else goto L27
L27:
    r99 = load_address PyBytes_Type
    inc_ref r90
    inc_ref r99
    r100 = (r90, r93, r98, r99)
    r101 = box(tuple[object, object, object, object], r100)
    r102 = PyObject_GetItem(r89, r101)
    dec_ref r89
    dec_ref r101
    if is_error(r102) goto L164 (error at <module>:44) else goto L28
L28:
    r103 = dank_mids.helpers._codec.globals :: static
    r104 = 'Encodable'
    r105 = CPyDict_SetItem(r103, r104, r102)
    dec_ref r102
    r106 = r105 >= 0 :: signed
    if not r106 goto L164 (error at <module>:44) else goto L29 :: bool
L29:
    r107 = dank_mids.helpers._codec.globals :: static
    r108 = 'Union'
    r109 = CPyDict_GetItem(r107, r108)
    if is_error(r109) goto L164 (error at <module>:46) else goto L30
L30:
    r110 = dank_mids.helpers._codec.globals :: static
    r111 = 'HexStr'
    r112 = CPyDict_GetItem(r110, r111)
    if is_error(r112) goto L169 (error at <module>:46) else goto L31
L31:
    r113 = dank_mids.helpers._codec.globals :: static
    r114 = 'List'
    r115 = CPyDict_GetItem(r113, r114)
    if is_error(r115) goto L170 (error at <module>:46) else goto L32
L32:
    r116 = dank_mids.helpers._codec.globals :: static
    r117 = 'HexStr'
    r118 = CPyDict_GetItem(r116, r117)
    if is_error(r118) goto L171 (error at <module>:46) else goto L33
L33:
    r119 = PyObject_GetItem(r115, r118)
    dec_ref r115
    dec_ref r118
    if is_error(r119) goto L170 (error at <module>:46) else goto L34
L34:
    r120 = dank_mids.helpers._codec.globals :: static
    r121 = 'Dict'
    r122 = CPyDict_GetItem(r120, r121)
    if is_error(r122) goto L172 (error at <module>:46) else goto L35
L35:
    r123 = load_address PyUnicode_Type
    r124 = dank_mids.helpers._codec.globals :: static
    r125 = 'HexStr'
    r126 = CPyDict_GetItem(r124, r125)
    if is_error(r126) goto L173 (error at <module>:46) else goto L36
L36:
    inc_ref r123
    r127 = (r123, r126)
    r128 = box(tuple[object, object], r127)
    r129 = PyObject_GetItem(r122, r128)
    dec_ref r122
    dec_ref r128
    if is_error(r129) goto L172 (error at <module>:46) else goto L37
L37:
    r130 = (r112, r119, r129)
    r131 = box(tuple[object, object, object], r130)
    r132 = PyObject_GetItem(r109, r131)
    dec_ref r109
    dec_ref r131
    if is_error(r132) goto L164 (error at <module>:46) else goto L38
L38:
    r133 = dank_mids.helpers._codec.globals :: static
    r134 = 'RpcThing'
    r135 = CPyDict_SetItem(r133, r134, r132)
    dec_ref r132
    r136 = r135 >= 0 :: signed
    if not r136 goto L164 (error at <module>:46) else goto L39 :: bool
L39:
    r137 = dank_mids.helpers._codec.globals :: static
    r138 = 'Tuple'
    r139 = CPyDict_GetItem(r137, r138)
    if is_error(r139) goto L164 (error at <module>:49) else goto L40
L40:
    r140 = dank_mids.helpers._codec.globals :: static
    r141 = 'ChecksumAddress'
    r142 = CPyDict_GetItem(r140, r141)
    if is_error(r142) goto L174 (error at <module>:49) else goto L41
L41:
    r143 = dank_mids.helpers._codec.globals :: static
    r144 = 'hexbytes'
    r145 = CPyDict_GetItem(r143, r144)
    if is_error(r145) goto L175 (error at <module>:49) else goto L42
L42:
    r146 = 'HexBytes'
    r147 = CPyObject_GetAttr(r145, r146)
    dec_ref r145
    if is_error(r147) goto L175 (error at <module>:49) else goto L43
L43:
    r148 = (r142, r147)
    r149 = box(tuple[object, object], r148)
    r150 = PyObject_GetItem(r139, r149)
    dec_ref r139
    dec_ref r149
    if is_error(r150) goto L164 (error at <module>:49) else goto L44
L44:
    r151 = dank_mids.helpers._codec.globals :: static
    r152 = 'MulticallChunk'
    r153 = CPyDict_SetItem(r151, r152, r150)
    dec_ref r150
    r154 = r153 >= 0 :: signed
    if not r154 goto L164 (error at <module>:49) else goto L45 :: bool
L45:
    r155 = dank_mids.helpers._codec.globals :: static
    r156 = 'Callable'
    r157 = CPyDict_GetItem(r155, r156)
    if is_error(r157) goto L164 (error at <module>:50) else goto L46
L46:
    r158 = dank_mids.helpers._codec.globals :: static
    r159 = 'Tuple'
    r160 = CPyDict_GetItem(r158, r159)
    if is_error(r160) goto L176 (error at <module>:50) else goto L47
L47:
    r161 = load_address PyBool_Type
    r162 = dank_mids.helpers._codec.globals :: static
    r163 = 'Iterable'
    r164 = CPyDict_GetItem(r162, r163)
    if is_error(r164) goto L177 (error at <module>:50) else goto L48
L48:
    r165 = dank_mids.helpers._codec.globals :: static
    r166 = 'MulticallChunk'
    r167 = CPyDict_GetItem(r165, r166)
    if is_error(r167) goto L178 (error at <module>:50) else goto L49
L49:
    r168 = PyObject_GetItem(r164, r167)
    dec_ref r164
    dec_ref r167
    if is_error(r168) goto L177 (error at <module>:50) else goto L50
L50:
    inc_ref r161
    r169 = (r161, r168)
    r170 = box(tuple[object, object], r169)
    r171 = PyObject_GetItem(r160, r170)
    dec_ref r160
    dec_ref r170
    if is_error(r171) goto L176 (error at <module>:50) else goto L51
L51:
    r172 = PyList_New(1)
    if is_error(r172) goto L179 (error at <module>:50) else goto L52
L52:
    r173 = get_element_ptr r172 ob_item :: PyListObject
    r174 = load_mem r173 :: ptr*
    set_mem r174, r171 :: builtins.object*
    r175 = load_address PyBytes_Type
    inc_ref r175
    r176 = (r172, r175)
    r177 = box(tuple[list, object], r176)
    r178 = PyObject_GetItem(r157, r177)
    dec_ref r157
    dec_ref r177
    if is_error(r178) goto L164 (error at <module>:50) else goto L53
L53:
    r179 = dank_mids.helpers._codec.globals :: static
    r180 = 'MulticallEncoder'
    r181 = CPyDict_SetItem(r179, r180, r178)
    dec_ref r178
    r182 = r181 >= 0 :: signed
    if not r182 goto L164 (error at <module>:50) else goto L54 :: bool
L54:
    r183 = dank_mids.helpers._codec.globals :: static
    r184 = 'Tuple'
    r185 = CPyDict_GetItem(r183, r184)
    if is_error(r185) goto L164 (error at <module>:52) else goto L55
L55:
    r186 = load_address PyLong_Type
    r187 = load_address PyLong_Type
    r188 = dank_mids.helpers._codec.globals :: static
    r189 = 'Tuple'
    r190 = CPyDict_GetItem(r188, r189)
    if is_error(r190) goto L180 (error at <module>:52) else goto L56
L56:
    r191 = dank_mids.helpers._codec.globals :: static
    r192 = 'Tuple'
    r193 = CPyDict_GetItem(r191, r192)
    if is_error(r193) goto L181 (error at <module>:52) else goto L57
L57:
    r194 = 'Success'
    r195 = load_address PyBytes_Type
    inc_ref r194
    inc_ref r195
    r196 = (r194, r195)
    r197 = box(tuple[str, object], r196)
    r198 = PyObject_GetItem(r193, r197)
    dec_ref r193
    dec_ref r197
    if is_error(r198) goto L181 (error at <module>:52) else goto L58
L58:
    r199 = load_address _Py_EllipsisObject
    inc_ref r199
    r200 = (r198, r199)
    r201 = box(tuple[object, object], r200)
    r202 = PyObject_GetItem(r190, r201)
    dec_ref r190
    dec_ref r201
    if is_error(r202) goto L180 (error at <module>:52) else goto L59
L59:
    inc_ref r186
    inc_ref r187
    r203 = (r186, r187, r202)
    r204 = box(tuple[object, object, object], r203)
    r205 = PyObject_GetItem(r185, r204)
    dec_ref r185
    dec_ref r204
    if is_error(r205) goto L164 (error at <module>:52) else goto L60
L60:
    r206 = dank_mids.helpers._codec.globals :: static
    r207 = 'DecodedMulticall'
    r208 = CPyDict_SetItem(r206, r207, r205)
    dec_ref r205
    r209 = r208 >= 0 :: signed
    if not r209 goto L164 (error at <module>:52) else goto L61 :: bool
L61:
    r210 = dank_mids.helpers._codec.globals :: static
    r211 = 'Callable'
    r212 = CPyDict_GetItem(r210, r211)
    if is_error(r212) goto L164 (error at <module>:53) else goto L62
L62:
    r213 = load_address _Py_EllipsisObject
    r214 = dank_mids.helpers._codec.globals :: static
    r215 = 'DecodedMulticall'
    r216 = CPyDict_GetItem(r214, r215)
    if is_error(r216) goto L182 (error at <module>:53) else goto L63
L63:
    inc_ref r213
    r217 = (r213, r216)
    r218 = box(tuple[object, object], r217)
    r219 = PyObject_GetItem(r212, r218)
    dec_ref r212
    dec_ref r218
    if is_error(r219) goto L164 (error at <module>:53) else goto L64
L64:
    r220 = dank_mids.helpers._codec.globals :: static
    r221 = 'MulticallDecoder'
    r222 = CPyDict_SetItem(r220, r221, r219)
    dec_ref r219
    r223 = r222 >= 0 :: signed
    if not r223 goto L164 (error at <module>:53) else goto L65 :: bool
L65:
    r224 = dank_mids.helpers._codec.globals :: static
    r225 = 'List'
    r226 = CPyDict_GetItem(r224, r225)
    if is_error(r226) goto L164 (error at <module>:56) else goto L66
L66:
    r227 = 'types.Request'
    r228 = PyObject_GetItem(r226, r227)
    dec_ref r226
    if is_error(r228) goto L164 (error at <module>:56) else goto L67
L67:
    r229 = dank_mids.helpers._codec.globals :: static
    r230 = 'JSONRPCBatchRequest'
    r231 = CPyDict_SetItem(r229, r230, r228)
    dec_ref r228
    r232 = r231 >= 0 :: signed
    if not r232 goto L164 (error at <module>:56) else goto L68 :: bool
L68:
    r233 = dank_mids.helpers._codec.globals :: static
    r234 = 'Union'
    r235 = CPyDict_GetItem(r233, r234)
    if is_error(r235) goto L164 (error at <module>:58) else goto L69
L69:
    r236 = dank_mids.helpers._codec.globals :: static
    r237 = 'List'
    r238 = CPyDict_GetItem(r236, r237)
    if is_error(r238) goto L183 (error at <module>:58) else goto L70
L70:
    r239 = 'RawResponse'
    r240 = PyObject_GetItem(r238, r239)
    dec_ref r238
    if is_error(r240) goto L183 (error at <module>:58) else goto L71
L71:
    r241 = 'types.PartialResponse'
    inc_ref r241
    r242 = (r240, r241)
    r243 = box(tuple[object, str], r242)
    r244 = PyObject_GetItem(r235, r243)
    dec_ref r235
    dec_ref r243
    if is_error(r244) goto L164 (error at <module>:58) else goto L72
L72:
    r245 = dank_mids.helpers._codec.globals :: static
    r246 = 'JSONRPCBatchResponse'
    r247 = CPyDict_SetItem(r245, r246, r244)
    dec_ref r244
    r248 = r247 >= 0 :: signed
    if not r248 goto L164 (error at <module>:58) else goto L73 :: bool
L73:
    r249 = dank_mids.helpers._codec.globals :: static
    r250 = 'Callable'
    r251 = CPyDict_GetItem(r249, r250)
    if is_error(r251) goto L164 (error at <module>:59) else goto L74
L74:
    r252 = dank_mids.helpers._codec.globals :: static
    r253 = 'Union'
    r254 = CPyDict_GetItem(r252, r253)
    if is_error(r254) goto L184 (error at <module>:59) else goto L75
L75:
    r255 = load_address PyUnicode_Type
    r256 = load_address PyBytes_Type
    inc_ref r255
    inc_ref r256
    r257 = (r255, r256)
    r258 = box(tuple[object, object], r257)
    r259 = PyObject_GetItem(r254, r258)
    dec_ref r254
    dec_ref r258
    if is_error(r259) goto L184 (error at <module>:59) else goto L76
L76:
    r260 = PyList_New(1)
    if is_error(r260) goto L185 (error at <module>:59) else goto L77
L77:
    r261 = get_element_ptr r260 ob_item :: PyListObject
    r262 = load_mem r261 :: ptr*
    set_mem r262, r259 :: builtins.object*
    r263 = dank_mids.helpers._codec.globals :: static
    r264 = 'Union'
    r265 = CPyDict_GetItem(r263, r264)
    if is_error(r265) goto L186 (error at <module>:59) else goto L78
L78:
    r266 = dank_mids.helpers._codec.globals :: static
    r267 = 'List'
    r268 = CPyDict_GetItem(r266, r267)
    if is_error(r268) goto L187 (error at <module>:59) else goto L79
L79:
    r269 = dank_mids.helpers._codec.globals :: static
    r270 = 'msgspec'
    r271 = CPyDict_GetItem(r269, r270)
    if is_error(r271) goto L188 (error at <module>:59) else goto L80
L80:
    r272 = 'Raw'
    r273 = CPyObject_GetAttr(r271, r272)
    dec_ref r271
    if is_error(r273) goto L188 (error at <module>:59) else goto L81
L81:
    r274 = PyObject_GetItem(r268, r273)
    dec_ref r268
    dec_ref r273
    if is_error(r274) goto L187 (error at <module>:59) else goto L82
L82:
    r275 = 'types.PartialResponse'
    inc_ref r275
    r276 = (r274, r275)
    r277 = box(tuple[object, str], r276)
    r278 = PyObject_GetItem(r265, r277)
    dec_ref r265
    dec_ref r277
    if is_error(r278) goto L186 (error at <module>:59) else goto L83
L83:
    r279 = (r260, r278)
    r280 = box(tuple[list, object], r279)
    r281 = PyObject_GetItem(r251, r280)
    dec_ref r251
    dec_ref r280
    if is_error(r281) goto L164 (error at <module>:59) else goto L84
L84:
    r282 = dank_mids.helpers._codec.globals :: static
    r283 = 'BatchDecoder'
    r284 = CPyDict_SetItem(r282, r283, r281)
    dec_ref r281
    r285 = r284 >= 0 :: signed
    if not r285 goto L164 (error at <module>:59) else goto L85 :: bool
L85:
    r286 = dank_mids.helpers._codec.globals :: static
    r287 = 'hexbytes'
    r288 = CPyDict_GetItem(r286, r287)
    if is_error(r288) goto L164 (error at <module>:62) else goto L86
L86:
    r289 = 'HexBytes'
    r290 = CPyObject_GetAttr(r288, r289)
    dec_ref r288
    if is_error(r290) goto L164 (error at <module>:62) else goto L87
L87:
    dank_mids.helpers._codec.HexBytes = r290 :: static
    r291 = dank_mids.helpers._codec.globals :: static
    r292 = 'HexBytes'
    r293 = CPyDict_SetItem(r291, r292, r290)
    dec_ref r290
    r294 = r293 >= 0 :: signed
    if not r294 goto L164 (error at <module>:62) else goto L88 :: bool
L88:
    r295 = dank_mids.helpers._codec.globals :: static
    r296 = 'msgspec'
    r297 = CPyDict_GetItem(r295, r296)
    if is_error(r297) goto L164 (error at <module>:63) else goto L89
L89:
    r298 = 'Raw'
    r299 = CPyObject_GetAttr(r297, r298)
    dec_ref r297
    if is_error(r299) goto L164 (error at <module>:63) else goto L90
L90:
    dank_mids.helpers._codec.Raw = r299 :: static
    r300 = dank_mids.helpers._codec.globals :: static
    r301 = 'Raw'
    r302 = CPyDict_SetItem(r300, r301, r299)
    dec_ref r299
    r303 = r302 >= 0 :: signed
    if not r303 goto L164 (error at <module>:63) else goto L91 :: bool
L91:
    r304 = dank_mids.helpers._codec.globals :: static
    r305 = 'decoding'
    r306 = CPyDict_GetItem(r304, r305)
    if is_error(r306) goto L164 (error at <module>:64) else goto L92
L92:
    r307 = 'ContextFramesBytesIO'
    r308 = CPyObject_GetAttr(r306, r307)
    dec_ref r306
    if is_error(r308) goto L164 (error at <module>:64) else goto L93
L93:
    dank_mids.helpers._codec.ContextFramesBytesIO = r308 :: static
    r309 = dank_mids.helpers._codec.globals :: static
    r310 = 'ContextFramesBytesIO'
    r311 = CPyDict_SetItem(r309, r310, r308)
    dec_ref r308
    r312 = r311 >= 0 :: signed
    if not r312 goto L164 (error at <module>:64) else goto L94 :: bool
L94:
    r313 = dank_mids.helpers._codec.globals :: static
    r314 = 'msgspec'
    r315 = CPyDict_GetItem(r313, r314)
    if is_error(r315) goto L164 (error at <module>:65) else goto L95
L95:
    r316 = 'DecodeError'
    r317 = CPyObject_GetAttr(r315, r316)
    dec_ref r315
    if is_error(r317) goto L164 (error at <module>:65) else goto L96
L96:
    dank_mids.helpers._codec.DecodeError = r317 :: static
    r318 = dank_mids.helpers._codec.globals :: static
    r319 = 'DecodeError'
    r320 = CPyDict_SetItem(r318, r319, r317)
    dec_ref r317
    r321 = r320 >= 0 :: signed
    if not r321 goto L164 (error at <module>:65) else goto L97 :: bool
L97:
    r322 = load_address PyUnicode_Type
    r323 = dank_mids.helpers._codec.globals :: static
    r324 = 'Decoder'
    r325 = CPyDict_GetItem(r323, r324)
    if is_error(r325) goto L164 (error at <module>:67) else goto L98
L98:
    r326 = [r322]
    r327 = load_address r326
    r328 = ('type',)
    r329 = _PyObject_Vectorcall(r325, r327, 0, r328)
    dec_ref r325
    if is_error(r329) goto L164 (error at <module>:67) else goto L99
L99:
    r330 = 'decode'
    r331 = CPyObject_GetAttr(r329, r330)
    dec_ref r329
    if is_error(r331) goto L164 (error at <module>:67) else goto L100
L100:
    dank_mids.helpers._codec.decode_string = r331 :: static
    r332 = dank_mids.helpers._codec.globals :: static
    r333 = 'decode_string'
    r334 = CPyDict_SetItem(r332, r333, r331)
    dec_ref r331
    r335 = r334 >= 0 :: signed
    if not r335 goto L164 (error at <module>:67) else goto L101 :: bool
L101:
    r336 = dank_mids.helpers._codec.Raw :: static
    if is_error(r336) goto L102 else goto L104
L102:
    r337 = raise NameError('value for final name "Raw" was not set')
    if not r337 goto L164 (error at <module>:68) else goto L103 :: bool
L103:
    unreachable
L104:
    r338 = dank_mids.helpers._codec.globals :: static
    r339 = 'Decoder'
    r340 = CPyDict_GetItem(r338, r339)
    if is_error(r340) goto L164 (error at <module>:68) else goto L105
L105:
    r341 = [r336]
    r342 = load_address r341
    r343 = ('type',)
    r344 = _PyObject_Vectorcall(r340, r342, 0, r343)
    dec_ref r340
    if is_error(r344) goto L164 (error at <module>:68) else goto L106
L106:
    r345 = 'decode'
    r346 = CPyObject_GetAttr(r344, r345)
    dec_ref r344
    if is_error(r346) goto L164 (error at <module>:68) else goto L107
L107:
    dank_mids.helpers._codec._decode_raw = r346 :: static
    r347 = dank_mids.helpers._codec.globals :: static
    r348 = '_decode_raw'
    r349 = CPyDict_SetItem(r347, r348, r346)
    dec_ref r346
    r350 = r349 >= 0 :: signed
    if not r350 goto L164 (error at <module>:68) else goto L108 :: bool
L108:
    r351 = dank_mids.helpers._codec.globals :: static
    r352 = '_decode_batch'
    r353 = box(None, 1)
    r354 = CPyDict_SetItem(r351, r352, r353)
    r355 = r354 >= 0 :: signed
    if not r355 goto L164 (error at <module>:70) else goto L109 :: bool
L109:
    r356 = <error> :: object
    r357 = 'dank_mids.helpers._codec'
    r358 = dank_mids.helpers._codec.RawResponse_template :: type
    r359 = CPyType_FromTemplate(r358, r356, r357)
    if is_error(r359) goto L164 (error at <module>:74) else goto L110
L110:
    r360 = RawResponse_trait_vtable_setup()
    if is_error(r360) goto L189 (error at <module>:-1) else goto L111
L111:
    r361 = '__mypyc_attrs__'
    r362 = '_raw'
    r363 = PyTuple_Pack(1, r362)
    if is_error(r363) goto L189 (error at <module>:74) else goto L112
L112:
    r364 = PyObject_SetAttr(r359, r361, r363)
    dec_ref r363
    r365 = r364 >= 0 :: signed
    if not r365 goto L189 (error at <module>:74) else goto L113 :: bool
L113:
    dank_mids.helpers._codec.RawResponse = r359 :: type
    r366 = dank_mids.helpers._codec.globals :: static
    r367 = 'RawResponse'
    r368 = CPyDict_SetItem(r366, r367, r359)
    dec_ref r359
    r369 = r368 >= 0 :: signed
    if not r369 goto L164 (error at <module>:74) else goto L114 :: bool
L114:
    r370 = dank_mids.helpers._codec.globals :: static
    r371 = '_encode_hook'
    r372 = CPyDict_GetItem(r370, r371)
    if is_error(r372) goto L164 (error at <module>:174) else goto L115
L115:
    r373 = dank_mids.helpers._codec.globals :: static
    r374 = 'Encoder'
    r375 = CPyDict_GetItem(r373, r374)
    if is_error(r375) goto L190 (error at <module>:174) else goto L116
L116:
    r376 = [r372]
    r377 = load_address r376
    r378 = ('enc_hook',)
    r379 = _PyObject_Vectorcall(r375, r377, 0, r378)
    dec_ref r375
    if is_error(r379) goto L190 (error at <module>:174) else goto L117
L117:
    dec_ref r372
    r380 = 'encode'
    r381 = CPyObject_GetAttr(r379, r380)
    dec_ref r379
    if is_error(r381) goto L164 (error at <module>:174) else goto L118
L118:
    dank_mids.helpers._codec.encode = r381 :: static
    r382 = dank_mids.helpers._codec.globals :: static
    r383 = 'encode'
    r384 = CPyDict_SetItem(r382, r383, r381)
    dec_ref r381
    r385 = r384 >= 0 :: signed
    if not r385 goto L164 (error at <module>:174) else goto L119 :: bool
L119:
    r386 = dank_mids.helpers._codec.globals :: static
    r387 = 'default_codec'
    r388 = CPyDict_GetItem(r386, r387)
    if is_error(r388) goto L164 (error at <module>:193) else goto L120
L120:
    r389 = '_registry'
    r390 = CPyObject_GetAttr(r388, r389)
    dec_ref r388
    if is_error(r390) goto L164 (error at <module>:193) else goto L121
L121:
    r391 = '(bool,(address,bytes)[])'
    r392 = 'get_encoder'
    r393 = [r390, r391]
    r394 = load_address r393
    r395 = PyObject_VectorcallMethod(r392, r394, 9223372036854775810, 0)
    if is_error(r395) goto L191 (error at <module>:193) else goto L122
L122:
    dec_ref r390
    dank_mids.helpers._codec._mcall_encoder = r395 :: static
    r396 = dank_mids.helpers._codec.globals :: static
    r397 = '_mcall_encoder'
    r398 = CPyDict_SetItem(r396, r397, r395)
    dec_ref r395
    r399 = r398 >= 0 :: signed
    if not r399 goto L164 (error at <module>:193) else goto L123 :: bool
L123:
    r400 = dank_mids.helpers._codec._mcall_encoder :: static
    if is_error(r400) goto L124 else goto L126
L124:
    r401 = raise NameError('value for final name "_mcall_encoder" was not set')
    if not r401 goto L164 (error at <module>:196) else goto L125 :: bool
L125:
    unreachable
L126:
    r402 = 'encoders'
    r403 = CPyObject_GetAttr(r400, r402)
    if is_error(r403) goto L164 (error at <module>:196) else goto L127
L127:
    r404 = object -1
    r405 = PyObject_GetItem(r403, r404)
    dec_ref r403
    if is_error(r405) goto L164 (error at <module>:196) else goto L128
L128:
    dank_mids.helpers._codec._array_encoder = r405 :: static
    r406 = dank_mids.helpers._codec.globals :: static
    r407 = '_array_encoder'
    r408 = CPyDict_SetItem(r406, r407, r405)
    dec_ref r405
    r409 = r408 >= 0 :: signed
    if not r409 goto L164 (error at <module>:196) else goto L129 :: bool
L129:
    r410 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r410) goto L130 else goto L132
L130:
    r411 = raise NameError('value for final name "_array_encoder" was not set')
    if not r411 goto L164 (error at <module>:197) else goto L131 :: bool
L131:
    unreachable
L132:
    r412 = 'item_encoder'
    r413 = CPyObject_GetAttr(r410, r412)
    if is_error(r413) goto L164 (error at <module>:197) else goto L133
L133:
    dank_mids.helpers._codec._item_encoder = r413 :: static
    r414 = dank_mids.helpers._codec.globals :: static
    r415 = '_item_encoder'
    r416 = CPyDict_SetItem(r414, r415, r413)
    dec_ref r413
    r417 = r416 >= 0 :: signed
    if not r417 goto L164 (error at <module>:197) else goto L134 :: bool
L134:
    r418 = __mypyc_lambda__0_obj()
    if is_error(r418) goto L164 (error at <module>:200) else goto L135
L135:
    r419 = dank_mids.helpers._codec._mcall_encoder :: static
    if is_error(r419) goto L192 else goto L138
L136:
    r420 = raise NameError('value for final name "_mcall_encoder" was not set')
    if not r420 goto L164 (error at <module>:200) else goto L137 :: bool
L137:
    unreachable
L138:
    r421 = 'validate_value'
    r422 = PyObject_SetAttr(r419, r421, r418)
    r423 = r422 >= 0 :: signed
    if not r423 goto L193 (error at <module>:200) else goto L139 :: bool
L139:
    r424 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r424) goto L194 else goto L142
L140:
    r425 = raise NameError('value for final name "_array_encoder" was not set')
    if not r425 goto L164 (error at <module>:200) else goto L141 :: bool
L141:
    unreachable
L142:
    r426 = 'validate_value'
    r427 = PyObject_SetAttr(r424, r426, r418)
    r428 = r427 >= 0 :: signed
    if not r428 goto L193 (error at <module>:200) else goto L143 :: bool
L143:
    r429 = dank_mids.helpers._codec._item_encoder :: static
    if is_error(r429) goto L195 else goto L146
L144:
    r430 = raise NameError('value for final name "_item_encoder" was not set')
    if not r430 goto L164 (error at <module>:200) else goto L145 :: bool
L145:
    unreachable
L146:
    r431 = 'validate_value'
    r432 = PyObject_SetAttr(r429, r431, r418)
    dec_ref r418
    r433 = r432 >= 0 :: signed
    if not r433 goto L164 (error at <module>:200) else goto L147 :: bool
L147:
    r434 = dank_mids.helpers._codec.globals :: static
    r435 = '__encode_new'
    r436 = CPyDict_GetItem(r434, r435)
    if is_error(r436) goto L164 (error at <module>:230) else goto L148
L148:
    r437 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r437) goto L196 else goto L151
L149:
    r438 = raise NameError('value for final name "_array_encoder" was not set')
    if not r438 goto L164 (error at <module>:230) else goto L150 :: bool
L150:
    unreachable
L151:
    r439 = 'encode'
    r440 = PyObject_SetAttr(r437, r439, r436)
    dec_ref r436
    r441 = r440 >= 0 :: signed
    if not r441 goto L164 (error at <module>:230) else goto L152 :: bool
L152:
    r442 = dank_mids.helpers._codec.globals :: static
    r443 = '__encode_elements_new'
    r444 = CPyDict_GetItem(r442, r443)
    if is_error(r444) goto L164 (error at <module>:231) else goto L153
L153:
    r445 = dank_mids.helpers._codec._array_encoder :: static
    if is_error(r445) goto L197 else goto L156
L154:
    r446 = raise NameError('value for final name "_array_encoder" was not set')
    if not r446 goto L164 (error at <module>:231) else goto L155 :: bool
L155:
    unreachable
L156:
    r447 = 'encode_elements'
    r448 = PyObject_SetAttr(r445, r447, r444)
    dec_ref r444
    r449 = r448 >= 0 :: signed
    if not r449 goto L164 (error at <module>:231) else goto L157 :: bool
L157:
    r450 = dank_mids.helpers._codec.globals :: static
    r451 = 'default_codec'
    r452 = CPyDict_GetItem(r450, r451)
    if is_error(r452) goto L164 (error at <module>:234) else goto L158
L158:
    r453 = '_registry'
    r454 = CPyObject_GetAttr(r452, r453)
    dec_ref r452
    if is_error(r454) goto L164 (error at <module>:234) else goto L159
L159:
    r455 = '(uint256,uint256,(bool,bytes)[])'
    r456 = 'get_decoder'
    r457 = [r454, r455]
    r458 = load_address r457
    r459 = PyObject_VectorcallMethod(r456, r458, 9223372036854775810, 0)
    if is_error(r459) goto L198 (error at <module>:234) else goto L160
L160:
    dec_ref r454
    r460 = 'decode'
    r461 = CPyObject_GetAttr(r459, r460)
    dec_ref r459
    if is_error(r461) goto L164 (error at <module>:234) else goto L161
L161:
    dank_mids.helpers._codec._mcall_decoder = r461 :: static
    r462 = dank_mids.helpers._codec.globals :: static
    r463 = '_mcall_decoder'
    r464 = CPyDict_SetItem(r462, r463, r461)
    dec_ref r461
    r465 = r464 >= 0 :: signed
    if not r465 goto L164 (error at <module>:234) else goto L162 :: bool
L162:
    r466 = load_address PyBool_Type
    r467 = dank_mids.helpers._codec.globals :: static
    r468 = 'Success'
    r469 = CPyDict_SetItem(r467, r468, r466)
    r470 = r469 >= 0 :: signed
    if not r470 goto L164 (error at <module>:244) else goto L163 :: bool
L163:
    return 1
L164:
    r471 = <error> :: None
    return r471
L165:
    dec_ref r73
    goto L164
L166:
    dec_ref r73
    dec_ref r76
    goto L164
L167:
    dec_ref r89
    goto L164
L168:
    dec_ref r89
    dec_ref r93
    goto L164
L169:
    dec_ref r109
    goto L164
L170:
    dec_ref r109
    dec_ref r112
    goto L164
L171:
    dec_ref r109
    dec_ref r112
    dec_ref r115
    goto L164
L172:
    dec_ref r109
    dec_ref r112
    dec_ref r119
    goto L164
L173:
    dec_ref r109
    dec_ref r112
    dec_ref r119
    dec_ref r122
    goto L164
L174:
    dec_ref r139
    goto L164
L175:
    dec_ref r139
    dec_ref r142
    goto L164
L176:
    dec_ref r157
    goto L164
L177:
    dec_ref r157
    dec_ref r160
    goto L164
L178:
    dec_ref r157
    dec_ref r160
    dec_ref r164
    goto L164
L179:
    dec_ref r157
    dec_ref r171
    goto L164
L180:
    dec_ref r185
    goto L164
L181:
    dec_ref r185
    dec_ref r190
    goto L164
L182:
    dec_ref r212
    goto L164
L183:
    dec_ref r235
    goto L164
L184:
    dec_ref r251
    goto L164
L185:
    dec_ref r251
    dec_ref r259
    goto L164
L186:
    dec_ref r251
    dec_ref r260
    goto L164
L187:
    dec_ref r251
    dec_ref r260
    dec_ref r265
    goto L164
L188:
    dec_ref r251
    dec_ref r260
    dec_ref r265
    dec_ref r268
    goto L164
L189:
    dec_ref r359
    goto L164
L190:
    dec_ref r372
    goto L164
L191:
    dec_ref r390
    goto L164
L192:
    dec_ref r418
    goto L136
L193:
    dec_ref r418
    goto L164
L194:
    dec_ref r418
    goto L140
L195:
    dec_ref r418
    goto L144
L196:
    dec_ref r436
    goto L149
L197:
    dec_ref r444
    goto L154
L198:
    dec_ref r454
    goto L164

def error_logger_log_debug(msg, args):
    msg :: str
    args :: tuple
    r0 :: int
    r1 :: bool
    r2 :: object
    r3 :: bool
    r4 :: object
    r5 :: object[3]
    r6 :: object_ptr
    r7 :: object
    r8 :: None
L0:
    r0 = dank_mids._logging.DEBUG :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "DEBUG" was not set')
    if not r1 goto L8 (error at error_logger_log_debug:18) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = dank_mids.helpers._errors.error_logger_log :: static
    if is_error(r2) goto L4 else goto L6
L4:
    r3 = raise NameError('value for final name "error_logger_log" was not set')
    if not r3 goto L8 (error at error_logger_log_debug:18) else goto L5 :: bool
L5:
    unreachable
L6:
    inc_ref r0 :: int
    r4 = box(int, r0)
    r5 = [r4, msg, args]
    r6 = load_address r5
    r7 = _PyObject_Vectorcall(r2, r6, 3, 0)
    if is_error(r7) goto L9 (error at error_logger_log_debug:18) else goto L10
L7:
    dec_ref r4
    return 1
L8:
    r8 = <error> :: None
    return r8
L9:
    dec_ref r4
    goto L8
L10:
    dec_ref r7
    goto L7

def revert_logger_log_debug(msg, args):
    msg :: str
    args :: tuple
    r0 :: int
    r1 :: bool
    r2 :: object
    r3 :: bool
    r4 :: object
    r5 :: object[3]
    r6 :: object_ptr
    r7 :: object
    r8 :: None
L0:
    r0 = dank_mids._logging.DEBUG :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "DEBUG" was not set')
    if not r1 goto L8 (error at revert_logger_log_debug:26) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = dank_mids.helpers._errors.revert_logger_log :: static
    if is_error(r2) goto L4 else goto L6
L4:
    r3 = raise NameError('value for final name "revert_logger_log" was not set')
    if not r3 goto L8 (error at revert_logger_log_debug:26) else goto L5 :: bool
L5:
    unreachable
L6:
    inc_ref r0 :: int
    r4 = box(int, r0)
    r5 = [r4, msg, args]
    r6 = load_address r5
    r7 = _PyObject_Vectorcall(r2, r6, 3, 0)
    if is_error(r7) goto L9 (error at revert_logger_log_debug:26) else goto L10
L7:
    dec_ref r4
    return 1
L8:
    r8 = <error> :: None
    return r8
L9:
    dec_ref r4
    goto L8
L10:
    dec_ref r7
    goto L7

def log_internal_error(logger, batch, exc):
    logger, batch, exc :: object
    r0, batch_objs :: list
    r1 :: tuple[object, object, object]
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: bit
    r6 :: list
    r7, r8 :: ptr
    r9 :: bit
    r10 :: str
    r11 :: object
    r12 :: str
    r13 :: object
    r14 :: str
    r15 :: ptr
    r16 :: native_int
    r17 :: short_int
    r18 :: object
    r19 :: str
    r20 :: object
    r21, r22 :: str
    r23, r24 :: object
    r25 :: object[8]
    r26 :: object_ptr
    r27, r28 :: object
    r29 :: None
L0:
L1:
    r0 = PySequence_List(batch)
    if is_error(r0) goto L3 (error at log_internal_error:48) else goto L2
L2:
    batch_objs = r0
    goto L12
L3:
    r1 = CPy_CatchError()
    r2 = builtins :: module
    r3 = 'TypeError'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L10 (error at log_internal_error:49) else goto L4
L4:
    r5 = CPy_ExceptionMatches(r4)
    dec_ref r4
    if r5 goto L5 else goto L7 :: bool
L5:
    r6 = PyList_New(1)
    if is_error(r6) goto L10 (error at log_internal_error:51) else goto L6
L6:
    r7 = get_element_ptr r6 ob_item :: PyListObject
    r8 = load_mem r7 :: ptr*
    inc_ref batch
    set_mem r8, batch :: builtins.object*
    batch_objs = r6
    goto L9
L7:
    CPy_Reraise()
    if not 0 goto L10 else goto L19 :: bool
L8:
    unreachable
L9:
    CPy_RestoreExcInfo(r1)
    dec_ref r1
    goto L12
L10:
    CPy_RestoreExcInfo(r1)
    dec_ref r1
    r9 = CPy_KeepPropagating()
    if not r9 goto L18 else goto L11 :: bool
L11:
    unreachable
L12:
    r10 = "That's not good, there was an exception in a %s (len=%s). These are supposed to be handled.\nExc: %s\n%s contents: %s\n\n"
    r11 = PyObject_Type(batch)
    r12 = '__name__'
    r13 = CPyObject_GetAttr(r11, r12)
    dec_ref r11
    if is_error(r13) goto L20 (error at log_internal_error:56) else goto L13
L13:
    r14 = cast(str, r13)
    if is_error(r14) goto L20 (error at log_internal_error:56) else goto L14
L14:
    r15 = get_element_ptr batch_objs ob_size :: PyVarObject
    r16 = load_mem r15 :: native_int*
    r17 = r16 << 1
    r18 = PyObject_Type(batch)
    r19 = '__name__'
    r20 = CPyObject_GetAttr(r18, r19)
    dec_ref r18
    if is_error(r20) goto L21 (error at log_internal_error:59) else goto L15
L15:
    r21 = cast(str, r20)
    if is_error(r21) goto L21 (error at log_internal_error:59) else goto L16
L16:
    r22 = 'error'
    r23 = box(short_int, r17)
    r24 = box(bool, 1)
    r25 = [logger, r10, r14, r23, exc, r21, batch_objs, r24]
    r26 = load_address r25
    r27 = ('exc_info',)
    r28 = PyObject_VectorcallMethod(r22, r26, 9223372036854775815, r27)
    if is_error(r28) goto L22 (error at log_internal_error:52) else goto L23
L17:
    dec_ref r14
    dec_ref r23
    dec_ref r21
    dec_ref batch_objs
    return 1
L18:
    r29 = <error> :: None
    return r29
L19:
    dec_ref r1
    goto L8
L20:
    dec_ref batch_objs
    goto L18
L21:
    dec_ref batch_objs
    dec_ref r14
    goto L18
L22:
    dec_ref batch_objs
    dec_ref r14
    dec_ref r21
    dec_ref r23
    goto L18
L23:
    dec_ref r28
    goto L17

def needs_full_request_spec(response):
    response :: object
    r0 :: str
    r1, r2 :: object
    r3 :: bit
    r4 :: bool
    r5 :: str
    r6 :: object
    r7 :: str
    r8 :: object
    r9, r10 :: str
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14, r15 :: str
    r16 :: i32
    r17 :: bit
    r18 :: object
    r19, r20, r21 :: bit
    r22 :: bool
    r23 :: str
    r24 :: object
    r25 :: str
    r26 :: object
    r27, r28 :: str
    r29 :: object[1]
    r30 :: object_ptr
    r31 :: object
    r32, r33 :: str
    r34 :: i32
    r35 :: bit
    r36 :: object
    r37, r38, r39 :: bit
    r40 :: bool
L0:
    r0 = 'error'
    r1 = CPyObject_GetAttr(response, r0)
    if is_error(r1) goto L24 (error at needs_full_request_spec:78) else goto L1
L1:
    r2 = load_address _Py_NoneStruct
    r3 = r1 != r2
    dec_ref r1
    if r3 goto L3 else goto L2 :: bool
L2:
    r4 = r3
    goto L23
L3:
    r5 = 'error'
    r6 = CPyObject_GetAttr(response, r5)
    if is_error(r6) goto L24 (error at needs_full_request_spec:78) else goto L4
L4:
    r7 = 'message'
    r8 = CPyObject_GetAttr(r6, r7)
    dec_ref r6
    if is_error(r8) goto L24 (error at needs_full_request_spec:78) else goto L5
L5:
    r9 = cast(str, r8)
    if is_error(r9) goto L24 (error at needs_full_request_spec:78) else goto L6
L6:
    r10 = 'lower'
    r11 = [r9]
    r12 = load_address r11
    r13 = PyObject_VectorcallMethod(r10, r12, 9223372036854775809, 0)
    if is_error(r13) goto L25 (error at needs_full_request_spec:78) else goto L7
L7:
    dec_ref r9
    r14 = cast(str, r13)
    if is_error(r14) goto L24 (error at needs_full_request_spec:78) else goto L8
L8:
    r15 = 'invalid request'
    r16 = PyUnicode_Compare(r14, r15)
    dec_ref r14
    r17 = r16 == -1
    if r17 goto L9 else goto L11 :: bool
L9:
    r18 = PyErr_Occurred()
    r19 = r18 != 0
    if r19 goto L10 else goto L11 :: bool
L10:
    r20 = CPy_KeepPropagating()
    if not r20 goto L24 (error at needs_full_request_spec:-1) else goto L11 :: bool
L11:
    r21 = r16 == 0
    if r21 goto L12 else goto L13 :: bool
L12:
    r22 = r21
    goto L22
L13:
    r23 = 'error'
    r24 = CPyObject_GetAttr(response, r23)
    if is_error(r24) goto L24 (error at needs_full_request_spec:78) else goto L14
L14:
    r25 = 'message'
    r26 = CPyObject_GetAttr(r24, r25)
    dec_ref r24
    if is_error(r26) goto L24 (error at needs_full_request_spec:78) else goto L15
L15:
    r27 = cast(str, r26)
    if is_error(r27) goto L24 (error at needs_full_request_spec:78) else goto L16
L16:
    r28 = 'lower'
    r29 = [r27]
    r30 = load_address r29
    r31 = PyObject_VectorcallMethod(r28, r30, 9223372036854775809, 0)
    if is_error(r31) goto L26 (error at needs_full_request_spec:78) else goto L17
L17:
    dec_ref r27
    r32 = cast(str, r31)
    if is_error(r32) goto L24 (error at needs_full_request_spec:78) else goto L18
L18:
    r33 = 'parse error'
    r34 = PyUnicode_Compare(r32, r33)
    dec_ref r32
    r35 = r34 == -1
    if r35 goto L19 else goto L21 :: bool
L19:
    r36 = PyErr_Occurred()
    r37 = r36 != 0
    if r37 goto L20 else goto L21 :: bool
L20:
    r38 = CPy_KeepPropagating()
    if not r38 goto L24 (error at needs_full_request_spec:-1) else goto L21 :: bool
L21:
    r39 = r34 == 0
    r22 = r39
L22:
    r4 = r22
L23:
    return r4
L24:
    r40 = <error> :: bool
    return r40
L25:
    dec_ref r9
    goto L24
L26:
    dec_ref r27
    goto L24

def is_call_revert(e):
    e :: dank_mids._exceptions.BadResponse
    r0, r1, r2 :: str
    r3 :: object[3]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: str
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11, r12 :: str
    r13 :: object
    r14 :: set
    r15 :: bool
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: object[2]
    r20 :: object_ptr
    r21, r22 :: object
    r23 :: str
    r24 :: object
    r25 :: object[1]
    r26 :: object_ptr
    r27 :: object
    r28, r29 :: bool
L0:
    r0 = '{:{}}'
    r1 = ''
    r2 = 'format'
    r3 = [r0, e, r1]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r2, r4, 9223372036854775811, 0)
    if is_error(r5) goto L14 (error at is_call_revert:94) else goto L1
L1:
    r6 = cast(str, r5)
    if is_error(r6) goto L14 (error at is_call_revert:94) else goto L2
L2:
    r7 = 'lower'
    r8 = [r6]
    r9 = load_address r8
    r10 = PyObject_VectorcallMethod(r7, r9, 9223372036854775809, 0)
    if is_error(r10) goto L15 (error at is_call_revert:94) else goto L3
L3:
    dec_ref r6
    r11 = cast(str, r10)
    if is_error(r11) goto L14 (error at is_call_revert:94) else goto L4
L4:
    r12 = '__contains__'
    r13 = CPyObject_GetAttr(r11, r12)
    dec_ref r11
    if is_error(r13) goto L14 (error at is_call_revert:94) else goto L5
L5:
    r14 = dank_mids.helpers._errors.INDIVIDUAL_CALL_REVERT_STRINGS :: static
    if is_error(r14) goto L16 else goto L8
L6:
    r15 = raise NameError('value for final name "INDIVIDUAL_CALL_REVERT_STRINGS" was not set')
    if not r15 goto L14 (error at is_call_revert:94) else goto L7 :: bool
L7:
    unreachable
L8:
    r16 = builtins :: module
    r17 = 'map'
    r18 = CPyObject_GetAttr(r16, r17)
    if is_error(r18) goto L17 (error at is_call_revert:94) else goto L9
L9:
    r19 = [r13, r14]
    r20 = load_address r19
    r21 = _PyObject_Vectorcall(r18, r20, 2, 0)
    dec_ref r18
    if is_error(r21) goto L17 (error at is_call_revert:94) else goto L10
L10:
    dec_ref r13
    r22 = builtins :: module
    r23 = 'any'
    r24 = CPyObject_GetAttr(r22, r23)
    if is_error(r24) goto L18 (error at is_call_revert:94) else goto L11
L11:
    r25 = [r21]
    r26 = load_address r25
    r27 = _PyObject_Vectorcall(r24, r26, 1, 0)
    dec_ref r24
    if is_error(r27) goto L18 (error at is_call_revert:94) else goto L12
L12:
    dec_ref r21
    r28 = unbox(bool, r27)
    dec_ref r27
    if is_error(r28) goto L14 (error at is_call_revert:94) else goto L13
L13:
    return r28
L14:
    r29 = <error> :: bool
    return r29
L15:
    dec_ref r6
    goto L14
L16:
    dec_ref r13
    goto L6
L17:
    dec_ref r13
    goto L14
L18:
    dec_ref r21
    goto L14

def log_request_type_switch():
    r0 :: str
    r1 :: object
    r2 :: bool
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6 :: None
L0:
    r0 = 'your node says the partial request was invalid but its okay, we can use the full jsonrpc spec instead'
    r1 = dank_mids.helpers._errors.error_logger_debug :: static
    if is_error(r1) goto L1 else goto L3
L1:
    r2 = raise NameError('value for final name "error_logger_debug" was not set')
    if not r2 goto L5 (error at log_request_type_switch:98) else goto L2 :: bool
L2:
    unreachable
L3:
    r3 = [r0]
    r4 = load_address r3
    r5 = _PyObject_Vectorcall(r1, r4, 1, 0)
    if is_error(r5) goto L5 (error at log_request_type_switch:98) else goto L6
L4:
    return 1
L5:
    r6 = <error> :: None
    return r6
L6:
    dec_ref r5
    goto L4

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24 :: object
    r25 :: str
    r26 :: object
    r27 :: bool
    r28 :: object[1]
    r29 :: object_ptr
    r30 :: object
    r31 :: dict
    r32 :: str
    r33 :: i32
    r34 :: bit
    r35 :: object
    r36 :: bool
    r37 :: str
    r38 :: object
    r39 :: dict
    r40 :: str
    r41 :: i32
    r42 :: bit
    r43 :: object
    r44 :: bool
    r45 :: str
    r46 :: object
    r47 :: dict
    r48 :: str
    r49 :: i32
    r50 :: bit
    r51 :: object
    r52 :: bool
    r53, r54 :: str
    r55 :: object[2]
    r56 :: object_ptr
    r57 :: object
    r58 :: dict
    r59 :: str
    r60 :: i32
    r61 :: bit
    r62 :: object
    r63 :: bool
    r64 :: str
    r65 :: object
    r66 :: dict
    r67 :: str
    r68 :: i32
    r69 :: bit
    r70 :: object
    r71 :: bool
    r72, r73 :: str
    r74 :: object[2]
    r75 :: object_ptr
    r76 :: object
    r77 :: dict
    r78 :: str
    r79 :: i32
    r80 :: bit
    r81 :: object
    r82 :: bool
    r83 :: str
    r84 :: object
    r85 :: dict
    r86 :: str
    r87 :: i32
    r88 :: bit
    r89 :: object
    r90 :: bool
    r91 :: str
    r92 :: object
    r93 :: dict
    r94 :: str
    r95 :: i32
    r96 :: bit
    r97 :: object
    r98 :: bool
    r99, r100 :: str
    r101 :: object[2]
    r102 :: object_ptr
    r103 :: object
    r104 :: dict
    r105 :: str
    r106 :: i32
    r107 :: bit
    r108 :: object
    r109 :: bool
    r110 :: str
    r111 :: object
    r112 :: dict
    r113 :: str
    r114 :: i32
    r115 :: bit
    r116, r117, r118, r119, r120 :: str
    r121 :: set
    r122 :: i32
    r123 :: bit
    r124 :: i32
    r125 :: bit
    r126 :: i32
    r127 :: bit
    r128 :: i32
    r129 :: bit
    r130 :: i32
    r131 :: bit
    r132 :: dict
    r133 :: str
    r134 :: i32
    r135 :: bit
    r136 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L67 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Logger',)
    r6 = 'logging'
    r7 = dank_mids.helpers._errors.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L67 (error at <module>:1) else goto L4
L4:
    logging = r8 :: module
    dec_ref r8
    r9 = ('TYPE_CHECKING', 'Any', 'Final')
    r10 = 'typing'
    r11 = dank_mids.helpers._errors.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L67 (error at <module>:2) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = ('BadResponse',)
    r14 = 'dank_mids._exceptions'
    r15 = dank_mids.helpers._errors.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L67 (error at <module>:4) else goto L6
L6:
    dank_mids._exceptions = r16 :: module
    dec_ref r16
    r17 = ('DEBUG', 'getLogger')
    r18 = 'dank_mids._logging'
    r19 = dank_mids.helpers._errors.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L67 (error at <module>:5) else goto L7
L7:
    dank_mids._logging = r20 :: module
    dec_ref r20
    r21 = ('PartialResponse',)
    r22 = 'dank_mids.types'
    r23 = dank_mids.helpers._errors.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L67 (error at <module>:6) else goto L8
L8:
    dank_mids.types = r24 :: module
    dec_ref r24
    if 0 goto L9 else goto L9 :: bool
L9:
    r25 = 'dank_mids.errors'
    r26 = dank_mids._logging.getLogger :: static
    if is_error(r26) goto L10 else goto L12
L10:
    r27 = raise NameError('value for final name "getLogger" was not set')
    if not r27 goto L67 (error at <module>:12) else goto L11 :: bool
L11:
    unreachable
L12:
    r28 = [r25]
    r29 = load_address r28
    r30 = _PyObject_Vectorcall(r26, r29, 1, 0)
    if is_error(r30) goto L67 (error at <module>:12) else goto L13
L13:
    dank_mids.helpers._errors.error_logger = r30 :: static
    r31 = dank_mids.helpers._errors.globals :: static
    r32 = 'error_logger'
    r33 = CPyDict_SetItem(r31, r32, r30)
    dec_ref r30
    r34 = r33 >= 0 :: signed
    if not r34 goto L67 (error at <module>:12) else goto L14 :: bool
L14:
    r35 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r35) goto L15 else goto L17
L15:
    r36 = raise NameError('value for final name "error_logger" was not set')
    if not r36 goto L67 (error at <module>:13) else goto L16 :: bool
L16:
    unreachable
L17:
    r37 = 'debug'
    r38 = CPyObject_GetAttr(r35, r37)
    if is_error(r38) goto L67 (error at <module>:13) else goto L18
L18:
    dank_mids.helpers._errors.error_logger_debug = r38 :: static
    r39 = dank_mids.helpers._errors.globals :: static
    r40 = 'error_logger_debug'
    r41 = CPyDict_SetItem(r39, r40, r38)
    dec_ref r38
    r42 = r41 >= 0 :: signed
    if not r42 goto L67 (error at <module>:13) else goto L19 :: bool
L19:
    r43 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r43) goto L20 else goto L22
L20:
    r44 = raise NameError('value for final name "error_logger" was not set')
    if not r44 goto L67 (error at <module>:14) else goto L21 :: bool
L21:
    unreachable
L22:
    r45 = '_log'
    r46 = CPyObject_GetAttr(r43, r45)
    if is_error(r46) goto L67 (error at <module>:14) else goto L23
L23:
    dank_mids.helpers._errors.error_logger_log = r46 :: static
    r47 = dank_mids.helpers._errors.globals :: static
    r48 = 'error_logger_log'
    r49 = CPyDict_SetItem(r47, r48, r46)
    dec_ref r46
    r50 = r49 >= 0 :: signed
    if not r50 goto L67 (error at <module>:14) else goto L24 :: bool
L24:
    r51 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r51) goto L25 else goto L27
L25:
    r52 = raise NameError('value for final name "error_logger" was not set')
    if not r52 goto L67 (error at <module>:21) else goto L26 :: bool
L26:
    unreachable
L27:
    r53 = 'reverts'
    r54 = 'getChild'
    r55 = [r51, r53]
    r56 = load_address r55
    r57 = PyObject_VectorcallMethod(r54, r56, 9223372036854775810, 0)
    if is_error(r57) goto L67 (error at <module>:21) else goto L28
L28:
    dank_mids.helpers._errors.revert_logger = r57 :: static
    r58 = dank_mids.helpers._errors.globals :: static
    r59 = 'revert_logger'
    r60 = CPyDict_SetItem(r58, r59, r57)
    dec_ref r57
    r61 = r60 >= 0 :: signed
    if not r61 goto L67 (error at <module>:21) else goto L29 :: bool
L29:
    r62 = dank_mids.helpers._errors.revert_logger :: static
    if is_error(r62) goto L30 else goto L32
L30:
    r63 = raise NameError('value for final name "revert_logger" was not set')
    if not r63 goto L67 (error at <module>:22) else goto L31 :: bool
L31:
    unreachable
L32:
    r64 = '_log'
    r65 = CPyObject_GetAttr(r62, r64)
    if is_error(r65) goto L67 (error at <module>:22) else goto L33
L33:
    dank_mids.helpers._errors.revert_logger_log = r65 :: static
    r66 = dank_mids.helpers._errors.globals :: static
    r67 = 'revert_logger_log'
    r68 = CPyDict_SetItem(r66, r67, r65)
    dec_ref r65
    r69 = r68 >= 0 :: signed
    if not r69 goto L67 (error at <module>:22) else goto L34 :: bool
L34:
    r70 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r70) goto L35 else goto L37
L35:
    r71 = raise NameError('value for final name "error_logger" was not set')
    if not r71 goto L67 (error at <module>:29) else goto L36 :: bool
L36:
    unreachable
L37:
    r72 = 'timeouts'
    r73 = 'getChild'
    r74 = [r70, r72]
    r75 = load_address r74
    r76 = PyObject_VectorcallMethod(r73, r75, 9223372036854775810, 0)
    if is_error(r76) goto L67 (error at <module>:29) else goto L38
L38:
    dank_mids.helpers._errors.timeout_logger = r76 :: static
    r77 = dank_mids.helpers._errors.globals :: static
    r78 = 'timeout_logger'
    r79 = CPyDict_SetItem(r77, r78, r76)
    dec_ref r76
    r80 = r79 >= 0 :: signed
    if not r80 goto L67 (error at <module>:29) else goto L39 :: bool
L39:
    r81 = dank_mids.helpers._errors.timeout_logger :: static
    if is_error(r81) goto L40 else goto L42
L40:
    r82 = raise NameError('value for final name "timeout_logger" was not set')
    if not r82 goto L67 (error at <module>:30) else goto L41 :: bool
L41:
    unreachable
L42:
    r83 = 'debug'
    r84 = CPyObject_GetAttr(r81, r83)
    if is_error(r84) goto L67 (error at <module>:30) else goto L43
L43:
    dank_mids.helpers._errors.timeout_logger_debug = r84 :: static
    r85 = dank_mids.helpers._errors.globals :: static
    r86 = 'timeout_logger_debug'
    r87 = CPyDict_SetItem(r85, r86, r84)
    dec_ref r84
    r88 = r87 >= 0 :: signed
    if not r88 goto L67 (error at <module>:30) else goto L44 :: bool
L44:
    r89 = dank_mids.helpers._errors.timeout_logger :: static
    if is_error(r89) goto L45 else goto L47
L45:
    r90 = raise NameError('value for final name "timeout_logger" was not set')
    if not r90 goto L67 (error at <module>:31) else goto L46 :: bool
L46:
    unreachable
L47:
    r91 = 'warning'
    r92 = CPyObject_GetAttr(r89, r91)
    if is_error(r92) goto L67 (error at <module>:31) else goto L48
L48:
    dank_mids.helpers._errors.timeout_logger_warning = r92 :: static
    r93 = dank_mids.helpers._errors.globals :: static
    r94 = 'timeout_logger_warning'
    r95 = CPyDict_SetItem(r93, r94, r92)
    dec_ref r92
    r96 = r95 >= 0 :: signed
    if not r96 goto L67 (error at <module>:31) else goto L49 :: bool
L49:
    r97 = dank_mids.helpers._errors.error_logger :: static
    if is_error(r97) goto L50 else goto L52
L50:
    r98 = raise NameError('value for final name "error_logger" was not set')
    if not r98 goto L67 (error at <module>:34) else goto L51 :: bool
L51:
    unreachable
L52:
    r99 = 'gas'
    r100 = 'getChild'
    r101 = [r97, r99]
    r102 = load_address r101
    r103 = PyObject_VectorcallMethod(r100, r102, 9223372036854775810, 0)
    if is_error(r103) goto L67 (error at <module>:34) else goto L53
L53:
    dank_mids.helpers._errors.gas_logger = r103 :: static
    r104 = dank_mids.helpers._errors.globals :: static
    r105 = 'gas_logger'
    r106 = CPyDict_SetItem(r104, r105, r103)
    dec_ref r103
    r107 = r106 >= 0 :: signed
    if not r107 goto L67 (error at <module>:34) else goto L54 :: bool
L54:
    r108 = dank_mids.helpers._errors.gas_logger :: static
    if is_error(r108) goto L55 else goto L57
L55:
    r109 = raise NameError('value for final name "gas_logger" was not set')
    if not r109 goto L67 (error at <module>:35) else goto L56 :: bool
L56:
    unreachable
L57:
    r110 = 'debug'
    r111 = CPyObject_GetAttr(r108, r110)
    if is_error(r111) goto L67 (error at <module>:35) else goto L58
L58:
    dank_mids.helpers._errors.gas_logger_debug = r111 :: static
    r112 = dank_mids.helpers._errors.globals :: static
    r113 = 'gas_logger_debug'
    r114 = CPyDict_SetItem(r112, r113, r111)
    dec_ref r111
    r115 = r114 >= 0 :: signed
    if not r115 goto L67 (error at <module>:35) else goto L59 :: bool
L59:
    r116 = 'invalid opcode'
    r117 = 'missing trie node'
    r118 = 'resource not found'
    r119 = 'invalid ether transfer'
    r120 = 'error processing call revert'
    r121 = PySet_New(0)
    if is_error(r121) goto L67 (error at <module>:37) else goto L60
L60:
    r122 = PySet_Add(r121, r116)
    r123 = r122 >= 0 :: signed
    if not r123 goto L68 (error at <module>:37) else goto L61 :: bool
L61:
    r124 = PySet_Add(r121, r117)
    r125 = r124 >= 0 :: signed
    if not r125 goto L68 (error at <module>:37) else goto L62 :: bool
L62:
    r126 = PySet_Add(r121, r118)
    r127 = r126 >= 0 :: signed
    if not r127 goto L68 (error at <module>:37) else goto L63 :: bool
L63:
    r128 = PySet_Add(r121, r119)
    r129 = r128 >= 0 :: signed
    if not r129 goto L68 (error at <module>:37) else goto L64 :: bool
L64:
    r130 = PySet_Add(r121, r120)
    r131 = r130 >= 0 :: signed
    if not r131 goto L68 (error at <module>:37) else goto L65 :: bool
L65:
    dank_mids.helpers._errors.INDIVIDUAL_CALL_REVERT_STRINGS = r121 :: static
    r132 = dank_mids.helpers._errors.globals :: static
    r133 = 'INDIVIDUAL_CALL_REVERT_STRINGS'
    r134 = CPyDict_SetItem(r132, r133, r121)
    dec_ref r121
    r135 = r134 >= 0 :: signed
    if not r135 goto L67 (error at <module>:37) else goto L66 :: bool
L66:
    return 1
L67:
    r136 = <error> :: None
    return r136
L68:
    dec_ref r121
    goto L67

def BadResponse.__init__(self, response):
    self :: dank_mids._exceptions.BadResponse
    response :: object
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object[1]
    r10 :: object_ptr
    r11 :: object
    r12 :: str
    r13 :: object[3]
    r14 :: object_ptr
    r15 :: object
    r16 :: None
L0:
    r0 = 'response'
    r1 = PyObject_SetAttr(self, r0, response)
    r2 = r1 >= 0 :: signed
    if not r2 goto L6 (error at __init__:21) else goto L1 :: bool
L1:
    r3 = builtins :: module
    r4 = 'BaseException'
    r5 = CPyObject_GetAttr(r3, r4)
    if is_error(r5) goto L6 (error at __init__:22) else goto L2
L2:
    r6 = 'error'
    r7 = CPyObject_GetAttr(response, r6)
    if is_error(r7) goto L7 (error at __init__:22) else goto L3
L3:
    r8 = 'to_dict'
    r9 = [r7]
    r10 = load_address r9
    r11 = PyObject_VectorcallMethod(r8, r10, 9223372036854775809, 0)
    if is_error(r11) goto L8 (error at __init__:22) else goto L4
L4:
    dec_ref r7
    r12 = '__init__'
    r13 = [r5, self, r11]
    r14 = load_address r13
    r15 = PyObject_VectorcallMethod(r12, r14, 9223372036854775811, 0)
    if is_error(r15) goto L9 (error at __init__:22) else goto L10
L5:
    dec_ref r5
    dec_ref r11
    return 1
L6:
    r16 = <error> :: None
    return r16
L7:
    dec_ref r5
    goto L6
L8:
    dec_ref r5
    dec_ref r7
    goto L6
L9:
    dec_ref r5
    dec_ref r11
    goto L6
L10:
    dec_ref r15
    goto L5

def ExecutionReverted.__init__(self, response):
    self :: dank_mids._exceptions.ExecutionReverted
    response :: object
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: str
    r6 :: object
    r7, message, r8, r9 :: str
    r10 :: object[2]
    r11 :: object_ptr
    r12 :: object
    r13 :: int
    r14 :: bit
    r15 :: str
    r16 :: list
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: str
    r21 :: object
    r22 :: str
    r23 :: object[3]
    r24 :: object_ptr
    r25 :: object
    r26 :: None
L0:
    r0 = 'response'
    r1 = PyObject_SetAttr(self, r0, response)
    r2 = r1 >= 0 :: signed
    if not r2 goto L14 (error at __init__:35) else goto L1 :: bool
L1:
    r3 = 'error'
    r4 = CPyObject_GetAttr(response, r3)
    if is_error(r4) goto L14 (error at __init__:36) else goto L2
L2:
    r5 = 'message'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L14 (error at __init__:36) else goto L3
L3:
    r7 = cast(str, r6)
    if is_error(r7) goto L14 (error at __init__:36) else goto L4
L4:
    message = r7
    r8 = ':'
    r9 = 'count'
    r10 = [message, r8]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775810, 0)
    if is_error(r12) goto L15 (error at __init__:37) else goto L5
L5:
    r13 = unbox(int, r12)
    dec_ref r12
    if is_error(r13) goto L15 (error at __init__:37) else goto L6
L6:
    r14 = r13 == 2
    dec_ref r13 :: int
    if r14 goto L7 else goto L11 :: bool
L7:
    r15 = ':'
    r16 = PyUnicode_Split(message, r15, -1)
    dec_ref message
    if is_error(r16) goto L14 (error at __init__:38) else goto L8
L8:
    r17 = CPyList_GetItemShort(r16, 2)
    dec_ref r16
    if is_error(r17) goto L14 (error at __init__:38) else goto L9
L9:
    r18 = cast(str, r17)
    if is_error(r18) goto L14 (error at __init__:38) else goto L10
L10:
    message = r18
L11:
    r19 = builtins :: module
    r20 = 'BaseException'
    r21 = CPyObject_GetAttr(r19, r20)
    if is_error(r21) goto L15 (error at __init__:39) else goto L12
L12:
    r22 = '__init__'
    r23 = [r21, self, message]
    r24 = load_address r23
    r25 = PyObject_VectorcallMethod(r22, r24, 9223372036854775811, 0)
    if is_error(r25) goto L16 (error at __init__:39) else goto L17
L13:
    dec_ref r21
    dec_ref message
    return 1
L14:
    r26 = <error> :: None
    return r26
L15:
    dec_ref message
    goto L14
L16:
    dec_ref message
    dec_ref r21
    goto L14
L17:
    dec_ref r25
    goto L13

def ExceedsMaxBatchSize.limit(self):
    self :: dank_mids._exceptions.ExceedsMaxBatchSize
    r0, r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: str
    r6, r7 :: object
    r8 :: str
    r9 :: object
    r10 :: object[2]
    r11 :: object_ptr
    r12, r13, r14, r15 :: object
    r16 :: object[1]
    r17 :: object_ptr
    r18 :: object
    r19, r20 :: int
L0:
    r0 = 'batch limit (\\d+) exceeded'
    r1 = 'response'
    r2 = CPyObject_GetAttr(self, r1)
    if is_error(r2) goto L9 (error at limit:59) else goto L1
L1:
    r3 = 'error'
    r4 = CPyObject_GetAttr(r2, r3)
    dec_ref r2
    if is_error(r4) goto L9 (error at limit:59) else goto L2
L2:
    r5 = 'message'
    r6 = CPyObject_GetAttr(r4, r5)
    dec_ref r4
    if is_error(r6) goto L9 (error at limit:59) else goto L3
L3:
    r7 = re :: module
    r8 = 'search'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L10 (error at limit:59) else goto L4
L4:
    r10 = [r0, r6]
    r11 = load_address r10
    r12 = _PyObject_Vectorcall(r9, r11, 2, 0)
    dec_ref r9
    if is_error(r12) goto L10 (error at limit:59) else goto L5
L5:
    dec_ref r6
    r13 = object 1
    r14 = PyObject_GetItem(r12, r13)
    dec_ref r12
    if is_error(r14) goto L9 (error at limit:59) else goto L6
L6:
    r15 = load_address PyLong_Type
    r16 = [r14]
    r17 = load_address r16
    r18 = _PyObject_Vectorcall(r15, r17, 1, 0)
    if is_error(r18) goto L11 (error at limit:59) else goto L7
L7:
    dec_ref r14
    r19 = unbox(int, r18)
    dec_ref r18
    if is_error(r19) goto L9 (error at limit:59) else goto L8
L8:
    return r19
L9:
    r20 = <error> :: int
    return r20
L10:
    dec_ref r6
    goto L9
L11:
    dec_ref r14
    goto L9

def DankMidsClientResponseError.__init__(self, exc, request):
    self :: dank_mids._exceptions.DankMidsClientResponseError
    exc, request :: object
    r0 :: tuple
    r1 :: list
    r2 :: object
    r3 :: i32
    r4 :: bit
    r5 :: tuple
    r6 :: object
    r7 :: str
    r8, r9 :: object
    r10 :: object[2]
    r11 :: object_ptr
    r12 :: object
    r13 :: str
    r14 :: object
    r15 :: str
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: str
    r24 :: object
    r25 :: object[5]
    r26 :: object_ptr
    r27, r28 :: object
    r29 :: None
L0:
    inc_ref request
    self.request = request
    r0 = self.args
    if is_error(r0) goto L15 (error at __init__:77) else goto L1
L1:
    r1 = PyList_New(0)
    if is_error(r1) goto L16 (error at __init__:77) else goto L2
L2:
    r2 = CPyList_Extend(r1, r0)
    dec_ref r0
    if is_error(r2) goto L17 (error at __init__:77) else goto L18
L3:
    r3 = PyList_Append(r1, request)
    r4 = r3 >= 0 :: signed
    if not r4 goto L17 (error at __init__:77) else goto L4 :: bool
L4:
    r5 = PyList_AsTuple(r1)
    dec_ref r1
    if is_error(r5) goto L15 (error at __init__:77) else goto L5
L5:
    self.args = r5
    inc_ref exc
    self._exception = exc
    r6 = builtins :: module
    r7 = 'super'
    r8 = CPyObject_GetAttr(r6, r7)
    if is_error(r8) goto L15 (error at __init__:85) else goto L6
L6:
    r9 = dank_mids._exceptions.DankMidsClientResponseError :: type
    r10 = [r9, self]
    r11 = load_address r10
    r12 = _PyObject_Vectorcall(r8, r11, 2, 0)
    dec_ref r8
    if is_error(r12) goto L15 (error at __init__:85) else goto L7
L7:
    r13 = '__init__'
    r14 = CPyObject_GetAttr(r12, r13)
    dec_ref r12
    if is_error(r14) goto L15 (error at __init__:85) else goto L8
L8:
    r15 = 'request_info'
    r16 = CPyObject_GetAttr(exc, r15)
    if is_error(r16) goto L19 (error at __init__:86) else goto L9
L9:
    r17 = 'history'
    r18 = CPyObject_GetAttr(exc, r17)
    if is_error(r18) goto L20 (error at __init__:87) else goto L10
L10:
    r19 = 'status'
    r20 = CPyObject_GetAttr(exc, r19)
    if is_error(r20) goto L21 (error at __init__:88) else goto L11
L11:
    r21 = 'message'
    r22 = CPyObject_GetAttr(exc, r21)
    if is_error(r22) goto L22 (error at __init__:89) else goto L12
L12:
    r23 = 'headers'
    r24 = CPyObject_GetAttr(exc, r23)
    if is_error(r24) goto L23 (error at __init__:90) else goto L13
L13:
    r25 = [r16, r18, r20, r22, r24]
    r26 = load_address r25
    r27 = ('status', 'message', 'headers')
    r28 = _PyObject_Vectorcall(r14, r26, 2, r27)
    dec_ref r14
    if is_error(r28) goto L24 (error at __init__:85) else goto L25
L14:
    dec_ref r16
    dec_ref r18
    dec_ref r20
    dec_ref r22
    dec_ref r24
    return 1
L15:
    r29 = <error> :: None
    return r29
L16:
    dec_ref r0
    goto L15
L17:
    dec_ref r1
    goto L15
L18:
    dec_ref r2
    goto L3
L19:
    dec_ref r14
    goto L15
L20:
    dec_ref r14
    dec_ref r16
    goto L15
L21:
    dec_ref r14
    dec_ref r16
    dec_ref r18
    goto L15
L22:
    dec_ref r14
    dec_ref r16
    dec_ref r18
    dec_ref r20
    goto L15
L23:
    dec_ref r14
    dec_ref r16
    dec_ref r18
    dec_ref r20
    dec_ref r22
    goto L15
L24:
    dec_ref r16
    dec_ref r18
    dec_ref r20
    dec_ref r22
    dec_ref r24
    goto L15
L25:
    dec_ref r28
    goto L14

def DankMidsInternalError.__init__(self, exc):
    self :: dank_mids._exceptions.DankMidsInternalError
    exc, r0 :: object
    r1 :: bool
    r2, r3, r4, r5 :: str
    r6 :: object
    r7 :: object[3]
    r8 :: object_ptr
    r9, r10 :: object
    r11 :: str
    r12 :: i32
    r13 :: bit
    r14 :: object
    r15 :: str
    r16, r17 :: object
    r18 :: object[2]
    r19 :: object_ptr
    r20 :: object
    r21 :: str
    r22, r23 :: object
    r24 :: str
    r25 :: object
    r26 :: object[1]
    r27 :: object_ptr
    r28 :: object
    r29 :: str
    r30 :: object[1]
    r31 :: object_ptr
    r32 :: object
    r33 :: None
L0:
    r0 = dank_mids._exceptions.logger :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "logger" was not set')
    if not r1 goto L15 (error at __init__:104) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = 'unhandled exception inside dank mids internals: '
    r3 = PyObject_Str(exc)
    if is_error(r3) goto L15 (error at __init__:104) else goto L4
L4:
    r4 = CPyStr_Build(2, r2, r3)
    dec_ref r3
    if is_error(r4) goto L15 (error at __init__:104) else goto L5
L5:
    r5 = 'warning'
    r6 = box(bool, 1)
    r7 = [r0, r4, r6]
    r8 = load_address r7
    r9 = ('exc_info',)
    r10 = PyObject_VectorcallMethod(r5, r8, 9223372036854775810, r9)
    if is_error(r10) goto L16 (error at __init__:104) else goto L17
L6:
    dec_ref r4
    r11 = '_original_exception'
    r12 = PyObject_SetAttr(self, r11, exc)
    r13 = r12 >= 0 :: signed
    if not r13 goto L15 (error at __init__:106) else goto L7 :: bool
L7:
    r14 = builtins :: module
    r15 = 'super'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L15 (error at __init__:112) else goto L8
L8:
    r17 = dank_mids._exceptions.DankMidsInternalError :: type
    r18 = [r17, self]
    r19 = load_address r18
    r20 = _PyObject_Vectorcall(r16, r19, 2, 0)
    dec_ref r16
    if is_error(r20) goto L15 (error at __init__:112) else goto L9
L9:
    r21 = '__init__'
    r22 = CPyObject_GetAttr(r20, r21)
    dec_ref r20
    if is_error(r22) goto L15 (error at __init__:112) else goto L10
L10:
    r23 = builtins :: module
    r24 = 'repr'
    r25 = CPyObject_GetAttr(r23, r24)
    if is_error(r25) goto L18 (error at __init__:112) else goto L11
L11:
    r26 = [exc]
    r27 = load_address r26
    r28 = _PyObject_Vectorcall(r25, r27, 1, 0)
    dec_ref r25
    if is_error(r28) goto L18 (error at __init__:112) else goto L12
L12:
    r29 = cast(str, r28)
    if is_error(r29) goto L18 (error at __init__:112) else goto L13
L13:
    r30 = [r29]
    r31 = load_address r30
    r32 = _PyObject_Vectorcall(r22, r31, 1, 0)
    dec_ref r22
    if is_error(r32) goto L19 (error at __init__:112) else goto L20
L14:
    dec_ref r29
    return 1
L15:
    r33 = <error> :: None
    return r33
L16:
    dec_ref r4
    goto L15
L17:
    dec_ref r10
    goto L6
L18:
    dec_ref r22
    goto L15
L19:
    dec_ref r29
    goto L15
L20:
    dec_ref r32
    goto L14

def BatchResponseSortError.__init__(self, controller, calls, response):
    self :: dank_mids._exceptions.BatchResponseSortError
    controller, calls :: object
    response :: list
    r0 :: str
    r1 :: i32
    r2 :: bit
    r3 :: ptr
    r4 :: native_int
    r5 :: list
    r6 :: short_int
    r7 :: ptr
    r8 :: native_int
    r9 :: short_int
    r10 :: bit
    r11 :: native_int
    r12, r13 :: ptr
    r14 :: native_int
    r15 :: ptr
    r16 :: object
    r17 :: dank_mids.helpers._codec.RawResponse
    r18 :: bool
    r19 :: object
    r20 :: bit
    r21 :: short_int
    r22 :: str
    r23 :: i32
    r24 :: bit
    r25 :: object
    r26 :: str
    r27, r28 :: object
    r29 :: object[2]
    r30 :: object_ptr
    r31 :: object
    r32 :: str
    r33 :: object
    r34, r35 :: str
    r36 :: object
    r37, r38, r39 :: str
    r40 :: object
    r41, r42 :: str
    r43 :: list
    r44, r45 :: object
    r46 :: str
    r47 :: object
    r48 :: i32
    r49, r50 :: bit
    r51, r52, r53 :: str
    r54 :: object
    r55 :: list
    r56, r57 :: str
    r58 :: object[1]
    r59 :: object_ptr
    r60 :: object
    r61 :: None
L0:
    r0 = 'calls'
    r1 = PyObject_SetAttr(self, r0, calls)
    r2 = r1 >= 0 :: signed
    if not r2 goto L29 (error at __init__:128) else goto L1 :: bool
L1:
    r3 = get_element_ptr response ob_size :: PyVarObject
    r4 = load_mem r3 :: native_int*
    r5 = PyList_New(r4)
    if is_error(r5) goto L29 (error at __init__:134) else goto L2
L2:
    r6 = 0
L3:
    r7 = get_element_ptr response ob_size :: PyVarObject
    r8 = load_mem r7 :: native_int*
    r9 = r8 << 1
    r10 = r6 < r9 :: signed
    if r10 goto L4 else goto L8 :: bool
L4:
    r11 = r6 >> 1
    r12 = get_element_ptr response ob_item :: PyListObject
    r13 = load_mem r12 :: ptr*
    r14 = r11 * 8
    r15 = r13 + r14
    r16 = load_mem r15 :: builtins.object*
    inc_ref r16
    r17 = cast(dank_mids.helpers._codec.RawResponse, r16)
    if is_error(r17) goto L30 (error at __init__:134) else goto L5
L5:
    r18 = <error> :: bool
    r19 = r17.decode(r18)
    dec_ref r17
    if is_error(r19) goto L30 (error at __init__:134) else goto L6
L6:
    r20 = CPyList_SetItemUnsafe(r5, r6, r19)
    if not r20 goto L30 (error at __init__:134) else goto L7 :: bool
L7:
    r21 = r6 + 2
    r6 = r21
    goto L3
L8:
    r22 = 'results'
    r23 = PyObject_SetAttr(self, r22, r5)
    dec_ref r5
    r24 = r23 >= 0 :: signed
    if not r24 goto L29 (error at __init__:134) else goto L9 :: bool
L9:
    r25 = builtins :: module
    r26 = 'super'
    r27 = CPyObject_GetAttr(r25, r26)
    if is_error(r27) goto L29 (error at __init__:140) else goto L10
L10:
    r28 = dank_mids._exceptions.BatchResponseSortError :: type
    r29 = [r28, self]
    r30 = load_address r29
    r31 = _PyObject_Vectorcall(r27, r30, 2, 0)
    dec_ref r27
    if is_error(r31) goto L29 (error at __init__:140) else goto L11
L11:
    r32 = '__init__'
    r33 = CPyObject_GetAttr(r31, r32)
    dec_ref r31
    if is_error(r33) goto L29 (error at __init__:140) else goto L12
L12:
    r34 = 'This will not mess up your run but will make things needlessly slow. Please show this to Bob.\nendpoint='
    r35 = 'endpoint'
    r36 = CPyObject_GetAttr(controller, r35)
    if is_error(r36) goto L31 (error at __init__:142) else goto L13
L13:
    r37 = cast(str, r36)
    if is_error(r37) goto L31 (error at __init__:142) else goto L14
L14:
    r38 = '\nclient_version='
    r39 = 'client_version'
    r40 = CPyObject_GetAttr(controller, r39)
    if is_error(r40) goto L32 (error at __init__:143) else goto L15
L15:
    r41 = cast(str, r40)
    if is_error(r41) goto L32 (error at __init__:143) else goto L16
L16:
    r42 = '\ncalls='
    r43 = PyList_New(0)
    if is_error(r43) goto L33 (error at __init__:144) else goto L17
L17:
    r44 = PyObject_GetIter(calls)
    if is_error(r44) goto L34 (error at __init__:144) else goto L18
L18:
    r45 = PyIter_Next(r44)
    if is_error(r45) goto L35 else goto L19
L19:
    r46 = 'uid'
    r47 = CPyObject_GetAttr(r45, r46)
    dec_ref r45
    if is_error(r47) goto L36 (error at __init__:144) else goto L20
L20:
    r48 = PyList_Append(r43, r47)
    dec_ref r47
    r49 = r48 >= 0 :: signed
    if not r49 goto L36 (error at __init__:144) else goto L18 :: bool
L21:
    r50 = CPy_NoErrOccurred()
    if not r50 goto L34 (error at __init__:144) else goto L22 :: bool
L22:
    r51 = PyObject_Str(r43)
    dec_ref r43
    if is_error(r51) goto L33 (error at __init__:141) else goto L23
L23:
    r52 = '\nresponse='
    r53 = 'results'
    r54 = CPyObject_GetAttr(self, r53)
    if is_error(r54) goto L37 (error at __init__:145) else goto L24
L24:
    r55 = cast(list, r54)
    if is_error(r55) goto L37 (error at __init__:145) else goto L25
L25:
    r56 = PyObject_Str(r55)
    dec_ref r55
    if is_error(r56) goto L37 (error at __init__:141) else goto L26
L26:
    r57 = CPyStr_Build(8, r34, r37, r38, r41, r42, r51, r52, r56)
    dec_ref r37
    dec_ref r41
    dec_ref r51
    dec_ref r56
    if is_error(r57) goto L31 (error at __init__:141) else goto L27
L27:
    r58 = [r57]
    r59 = load_address r58
    r60 = _PyObject_Vectorcall(r33, r59, 1, 0)
    dec_ref r33
    if is_error(r60) goto L38 (error at __init__:140) else goto L39
L28:
    dec_ref r57
    return 1
L29:
    r61 = <error> :: None
    return r61
L30:
    dec_ref r5
    goto L29
L31:
    dec_ref r33
    goto L29
L32:
    dec_ref r33
    dec_ref r37
    goto L29
L33:
    dec_ref r33
    dec_ref r37
    dec_ref r41
    goto L29
L34:
    dec_ref r33
    dec_ref r37
    dec_ref r41
    dec_ref r43
    goto L29
L35:
    dec_ref r44
    goto L21
L36:
    dec_ref r33
    dec_ref r37
    dec_ref r41
    dec_ref r43
    dec_ref r44
    goto L29
L37:
    dec_ref r33
    dec_ref r37
    dec_ref r41
    dec_ref r51
    goto L29
L38:
    dec_ref r57
    goto L29
L39:
    dec_ref r60
    goto L28

def ChainstackRateLimitError.try_again_in(self):
    self :: dank_mids._exceptions.ChainstackRateLimitError
    r0 :: str
    r1 :: object
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: float
    r9 :: bit
    r10 :: object
    r11 :: float
L0:
    r0 = 'response'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L7 (error at try_again_in:168) else goto L1
L1:
    r2 = 'error'
    r3 = CPyObject_GetAttr(r1, r2)
    dec_ref r1
    if is_error(r3) goto L7 (error at try_again_in:168) else goto L2
L2:
    r4 = 'data'
    r5 = CPyObject_GetAttr(r3, r4)
    dec_ref r3
    if is_error(r5) goto L7 (error at try_again_in:168) else goto L3
L3:
    r6 = 'try_again_in'
    r7 = CPyObject_GetAttr(r5, r6)
    dec_ref r5
    if is_error(r7) goto L7 (error at try_again_in:168) else goto L4
L4:
    r8 = unbox(float, r7)
    dec_ref r7
    r9 = r8 == -113.0
    if r9 goto L6 else goto L5 :: bool
L5:
    return r8
L6:
    r10 = PyErr_Occurred()
    if not is_error(r10) goto L7 (error at try_again_in:168) else goto L5
L7:
    r11 = <error> :: float
    return r11

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5, r6 :: object_ptr
    r7 :: object_ptr[2]
    r8 :: c_ptr
    r9 :: native_int[2]
    r10 :: c_ptr
    r11 :: object
    r12 :: dict
    r13, r14 :: str
    r15 :: bit
    r16 :: object
    r17 :: str
    r18 :: dict
    r19, r20 :: object
    r21 :: str
    r22 :: dict
    r23 :: object
    r24 :: str
    r25 :: object
    r26 :: str
    r27 :: object
    r28 :: object[1]
    r29 :: object_ptr
    r30 :: object
    r31 :: dict
    r32 :: str
    r33 :: i32
    r34 :: bit
    r35 :: object
    r36 :: str
    r37 :: object
    r38 :: tuple
    r39 :: str
    r40, r41 :: object
    r42, r43 :: str
    r44 :: tuple
    r45 :: i32
    r46 :: bit
    r47 :: dict
    r48 :: str
    r49 :: i32
    r50 :: bit
    r51 :: object
    r52 :: str
    r53 :: object
    r54 :: tuple
    r55 :: str
    r56, r57 :: object
    r58, r59 :: str
    r60 :: tuple
    r61 :: i32
    r62 :: bit
    r63 :: dict
    r64 :: str
    r65 :: i32
    r66 :: bit
    r67 :: object
    r68 :: tuple
    r69 :: str
    r70, r71 :: object
    r72, r73 :: str
    r74 :: tuple
    r75 :: i32
    r76 :: bit
    r77 :: dict
    r78 :: str
    r79 :: i32
    r80 :: bit
    r81 :: object
    r82 :: tuple
    r83 :: str
    r84, r85 :: object
    r86, r87 :: str
    r88 :: tuple
    r89 :: i32
    r90 :: bit
    r91 :: dict
    r92 :: str
    r93 :: i32
    r94 :: bit
    r95 :: object
    r96 :: tuple
    r97 :: str
    r98, r99 :: object
    r100, r101 :: str
    r102 :: tuple
    r103 :: i32
    r104 :: bit
    r105 :: dict
    r106 :: str
    r107 :: i32
    r108 :: bit
    r109 :: object
    r110 :: tuple
    r111 :: str
    r112, r113 :: object
    r114, r115 :: str
    r116 :: tuple
    r117 :: i32
    r118 :: bit
    r119 :: dict
    r120 :: str
    r121 :: i32
    r122 :: bit
    r123 :: dict
    r124 :: str
    r125 :: object
    r126 :: tuple
    r127 :: str
    r128, r129 :: object
    r130 :: bool
    r131, r132, r133, r134 :: str
    r135 :: tuple
    r136 :: i32
    r137 :: bit
    r138 :: dict
    r139 :: str
    r140 :: i32
    r141 :: bit
    r142 :: dict
    r143 :: str
    r144, r145 :: object
    r146 :: str
    r147, r148 :: object
    r149 :: str
    r150, r151 :: object
    r152 :: str
    r153, r154 :: object
    r155 :: str
    r156, r157 :: object
    r158 :: str
    r159, r160 :: object
    r161 :: str
    r162 :: object
    r163 :: tuple[object, object, object, object, object, object]
    r164, r165 :: object
    r166 :: dict
    r167 :: str
    r168 :: i32
    r169 :: bit
    r170 :: dict
    r171 :: str
    r172 :: object
    r173 :: dict
    r174 :: str
    r175 :: i32
    r176 :: bit
    r177 :: object
    r178 :: str
    r179 :: object
    r180 :: tuple
    r181 :: str
    r182, r183 :: object
    r184, r185 :: str
    r186 :: tuple
    r187 :: i32
    r188 :: bit
    r189 :: dict
    r190 :: str
    r191 :: i32
    r192 :: bit
    r193 :: object
    r194 :: str
    r195 :: object
    r196 :: tuple
    r197 :: str
    r198, r199 :: object
    r200, r201 :: str
    r202 :: tuple
    r203 :: i32
    r204 :: bit
    r205 :: dict
    r206 :: str
    r207 :: i32
    r208 :: bit
    r209 :: object
    r210 :: tuple
    r211 :: str
    r212, r213 :: object
    r214, r215 :: str
    r216 :: tuple
    r217 :: i32
    r218 :: bit
    r219 :: dict
    r220 :: str
    r221 :: i32
    r222 :: bit
    r223 :: object
    r224 :: tuple
    r225 :: str
    r226, r227 :: object
    r228, r229 :: str
    r230 :: tuple
    r231 :: i32
    r232 :: bit
    r233 :: dict
    r234 :: str
    r235 :: i32
    r236 :: bit
    r237 :: object
    r238 :: tuple
    r239 :: str
    r240, r241 :: object
    r242, r243 :: str
    r244 :: tuple
    r245 :: i32
    r246 :: bit
    r247 :: dict
    r248 :: str
    r249 :: i32
    r250 :: bit
    r251 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L88 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address logging :: module
    r6 = load_address re :: module
    r7 = [r5, r6]
    r8 = load_address r7
    r9 = [1, 2]
    r10 = load_address r9
    r11 = (('logging', 'logging', 'logging'), ('re', 're', 're'))
    r12 = dank_mids._exceptions.globals :: static
    r13 = 'dank_mids\\_exceptions.py'
    r14 = '<module>'
    r15 = CPyImport_ImportMany(r11, r8, r12, r13, r14, r10)
    if not r15 goto L88 else goto L4 :: bool
L4:
    r16 = ('TYPE_CHECKING', 'Final', 'List', 'Sequence', 'Union', 'final')
    r17 = 'typing'
    r18 = dank_mids._exceptions.globals :: static
    r19 = CPyImport_ImportFromMany(r17, r16, r16, r18)
    if is_error(r19) goto L88 (error at <module>:3) else goto L5
L5:
    typing = r19 :: module
    dec_ref r19
    r20 = ('ClientResponseError',)
    r21 = 'aiohttp.client_exceptions'
    r22 = dank_mids._exceptions.globals :: static
    r23 = CPyImport_ImportFromMany(r21, r20, r20, r22)
    if is_error(r23) goto L88 (error at <module>:5) else goto L6
L6:
    aiohttp.client_exceptions = r23 :: module
    dec_ref r23
    if 0 goto L7 else goto L7 :: bool
L7:
    r24 = 'dank_mids.exceptions'
    r25 = logging :: module
    r26 = 'getLogger'
    r27 = CPyObject_GetAttr(r25, r26)
    if is_error(r27) goto L88 (error at <module>:14) else goto L8
L8:
    r28 = [r24]
    r29 = load_address r28
    r30 = _PyObject_Vectorcall(r27, r29, 1, 0)
    dec_ref r27
    if is_error(r30) goto L88 (error at <module>:14) else goto L9
L9:
    dank_mids._exceptions.logger = r30 :: static
    r31 = dank_mids._exceptions.globals :: static
    r32 = 'logger'
    r33 = CPyDict_SetItem(r31, r32, r30)
    dec_ref r30
    r34 = r33 >= 0 :: signed
    if not r34 goto L88 (error at <module>:14) else goto L10 :: bool
L10:
    r35 = builtins :: module
    r36 = 'ValueError'
    r37 = CPyObject_GetAttr(r35, r36)
    if is_error(r37) goto L88 (error at <module>:17) else goto L11
L11:
    r38 = PyTuple_Pack(1, r37)
    dec_ref r37
    if is_error(r38) goto L88 (error at <module>:17) else goto L12
L12:
    r39 = 'dank_mids._exceptions'
    r40 = dank_mids._exceptions.BadResponse_template :: type
    r41 = CPyType_FromTemplate(r40, r38, r39)
    dec_ref r38
    if is_error(r41) goto L88 (error at <module>:17) else goto L13
L13:
    r42 = '__mypyc_attrs__'
    r43 = '__dict__'
    r44 = PyTuple_Pack(1, r43)
    if is_error(r44) goto L89 (error at <module>:17) else goto L14
L14:
    r45 = PyObject_SetAttr(r41, r42, r44)
    dec_ref r44
    r46 = r45 >= 0 :: signed
    if not r46 goto L89 (error at <module>:17) else goto L15 :: bool
L15:
    dank_mids._exceptions.BadResponse = r41 :: type
    r47 = dank_mids._exceptions.globals :: static
    r48 = 'BadResponse'
    r49 = CPyDict_SetItem(r47, r48, r41)
    dec_ref r41
    r50 = r49 >= 0 :: signed
    if not r50 goto L88 (error at <module>:17) else goto L16 :: bool
L16:
    r51 = builtins :: module
    r52 = 'ValueError'
    r53 = CPyObject_GetAttr(r51, r52)
    if is_error(r53) goto L88 (error at <module>:26) else goto L17
L17:
    r54 = PyTuple_Pack(1, r53)
    dec_ref r53
    if is_error(r54) goto L88 (error at <module>:26) else goto L18
L18:
    r55 = 'dank_mids._exceptions'
    r56 = dank_mids._exceptions.EmptyBatch_template :: type
    r57 = CPyType_FromTemplate(r56, r54, r55)
    dec_ref r54
    if is_error(r57) goto L88 (error at <module>:26) else goto L19
L19:
    r58 = '__mypyc_attrs__'
    r59 = '__dict__'
    r60 = PyTuple_Pack(1, r59)
    if is_error(r60) goto L90 (error at <module>:26) else goto L20
L20:
    r61 = PyObject_SetAttr(r57, r58, r60)
    dec_ref r60
    r62 = r61 >= 0 :: signed
    if not r62 goto L90 (error at <module>:26) else goto L21 :: bool
L21:
    dank_mids._exceptions.EmptyBatch = r57 :: type
    r63 = dank_mids._exceptions.globals :: static
    r64 = 'EmptyBatch'
    r65 = CPyDict_SetItem(r63, r64, r57)
    dec_ref r57
    r66 = r65 >= 0 :: signed
    if not r66 goto L88 (error at <module>:26) else goto L22 :: bool
L22:
    r67 = dank_mids._exceptions.BadResponse :: type
    r68 = PyTuple_Pack(1, r67)
    if is_error(r68) goto L88 (error at <module>:31) else goto L23
L23:
    r69 = 'dank_mids._exceptions'
    r70 = dank_mids._exceptions.ExecutionReverted_template :: type
    r71 = CPyType_FromTemplate(r70, r68, r69)
    dec_ref r68
    if is_error(r71) goto L88 (error at <module>:31) else goto L24
L24:
    r72 = '__mypyc_attrs__'
    r73 = '__dict__'
    r74 = PyTuple_Pack(1, r73)
    if is_error(r74) goto L91 (error at <module>:31) else goto L25
L25:
    r75 = PyObject_SetAttr(r71, r72, r74)
    dec_ref r74
    r76 = r75 >= 0 :: signed
    if not r76 goto L91 (error at <module>:31) else goto L26 :: bool
L26:
    dank_mids._exceptions.ExecutionReverted = r71 :: type
    r77 = dank_mids._exceptions.globals :: static
    r78 = 'ExecutionReverted'
    r79 = CPyDict_SetItem(r77, r78, r71)
    dec_ref r71
    r80 = r79 >= 0 :: signed
    if not r80 goto L88 (error at <module>:31) else goto L27 :: bool
L27:
    r81 = dank_mids._exceptions.BadResponse :: type
    r82 = PyTuple_Pack(1, r81)
    if is_error(r82) goto L88 (error at <module>:43) else goto L28
L28:
    r83 = 'dank_mids._exceptions'
    r84 = dank_mids._exceptions.OutOfGas_template :: type
    r85 = CPyType_FromTemplate(r84, r82, r83)
    dec_ref r82
    if is_error(r85) goto L88 (error at <module>:43) else goto L29
L29:
    r86 = '__mypyc_attrs__'
    r87 = '__dict__'
    r88 = PyTuple_Pack(1, r87)
    if is_error(r88) goto L92 (error at <module>:43) else goto L30
L30:
    r89 = PyObject_SetAttr(r85, r86, r88)
    dec_ref r88
    r90 = r89 >= 0 :: signed
    if not r90 goto L92 (error at <module>:43) else goto L31 :: bool
L31:
    dank_mids._exceptions.OutOfGas = r85 :: type
    r91 = dank_mids._exceptions.globals :: static
    r92 = 'OutOfGas'
    r93 = CPyDict_SetItem(r91, r92, r85)
    dec_ref r85
    r94 = r93 >= 0 :: signed
    if not r94 goto L88 (error at <module>:43) else goto L32 :: bool
L32:
    r95 = dank_mids._exceptions.BadResponse :: type
    r96 = PyTuple_Pack(1, r95)
    if is_error(r96) goto L88 (error at <module>:48) else goto L33
L33:
    r97 = 'dank_mids._exceptions'
    r98 = dank_mids._exceptions.PayloadTooLarge_template :: type
    r99 = CPyType_FromTemplate(r98, r96, r97)
    dec_ref r96
    if is_error(r99) goto L88 (error at <module>:48) else goto L34
L34:
    r100 = '__mypyc_attrs__'
    r101 = '__dict__'
    r102 = PyTuple_Pack(1, r101)
    if is_error(r102) goto L93 (error at <module>:48) else goto L35
L35:
    r103 = PyObject_SetAttr(r99, r100, r102)
    dec_ref r102
    r104 = r103 >= 0 :: signed
    if not r104 goto L93 (error at <module>:48) else goto L36 :: bool
L36:
    dank_mids._exceptions.PayloadTooLarge = r99 :: type
    r105 = dank_mids._exceptions.globals :: static
    r106 = 'PayloadTooLarge'
    r107 = CPyDict_SetItem(r105, r106, r99)
    dec_ref r99
    r108 = r107 >= 0 :: signed
    if not r108 goto L88 (error at <module>:48) else goto L37 :: bool
L37:
    r109 = dank_mids._exceptions.BadResponse :: type
    r110 = PyTuple_Pack(1, r109)
    if is_error(r110) goto L88 (error at <module>:53) else goto L38
L38:
    r111 = 'dank_mids._exceptions'
    r112 = dank_mids._exceptions.ExceedsMaxBatchSize_template :: type
    r113 = CPyType_FromTemplate(r112, r110, r111)
    dec_ref r110
    if is_error(r113) goto L88 (error at <module>:53) else goto L39
L39:
    r114 = '__mypyc_attrs__'
    r115 = '__dict__'
    r116 = PyTuple_Pack(1, r115)
    if is_error(r116) goto L94 (error at <module>:53) else goto L40
L40:
    r117 = PyObject_SetAttr(r113, r114, r116)
    dec_ref r116
    r118 = r117 >= 0 :: signed
    if not r118 goto L94 (error at <module>:53) else goto L41 :: bool
L41:
    dank_mids._exceptions.ExceedsMaxBatchSize = r113 :: type
    r119 = dank_mids._exceptions.globals :: static
    r120 = 'ExceedsMaxBatchSize'
    r121 = CPyDict_SetItem(r119, r120, r113)
    dec_ref r113
    r122 = r121 >= 0 :: signed
    if not r122 goto L88 (error at <module>:53) else goto L42 :: bool
L42:
    r123 = dank_mids._exceptions.globals :: static
    r124 = 'ClientResponseError'
    r125 = CPyDict_GetItem(r123, r124)
    if is_error(r125) goto L88 (error at <module>:63) else goto L43
L43:
    r126 = PyTuple_Pack(1, r125)
    dec_ref r125
    if is_error(r126) goto L88 (error at <module>:63) else goto L44
L44:
    r127 = 'dank_mids._exceptions'
    r128 = dank_mids._exceptions.DankMidsClientResponseError_template :: type
    r129 = CPyType_FromTemplate(r128, r126, r127)
    dec_ref r126
    if is_error(r129) goto L88 (error at <module>:63) else goto L45
L45:
    r130 = DankMidsClientResponseError_trait_vtable_setup()
    if is_error(r130) goto L95 (error at <module>:-1) else goto L46
L46:
    r131 = '__mypyc_attrs__'
    r132 = 'request'
    r133 = 'args'
    r134 = '_exception'
    r135 = PyTuple_Pack(3, r132, r133, r134)
    if is_error(r135) goto L95 (error at <module>:63) else goto L47
L47:
    r136 = PyObject_SetAttr(r129, r131, r135)
    dec_ref r135
    r137 = r136 >= 0 :: signed
    if not r137 goto L95 (error at <module>:63) else goto L48 :: bool
L48:
    dank_mids._exceptions.DankMidsClientResponseError = r129 :: type
    r138 = dank_mids._exceptions.globals :: static
    r139 = 'DankMidsClientResponseError'
    r140 = CPyDict_SetItem(r138, r139, r129)
    dec_ref r129
    r141 = r140 >= 0 :: signed
    if not r141 goto L88 (error at <module>:63) else goto L49 :: bool
L49:
    r142 = dank_mids._exceptions.globals :: static
    r143 = 'Union'
    r144 = CPyDict_GetItem(r142, r143)
    if is_error(r144) goto L88 (error at <module>:94) else goto L50
L50:
    r145 = builtins :: module
    r146 = 'AttributeError'
    r147 = CPyObject_GetAttr(r145, r146)
    if is_error(r147) goto L96 (error at <module>:95) else goto L51
L51:
    r148 = builtins :: module
    r149 = 'TypeError'
    r150 = CPyObject_GetAttr(r148, r149)
    if is_error(r150) goto L97 (error at <module>:95) else goto L52
L52:
    r151 = builtins :: module
    r152 = 'UnboundLocalError'
    r153 = CPyObject_GetAttr(r151, r152)
    if is_error(r153) goto L98 (error at <module>:95) else goto L53
L53:
    r154 = builtins :: module
    r155 = 'NotImplementedError'
    r156 = CPyObject_GetAttr(r154, r155)
    if is_error(r156) goto L99 (error at <module>:95) else goto L54
L54:
    r157 = builtins :: module
    r158 = 'RuntimeError'
    r159 = CPyObject_GetAttr(r157, r158)
    if is_error(r159) goto L100 (error at <module>:95) else goto L55
L55:
    r160 = builtins :: module
    r161 = 'SyntaxError'
    r162 = CPyObject_GetAttr(r160, r161)
    if is_error(r162) goto L101 (error at <module>:95) else goto L56
L56:
    r163 = (r147, r150, r153, r156, r159, r162)
    r164 = box(tuple[object, object, object, object, object, object], r163)
    r165 = PyObject_GetItem(r144, r164)
    dec_ref r144
    dec_ref r164
    if is_error(r165) goto L88 (error at <module>:94) else goto L57
L57:
    r166 = dank_mids._exceptions.globals :: static
    r167 = '_internal_err_types'
    r168 = CPyDict_SetItem(r166, r167, r165)
    dec_ref r165
    r169 = r168 >= 0 :: signed
    if not r169 goto L88 (error at <module>:94) else goto L58 :: bool
L58:
    r170 = dank_mids._exceptions.globals :: static
    r171 = '_internal_err_types'
    r172 = CPyDict_GetItem(r170, r171)
    if is_error(r172) goto L88 (error at <module>:97) else goto L59
L59:
    dank_mids._exceptions.internal_err_types = r172 :: static
    r173 = dank_mids._exceptions.globals :: static
    r174 = 'internal_err_types'
    r175 = CPyDict_SetItem(r173, r174, r172)
    dec_ref r172
    r176 = r175 >= 0 :: signed
    if not r176 goto L88 (error at <module>:97) else goto L60 :: bool
L60:
    r177 = builtins :: module
    r178 = 'Exception'
    r179 = CPyObject_GetAttr(r177, r178)
    if is_error(r179) goto L88 (error at <module>:100) else goto L61
L61:
    r180 = PyTuple_Pack(1, r179)
    dec_ref r179
    if is_error(r180) goto L88 (error at <module>:100) else goto L62
L62:
    r181 = 'dank_mids._exceptions'
    r182 = dank_mids._exceptions.DankMidsInternalError_template :: type
    r183 = CPyType_FromTemplate(r182, r180, r181)
    dec_ref r180
    if is_error(r183) goto L88 (error at <module>:100) else goto L63
L63:
    r184 = '__mypyc_attrs__'
    r185 = '__dict__'
    r186 = PyTuple_Pack(1, r185)
    if is_error(r186) goto L102 (error at <module>:100) else goto L64
L64:
    r187 = PyObject_SetAttr(r183, r184, r186)
    dec_ref r186
    r188 = r187 >= 0 :: signed
    if not r188 goto L102 (error at <module>:100) else goto L65 :: bool
L65:
    dank_mids._exceptions.DankMidsInternalError = r183 :: type
    r189 = dank_mids._exceptions.globals :: static
    r190 = 'DankMidsInternalError'
    r191 = CPyDict_SetItem(r189, r190, r183)
    dec_ref r183
    r192 = r191 >= 0 :: signed
    if not r192 goto L88 (error at <module>:100) else goto L66 :: bool
L66:
    r193 = builtins :: module
    r194 = 'Exception'
    r195 = CPyObject_GetAttr(r193, r194)
    if is_error(r195) goto L88 (error at <module>:116) else goto L67
L67:
    r196 = PyTuple_Pack(1, r195)
    dec_ref r195
    if is_error(r196) goto L88 (error at <module>:116) else goto L68
L68:
    r197 = 'dank_mids._exceptions'
    r198 = dank_mids._exceptions.BatchResponseSortError_template :: type
    r199 = CPyType_FromTemplate(r198, r196, r197)
    dec_ref r196
    if is_error(r199) goto L88 (error at <module>:116) else goto L69
L69:
    r200 = '__mypyc_attrs__'
    r201 = '__dict__'
    r202 = PyTuple_Pack(1, r201)
    if is_error(r202) goto L103 (error at <module>:116) else goto L70
L70:
    r203 = PyObject_SetAttr(r199, r200, r202)
    dec_ref r202
    r204 = r203 >= 0 :: signed
    if not r204 goto L103 (error at <module>:116) else goto L71 :: bool
L71:
    dank_mids._exceptions.BatchResponseSortError = r199 :: type
    r205 = dank_mids._exceptions.globals :: static
    r206 = 'BatchResponseSortError'
    r207 = CPyDict_SetItem(r205, r206, r199)
    dec_ref r199
    r208 = r207 >= 0 :: signed
    if not r208 goto L88 (error at <module>:116) else goto L72 :: bool
L72:
    r209 = dank_mids._exceptions.BadResponse :: type
    r210 = PyTuple_Pack(1, r209)
    if is_error(r210) goto L88 (error at <module>:149) else goto L73
L73:
    r211 = 'dank_mids._exceptions'
    r212 = dank_mids._exceptions.RateLimitError_template :: type
    r213 = CPyType_FromTemplate(r212, r210, r211)
    dec_ref r210
    if is_error(r213) goto L88 (error at <module>:149) else goto L74
L74:
    r214 = '__mypyc_attrs__'
    r215 = '__dict__'
    r216 = PyTuple_Pack(1, r215)
    if is_error(r216) goto L104 (error at <module>:149) else goto L75
L75:
    r217 = PyObject_SetAttr(r213, r214, r216)
    dec_ref r216
    r218 = r217 >= 0 :: signed
    if not r218 goto L104 (error at <module>:149) else goto L76 :: bool
L76:
    dank_mids._exceptions.RateLimitError = r213 :: type
    r219 = dank_mids._exceptions.globals :: static
    r220 = 'RateLimitError'
    r221 = CPyDict_SetItem(r219, r220, r213)
    dec_ref r213
    r222 = r221 >= 0 :: signed
    if not r222 goto L88 (error at <module>:149) else goto L77 :: bool
L77:
    r223 = dank_mids._exceptions.RateLimitError :: type
    r224 = PyTuple_Pack(1, r223)
    if is_error(r224) goto L88 (error at <module>:153) else goto L78
L78:
    r225 = 'dank_mids._exceptions'
    r226 = dank_mids._exceptions.ChainstackRateLimitError_template :: type
    r227 = CPyType_FromTemplate(r226, r224, r225)
    dec_ref r224
    if is_error(r227) goto L88 (error at <module>:153) else goto L79
L79:
    r228 = '__mypyc_attrs__'
    r229 = '__dict__'
    r230 = PyTuple_Pack(1, r229)
    if is_error(r230) goto L105 (error at <module>:153) else goto L80
L80:
    r231 = PyObject_SetAttr(r227, r228, r230)
    dec_ref r230
    r232 = r231 >= 0 :: signed
    if not r232 goto L105 (error at <module>:153) else goto L81 :: bool
L81:
    dank_mids._exceptions.ChainstackRateLimitError = r227 :: type
    r233 = dank_mids._exceptions.globals :: static
    r234 = 'ChainstackRateLimitError'
    r235 = CPyDict_SetItem(r233, r234, r227)
    dec_ref r227
    r236 = r235 >= 0 :: signed
    if not r236 goto L88 (error at <module>:153) else goto L82 :: bool
L82:
    r237 = dank_mids._exceptions.RateLimitError :: type
    r238 = PyTuple_Pack(1, r237)
    if is_error(r238) goto L88 (error at <module>:172) else goto L83
L83:
    r239 = 'dank_mids._exceptions'
    r240 = dank_mids._exceptions.QuiknodeRateLimitError_template :: type
    r241 = CPyType_FromTemplate(r240, r238, r239)
    dec_ref r238
    if is_error(r241) goto L88 (error at <module>:172) else goto L84
L84:
    r242 = '__mypyc_attrs__'
    r243 = '__dict__'
    r244 = PyTuple_Pack(1, r243)
    if is_error(r244) goto L106 (error at <module>:172) else goto L85
L85:
    r245 = PyObject_SetAttr(r241, r242, r244)
    dec_ref r244
    r246 = r245 >= 0 :: signed
    if not r246 goto L106 (error at <module>:172) else goto L86 :: bool
L86:
    dank_mids._exceptions.QuiknodeRateLimitError = r241 :: type
    r247 = dank_mids._exceptions.globals :: static
    r248 = 'QuiknodeRateLimitError'
    r249 = CPyDict_SetItem(r247, r248, r241)
    dec_ref r241
    r250 = r249 >= 0 :: signed
    if not r250 goto L88 (error at <module>:172) else goto L87 :: bool
L87:
    return 1
L88:
    r251 = <error> :: None
    return r251
L89:
    dec_ref r41
    goto L88
L90:
    dec_ref r57
    goto L88
L91:
    dec_ref r71
    goto L88
L92:
    dec_ref r85
    goto L88
L93:
    dec_ref r99
    goto L88
L94:
    dec_ref r113
    goto L88
L95:
    dec_ref r129
    goto L88
L96:
    dec_ref r144
    goto L88
L97:
    dec_ref r144
    dec_ref r147
    goto L88
L98:
    dec_ref r144
    dec_ref r147
    dec_ref r150
    goto L88
L99:
    dec_ref r144
    dec_ref r147
    dec_ref r150
    dec_ref r153
    goto L88
L100:
    dec_ref r144
    dec_ref r147
    dec_ref r150
    dec_ref r153
    dec_ref r156
    goto L88
L101:
    dec_ref r144
    dec_ref r147
    dec_ref r150
    dec_ref r153
    dec_ref r156
    dec_ref r159
    goto L88
L102:
    dec_ref r183
    goto L88
L103:
    dec_ref r199
    goto L88
L104:
    dec_ref r213
    goto L88
L105:
    dec_ref r227
    goto L88
L106:
    dec_ref r241
    goto L88

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20 :: object
    r21, r22, r23, r24 :: str
    r25 :: list
    r26, r27, r28, r29, r30 :: ptr
    r31 :: dict
    r32 :: str
    r33 :: i32
    r34 :: bit
    r35 :: object
    r36 :: str
    r37 :: dict
    r38, r39 :: object
    r40 :: str
    r41 :: dict
    r42 :: object
    r43 :: dict
    r44 :: str
    r45 :: dict
    r46 :: str
    r47 :: object
    r48 :: str
    r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: object
    r53 :: object[1]
    r54 :: object_ptr
    r55, r56 :: object
    r57 :: str
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: object[1]
    r62 :: object_ptr
    r63 :: object
    r64 :: bool
    r65 :: object
    r66 :: str
    r67 :: dict
    r68 :: object
    r69 :: dict
    r70 :: str
    r71 :: object
    r72 :: str
    r73 :: object[1]
    r74 :: object_ptr
    r75 :: object
    r76 :: i32
    r77 :: bit
    r78 :: bool
    r79 :: object
    r80 :: str
    r81 :: dict
    r82 :: object
    r83 :: dict
    r84 :: str
    r85 :: object
    r86 :: dict
    r87 :: str
    r88 :: object
    r89 :: object[1]
    r90 :: object_ptr
    r91 :: object
    r92 :: dict
    r93 :: str
    r94 :: i32
    r95 :: bit
    r96 :: dict
    r97 :: str
    r98 :: object
    r99 :: str
    r100 :: object
    r101 :: dict
    r102 :: str
    r103 :: i32
    r104 :: bit
    r105 :: dict
    r106 :: str
    r107 :: object
    r108, r109, r110, r111 :: str
    r112 :: list
    r113, r114, r115, r116, r117 :: ptr
    r118 :: object
    r119 :: i32
    r120 :: bit
    r121, r122 :: tuple[object, object, object]
    r123, r124, r125 :: object
    r126 :: object[4]
    r127 :: object_ptr
    r128 :: object
    r129 :: i32
    r130 :: bit
    r131 :: bool
    r132 :: bit
    r133, r134, r135 :: tuple[object, object, object]
    r136 :: object
    r137 :: object[4]
    r138 :: object_ptr
    r139 :: object
    r140 :: bit
    r141 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L56 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('suppress',)
    r6 = 'contextlib'
    r7 = dank_mids.brownie_patch.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L56 (error at <module>:1) else goto L4
L4:
    contextlib = r8 :: module
    dec_ref r8
    r9 = ('AsyncEth',)
    r10 = 'web3.eth'
    r11 = dank_mids.brownie_patch.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L56 (error at <module>:3) else goto L5
L5:
    web3.eth = r12 :: module
    dec_ref r12
    r13 = ('setup_dank_w3_from_sync',)
    r14 = 'dank_mids.helpers'
    r15 = dank_mids.brownie_patch.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L56 (error at <module>:5) else goto L6
L6:
    dank_mids.helpers = r16 :: module
    dec_ref r16
    r17 = ('DankContractCall', 'DankContractMethod', 'DankContractTx', 'DankOverloadedMethod')
    r18 = 'dank_mids.brownie_patch.types'
    r19 = dank_mids.brownie_patch.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L56 (error at <module>:6) else goto L7
L7:
    dank_mids.brownie_patch.types = r20 :: module
    dec_ref r20
    r21 = 'DankContractCall'
    r22 = 'DankContractMethod'
    r23 = 'DankContractTx'
    r24 = 'DankOverloadedMethod'
    r25 = PyList_New(4)
    if is_error(r25) goto L56 (error at <module>:13) else goto L8
L8:
    r26 = get_element_ptr r25 ob_item :: PyListObject
    r27 = load_mem r26 :: ptr*
    inc_ref r21
    set_mem r27, r21 :: builtins.object*
    inc_ref r22
    r28 = r27 + 8
    set_mem r28, r22 :: builtins.object*
    inc_ref r23
    r29 = r27 + 16
    set_mem r29, r23 :: builtins.object*
    inc_ref r24
    r30 = r27 + 24
    set_mem r30, r24 :: builtins.object*
    r31 = dank_mids.brownie_patch.globals :: static
    r32 = '__all__'
    r33 = CPyDict_SetItem(r31, r32, r25)
    dec_ref r25
    r34 = r33 >= 0 :: signed
    if not r34 goto L56 (error at <module>:13) else goto L9 :: bool
L9:
    r35 = ('DankEth',)
    r36 = 'dank_mids.eth'
    r37 = dank_mids.brownie_patch.globals :: static
    r38 = CPyImport_ImportFromMany(r36, r35, r35, r37)
    if is_error(r38) goto L56 (error at <module>:15) else goto L10
L10:
    dank_mids.eth = r38 :: module
    dec_ref r38
    r39 = ('DankWeb3',)
    r40 = 'dank_mids.helpers._helpers'
    r41 = dank_mids.brownie_patch.globals :: static
    r42 = CPyImport_ImportFromMany(r40, r39, r39, r41)
    if is_error(r42) goto L56 (error at <module>:16) else goto L11
L11:
    dank_mids.helpers._helpers = r42 :: module
    dec_ref r42
    r43 = dank_mids.brownie_patch.globals :: static
    r44 = 'dank_web3'
    r45 = dank_mids.brownie_patch.globals :: static
    r46 = 'dank_eth'
    r47 = builtins :: module
    r48 = 'ImportError'
    r49 = CPyObject_GetAttr(r47, r48)
    if is_error(r49) goto L56 (error at <module>:33) else goto L12
L12:
    r50 = dank_mids.brownie_patch.globals :: static
    r51 = 'suppress'
    r52 = CPyDict_GetItem(r50, r51)
    if is_error(r52) goto L57 (error at <module>:33) else goto L13
L13:
    r53 = [r49]
    r54 = load_address r53
    r55 = _PyObject_Vectorcall(r52, r54, 1, 0)
    dec_ref r52
    if is_error(r55) goto L57 (error at <module>:33) else goto L14
L14:
    dec_ref r49
    r56 = PyObject_Type(r55)
    r57 = '__exit__'
    r58 = CPyObject_GetAttr(r56, r57)
    if is_error(r58) goto L58 (error at <module>:33) else goto L15
L15:
    r59 = '__enter__'
    r60 = CPyObject_GetAttr(r56, r59)
    dec_ref r56
    if is_error(r60) goto L59 (error at <module>:33) else goto L16
L16:
    r61 = [r55]
    r62 = load_address r61
    r63 = _PyObject_Vectorcall(r60, r62, 1, 0)
    dec_ref r60
    if is_error(r63) goto L59 (error at <module>:33) else goto L60
L17:
    r64 = 1
L18:
    r65 = ('network', 'web3')
    r66 = 'brownie'
    r67 = dank_mids.brownie_patch.globals :: static
    r68 = CPyImport_ImportFromMany(r66, r65, r65, r67)
    if is_error(r68) goto L35 (error at <module>:34) else goto L19
L19:
    brownie = r68 :: module
    dec_ref r68
    r69 = dank_mids.brownie_patch.globals :: static
    r70 = 'network'
    r71 = CPyDict_GetItem(r69, r70)
    if is_error(r71) goto L35 (error at <module>:36) else goto L20
L20:
    r72 = 'is_connected'
    r73 = [r71]
    r74 = load_address r73
    r75 = PyObject_VectorcallMethod(r72, r74, 9223372036854775809, 0)
    if is_error(r75) goto L61 (error at <module>:36) else goto L21
L21:
    dec_ref r71
    r76 = PyObject_IsTrue(r75)
    dec_ref r75
    r77 = r76 >= 0 :: signed
    if not r77 goto L35 (error at <module>:36) else goto L22 :: bool
L22:
    r78 = truncate r76: i32 to builtins.bool
    if r78 goto L23 else goto L43 :: bool
L23:
    r79 = ('Contract', 'patch_contract')
    r80 = 'dank_mids.brownie_patch.contract'
    r81 = dank_mids.brownie_patch.globals :: static
    r82 = CPyImport_ImportFromMany(r80, r79, r79, r81)
    if is_error(r82) goto L35 (error at <module>:37) else goto L24
L24:
    dank_mids.brownie_patch.contract = r82 :: module
    dec_ref r82
    r83 = dank_mids.brownie_patch.globals :: static
    r84 = 'web3'
    r85 = CPyDict_GetItem(r83, r84)
    if is_error(r85) goto L35 (error at <module>:39) else goto L25
L25:
    r86 = dank_mids.brownie_patch.globals :: static
    r87 = 'setup_dank_w3_from_sync'
    r88 = CPyDict_GetItem(r86, r87)
    if is_error(r88) goto L62 (error at <module>:39) else goto L26
L26:
    r89 = [r85]
    r90 = load_address r89
    r91 = _PyObject_Vectorcall(r88, r90, 1, 0)
    dec_ref r88
    if is_error(r91) goto L62 (error at <module>:39) else goto L27
L27:
    dec_ref r85
    r92 = dank_mids.brownie_patch.globals :: static
    r93 = 'dank_web3'
    r94 = CPyDict_SetItem(r92, r93, r91)
    dec_ref r91
    r95 = r94 >= 0 :: signed
    if not r95 goto L35 (error at <module>:39) else goto L28 :: bool
L28:
    r96 = dank_mids.brownie_patch.globals :: static
    r97 = 'dank_web3'
    r98 = CPyDict_GetItem(r96, r97)
    if is_error(r98) goto L35 (error at <module>:40) else goto L29
L29:
    r99 = 'eth'
    r100 = CPyObject_GetAttr(r98, r99)
    dec_ref r98
    if is_error(r100) goto L35 (error at <module>:40) else goto L30
L30:
    r101 = dank_mids.brownie_patch.globals :: static
    r102 = 'dank_eth'
    r103 = CPyDict_SetItem(r101, r102, r100)
    dec_ref r100
    r104 = r103 >= 0 :: signed
    if not r104 goto L35 (error at <module>:40) else goto L31 :: bool
L31:
    r105 = dank_mids.brownie_patch.globals :: static
    r106 = '__all__'
    r107 = CPyDict_GetItem(r105, r106)
    if is_error(r107) goto L35 (error at <module>:41) else goto L32
L32:
    r108 = 'Contract'
    r109 = 'patch_contract'
    r110 = 'dank_web3'
    r111 = 'dank_eth'
    r112 = PyList_New(4)
    if is_error(r112) goto L63 (error at <module>:41) else goto L33
L33:
    r113 = get_element_ptr r112 ob_item :: PyListObject
    r114 = load_mem r113 :: ptr*
    inc_ref r108
    set_mem r114, r108 :: builtins.object*
    inc_ref r109
    r115 = r114 + 8
    set_mem r115, r109 :: builtins.object*
    inc_ref r110
    r116 = r114 + 16
    set_mem r116, r110 :: builtins.object*
    inc_ref r111
    r117 = r114 + 24
    set_mem r117, r111 :: builtins.object*
    r118 = PyNumber_InPlaceAdd(r107, r112)
    dec_ref r107
    dec_ref r112
    if is_error(r118) goto L35 (error at <module>:41) else goto L34
L34:
    r119 = CPyDict_SetItem(r105, r106, r118)
    dec_ref r118
    r120 = r119 >= 0 :: signed
    if not r120 goto L35 (error at <module>:41) else goto L43 :: bool
L35:
    r121 = CPy_CatchError()
    r64 = 0
    r122 = CPy_GetExcInfo()
    r123 = r122[0]
    r124 = r122[1]
    r125 = r122[2]
    dec_ref r122
    r126 = [r55, r123, r124, r125]
    r127 = load_address r126
    r128 = _PyObject_Vectorcall(r58, r127, 4, 0)
    if is_error(r128) goto L64 (error at <module>:33) else goto L36
L36:
    dec_ref r123
    dec_ref r124
    dec_ref r125
    r129 = PyObject_IsTrue(r128)
    dec_ref r128
    r130 = r129 >= 0 :: signed
    if not r130 goto L41 (error at <module>:33) else goto L37 :: bool
L37:
    r131 = truncate r129: i32 to builtins.bool
    if r131 goto L40 else goto L38 :: bool
L38:
    CPy_Reraise()
    if not 0 goto L41 else goto L65 :: bool
L39:
    unreachable
L40:
    CPy_RestoreExcInfo(r121)
    dec_ref r121
    goto L43
L41:
    CPy_RestoreExcInfo(r121)
    dec_ref r121
    r132 = CPy_KeepPropagating()
    if not r132 goto L44 else goto L66 :: bool
L42:
    unreachable
L43:
    r133 = <error> :: tuple[object, object, object]
    r134 = r133
    goto L45
L44:
    r135 = CPy_CatchError()
    r134 = r135
L45:
    if r64 goto L46 else goto L67 :: bool
L46:
    r136 = load_address _Py_NoneStruct
    r137 = [r55, r136, r136, r136]
    r138 = load_address r137
    r139 = _PyObject_Vectorcall(r58, r138, 4, 0)
    dec_ref r58
    if is_error(r139) goto L68 (error at <module>:33) else goto L69
L47:
    dec_ref r55
L48:
    if is_error(r134) goto L55 else goto L49
L49:
    CPy_Reraise()
    if not 0 goto L51 else goto L70 :: bool
L50:
    unreachable
L51:
    if is_error(r134) goto L53 else goto L52
L52:
    CPy_RestoreExcInfo(r134)
    xdec_ref r134
L53:
    r140 = CPy_KeepPropagating()
    if not r140 goto L56 else goto L54 :: bool
L54:
    unreachable
L55:
    return 1
L56:
    r141 = <error> :: None
    return r141
L57:
    dec_ref r49
    goto L56
L58:
    dec_ref r55
    dec_ref r56
    goto L56
L59:
    dec_ref r55
    dec_ref r58
    goto L56
L60:
    dec_ref r63
    goto L17
L61:
    dec_ref r71
    goto L35
L62:
    dec_ref r85
    goto L35
L63:
    dec_ref r107
    goto L35
L64:
    dec_ref r123
    dec_ref r124
    dec_ref r125
    goto L41
L65:
    dec_ref r55
    dec_ref r58
    dec_ref r121
    goto L39
L66:
    dec_ref r55
    dec_ref r58
    goto L42
L67:
    dec_ref r55
    dec_ref r58
    goto L48
L68:
    dec_ref r55
    goto L51
L69:
    dec_ref r139
    goto L47
L70:
    xdec_ref r134
    goto L50

def return_as_is(x):
    x :: object
L0:
    inc_ref x
    return x

def abi_request_formatters_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    type, value, traceback, arg :: object
    r0 :: dank_mids._web3.formatters.abi_request_formatters_env
    r1 :: int
    r2 :: object
    r3 :: bit
    r4 :: dict
    r5, r6 :: bool
    r7 :: dict
    r8 :: native_int
    r9 :: short_int
    r10 :: bool
    r11 :: object
    r12 :: bool
    r13 :: object
    r14 :: short_int
    r15 :: tuple[bool, short_int, object, object]
    r16 :: short_int
    r17, r18 :: bool
    r19, r20 :: object
    r21 :: union[list, dict]
    r22, r23 :: bool
    r24 :: union[list, dict]
    r25 :: object
    r26 :: i32
    r27 :: bit
    r28 :: bool
    r29, r30 :: object
    r31 :: tuple
    r32 :: union[list, dict]
    r33 :: list
    r34 :: tuple
    r35 :: dict
    r36 :: str
    r37 :: object
    r38 :: object[2]
    r39 :: object_ptr
    r40 :: object
    r41 :: tuple[object, object]
    r42 :: object
    r43 :: bool
    r44 :: object
    r45 :: bit
    r46 :: union[list, dict]
    r47 :: object
    r48 :: i32
    r49 :: bit
    r50 :: bool
    r51 :: object
    r52 :: union[list, dict]
    r53, r54 :: dict
    r55 :: str
    r56 :: object
    r57 :: object[2]
    r58 :: object_ptr
    r59 :: object
    r60 :: bool
    r61, r62 :: object
    r63 :: dict
    r64 :: str
    r65, r66 :: object
    r67 :: object[2]
    r68 :: object_ptr
    r69 :: object
    r70 :: tuple[object, object]
    r71 :: object
    r72 :: bool
    r73 :: object
    r74 :: bit
    r75, r76, r77 :: str
    r78 :: union[list, dict]
    r79, r80 :: str
    r81 :: object[3]
    r82 :: object_ptr
    r83 :: object
    r84 :: list
    r85, r86, r87 :: ptr
    r88 :: str
    r89 :: object
    r90 :: str
    r91 :: object
    r92 :: object[1]
    r93 :: object_ptr
    r94 :: object
    r95 :: dict
    r96 :: short_int
    r97, r98 :: bit
    r99 :: object
    r100 :: bool
    r101, r102, r103 :: bit
    r104 :: bool
    r105 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L73 (error at abi_request_formatters:28) else goto L1
L1:
    r1 = r0.__mypyc_next_label__
    if is_error(r1) goto L74 (error at abi_request_formatters:28) else goto L68
L2:
    r2 = load_address _Py_NoneStruct
    r3 = type != r2
    if r3 goto L75 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L73 (error at abi_request_formatters:28) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = r0.abis
    if is_error(r4) goto L74 (error at abi_request_formatters:32) else goto L6
L6:
    inc_ref r4
    r0.__mypyc_temp__0 = r4; r5 = is_error
    if not r5 goto L76 (error at abi_request_formatters:-1) else goto L7 :: bool
L7:
    r0.__mypyc_temp__1 = 0; r6 = is_error
    if not r6 goto L76 (error at abi_request_formatters:-1) else goto L8 :: bool
L8:
    r7 = r0.__mypyc_temp__0
    if is_error(r7) goto L76 (error at abi_request_formatters:32) else goto L9
L9:
    r8 = PyDict_Size(r7)
    dec_ref r7
    r9 = r8 << 1
    r0.__mypyc_temp__2 = r9; r10 = is_error
    if not r10 goto L76 (error at abi_request_formatters:-1) else goto L10 :: bool
L10:
    r11 = CPyDict_GetItemsIter(r4)
    dec_ref r4
    if is_error(r11) goto L74 (error at abi_request_formatters:32) else goto L11
L11:
    r0.__mypyc_temp__3 = r11; r12 = is_error
    if not r12 goto L74 (error at abi_request_formatters:-1) else goto L12 :: bool
L12:
    r13 = r0.__mypyc_temp__3
    if is_error(r13) goto L74 (error at abi_request_formatters:32) else goto L13
L13:
    r14 = r0.__mypyc_temp__1
    if is_error(r14) goto L77 (error at abi_request_formatters:32) else goto L14
L14:
    r15 = CPyDict_NextItem(r13, r14)
    dec_ref r13
    r16 = r15[1]
    r0.__mypyc_temp__1 = r16; r17 = is_error
    if not r17 goto L78 (error at abi_request_formatters:32) else goto L15 :: bool
L15:
    r18 = r15[0]
    if r18 goto L16 else goto L79 :: bool
L16:
    r19 = r15[2]
    r20 = r15[3]
    dec_ref r15
    r21 = cast(union[list, dict], r20)
    if is_error(r21) goto L80 (error at abi_request_formatters:32) else goto L17
L17:
    r0.method = r19; r22 = is_error
    if not r22 goto L81 (error at abi_request_formatters:32) else goto L18 :: bool
L18:
    r0.abi_types = r21; r23 = is_error
    if not r23 goto L74 (error at abi_request_formatters:32) else goto L19 :: bool
L19:
    r24 = r0.abi_types
    if is_error(r24) goto L74 (error at abi_request_formatters:33) else goto L20
L20:
    r25 = load_address PyList_Type
    r26 = PyObject_IsInstance(r24, r25)
    dec_ref r24
    r27 = r26 >= 0 :: signed
    if not r27 goto L74 (error at abi_request_formatters:33) else goto L21 :: bool
L21:
    r28 = truncate r26: i32 to builtins.bool
    if r28 goto L22 else goto L35 :: bool
L22:
    r29 = r0.method
    if is_error(r29) goto L74 (error at abi_request_formatters:34) else goto L23
L23:
    r30 = r0.normalizers
    if is_error(r30) goto L82 (error at abi_request_formatters:34) else goto L24
L24:
    r31 = PySequence_Tuple(r30)
    dec_ref r30
    if is_error(r31) goto L82 (error at abi_request_formatters:34) else goto L25
L25:
    r32 = r0.abi_types
    if is_error(r32) goto L83 (error at abi_request_formatters:34) else goto L26
L26:
    r33 = cast(list, r32)
    if is_error(r33) goto L83 (error at abi_request_formatters:34) else goto L27
L27:
    r34 = PyList_AsTuple(r33)
    dec_ref r33
    if is_error(r34) goto L83 (error at abi_request_formatters:34) else goto L28
L28:
    r35 = dank_mids._web3.formatters.globals :: static
    r36 = 'get_mapper'
    r37 = CPyDict_GetItem(r35, r36)
    if is_error(r37) goto L84 (error at abi_request_formatters:34) else goto L29
L29:
    r38 = [r31, r34]
    r39 = load_address r38
    r40 = _PyObject_Vectorcall(r37, r39, 2, 0)
    dec_ref r37
    if is_error(r40) goto L84 (error at abi_request_formatters:34) else goto L30
L30:
    dec_ref r31
    dec_ref r34
    r41 = (r29, r40)
    r42 = box(tuple[object, object], r41)
    r0.__mypyc_next_label__ = 2; r43 = is_error
    dec_ref r0
    if not r43 goto L85 (error at abi_request_formatters:34) else goto L31 :: bool
L31:
    return r42
L32:
    r44 = load_address _Py_NoneStruct
    r45 = type != r44
    if r45 goto L86 else goto L61 :: bool
L33:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L73 (error at abi_request_formatters:34) else goto L34 :: bool
L34:
    unreachable
L35:
    r46 = r0.abi_types
    if is_error(r46) goto L74 (error at abi_request_formatters:35) else goto L36
L36:
    r47 = load_address PyDict_Type
    r48 = PyObject_IsInstance(r46, r47)
    dec_ref r46
    r49 = r48 >= 0 :: signed
    if not r49 goto L74 (error at abi_request_formatters:35) else goto L37 :: bool
L37:
    r50 = truncate r48: i32 to builtins.bool
    if r50 goto L38 else goto L53 :: bool
L38:
    r51 = r0.normalizers
    if is_error(r51) goto L74 (error at abi_request_formatters:36) else goto L39
L39:
    r52 = r0.abi_types
    if is_error(r52) goto L87 (error at abi_request_formatters:36) else goto L40
L40:
    r53 = cast(dict, r52)
    if is_error(r53) goto L87 (error at abi_request_formatters:36) else goto L41
L41:
    r54 = dank_mids._web3.formatters.globals :: static
    r55 = 'apply_abi_formatters_to_dict'
    r56 = CPyDict_GetItem(r54, r55)
    if is_error(r56) goto L88 (error at abi_request_formatters:36) else goto L42
L42:
    r57 = [r51, r53]
    r58 = load_address r57
    r59 = _PyObject_Vectorcall(r56, r58, 2, 0)
    dec_ref r56
    if is_error(r59) goto L88 (error at abi_request_formatters:36) else goto L43
L43:
    dec_ref r51
    dec_ref r53
    r0.single_dict_formatter = r59; r60 = is_error
    if not r60 goto L74 (error at abi_request_formatters:36) else goto L44 :: bool
L44:
    r61 = r0.method
    if is_error(r61) goto L74 (error at abi_request_formatters:37) else goto L45
L45:
    r62 = r0.single_dict_formatter
    if is_error(r62) goto L89 (error at abi_request_formatters:37) else goto L46
L46:
    r63 = dank_mids._web3.formatters.globals :: static
    r64 = 'apply_formatter_at_index'
    r65 = CPyDict_GetItem(r63, r64)
    if is_error(r65) goto L90 (error at abi_request_formatters:37) else goto L47
L47:
    r66 = object 0
    r67 = [r62, r66]
    r68 = load_address r67
    r69 = _PyObject_Vectorcall(r65, r68, 2, 0)
    dec_ref r65
    if is_error(r69) goto L90 (error at abi_request_formatters:37) else goto L48
L48:
    dec_ref r62
    r70 = (r61, r69)
    r71 = box(tuple[object, object], r70)
    r0.__mypyc_next_label__ = 4; r72 = is_error
    dec_ref r0
    if not r72 goto L91 (error at abi_request_formatters:37) else goto L49 :: bool
L49:
    return r71
L50:
    r73 = load_address _Py_NoneStruct
    r74 = type != r73
    if r74 goto L92 else goto L61 :: bool
L51:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L73 (error at abi_request_formatters:37) else goto L52 :: bool
L52:
    unreachable
L53:
    r75 = ''
    r76 = 'ABI definitions must be a list or dictionary, got '
    r77 = '{!r:{}}'
    r78 = r0.abi_types
    dec_ref r0
    if is_error(r78) goto L73 (error at abi_request_formatters:39) else goto L54
L54:
    r79 = ''
    r80 = 'format'
    r81 = [r77, r78, r79]
    r82 = load_address r81
    r83 = PyObject_VectorcallMethod(r80, r82, 9223372036854775811, 0)
    if is_error(r83) goto L93 (error at abi_request_formatters:39) else goto L55
L55:
    dec_ref r78
    r84 = PyList_New(2)
    if is_error(r84) goto L94 (error at abi_request_formatters:39) else goto L56
L56:
    r85 = get_element_ptr r84 ob_item :: PyListObject
    r86 = load_mem r85 :: ptr*
    inc_ref r76
    set_mem r86, r76 :: builtins.object*
    r87 = r86 + 8
    set_mem r87, r83 :: builtins.object*
    r88 = PyUnicode_Join(r75, r84)
    dec_ref r84
    if is_error(r88) goto L73 (error at abi_request_formatters:39) else goto L57
L57:
    r89 = builtins :: module
    r90 = 'TypeError'
    r91 = CPyObject_GetAttr(r89, r90)
    if is_error(r91) goto L95 (error at abi_request_formatters:39) else goto L58
L58:
    r92 = [r88]
    r93 = load_address r92
    r94 = _PyObject_Vectorcall(r91, r93, 1, 0)
    dec_ref r91
    if is_error(r94) goto L95 (error at abi_request_formatters:39) else goto L59
L59:
    dec_ref r88
    CPy_Raise(r94)
    dec_ref r94
    if not 0 goto L73 (error at abi_request_formatters:39) else goto L60 :: bool
L60:
    unreachable
L61:
    r95 = r0.__mypyc_temp__0
    if is_error(r95) goto L74 (error at abi_request_formatters:32) else goto L62
L62:
    r96 = r0.__mypyc_temp__2
    if is_error(r96) goto L96 (error at abi_request_formatters:32) else goto L63
L63:
    r97 = CPyDict_CheckSize(r95, r96)
    dec_ref r95
    if not r97 goto L74 (error at abi_request_formatters:32) else goto L12 :: bool
L64:
    r98 = CPy_NoErrOccurred()
    if not r98 goto L74 (error at abi_request_formatters:32) else goto L65 :: bool
L65:
    r99 = box(None, 1)
    r0.__mypyc_next_label__ = -2; r100 = is_error
    dec_ref r0
    if not r100 goto L73 (error at abi_request_formatters:28) else goto L66 :: bool
L66:
    CPyGen_SetStopIterationValue(r99)
    if not 0 goto L73 else goto L67 :: bool
L67:
    unreachable
L68:
    r101 = r1 == 0
    if r101 goto L97 else goto L69 :: bool
L69:
    r102 = r1 == 2
    if r102 goto L98 else goto L70 :: bool
L70:
    r103 = r1 == 4
    dec_ref r1 :: int
    if r103 goto L50 else goto L99 :: bool
L71:
    r104 = raise StopIteration
    if not r104 goto L73 (error at abi_request_formatters:28) else goto L72 :: bool
L72:
    unreachable
L73:
    r105 = <error> :: object
    return r105
L74:
    dec_ref r0
    goto L73
L75:
    dec_ref r0
    goto L3
L76:
    dec_ref r0
    dec_ref r4
    goto L73
L77:
    dec_ref r0
    dec_ref r13
    goto L73
L78:
    dec_ref r0
    dec_ref r15
    goto L73
L79:
    dec_ref r15
    goto L64
L80:
    dec_ref r0
    dec_ref r19
    goto L73
L81:
    dec_ref r0
    dec_ref r21
    goto L73
L82:
    dec_ref r0
    dec_ref r29
    goto L73
L83:
    dec_ref r0
    dec_ref r29
    dec_ref r31
    goto L73
L84:
    dec_ref r0
    dec_ref r29
    dec_ref r31
    dec_ref r34
    goto L73
L85:
    dec_ref r42
    goto L73
L86:
    dec_ref r0
    goto L33
L87:
    dec_ref r0
    dec_ref r51
    goto L73
L88:
    dec_ref r0
    dec_ref r51
    dec_ref r53
    goto L73
L89:
    dec_ref r0
    dec_ref r61
    goto L73
L90:
    dec_ref r0
    dec_ref r61
    dec_ref r62
    goto L73
L91:
    dec_ref r71
    goto L73
L92:
    dec_ref r0
    goto L51
L93:
    dec_ref r78
    goto L73
L94:
    dec_ref r83
    goto L73
L95:
    dec_ref r88
    goto L73
L96:
    dec_ref r0
    dec_ref r95
    goto L73
L97:
    dec_ref r1 :: int
    goto L2
L98:
    dec_ref r1 :: int
    goto L32
L99:
    dec_ref r0
    goto L71

def abi_request_formatters_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = abi_request_formatters_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def abi_request_formatters_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = abi_request_formatters_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def abi_request_formatters_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def abi_request_formatters_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = abi_request_formatters_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def abi_request_formatters_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids._web3.formatters.abi_request_formatters_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def abi_request_formatters(normalizers, abis):
    normalizers :: object
    abis :: dict
    r0 :: dank_mids._web3.formatters.abi_request_formatters_env
    r1, r2 :: bool
    r3 :: dank_mids._web3.formatters.abi_request_formatters_gen
    r4, r5 :: bool
    r6 :: object
L0:
    r0 = abi_request_formatters_env()
    if is_error(r0) goto L7 (error at abi_request_formatters:28) else goto L1
L1:
    inc_ref normalizers
    r0.normalizers = normalizers; r1 = is_error
    if not r1 goto L8 (error at abi_request_formatters:28) else goto L2 :: bool
L2:
    inc_ref abis
    r0.abis = abis; r2 = is_error
    if not r2 goto L8 (error at abi_request_formatters:28) else goto L3 :: bool
L3:
    r3 = abi_request_formatters_gen()
    if is_error(r3) goto L8 (error at abi_request_formatters:28) else goto L4
L4:
    inc_ref r0
    r3.__mypyc_env__ = r0; r4 = is_error
    if not r4 goto L9 (error at abi_request_formatters:28) else goto L5 :: bool
L5:
    r0.__mypyc_next_label__ = 0; r5 = is_error
    dec_ref r0
    if not r5 goto L10 (error at abi_request_formatters:28) else goto L6 :: bool
L6:
    return r3
L7:
    r6 = <error> :: object
    return r6
L8:
    dec_ref r0
    goto L7
L9:
    dec_ref r0
    dec_ref r3
    goto L7
L10:
    dec_ref r3
    goto L7

def get_request_formatters(method_name):
    method_name, r0 :: object
    r1 :: bool
    r2 :: str
    r3 :: object[2]
    r4 :: object_ptr
    r5, formatters, r6 :: object
    r7 :: bit
    r8 :: list
    r9 :: tuple[object, object, object]
    r10 :: bool
    r11, r12, r13 :: object
    r14 :: str
    r15 :: object[2]
    r16 :: object_ptr
    r17 :: object
    r18 :: i32
    r19, r20 :: bit
    r21 :: object
    r22 :: list
    r23, r24, r25 :: object
    r26 :: bit
    r27 :: i32
    r28, r29 :: bit
    r30 :: ptr
    r31 :: native_int
    r32 :: short_int
    r33 :: bit
    r34 :: dict
    r35 :: str
    r36 :: object
    r37 :: ptr
    r38 :: native_int
    r39 :: short_int
    r40 :: bit
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: object
    r45 :: list
    r46 :: object
    r47 :: tuple
    r48 :: dict
    r49, r50 :: object
    r51 :: bool
    r52 :: i32
    r53 :: bit
    r54 :: object
L0:
    r0 = dank_mids._web3.formatters._request_formatters :: static
    if is_error(r0) goto L1 else goto L3
L1:
    r1 = raise NameError('value for final name "_request_formatters" was not set')
    if not r1 goto L39 (error at get_request_formatters:60) else goto L2 :: bool
L2:
    unreachable
L3:
    r2 = 'get'
    r3 = [r0, method_name]
    r4 = load_address r3
    r5 = PyObject_VectorcallMethod(r2, r4, 9223372036854775810, 0)
    if is_error(r5) goto L39 (error at get_request_formatters:60) else goto L4
L4:
    formatters = r5
    r6 = load_address _Py_NoneStruct
    r7 = formatters == r6
    if r7 goto L40 else goto L38 :: bool
L5:
    r8 = PyList_New(0)
    if is_error(r8) goto L39 (error at get_request_formatters:62) else goto L6
L6:
    r9 = dank_mids._web3.formatters.REQUEST_FORMATTER_MAPS :: static
    if is_error(r9) goto L41 else goto L9
L7:
    r10 = raise NameError('value for final name "REQUEST_FORMATTER_MAPS" was not set')
    if not r10 goto L39 (error at get_request_formatters:62) else goto L8 :: bool
L8:
    unreachable
L9:
    inc_ref r9
    r11 = box(tuple[object, object, object], r9)
    r12 = PyObject_GetIter(r11)
    dec_ref r11
    if is_error(r12) goto L42 (error at get_request_formatters:62) else goto L10
L10:
    r13 = PyIter_Next(r12)
    if is_error(r13) goto L43 else goto L11
L11:
    r14 = 'get'
    r15 = [r13, method_name]
    r16 = load_address r15
    r17 = PyObject_VectorcallMethod(r14, r16, 9223372036854775810, 0)
    if is_error(r17) goto L44 (error at get_request_formatters:62) else goto L12
L12:
    dec_ref r13
    r18 = PyList_Append(r8, r17)
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L45 (error at get_request_formatters:62) else goto L10 :: bool
L13:
    r20 = CPy_NoErrOccurred()
    if not r20 goto L42 (error at get_request_formatters:62) else goto L14 :: bool
L14:
    r21 = PyObject_GetIter(r8)
    dec_ref r8
    if is_error(r21) goto L39 (error at get_request_formatters:62) else goto L15
L15:
    r22 = PyList_New(0)
    if is_error(r22) goto L46 (error at get_request_formatters:63) else goto L16
L16:
    r23 = PyObject_GetIter(r21)
    if is_error(r23) goto L47 (error at get_request_formatters:63) else goto L17
L17:
    r24 = PyIter_Next(r23)
    if is_error(r24) goto L48 else goto L18
L18:
    r25 = load_address _Py_NoneStruct
    r26 = r24 != r25
    if r26 goto L19 else goto L49 :: bool
L19:
    r27 = PyList_Append(r22, r24)
    dec_ref r24
    r28 = r27 >= 0 :: signed
    if not r28 goto L50 (error at get_request_formatters:63) else goto L17 :: bool
L20:
    r29 = CPy_NoErrOccurred()
    if not r29 goto L47 (error at get_request_formatters:63) else goto L21 :: bool
L21:
    r30 = get_element_ptr r22 ob_size :: PyVarObject
    r31 = load_mem r30 :: native_int*
    r32 = r31 << 1
    r33 = r32 != 0
    if r33 goto L24 else goto L51 :: bool
L22:
    r34 = dank_mids._web3.formatters.globals :: static
    r35 = 'return_as_is'
    r36 = CPyDict_GetItem(r34, r35)
    if is_error(r36) goto L39 (error at get_request_formatters:65) else goto L23
L23:
    formatters = r36
    goto L34
L24:
    r37 = get_element_ptr r22 ob_size :: PyVarObject
    r38 = load_mem r37 :: native_int*
    r39 = r38 << 1
    r40 = r39 == 2
    if r40 goto L52 else goto L53 :: bool
L25:
    r41 = CPyList_GetItemShort(r22, 0)
    dec_ref r22
    if is_error(r41) goto L39 (error at get_request_formatters:67) else goto L26
L26:
    formatters = r41
    goto L34
L27:
    r42 = dank_mids._web3.formatters.globals :: static
    r43 = 'compose'
    r44 = CPyDict_GetItem(r42, r43)
    if is_error(r44) goto L46 (error at get_request_formatters:71) else goto L28
L28:
    r45 = PyList_New(0)
    if is_error(r45) goto L54 (error at get_request_formatters:71) else goto L29
L29:
    r46 = CPyList_Extend(r45, r21)
    dec_ref r21
    if is_error(r46) goto L55 (error at get_request_formatters:71) else goto L56
L30:
    r47 = PyList_AsTuple(r45)
    dec_ref r45
    if is_error(r47) goto L57 (error at get_request_formatters:71) else goto L31
L31:
    r48 = PyDict_New()
    if is_error(r48) goto L58 (error at get_request_formatters:71) else goto L32
L32:
    r49 = PyObject_Call(r44, r47, r48)
    dec_ref r44
    dec_ref r47
    dec_ref r48
    if is_error(r49) goto L39 (error at get_request_formatters:71) else goto L33
L33:
    formatters = r49
L34:
    r50 = dank_mids._web3.formatters._request_formatters :: static
    if is_error(r50) goto L59 else goto L37
L35:
    r51 = raise NameError('value for final name "_request_formatters" was not set')
    if not r51 goto L39 (error at get_request_formatters:72) else goto L36 :: bool
L36:
    unreachable
L37:
    r52 = PyObject_SetItem(r50, method_name, formatters)
    r53 = r52 >= 0 :: signed
    if not r53 goto L60 (error at get_request_formatters:72) else goto L38 :: bool
L38:
    return formatters
L39:
    r54 = <error> :: object
    return r54
L40:
    dec_ref formatters
    goto L5
L41:
    dec_ref r8
    goto L7
L42:
    dec_ref r8
    goto L39
L43:
    dec_ref r12
    goto L13
L44:
    dec_ref r8
    dec_ref r12
    dec_ref r13
    goto L39
L45:
    dec_ref r8
    dec_ref r12
    goto L39
L46:
    dec_ref r21
    goto L39
L47:
    dec_ref r21
    dec_ref r22
    goto L39
L48:
    dec_ref r23
    goto L20
L49:
    dec_ref r24
    goto L17
L50:
    dec_ref r21
    dec_ref r22
    dec_ref r23
    goto L39
L51:
    dec_ref r21
    dec_ref r22
    goto L22
L52:
    dec_ref r21
    goto L25
L53:
    dec_ref r22
    goto L27
L54:
    dec_ref r21
    dec_ref r44
    goto L39
L55:
    dec_ref r44
    dec_ref r45
    goto L39
L56:
    dec_ref r46
    goto L30
L57:
    dec_ref r44
    goto L39
L58:
    dec_ref r44
    dec_ref r47
    goto L39
L59:
    dec_ref formatters
    goto L35
L60:
    dec_ref formatters
    goto L39

def _get_response_formatters(method):
    method :: object
    r0 :: dict
    r1 :: str
    r2 :: object
    r3 :: dict
    r4 :: str
    r5 :: object
    r6 :: dict
    r7 :: str
    r8 :: object
    r9 :: str
    r10 :: object[3]
    r11 :: object_ptr
    r12 :: object
    r13 :: dict
    r14 :: str
    r15 :: object
    r16 :: dict
    r17 :: str
    r18 :: object
    r19 :: str
    r20 :: object[3]
    r21 :: object_ptr
    r22 :: object
    r23 :: tuple[object, object, object]
    r24 :: dict
    r25 :: bool
    r26 :: object
    r27 :: i32
    r28 :: bit
    r29 :: tuple[object, object, object]
L0:
    r0 = dank_mids._web3.formatters.globals :: static
    r1 = 'return_as_is'
    r2 = CPyDict_GetItem(r0, r1)
    if is_error(r2) goto L12 (error at _get_response_formatters:87) else goto L1
L1:
    r3 = dank_mids._web3.formatters.globals :: static
    r4 = 'ERROR_FORMATTERS'
    r5 = CPyDict_GetItem(r3, r4)
    if is_error(r5) goto L13 (error at _get_response_formatters:88) else goto L2
L2:
    r6 = dank_mids._web3.formatters.globals :: static
    r7 = 'return_as_is'
    r8 = CPyDict_GetItem(r6, r7)
    if is_error(r8) goto L14 (error at _get_response_formatters:88) else goto L3
L3:
    r9 = 'get'
    r10 = [r5, method, r8]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775811, 0)
    if is_error(r12) goto L15 (error at _get_response_formatters:88) else goto L4
L4:
    dec_ref r5
    dec_ref r8
    r13 = dank_mids._web3.formatters.globals :: static
    r14 = 'NULL_RESULT_FORMATTERS'
    r15 = CPyDict_GetItem(r13, r14)
    if is_error(r15) goto L16 (error at _get_response_formatters:89) else goto L5
L5:
    r16 = dank_mids._web3.formatters.globals :: static
    r17 = 'return_as_is'
    r18 = CPyDict_GetItem(r16, r17)
    if is_error(r18) goto L17 (error at _get_response_formatters:89) else goto L6
L6:
    r19 = 'get'
    r20 = [r15, method, r18]
    r21 = load_address r20
    r22 = PyObject_VectorcallMethod(r19, r21, 9223372036854775811, 0)
    if is_error(r22) goto L18 (error at _get_response_formatters:89) else goto L7
L7:
    dec_ref r15
    dec_ref r18
    r23 = (r2, r12, r22)
    inc_ref r23
    r24 = dank_mids._web3.formatters._response_formatters :: static
    if is_error(r24) goto L19 else goto L10
L8:
    r25 = raise NameError('value for final name "_response_formatters" was not set')
    if not r25 goto L12 (error at _get_response_formatters:86) else goto L9 :: bool
L9:
    unreachable
L10:
    r26 = box(tuple[object, object, object], r23)
    r27 = CPyDict_SetItem(r24, method, r26)
    dec_ref r26
    r28 = r27 >= 0 :: signed
    if not r28 goto L20 (error at _get_response_formatters:86) else goto L11 :: bool
L11:
    return r23
L12:
    r29 = <error> :: tuple[object, object, object]
    return r29
L13:
    dec_ref r2
    goto L12
L14:
    dec_ref r2
    dec_ref r5
    goto L12
L15:
    dec_ref r2
    dec_ref r5
    dec_ref r8
    goto L12
L16:
    dec_ref r2
    dec_ref r12
    goto L12
L17:
    dec_ref r2
    dec_ref r12
    dec_ref r15
    goto L12
L18:
    dec_ref r2
    dec_ref r12
    dec_ref r15
    dec_ref r18
    goto L12
L19:
    dec_ref r23
    dec_ref r23
    goto L8
L20:
    dec_ref r23
    goto L12

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24, r25 :: object
    r26 :: str
    r27 :: dict
    r28, r29 :: object
    r30 :: str
    r31 :: dict
    r32, r33 :: object
    r34 :: str
    r35 :: dict
    r36, r37 :: object
    r38 :: str
    r39 :: dict
    r40 :: object
    r41 :: str
    r42 :: dict
    r43 :: str
    r44 :: object
    r45 :: object[1]
    r46 :: object_ptr
    r47 :: object
    r48 :: dict
    r49 :: str
    r50 :: i32
    r51 :: bit
    r52 :: dict
    r53 :: str
    r54 :: object
    r55 :: dict
    r56 :: str
    r57 :: object
    r58 :: dict
    r59 :: object
    r60, r61 :: dict
    r62 :: str
    r63 :: i32
    r64 :: bit
    r65 :: object
    r66 :: bool
    r67 :: dict
    r68 :: str
    r69 :: object
    r70 :: dict
    r71 :: str
    r72 :: object
    r73 :: tuple[object, object, object]
    r74 :: dict
    r75 :: str
    r76 :: object
    r77 :: i32
    r78 :: bit
    r79, r80 :: dict
    r81 :: str
    r82 :: i32
    r83 :: bit
    r84 :: dict
    r85 :: str
    r86 :: object
    r87 :: dict
    r88 :: str
    r89 :: object
    r90 :: list
    r91, r92 :: ptr
    r93 :: dict
    r94 :: str
    r95 :: object
    r96 :: tuple[list, object]
    r97, r98 :: object
    r99 :: dict
    r100 :: str
    r101 :: i32
    r102 :: bit
    r103 :: dict
    r104 :: str
    r105 :: object
    r106 :: dict
    r107 :: str
    r108 :: object
    r109 :: list
    r110, r111 :: ptr
    r112 :: dict
    r113 :: str
    r114 :: object
    r115 :: tuple[list, object]
    r116, r117 :: object
    r118 :: dict
    r119 :: str
    r120 :: i32
    r121 :: bit
    r122 :: dict
    r123 :: str
    r124 :: object
    r125 :: dict
    r126 :: str
    r127 :: object
    r128 :: list
    r129, r130 :: ptr
    r131 :: dict
    r132 :: str
    r133 :: object
    r134 :: tuple[list, object]
    r135, r136 :: object
    r137 :: dict
    r138 :: str
    r139 :: i32
    r140 :: bit
    r141 :: dict
    r142 :: str
    r143 :: object
    r144 :: dict
    r145 :: str
    r146 :: object
    r147 :: dict
    r148 :: str
    r149 :: object
    r150 :: dict
    r151 :: str
    r152 :: object
    r153 :: tuple[object, object, object]
    r154, r155 :: object
    r156 :: dict
    r157 :: str
    r158 :: i32
    r159 :: bit
    r160, r161 :: dict
    r162 :: str
    r163 :: i32
    r164 :: bit
    r165 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L56 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Any', 'Callable', 'Dict', 'Final', 'Iterator', 'List', 'Sequence', 'Tuple', 'TypeVar', 'Union')
    r6 = 'typing'
    r7 = dank_mids._web3.formatters.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L56 (error at <module>:1) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = ('TypeStr',)
    r10 = 'eth_typing'
    r11 = dank_mids._web3.formatters.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L56 (error at <module>:3) else goto L5
L5:
    eth_typing = r12 :: module
    dec_ref r12
    r13 = ('to_dict',)
    r14 = 'eth_utils'
    r15 = dank_mids._web3.formatters.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L56 (error at <module>:4) else goto L6
L6:
    eth_utils = r16 :: module
    dec_ref r16
    r17 = ('apply_formatter_at_index',)
    r18 = 'eth_utils.curried'
    r19 = dank_mids._web3.formatters.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L56 (error at <module>:5) else goto L7
L7:
    eth_utils.curried = r20 :: module
    dec_ref r20
    r21 = ('compose',)
    r22 = 'eth_utils.toolz'
    r23 = dank_mids._web3.formatters.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L56 (error at <module>:6) else goto L8
L8:
    eth_utils.toolz = r24 :: module
    dec_ref r24
    r25 = ('ERROR_FORMATTERS', 'METHOD_NORMALIZERS', 'NULL_RESULT_FORMATTERS', 'PYTHONIC_REQUEST_FORMATTERS', 'STANDARD_NORMALIZERS')
    r26 = 'web3._utils.method_formatters'
    r27 = dank_mids._web3.formatters.globals :: static
    r28 = CPyImport_ImportFromMany(r26, r25, r25, r27)
    if is_error(r28) goto L56 (error at <module>:7) else goto L9
L9:
    web3._utils.method_formatters = r28 :: module
    dec_ref r28
    r29 = ('RPC_ABIS', 'apply_abi_formatters_to_dict')
    r30 = 'web3._utils.rpc_abi'
    r31 = dank_mids._web3.formatters.globals :: static
    r32 = CPyImport_ImportFromMany(r30, r29, r29, r31)
    if is_error(r32) goto L56 (error at <module>:14) else goto L10
L10:
    web3._utils.rpc_abi = r32 :: module
    dec_ref r32
    r33 = ('Formatters', 'RPCEndpoint', 'RPCResponse')
    r34 = 'web3.types'
    r35 = dank_mids._web3.formatters.globals :: static
    r36 = CPyImport_ImportFromMany(r34, r33, r33, r35)
    if is_error(r36) goto L56 (error at <module>:15) else goto L11
L11:
    web3.types = r36 :: module
    dec_ref r36
    r37 = ('get_mapper',)
    r38 = 'dank_mids._web3.abi'
    r39 = dank_mids._web3.formatters.globals :: static
    r40 = CPyImport_ImportFromMany(r38, r37, r37, r39)
    if is_error(r40) goto L56 (error at <module>:18) else goto L12
L12:
    dank_mids._web3.abi = r40 :: module
    dec_ref r40
    r41 = '_T'
    r42 = dank_mids._web3.formatters.globals :: static
    r43 = 'TypeVar'
    r44 = CPyDict_GetItem(r42, r43)
    if is_error(r44) goto L56 (error at <module>:21) else goto L13
L13:
    r45 = [r41]
    r46 = load_address r45
    r47 = _PyObject_Vectorcall(r44, r46, 1, 0)
    dec_ref r44
    if is_error(r47) goto L56 (error at <module>:21) else goto L14
L14:
    r48 = dank_mids._web3.formatters.globals :: static
    r49 = '_T'
    r50 = CPyDict_SetItem(r48, r49, r47)
    dec_ref r47
    r51 = r50 >= 0 :: signed
    if not r51 goto L56 (error at <module>:21) else goto L15 :: bool
L15:
    r52 = dank_mids._web3.formatters.globals :: static
    r53 = 'STANDARD_NORMALIZERS'
    r54 = CPyDict_GetItem(r52, r53)
    if is_error(r54) goto L56 (error at <module>:43) else goto L16
L16:
    r55 = dank_mids._web3.formatters.globals :: static
    r56 = 'RPC_ABIS'
    r57 = CPyDict_GetItem(r55, r56)
    if is_error(r57) goto L57 (error at <module>:43) else goto L17
L17:
    r58 = cast(dict, r57)
    if is_error(r58) goto L57 (error at <module>:43) else goto L18
L18:
    r59 = abi_request_formatters(r54, r58)
    dec_ref r54
    dec_ref r58
    if is_error(r59) goto L56 (error at <module>:43) else goto L19
L19:
    r60 = CPyDict_FromAny(r59)
    dec_ref r59
    if is_error(r60) goto L56 (error at <module>:42) else goto L20
L20:
    dank_mids._web3.formatters.ABI_REQUEST_FORMATTERS = r60 :: static
    r61 = dank_mids._web3.formatters.globals :: static
    r62 = 'ABI_REQUEST_FORMATTERS'
    r63 = CPyDict_SetItem(r61, r62, r60)
    dec_ref r60
    r64 = r63 >= 0 :: signed
    if not r64 goto L56 (error at <module>:42) else goto L21 :: bool
L21:
    r65 = dank_mids._web3.formatters.ABI_REQUEST_FORMATTERS :: static
    if is_error(r65) goto L22 else goto L24
L22:
    r66 = raise NameError('value for final name "ABI_REQUEST_FORMATTERS" was not set')
    if not r66 goto L56 (error at <module>:47) else goto L23 :: bool
L23:
    unreachable
L24:
    r67 = dank_mids._web3.formatters.globals :: static
    r68 = 'METHOD_NORMALIZERS'
    r69 = CPyDict_GetItem(r67, r68)
    if is_error(r69) goto L56 (error at <module>:52) else goto L25
L25:
    r70 = dank_mids._web3.formatters.globals :: static
    r71 = 'PYTHONIC_REQUEST_FORMATTERS'
    r72 = CPyDict_GetItem(r70, r71)
    if is_error(r72) goto L58 (error at <module>:53) else goto L26
L26:
    inc_ref r65
    r73 = (r65, r69, r72)
    dank_mids._web3.formatters.REQUEST_FORMATTER_MAPS = r73 :: static
    r74 = dank_mids._web3.formatters.globals :: static
    r75 = 'REQUEST_FORMATTER_MAPS'
    r76 = box(tuple[object, object, object], r73)
    r77 = CPyDict_SetItem(r74, r75, r76)
    dec_ref r76
    r78 = r77 >= 0 :: signed
    if not r78 goto L56 (error at <module>:46) else goto L27 :: bool
L27:
    r79 = PyDict_New()
    if is_error(r79) goto L56 (error at <module>:56) else goto L28
L28:
    dank_mids._web3.formatters._request_formatters = r79 :: static
    r80 = dank_mids._web3.formatters.globals :: static
    r81 = '_request_formatters'
    r82 = CPyDict_SetItem(r80, r81, r79)
    dec_ref r79
    r83 = r82 >= 0 :: signed
    if not r83 goto L56 (error at <module>:56) else goto L29 :: bool
L29:
    r84 = dank_mids._web3.formatters.globals :: static
    r85 = 'Callable'
    r86 = CPyDict_GetItem(r84, r85)
    if is_error(r86) goto L56 (error at <module>:76) else goto L30
L30:
    r87 = dank_mids._web3.formatters.globals :: static
    r88 = 'RPCResponse'
    r89 = CPyDict_GetItem(r87, r88)
    if is_error(r89) goto L59 (error at <module>:76) else goto L31
L31:
    r90 = PyList_New(1)
    if is_error(r90) goto L60 (error at <module>:76) else goto L32
L32:
    r91 = get_element_ptr r90 ob_item :: PyListObject
    r92 = load_mem r91 :: ptr*
    set_mem r92, r89 :: builtins.object*
    r93 = dank_mids._web3.formatters.globals :: static
    r94 = 'Any'
    r95 = CPyDict_GetItem(r93, r94)
    if is_error(r95) goto L61 (error at <module>:76) else goto L33
L33:
    r96 = (r90, r95)
    r97 = box(tuple[list, object], r96)
    r98 = PyObject_GetItem(r86, r97)
    dec_ref r86
    dec_ref r97
    if is_error(r98) goto L56 (error at <module>:76) else goto L34
L34:
    r99 = dank_mids._web3.formatters.globals :: static
    r100 = 'SuccessFormatter'
    r101 = CPyDict_SetItem(r99, r100, r98)
    dec_ref r98
    r102 = r101 >= 0 :: signed
    if not r102 goto L56 (error at <module>:76) else goto L35 :: bool
L35:
    r103 = dank_mids._web3.formatters.globals :: static
    r104 = 'Callable'
    r105 = CPyDict_GetItem(r103, r104)
    if is_error(r105) goto L56 (error at <module>:77) else goto L36
L36:
    r106 = dank_mids._web3.formatters.globals :: static
    r107 = 'RPCResponse'
    r108 = CPyDict_GetItem(r106, r107)
    if is_error(r108) goto L62 (error at <module>:77) else goto L37
L37:
    r109 = PyList_New(1)
    if is_error(r109) goto L63 (error at <module>:77) else goto L38
L38:
    r110 = get_element_ptr r109 ob_item :: PyListObject
    r111 = load_mem r110 :: ptr*
    set_mem r111, r108 :: builtins.object*
    r112 = dank_mids._web3.formatters.globals :: static
    r113 = 'Any'
    r114 = CPyDict_GetItem(r112, r113)
    if is_error(r114) goto L64 (error at <module>:77) else goto L39
L39:
    r115 = (r109, r114)
    r116 = box(tuple[list, object], r115)
    r117 = PyObject_GetItem(r105, r116)
    dec_ref r105
    dec_ref r116
    if is_error(r117) goto L56 (error at <module>:77) else goto L40
L40:
    r118 = dank_mids._web3.formatters.globals :: static
    r119 = 'ErrorFormatter'
    r120 = CPyDict_SetItem(r118, r119, r117)
    dec_ref r117
    r121 = r120 >= 0 :: signed
    if not r121 goto L56 (error at <module>:77) else goto L41 :: bool
L41:
    r122 = dank_mids._web3.formatters.globals :: static
    r123 = 'Callable'
    r124 = CPyDict_GetItem(r122, r123)
    if is_error(r124) goto L56 (error at <module>:78) else goto L42
L42:
    r125 = dank_mids._web3.formatters.globals :: static
    r126 = 'RPCResponse'
    r127 = CPyDict_GetItem(r125, r126)
    if is_error(r127) goto L65 (error at <module>:78) else goto L43
L43:
    r128 = PyList_New(1)
    if is_error(r128) goto L66 (error at <module>:78) else goto L44
L44:
    r129 = get_element_ptr r128 ob_item :: PyListObject
    r130 = load_mem r129 :: ptr*
    set_mem r130, r127 :: builtins.object*
    r131 = dank_mids._web3.formatters.globals :: static
    r132 = 'Any'
    r133 = CPyDict_GetItem(r131, r132)
    if is_error(r133) goto L67 (error at <module>:78) else goto L45
L45:
    r134 = (r128, r133)
    r135 = box(tuple[list, object], r134)
    r136 = PyObject_GetItem(r124, r135)
    dec_ref r124
    dec_ref r135
    if is_error(r136) goto L56 (error at <module>:78) else goto L46
L46:
    r137 = dank_mids._web3.formatters.globals :: static
    r138 = 'NullFormatter'
    r139 = CPyDict_SetItem(r137, r138, r136)
    dec_ref r136
    r140 = r139 >= 0 :: signed
    if not r140 goto L56 (error at <module>:78) else goto L47 :: bool
L47:
    r141 = dank_mids._web3.formatters.globals :: static
    r142 = 'Tuple'
    r143 = CPyDict_GetItem(r141, r142)
    if is_error(r143) goto L56 (error at <module>:80) else goto L48
L48:
    r144 = dank_mids._web3.formatters.globals :: static
    r145 = 'SuccessFormatter'
    r146 = CPyDict_GetItem(r144, r145)
    if is_error(r146) goto L68 (error at <module>:80) else goto L49
L49:
    r147 = dank_mids._web3.formatters.globals :: static
    r148 = 'ErrorFormatter'
    r149 = CPyDict_GetItem(r147, r148)
    if is_error(r149) goto L69 (error at <module>:80) else goto L50
L50:
    r150 = dank_mids._web3.formatters.globals :: static
    r151 = 'NullFormatter'
    r152 = CPyDict_GetItem(r150, r151)
    if is_error(r152) goto L70 (error at <module>:80) else goto L51
L51:
    r153 = (r146, r149, r152)
    r154 = box(tuple[object, object, object], r153)
    r155 = PyObject_GetItem(r143, r154)
    dec_ref r143
    dec_ref r154
    if is_error(r155) goto L56 (error at <module>:80) else goto L52
L52:
    r156 = dank_mids._web3.formatters.globals :: static
    r157 = 'ResponseFormatters'
    r158 = CPyDict_SetItem(r156, r157, r155)
    dec_ref r155
    r159 = r158 >= 0 :: signed
    if not r159 goto L56 (error at <module>:80) else goto L53 :: bool
L53:
    r160 = PyDict_New()
    if is_error(r160) goto L56 (error at <module>:82) else goto L54
L54:
    dank_mids._web3.formatters._response_formatters = r160 :: static
    r161 = dank_mids._web3.formatters.globals :: static
    r162 = '_response_formatters'
    r163 = CPyDict_SetItem(r161, r162, r160)
    dec_ref r160
    r164 = r163 >= 0 :: signed
    if not r164 goto L56 (error at <module>:82) else goto L55 :: bool
L55:
    return 1
L56:
    r165 = <error> :: None
    return r165
L57:
    dec_ref r54
    goto L56
L58:
    dec_ref r69
    goto L56
L59:
    dec_ref r86
    goto L56
L60:
    dec_ref r86
    dec_ref r89
    goto L56
L61:
    dec_ref r86
    dec_ref r90
    goto L56
L62:
    dec_ref r105
    goto L56
L63:
    dec_ref r105
    dec_ref r108
    goto L56
L64:
    dec_ref r105
    dec_ref r109
    goto L56
L65:
    dec_ref r124
    goto L56
L66:
    dec_ref r124
    dec_ref r127
    goto L56
L67:
    dec_ref r124
    dec_ref r128
    goto L56
L68:
    dec_ref r143
    goto L56
L69:
    dec_ref r143
    dec_ref r146
    goto L56
L70:
    dec_ref r143
    dec_ref r146
    dec_ref r149
    goto L56

def gatherish_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    type, value, traceback, arg, r0, r1, r2, r3, r4, r5, r6, r7 :: object
    r8 :: dank_mids.helpers._gather.gatherish_env
    r9 :: int
    r10 :: object
    r11 :: bit
    r12 :: object
    r13 :: bool
    r14 :: object
    r15 :: bool
    r16 :: list
    r17 :: bool
    r18, r19 :: object
    r20, r21 :: bool
    r22, r23 :: object
    r24 :: bool
    r25, r26 :: object
    r27 :: union[str, None]
    r28 :: object
    r29 :: bool
    r30 :: object[3]
    r31 :: object_ptr
    r32, r33 :: object
    r34 :: list
    r35 :: i32
    r36, r37 :: bit
    r38 :: list
    r39 :: object
    r40 :: bool
    r41 :: object
    r42 :: bool
    r43, r44 :: object
    r45 :: bool
    r46, r47, r48, r49, r50 :: object
    r51 :: bool
    r52 :: object
    r53 :: bit
    r54 :: tuple[object, object, object]
    r55 :: bool
    r56 :: object_ptr
    r57 :: object
    r58, r59 :: bool
    r60 :: tuple[object, object, object]
    r61 :: bool
    r62, r63 :: tuple[object, object, object]
    r64 :: bit
    r65, r66, r67, r68 :: object
    r69 :: bool
    r70, r71 :: object
    r72 :: bool
    r73, r74, r75, r76, r77 :: object
    r78 :: bool
    r79 :: object
    r80 :: bit
    r81 :: tuple[object, object, object]
    r82 :: bool
    r83 :: object_ptr
    r84 :: object
    r85, r86 :: bool
    r87 :: tuple[object, object, object]
    r88 :: bool
    r89, r90 :: tuple[object, object, object]
    r91 :: bit
    r92, r93, r94, r95, r96 :: object
    r97, r98 :: bool
    r99, r100 :: object
    r101 :: bool
    r102, r103 :: object
    r104 :: bool
    r105, r106, r107, r108, r109 :: object
    r110 :: bool
    r111 :: object
    r112 :: bit
    r113 :: tuple[object, object, object]
    r114 :: bool
    r115 :: object_ptr
    r116 :: object
    r117, r118 :: bool
    r119 :: tuple[object, object, object]
    r120 :: bool
    r121, r122 :: tuple[object, object, object]
    r123 :: bit
    r124, r125, r126 :: object
    r127 :: tuple[object, object, object]
    r128 :: bool
    r129 :: object
    r130 :: str
    r131 :: object
    r132 :: bit
    r133, r134 :: object
    r135, r136 :: bool
    r137, r138 :: object
    r139 :: bool
    r140, r141 :: object
    r142 :: bool
    r143, r144, r145, r146, r147 :: object
    r148 :: bool
    r149 :: object
    r150 :: bit
    r151 :: tuple[object, object, object]
    r152 :: bool
    r153 :: object_ptr
    r154 :: object
    r155, r156 :: bool
    r157 :: tuple[object, object, object]
    r158 :: bool
    r159, r160 :: tuple[object, object, object]
    r161 :: bit
    r162, r163, r164 :: object
    r165 :: tuple[object, object, object]
    r166 :: bool
    r167 :: object
    r168 :: str
    r169 :: object
    r170 :: bit
    r171, r172 :: tuple[object, object, object]
    r173, r174 :: bit
    r175 :: tuple[object, object, object]
    r176, r177 :: bit
    r178 :: object
    r179 :: bool
    r180, r181, r182, r183, r184 :: bit
    r185 :: bool
    r186 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = <error> :: object
    r5 = r4
    r6 = <error> :: object
    r7 = r6
    r8 = __mypyc_self__.__mypyc_env__
    if is_error(r8) goto L229 (error at gatherish:33) else goto L1
L1:
    r9 = r8.__mypyc_next_label__
    if is_error(r9) goto L230 (error at gatherish:33) else goto L221
L2:
    r10 = load_address _Py_NoneStruct
    r11 = type != r10
    if r11 goto L231 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L228 (error at gatherish:33) else goto L4 :: bool
L4:
    unreachable
L5:
    r12 = dank_mids.helpers._gather.get_running_loop :: static
    if is_error(r12) goto L232 else goto L8
L6:
    r13 = raise NameError('value for final name "get_running_loop" was not set')
    if not r13 goto L228 (error at gatherish:41) else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = _PyObject_Vectorcall(r12, 0, 0, 0)
    if is_error(r14) goto L230 (error at gatherish:41) else goto L9
L9:
    r8.loop = r14; r15 = is_error
    if not r15 goto L230 (error at gatherish:41) else goto L10 :: bool
L10:
    r16 = PyList_New(0)
    if is_error(r16) goto L230 (error at gatherish:44) else goto L11
L11:
    r8.__mypyc_temp__0 = r16; r17 = is_error
    if not r17 goto L230 (error at gatherish:-1) else goto L12 :: bool
L12:
    r18 = r8.coros
    if is_error(r18) goto L230 (error at gatherish:44) else goto L13
L13:
    r19 = PyObject_GetIter(r18)
    if is_error(r19) goto L233 (error at gatherish:44) else goto L14
L14:
    r8.__mypyc_temp__1 = r18; r20 = is_error
    if not r20 goto L234 (error at gatherish:-1) else goto L15 :: bool
L15:
    r8.__mypyc_temp__2 = r19; r21 = is_error
    if not r21 goto L230 (error at gatherish:-1) else goto L16 :: bool
L16:
    r22 = r8.__mypyc_temp__2
    if is_error(r22) goto L230 (error at gatherish:44) else goto L17
L17:
    r23 = PyIter_Next(r22)
    dec_ref r22
    if is_error(r23) goto L28 else goto L18
L18:
    r8.coro = r23; r24 = is_error
    if not r24 goto L230 (error at gatherish:44) else goto L19 :: bool
L19:
    r25 = r8.coro
    if is_error(r25) goto L230 (error at gatherish:44) else goto L20
L20:
    r26 = r8.loop
    if is_error(r26) goto L235 (error at gatherish:44) else goto L21
L21:
    r27 = r8.name
    if is_error(r27) goto L236 (error at gatherish:44) else goto L22
L22:
    r28 = dank_mids.helpers._gather.Task :: static
    if is_error(r28) goto L237 else goto L25
L23:
    r29 = raise NameError('value for final name "Task" was not set')
    if not r29 goto L228 (error at gatherish:44) else goto L24 :: bool
L24:
    unreachable
L25:
    r30 = [r25, r26, r27]
    r31 = load_address r30
    r32 = ('loop', 'name')
    r33 = _PyObject_Vectorcall(r28, r31, 1, r32)
    if is_error(r33) goto L238 (error at gatherish:44) else goto L26
L26:
    dec_ref r25
    dec_ref r26
    dec_ref r27
    r34 = r8.__mypyc_temp__0
    if is_error(r34) goto L239 (error at gatherish:-1) else goto L27
L27:
    r35 = PyList_Append(r34, r33)
    dec_ref r34
    dec_ref r33
    r36 = r35 >= 0 :: signed
    if not r36 goto L230 (error at gatherish:44) else goto L16 :: bool
L28:
    r37 = CPy_NoErrOccurred()
    if not r37 goto L230 (error at gatherish:44) else goto L29 :: bool
L29:
    r38 = r8.__mypyc_temp__0
    if is_error(r38) goto L230 (error at gatherish:-1) else goto L30
L30:
    r39 = PyObject_GetIter(r38)
    dec_ref r38
    if is_error(r39) goto L230 (error at gatherish:44) else goto L31
L31:
    r8.tasks = r39; r40 = is_error
    if not r40 goto L230 (error at gatherish:44) else goto L32 :: bool
L32:
    r41 = dank_mids.helpers._gather.yield_to_loop :: static
    if is_error(r41) goto L240 else goto L35
L33:
    r42 = raise NameError('value for final name "yield_to_loop" was not set')
    if not r42 goto L228 (error at gatherish:49) else goto L34 :: bool
L34:
    unreachable
L35:
    r43 = _PyObject_Vectorcall(r41, 0, 0, 0)
    if is_error(r43) goto L230 (error at gatherish:49) else goto L36
L36:
    r44 = CPy_GetCoro(r43)
    dec_ref r43
    if is_error(r44) goto L230 (error at gatherish:49) else goto L37
L37:
    r8.__mypyc_temp__3 = r44; r45 = is_error
    if not r45 goto L230 (error at gatherish:-1) else goto L38 :: bool
L38:
    r46 = r8.__mypyc_temp__3
    if is_error(r46) goto L230 (error at gatherish:-1) else goto L39
L39:
    r47 = CPyIter_Next(r46)
    dec_ref r46
    if is_error(r47) goto L241 else goto L42
L40:
    r48 = CPy_FetchStopIterationValue()
    if is_error(r48) goto L242 (error at gatherish:49) else goto L41
L41:
    r49 = r48
    dec_ref r49
    goto L71
L42:
    r50 = r47
L43:
    r8.__mypyc_next_label__ = 2; r51 = is_error
    if not r51 goto L243 (error at gatherish:49) else goto L244 :: bool
L44:
    return r50
L45:
    r52 = load_address _Py_NoneStruct
    r53 = type != r52
    if r53 goto L46 else goto L48 :: bool
L46:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L49 (error at gatherish:49) else goto L245 :: bool
L47:
    unreachable
L48:
    inc_ref arg
    goto L66
L49:
    r54 = CPy_CatchError()
    r8.__mypyc_temp__4 = r54; r55 = is_error
    if not r55 goto L246 (error at gatherish:-1) else goto L50 :: bool
L50:
    r56 = load_address r1
    r57 = r8.__mypyc_temp__3
    if is_error(r57) goto L246 (error at gatherish:-1) else goto L51
L51:
    r58 = CPy_YieldFromErrorHandle(r57, r56)
    dec_ref r57
    if is_error(r58) goto L246 (error at gatherish:49) else goto L52
L52:
    if r58 goto L58 else goto L53 :: bool
L53:
    if is_error(r1) goto L247 else goto L56
L54:
    r59 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r59 goto L63 (error at gatherish:-1) else goto L248 :: bool
L55:
    unreachable
L56:
    inc_ref r1
    r50 = r1
    r60 = r8.__mypyc_temp__4
    if is_error(r60) goto L249 (error at gatherish:-1) else goto L57
L57:
    CPy_RestoreExcInfo(r60)
    dec_ref r60
    goto L43
L58:
    if is_error(r1) goto L250 else goto L61
L59:
    r61 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r61 goto L63 (error at gatherish:-1) else goto L251 :: bool
L60:
    unreachable
L61:
    r49 = r1
    dec_ref r49
    r62 = r8.__mypyc_temp__4
    if is_error(r62) goto L252 (error at gatherish:-1) else goto L62
L62:
    CPy_RestoreExcInfo(r62)
    dec_ref r62
    goto L71
L63:
    r63 = r8.__mypyc_temp__4
    dec_ref r8
    if is_error(r63) goto L228 (error at gatherish:-1) else goto L64
L64:
    CPy_RestoreExcInfo(r63)
    dec_ref r63
    r64 = CPy_KeepPropagating()
    if not r64 goto L228 else goto L65 :: bool
L65:
    unreachable
L66:
    r65 = r8.__mypyc_temp__3
    if is_error(r65) goto L253 (error at gatherish:-1) else goto L67
L67:
    r66 = CPyIter_Send(r65, arg)
    dec_ref r65
    dec_ref arg
    if is_error(r66) goto L254 else goto L68
L68:
    r50 = r66
    goto L43
L69:
    r67 = CPy_FetchStopIterationValue()
    if is_error(r67) goto L242 (error at gatherish:49) else goto L70
L70:
    r49 = r67
    dec_ref r49
L71:
    r68 = dank_mids.helpers._gather.yield_to_loop :: static
    if is_error(r68) goto L255 else goto L74
L72:
    r69 = raise NameError('value for final name "yield_to_loop" was not set')
    if not r69 goto L228 (error at gatherish:50) else goto L73 :: bool
L73:
    unreachable
L74:
    r70 = _PyObject_Vectorcall(r68, 0, 0, 0)
    if is_error(r70) goto L242 (error at gatherish:50) else goto L75
L75:
    r71 = CPy_GetCoro(r70)
    dec_ref r70
    if is_error(r71) goto L242 (error at gatherish:50) else goto L76
L76:
    r8.__mypyc_temp__5 = r71; r72 = is_error
    if not r72 goto L242 (error at gatherish:-1) else goto L77 :: bool
L77:
    r73 = r8.__mypyc_temp__5
    if is_error(r73) goto L242 (error at gatherish:-1) else goto L78
L78:
    r74 = CPyIter_Next(r73)
    dec_ref r73
    if is_error(r74) goto L256 else goto L81
L79:
    r75 = CPy_FetchStopIterationValue()
    if is_error(r75) goto L257 (error at gatherish:50) else goto L80
L80:
    r76 = r75
    dec_ref r76
    goto L110
L81:
    r77 = r74
L82:
    r8.__mypyc_next_label__ = 4; r78 = is_error
    if not r78 goto L258 (error at gatherish:50) else goto L259 :: bool
L83:
    return r77
L84:
    r79 = load_address _Py_NoneStruct
    r80 = type != r79
    if r80 goto L85 else goto L87 :: bool
L85:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L88 (error at gatherish:50) else goto L260 :: bool
L86:
    unreachable
L87:
    inc_ref arg
    goto L105
L88:
    r81 = CPy_CatchError()
    r8.__mypyc_temp__6 = r81; r82 = is_error
    if not r82 goto L261 (error at gatherish:-1) else goto L89 :: bool
L89:
    r83 = load_address r3
    r84 = r8.__mypyc_temp__5
    if is_error(r84) goto L261 (error at gatherish:-1) else goto L90
L90:
    r85 = CPy_YieldFromErrorHandle(r84, r83)
    dec_ref r84
    if is_error(r85) goto L261 (error at gatherish:50) else goto L91
L91:
    if r85 goto L97 else goto L92 :: bool
L92:
    if is_error(r3) goto L262 else goto L95
L93:
    r86 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r86 goto L102 (error at gatherish:-1) else goto L263 :: bool
L94:
    unreachable
L95:
    inc_ref r3
    r77 = r3
    r87 = r8.__mypyc_temp__6
    if is_error(r87) goto L264 (error at gatherish:-1) else goto L96
L96:
    CPy_RestoreExcInfo(r87)
    dec_ref r87
    goto L82
L97:
    if is_error(r3) goto L265 else goto L100
L98:
    r88 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r88 goto L102 (error at gatherish:-1) else goto L266 :: bool
L99:
    unreachable
L100:
    r76 = r3
    dec_ref r76
    r89 = r8.__mypyc_temp__6
    if is_error(r89) goto L267 (error at gatherish:-1) else goto L101
L101:
    CPy_RestoreExcInfo(r89)
    dec_ref r89
    goto L110
L102:
    r90 = r8.__mypyc_temp__6
    dec_ref r8
    if is_error(r90) goto L228 (error at gatherish:-1) else goto L103
L103:
    CPy_RestoreExcInfo(r90)
    dec_ref r90
    r91 = CPy_KeepPropagating()
    if not r91 goto L228 else goto L104 :: bool
L104:
    unreachable
L105:
    r92 = r8.__mypyc_temp__5
    if is_error(r92) goto L268 (error at gatherish:-1) else goto L106
L106:
    r93 = CPyIter_Send(r92, arg)
    dec_ref r92
    dec_ref arg
    if is_error(r93) goto L269 else goto L107
L107:
    r77 = r93
    goto L82
L108:
    r94 = CPy_FetchStopIterationValue()
    if is_error(r94) goto L257 (error at gatherish:50) else goto L109
L109:
    r76 = r94
    dec_ref r76
L110:
    r95 = r8.tasks
    if is_error(r95) goto L257 (error at gatherish:51) else goto L111
L111:
    r96 = PyObject_GetIter(r95)
    if is_error(r96) goto L270 (error at gatherish:51) else goto L112
L112:
    r8.__mypyc_temp__7 = r95; r97 = is_error
    if not r97 goto L271 (error at gatherish:-1) else goto L113 :: bool
L113:
    r8.__mypyc_temp__8 = r96; r98 = is_error
    if not r98 goto L257 (error at gatherish:-1) else goto L114 :: bool
L114:
    r99 = r8.__mypyc_temp__8
    if is_error(r99) goto L257 (error at gatherish:51) else goto L115
L115:
    r100 = PyIter_Next(r99)
    dec_ref r99
    if is_error(r100) goto L272 else goto L116
L116:
    r8.task = r100; r101 = is_error
    if not r101 goto L257 (error at gatherish:51) else goto L117 :: bool
L117:
    r102 = r8.task
    if is_error(r102) goto L273 (error at gatherish:53) else goto L118
L118:
    r103 = CPy_GetCoro(r102)
    dec_ref r102
    if is_error(r103) goto L273 (error at gatherish:53) else goto L119
L119:
    r8.__mypyc_temp__9 = r103; r104 = is_error
    if not r104 goto L273 (error at gatherish:-1) else goto L120 :: bool
L120:
    r105 = r8.__mypyc_temp__9
    if is_error(r105) goto L273 (error at gatherish:-1) else goto L121
L121:
    r106 = CPyIter_Next(r105)
    dec_ref r105
    if is_error(r106) goto L122 else goto L124
L122:
    r107 = CPy_FetchStopIterationValue()
    if is_error(r107) goto L273 (error at gatherish:53) else goto L123
L123:
    r108 = r107
    dec_ref r108
    goto L114
L124:
    r109 = r106
L125:
    r8.__mypyc_next_label__ = 6; r110 = is_error
    if not r110 goto L274 (error at gatherish:53) else goto L275 :: bool
L126:
    return r109
L127:
    r111 = load_address _Py_NoneStruct
    r112 = type != r111
    if r112 goto L128 else goto L130 :: bool
L128:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L131 (error at gatherish:53) else goto L276 :: bool
L129:
    unreachable
L130:
    inc_ref arg
    goto L148
L131:
    r113 = CPy_CatchError()
    r8.__mypyc_temp__10 = r113; r114 = is_error
    if not r114 goto L277 (error at gatherish:-1) else goto L132 :: bool
L132:
    r115 = load_address r5
    r116 = r8.__mypyc_temp__9
    if is_error(r116) goto L277 (error at gatherish:-1) else goto L133
L133:
    r117 = CPy_YieldFromErrorHandle(r116, r115)
    dec_ref r116
    if is_error(r117) goto L277 (error at gatherish:53) else goto L134
L134:
    if r117 goto L140 else goto L135 :: bool
L135:
    if is_error(r5) goto L136 else goto L138
L136:
    r118 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r118 goto L145 (error at gatherish:-1) else goto L278 :: bool
L137:
    unreachable
L138:
    inc_ref r5
    r109 = r5
    r119 = r8.__mypyc_temp__10
    if is_error(r119) goto L279 (error at gatherish:-1) else goto L139
L139:
    CPy_RestoreExcInfo(r119)
    dec_ref r119
    goto L125
L140:
    if is_error(r5) goto L141 else goto L143
L141:
    r120 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r120 goto L145 (error at gatherish:-1) else goto L280 :: bool
L142:
    unreachable
L143:
    inc_ref r5
    r108 = r5
    dec_ref r108
    r121 = r8.__mypyc_temp__10
    if is_error(r121) goto L277 (error at gatherish:-1) else goto L144
L144:
    CPy_RestoreExcInfo(r121)
    dec_ref r121
    goto L114
L145:
    r122 = r8.__mypyc_temp__10
    if is_error(r122) goto L153 (error at gatherish:-1) else goto L146
L146:
    CPy_RestoreExcInfo(r122)
    dec_ref r122
    r123 = CPy_KeepPropagating()
    if not r123 goto L153 else goto L281 :: bool
L147:
    unreachable
L148:
    r124 = r8.__mypyc_temp__9
    if is_error(r124) goto L282 (error at gatherish:-1) else goto L149
L149:
    r125 = CPyIter_Send(r124, arg)
    dec_ref r124
    dec_ref arg
    if is_error(r125) goto L151 else goto L150
L150:
    r109 = r125
    goto L125
L151:
    r126 = CPy_FetchStopIterationValue()
    if is_error(r126) goto L273 (error at gatherish:53) else goto L152
L152:
    r108 = r126
    dec_ref r108
    goto L114
L153:
    r127 = CPy_CatchError()
    r8.__mypyc_temp__11 = r127; r128 = is_error
    if not r128 goto L283 (error at gatherish:-1) else goto L154 :: bool
L154:
    r129 = builtins :: module
    r130 = 'Exception'
    r131 = CPyObject_GetAttr(r129, r130)
    if is_error(r131) goto L283 (error at gatherish:54) else goto L155
L155:
    r132 = CPy_ExceptionMatches(r131)
    dec_ref r131
    if r132 goto L156 else goto L284 :: bool
L156:
    r133 = r8.tasks
    if is_error(r133) goto L283 (error at gatherish:57) else goto L157
L157:
    r134 = PyObject_GetIter(r133)
    if is_error(r134) goto L285 (error at gatherish:57) else goto L158
L158:
    r8.__mypyc_temp__12 = r133; r135 = is_error
    if not r135 goto L286 (error at gatherish:-1) else goto L159 :: bool
L159:
    r8.__mypyc_temp__13 = r134; r136 = is_error
    if not r136 goto L283 (error at gatherish:-1) else goto L160 :: bool
L160:
    r137 = r8.__mypyc_temp__13
    if is_error(r137) goto L283 (error at gatherish:57) else goto L161
L161:
    r138 = PyIter_Next(r137)
    dec_ref r137
    if is_error(r138) goto L287 else goto L162
L162:
    r8.task = r138; r139 = is_error
    if not r139 goto L283 (error at gatherish:57) else goto L163 :: bool
L163:
    r140 = r8.task
    if is_error(r140) goto L199 (error at gatherish:60) else goto L164
L164:
    r141 = CPy_GetCoro(r140)
    dec_ref r140
    if is_error(r141) goto L199 (error at gatherish:60) else goto L165
L165:
    r8.__mypyc_temp__14 = r141; r142 = is_error
    if not r142 goto L199 (error at gatherish:-1) else goto L166 :: bool
L166:
    r143 = r8.__mypyc_temp__14
    if is_error(r143) goto L199 (error at gatherish:-1) else goto L167
L167:
    r144 = CPyIter_Next(r143)
    dec_ref r143
    if is_error(r144) goto L168 else goto L170
L168:
    r145 = CPy_FetchStopIterationValue()
    if is_error(r145) goto L199 (error at gatherish:60) else goto L169
L169:
    r146 = r145
    dec_ref r146
    goto L160
L170:
    r147 = r144
L171:
    r8.__mypyc_next_label__ = 8; r148 = is_error
    if not r148 goto L288 (error at gatherish:60) else goto L289 :: bool
L172:
    return r147
L173:
    r149 = load_address _Py_NoneStruct
    r150 = type != r149
    if r150 goto L174 else goto L176 :: bool
L174:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L177 (error at gatherish:60) else goto L290 :: bool
L175:
    unreachable
L176:
    inc_ref arg
    goto L194
L177:
    r151 = CPy_CatchError()
    r8.__mypyc_temp__15 = r151; r152 = is_error
    if not r152 goto L191 (error at gatherish:-1) else goto L178 :: bool
L178:
    r153 = load_address r7
    r154 = r8.__mypyc_temp__14
    if is_error(r154) goto L191 (error at gatherish:-1) else goto L179
L179:
    r155 = CPy_YieldFromErrorHandle(r154, r153)
    dec_ref r154
    if is_error(r155) goto L191 (error at gatherish:60) else goto L180
L180:
    if r155 goto L186 else goto L181 :: bool
L181:
    if is_error(r7) goto L182 else goto L184
L182:
    r156 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r156 goto L191 (error at gatherish:-1) else goto L291 :: bool
L183:
    unreachable
L184:
    inc_ref r7
    r147 = r7
    r157 = r8.__mypyc_temp__15
    if is_error(r157) goto L292 (error at gatherish:-1) else goto L185
L185:
    CPy_RestoreExcInfo(r157)
    dec_ref r157
    goto L171
L186:
    if is_error(r7) goto L187 else goto L189
L187:
    r158 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r158 goto L191 (error at gatherish:-1) else goto L293 :: bool
L188:
    unreachable
L189:
    inc_ref r7
    r146 = r7
    dec_ref r146
    r159 = r8.__mypyc_temp__15
    if is_error(r159) goto L191 (error at gatherish:-1) else goto L190
L190:
    CPy_RestoreExcInfo(r159)
    dec_ref r159
    goto L160
L191:
    r160 = r8.__mypyc_temp__15
    if is_error(r160) goto L199 (error at gatherish:-1) else goto L192
L192:
    CPy_RestoreExcInfo(r160)
    dec_ref r160
    r161 = CPy_KeepPropagating()
    if not r161 goto L199 else goto L294 :: bool
L193:
    unreachable
L194:
    r162 = r8.__mypyc_temp__14
    if is_error(r162) goto L295 (error at gatherish:-1) else goto L195
L195:
    r163 = CPyIter_Send(r162, arg)
    dec_ref r162
    dec_ref arg
    if is_error(r163) goto L197 else goto L196
L196:
    r147 = r163
    goto L171
L197:
    r164 = CPy_FetchStopIterationValue()
    if is_error(r164) goto L199 (error at gatherish:60) else goto L198
L198:
    r146 = r164
    dec_ref r146
    goto L160
L199:
    r165 = CPy_CatchError()
    r8.__mypyc_temp__16 = r165; r166 = is_error
    if not r166 goto L296 (error at gatherish:-1) else goto L200 :: bool
L200:
    r167 = builtins :: module
    r168 = 'Exception'
    r169 = CPyObject_GetAttr(r167, r168)
    if is_error(r169) goto L296 (error at gatherish:61) else goto L201
L201:
    r170 = CPy_ExceptionMatches(r169)
    dec_ref r169
    if r170 goto L204 else goto L297 :: bool
L202:
    CPy_Reraise()
    if not 0 goto L206 else goto L298 :: bool
L203:
    unreachable
L204:
    r171 = r8.__mypyc_temp__16
    if is_error(r171) goto L283 (error at gatherish:-1) else goto L205
L205:
    CPy_RestoreExcInfo(r171)
    dec_ref r171
    goto L160
L206:
    r172 = r8.__mypyc_temp__16
    if is_error(r172) goto L214 (error at gatherish:-1) else goto L207
L207:
    CPy_RestoreExcInfo(r172)
    dec_ref r172
    r173 = CPy_KeepPropagating()
    if not r173 goto L214 else goto L299 :: bool
L208:
    unreachable
L209:
    r174 = CPy_NoErrOccurred()
    if not r174 goto L214 (error at gatherish:57) else goto L210 :: bool
L210:
    CPy_Reraise()
    if not 0 goto L214 else goto L300 :: bool
L211:
    unreachable
L212:
    CPy_Reraise()
    if not 0 goto L214 else goto L301 :: bool
L213:
    unreachable
L214:
    r175 = r8.__mypyc_temp__11
    dec_ref r8
    if is_error(r175) goto L228 (error at gatherish:-1) else goto L215
L215:
    CPy_RestoreExcInfo(r175)
    dec_ref r175
    r176 = CPy_KeepPropagating()
    if not r176 goto L228 else goto L216 :: bool
L216:
    unreachable
L217:
    r177 = CPy_NoErrOccurred()
    if not r177 goto L302 (error at gatherish:51) else goto L218 :: bool
L218:
    r178 = box(None, 1)
    r8.__mypyc_next_label__ = -2; r179 = is_error
    dec_ref r8
    if not r179 goto L228 (error at gatherish:33) else goto L219 :: bool
L219:
    CPyGen_SetStopIterationValue(r178)
    if not 0 goto L228 else goto L220 :: bool
L220:
    unreachable
L221:
    r180 = r9 == 0
    if r180 goto L303 else goto L222 :: bool
L222:
    r181 = r9 == 2
    if r181 goto L304 else goto L305 :: bool
L223:
    r182 = r9 == 4
    if r182 goto L306 else goto L307 :: bool
L224:
    r183 = r9 == 6
    if r183 goto L308 else goto L309 :: bool
L225:
    r184 = r9 == 8
    dec_ref r9 :: int
    if r184 goto L173 else goto L310 :: bool
L226:
    r185 = raise StopIteration
    if not r185 goto L228 (error at gatherish:33) else goto L227 :: bool
L227:
    unreachable
L228:
    r186 = <error> :: object
    return r186
L229:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    goto L228
L230:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L228
L231:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L3
L232:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L6
L233:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r18
    goto L228
L234:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r19
    goto L228
L235:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r25
    goto L228
L236:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r25
    dec_ref r26
    goto L228
L237:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r25
    dec_ref r26
    dec_ref r27
    goto L23
L238:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r25
    dec_ref r26
    dec_ref r27
    goto L228
L239:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r33
    goto L228
L240:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L33
L241:
    xdec_ref r1
    goto L40
L242:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L228
L243:
    dec_ref r50
    goto L49
L244:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L44
L245:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L47
L246:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    goto L63
L247:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    goto L54
L248:
    dec_ref r8
    goto L55
L249:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r50
    goto L63
L250:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    goto L59
L251:
    dec_ref r8
    goto L60
L252:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    goto L63
L253:
    xdec_ref r1
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref arg
    goto L228
L254:
    xdec_ref r1
    goto L69
L255:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L72
L256:
    xdec_ref r3
    goto L79
L257:
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L228
L258:
    dec_ref r77
    goto L88
L259:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L83
L260:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L86
L261:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    goto L102
L262:
    xdec_ref r5
    xdec_ref r7
    goto L93
L263:
    dec_ref r8
    goto L94
L264:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r77
    goto L102
L265:
    xdec_ref r5
    xdec_ref r7
    goto L98
L266:
    dec_ref r8
    goto L99
L267:
    xdec_ref r5
    xdec_ref r7
    goto L102
L268:
    xdec_ref r3
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref arg
    goto L228
L269:
    xdec_ref r3
    goto L108
L270:
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r95
    goto L228
L271:
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    dec_ref r96
    goto L228
L272:
    xdec_ref r5
    xdec_ref r7
    goto L217
L273:
    xdec_ref r5
    goto L153
L274:
    dec_ref r109
    goto L131
L275:
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L126
L276:
    xdec_ref r5
    xdec_ref r7
    dec_ref r8
    goto L129
L277:
    xdec_ref r5
    goto L145
L278:
    xdec_ref r7
    dec_ref r8
    goto L137
L279:
    xdec_ref r5
    dec_ref r109
    goto L145
L280:
    xdec_ref r7
    dec_ref r8
    goto L142
L281:
    xdec_ref r7
    dec_ref r8
    goto L147
L282:
    xdec_ref r5
    dec_ref arg
    goto L153
L283:
    xdec_ref r7
    goto L214
L284:
    xdec_ref r7
    goto L212
L285:
    xdec_ref r7
    dec_ref r133
    goto L214
L286:
    xdec_ref r7
    dec_ref r134
    goto L214
L287:
    xdec_ref r7
    goto L209
L288:
    dec_ref r147
    goto L177
L289:
    xdec_ref r7
    dec_ref r8
    goto L172
L290:
    xdec_ref r7
    dec_ref r8
    goto L175
L291:
    xdec_ref r7
    dec_ref r8
    goto L183
L292:
    dec_ref r147
    goto L191
L293:
    xdec_ref r7
    dec_ref r8
    goto L188
L294:
    xdec_ref r7
    dec_ref r8
    goto L193
L295:
    dec_ref arg
    goto L199
L296:
    xdec_ref r7
    goto L206
L297:
    xdec_ref r7
    goto L202
L298:
    dec_ref r8
    goto L203
L299:
    dec_ref r8
    goto L208
L300:
    dec_ref r8
    goto L211
L301:
    dec_ref r8
    goto L213
L302:
    dec_ref r8
    goto L228
L303:
    dec_ref r9 :: int
    goto L2
L304:
    dec_ref r9 :: int
    goto L45
L305:
    xdec_ref r1
    goto L223
L306:
    dec_ref r9 :: int
    goto L84
L307:
    xdec_ref r3
    goto L224
L308:
    dec_ref r9 :: int
    goto L127
L309:
    xdec_ref r5
    goto L225
L310:
    xdec_ref r7
    dec_ref r8
    goto L226

def gatherish_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = gatherish_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def gatherish_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = gatherish_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def gatherish_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def gatherish_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = gatherish_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def gatherish_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def gatherish_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.gatherish_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def gatherish(coros, name):
    coros :: object
    name :: union[str, None]
    r0 :: object
    r1 :: dank_mids.helpers._gather.gatherish_env
    r2, r3 :: bool
    r4 :: dank_mids.helpers._gather.gatherish_gen
    r5, r6 :: bool
    r7 :: object
L0:
    if is_error(name) goto L1 else goto L10
L1:
    r0 = box(None, 1)
    inc_ref r0
    name = r0
L2:
    r1 = gatherish_env()
    if is_error(r1) goto L11 (error at gatherish:33) else goto L3
L3:
    inc_ref coros
    r1.coros = coros; r2 = is_error
    if not r2 goto L12 (error at gatherish:33) else goto L4 :: bool
L4:
    r1.name = name; r3 = is_error
    if not r3 goto L13 (error at gatherish:33) else goto L5 :: bool
L5:
    r4 = gatherish_gen()
    if is_error(r4) goto L13 (error at gatherish:33) else goto L6
L6:
    inc_ref r1
    r4.__mypyc_env__ = r1; r5 = is_error
    if not r5 goto L14 (error at gatherish:33) else goto L7 :: bool
L7:
    r1.__mypyc_next_label__ = 0; r6 = is_error
    dec_ref r1
    if not r6 goto L15 (error at gatherish:33) else goto L8 :: bool
L8:
    return r4
L9:
    r7 = <error> :: object
    return r7
L10:
    inc_ref name
    goto L2
L11:
    dec_ref name
    goto L9
L12:
    dec_ref name
    dec_ref r1
    goto L9
L13:
    dec_ref r1
    goto L9
L14:
    dec_ref r1
    dec_ref r4
    goto L9
L15:
    dec_ref r4
    goto L9

def first_completed_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    type, value, traceback, arg, r0, r1, r2, r3 :: object
    r4 :: dank_mids.helpers._gather.first_completed_env
    r5 :: int
    r6 :: object
    r7 :: bit
    r8 :: bool
    r9 :: tuple
    r10 :: str
    r11 :: object
    r12 :: bool
    r13 :: object[2]
    r14 :: object_ptr
    r15, r16, r17 :: object
    r18 :: bool
    r19, r20, r21, r22, r23 :: object
    r24 :: bool
    r25 :: object
    r26 :: bit
    r27 :: tuple[object, object, object]
    r28 :: bool
    r29 :: object_ptr
    r30 :: object
    r31, r32 :: bool
    r33 :: tuple[object, object, object]
    r34 :: bool
    r35, r36 :: tuple[object, object, object]
    r37 :: bit
    r38, r39, r40 :: object
    r41 :: tuple[set, set]
    r42 :: object
    r43 :: bool
    r44 :: tuple
    r45 :: str
    r46 :: object
    r47 :: bool
    r48 :: object[2]
    r49 :: object_ptr
    r50, r51, r52 :: object
    r53 :: bool
    r54, r55, r56, r57, r58 :: object
    r59 :: bool
    r60 :: object
    r61 :: bit
    r62 :: tuple[object, object, object]
    r63 :: bool
    r64 :: object_ptr
    r65 :: object
    r66, r67 :: bool
    r68 :: tuple[object, object, object]
    r69 :: bool
    r70, r71 :: tuple[object, object, object]
    r72 :: bit
    r73, r74, r75 :: object
    r76 :: tuple[set, set]
    r77, r78 :: set
    r79 :: bool
    r80, r81 :: set
    r82 :: bool
    r83 :: set
    r84 :: object
    r85, r86 :: bool
    r87, r88 :: object
    r89 :: bool
    r90 :: object
    r91 :: str
    r92 :: object[1]
    r93 :: object_ptr
    r94 :: object
    r95 :: bit
    r96 :: set
    r97 :: bool
    r98, r99, r100 :: bit
    r101 :: bool
    r102 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = __mypyc_self__.__mypyc_env__
    if is_error(r4) goto L115 (error at first_completed:74) else goto L1
L1:
    r5 = r4.__mypyc_next_label__
    if is_error(r5) goto L116 (error at first_completed:74) else goto L109
L2:
    r6 = load_address _Py_NoneStruct
    r7 = type != r6
    if r7 goto L117 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L114 (error at first_completed:74) else goto L4 :: bool
L4:
    unreachable
L5:
    r8 = r4.cancel
    if is_error(r8) goto L116 (error at first_completed:77) else goto L6
L6:
    if r8 goto L118 else goto L119 :: bool
L7:
    r9 = r4.fs
    if is_error(r9) goto L120 (error at first_completed:78) else goto L8
L8:
    r10 = 'FIRST_COMPLETED'
    r11 = dank_mids.helpers._gather.wait :: static
    if is_error(r11) goto L121 else goto L11
L9:
    r12 = raise NameError('value for final name "wait" was not set')
    if not r12 goto L114 (error at first_completed:78) else goto L10 :: bool
L10:
    unreachable
L11:
    r13 = [r9, r10]
    r14 = load_address r13
    r15 = ('return_when',)
    r16 = _PyObject_Vectorcall(r11, r14, 1, r15)
    if is_error(r16) goto L122 (error at first_completed:78) else goto L12
L12:
    dec_ref r9
    r17 = CPy_GetCoro(r16)
    dec_ref r16
    if is_error(r17) goto L120 (error at first_completed:78) else goto L13
L13:
    r4.__mypyc_temp__17 = r17; r18 = is_error
    if not r18 goto L120 (error at first_completed:-1) else goto L14 :: bool
L14:
    r19 = r4.__mypyc_temp__17
    if is_error(r19) goto L120 (error at first_completed:-1) else goto L15
L15:
    r20 = CPyIter_Next(r19)
    dec_ref r19
    if is_error(r20) goto L123 else goto L18
L16:
    r21 = CPy_FetchStopIterationValue()
    if is_error(r21) goto L124 (error at first_completed:78) else goto L17
L17:
    r22 = r21
    goto L47
L18:
    r23 = r20
L19:
    r4.__mypyc_next_label__ = 2; r24 = is_error
    if not r24 goto L125 (error at first_completed:78) else goto L126 :: bool
L20:
    return r23
L21:
    r25 = load_address _Py_NoneStruct
    r26 = type != r25
    if r26 goto L22 else goto L24 :: bool
L22:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L25 (error at first_completed:78) else goto L127 :: bool
L23:
    unreachable
L24:
    inc_ref arg
    goto L42
L25:
    r27 = CPy_CatchError()
    r4.__mypyc_temp__18 = r27; r28 = is_error
    if not r28 goto L128 (error at first_completed:-1) else goto L26 :: bool
L26:
    r29 = load_address r1
    r30 = r4.__mypyc_temp__17
    if is_error(r30) goto L128 (error at first_completed:-1) else goto L27
L27:
    r31 = CPy_YieldFromErrorHandle(r30, r29)
    dec_ref r30
    if is_error(r31) goto L128 (error at first_completed:78) else goto L28
L28:
    if r31 goto L34 else goto L29 :: bool
L29:
    if is_error(r1) goto L30 else goto L32
L30:
    r32 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r32 goto L39 (error at first_completed:-1) else goto L129 :: bool
L31:
    unreachable
L32:
    inc_ref r1
    r23 = r1
    r33 = r4.__mypyc_temp__18
    if is_error(r33) goto L130 (error at first_completed:-1) else goto L33
L33:
    CPy_RestoreExcInfo(r33)
    dec_ref r33
    goto L19
L34:
    if is_error(r1) goto L35 else goto L37
L35:
    r34 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r34 goto L39 (error at first_completed:-1) else goto L131 :: bool
L36:
    unreachable
L37:
    r22 = r1
    r35 = r4.__mypyc_temp__18
    if is_error(r35) goto L132 (error at first_completed:-1) else goto L38
L38:
    CPy_RestoreExcInfo(r35)
    dec_ref r35
    goto L47
L39:
    r36 = r4.__mypyc_temp__18
    dec_ref r4
    if is_error(r36) goto L114 (error at first_completed:-1) else goto L40
L40:
    CPy_RestoreExcInfo(r36)
    dec_ref r36
    r37 = CPy_KeepPropagating()
    if not r37 goto L114 else goto L41 :: bool
L41:
    unreachable
L42:
    r38 = r4.__mypyc_temp__17
    if is_error(r38) goto L133 (error at first_completed:-1) else goto L43
L43:
    r39 = CPyIter_Send(r38, arg)
    dec_ref r38
    dec_ref arg
    if is_error(r39) goto L134 else goto L44
L44:
    r23 = r39
    goto L19
L45:
    r40 = CPy_FetchStopIterationValue()
    if is_error(r40) goto L124 (error at first_completed:78) else goto L46
L46:
    r22 = r40
L47:
    r41 = unbox(tuple[set, set], r22)
    dec_ref r22
    if is_error(r41) goto L124 (error at first_completed:78) else goto L48
L48:
    r42 = box(tuple[set, set], r41)
    r4.__mypyc_next_label__ = -2; r43 = is_error
    dec_ref r4
    if not r43 goto L135 (error at first_completed:78) else goto L49 :: bool
L49:
    CPyGen_SetStopIterationValue(r42)
    dec_ref r42
    if not 0 goto L114 else goto L50 :: bool
L50:
    unreachable
L51:
    r44 = r4.fs
    if is_error(r44) goto L136 (error at first_completed:79) else goto L52
L52:
    r45 = 'FIRST_COMPLETED'
    r46 = dank_mids.helpers._gather.wait :: static
    if is_error(r46) goto L137 else goto L55
L53:
    r47 = raise NameError('value for final name "wait" was not set')
    if not r47 goto L114 (error at first_completed:79) else goto L54 :: bool
L54:
    unreachable
L55:
    r48 = [r44, r45]
    r49 = load_address r48
    r50 = ('return_when',)
    r51 = _PyObject_Vectorcall(r46, r49, 1, r50)
    if is_error(r51) goto L138 (error at first_completed:79) else goto L56
L56:
    dec_ref r44
    r52 = CPy_GetCoro(r51)
    dec_ref r51
    if is_error(r52) goto L136 (error at first_completed:79) else goto L57
L57:
    r4.__mypyc_temp__19 = r52; r53 = is_error
    if not r53 goto L136 (error at first_completed:-1) else goto L58 :: bool
L58:
    r54 = r4.__mypyc_temp__19
    if is_error(r54) goto L136 (error at first_completed:-1) else goto L59
L59:
    r55 = CPyIter_Next(r54)
    dec_ref r54
    if is_error(r55) goto L139 else goto L62
L60:
    r56 = CPy_FetchStopIterationValue()
    if is_error(r56) goto L124 (error at first_completed:79) else goto L61
L61:
    r57 = r56
    goto L91
L62:
    r58 = r55
L63:
    r4.__mypyc_next_label__ = 4; r59 = is_error
    if not r59 goto L140 (error at first_completed:79) else goto L141 :: bool
L64:
    return r58
L65:
    r60 = load_address _Py_NoneStruct
    r61 = type != r60
    if r61 goto L66 else goto L68 :: bool
L66:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L69 (error at first_completed:79) else goto L142 :: bool
L67:
    unreachable
L68:
    inc_ref arg
    goto L86
L69:
    r62 = CPy_CatchError()
    r4.__mypyc_temp__20 = r62; r63 = is_error
    if not r63 goto L143 (error at first_completed:-1) else goto L70 :: bool
L70:
    r64 = load_address r3
    r65 = r4.__mypyc_temp__19
    if is_error(r65) goto L143 (error at first_completed:-1) else goto L71
L71:
    r66 = CPy_YieldFromErrorHandle(r65, r64)
    dec_ref r65
    if is_error(r66) goto L143 (error at first_completed:79) else goto L72
L72:
    if r66 goto L78 else goto L73 :: bool
L73:
    if is_error(r3) goto L74 else goto L76
L74:
    r67 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r67 goto L83 (error at first_completed:-1) else goto L144 :: bool
L75:
    unreachable
L76:
    inc_ref r3
    r58 = r3
    r68 = r4.__mypyc_temp__20
    if is_error(r68) goto L145 (error at first_completed:-1) else goto L77
L77:
    CPy_RestoreExcInfo(r68)
    dec_ref r68
    goto L63
L78:
    if is_error(r3) goto L79 else goto L81
L79:
    r69 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r69 goto L83 (error at first_completed:-1) else goto L146 :: bool
L80:
    unreachable
L81:
    r57 = r3
    r70 = r4.__mypyc_temp__20
    if is_error(r70) goto L147 (error at first_completed:-1) else goto L82
L82:
    CPy_RestoreExcInfo(r70)
    dec_ref r70
    goto L91
L83:
    r71 = r4.__mypyc_temp__20
    dec_ref r4
    if is_error(r71) goto L114 (error at first_completed:-1) else goto L84
L84:
    CPy_RestoreExcInfo(r71)
    dec_ref r71
    r72 = CPy_KeepPropagating()
    if not r72 goto L114 else goto L85 :: bool
L85:
    unreachable
L86:
    r73 = r4.__mypyc_temp__19
    if is_error(r73) goto L148 (error at first_completed:-1) else goto L87
L87:
    r74 = CPyIter_Send(r73, arg)
    dec_ref r73
    dec_ref arg
    if is_error(r74) goto L149 else goto L88
L88:
    r58 = r74
    goto L63
L89:
    r75 = CPy_FetchStopIterationValue()
    if is_error(r75) goto L124 (error at first_completed:79) else goto L90
L90:
    r57 = r75
L91:
    r76 = unbox(tuple[set, set], r57)
    dec_ref r57
    if is_error(r76) goto L124 (error at first_completed:79) else goto L92
L92:
    r77 = borrow r76[0]
    r78 = unborrow r77
    r4.done = r78; r79 = is_error
    if not r79 goto L150 (error at first_completed:79) else goto L93 :: bool
L93:
    r80 = borrow r76[1]
    r81 = unborrow r80
    r4.pending = r81; r82 = is_error
    if not r82 goto L150 (error at first_completed:79) else goto L94 :: bool
L94:
    r83 = r4.pending
    if is_error(r83) goto L124 (error at first_completed:80) else goto L95
L95:
    r84 = PyObject_GetIter(r83)
    if is_error(r84) goto L151 (error at first_completed:80) else goto L96
L96:
    r4.__mypyc_temp__21 = r83; r85 = is_error
    if not r85 goto L152 (error at first_completed:-1) else goto L97 :: bool
L97:
    r4.__mypyc_temp__22 = r84; r86 = is_error
    if not r86 goto L124 (error at first_completed:-1) else goto L98 :: bool
L98:
    r87 = r4.__mypyc_temp__22
    if is_error(r87) goto L124 (error at first_completed:80) else goto L99
L99:
    r88 = PyIter_Next(r87)
    dec_ref r87
    if is_error(r88) goto L104 else goto L100
L100:
    r4.p = r88; r89 = is_error
    if not r89 goto L124 (error at first_completed:80) else goto L101 :: bool
L101:
    r90 = r4.p
    if is_error(r90) goto L124 (error at first_completed:81) else goto L102
L102:
    r91 = 'cancel'
    r92 = [r90]
    r93 = load_address r92
    r94 = PyObject_VectorcallMethod(r91, r93, 9223372036854775809, 0)
    if is_error(r94) goto L153 (error at first_completed:81) else goto L154
L103:
    dec_ref r90
    goto L98
L104:
    r95 = CPy_NoErrOccurred()
    if not r95 goto L124 (error at first_completed:80) else goto L105 :: bool
L105:
    r96 = r4.done
    if is_error(r96) goto L124 (error at first_completed:82) else goto L106
L106:
    r4.__mypyc_next_label__ = -2; r97 = is_error
    dec_ref r4
    if not r97 goto L155 (error at first_completed:82) else goto L107 :: bool
L107:
    CPyGen_SetStopIterationValue(r96)
    dec_ref r96
    if not 0 goto L114 else goto L108 :: bool
L108:
    unreachable
L109:
    r98 = r5 == 0
    if r98 goto L156 else goto L110 :: bool
L110:
    r99 = r5 == 2
    if r99 goto L157 else goto L158 :: bool
L111:
    r100 = r5 == 4
    dec_ref r5 :: int
    if r100 goto L65 else goto L159 :: bool
L112:
    r101 = raise StopIteration
    if not r101 goto L114 (error at first_completed:74) else goto L113 :: bool
L113:
    unreachable
L114:
    r102 = <error> :: object
    return r102
L115:
    xdec_ref r1
    xdec_ref r3
    goto L114
L116:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L114
L117:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L3
L118:
    xdec_ref r1
    goto L51
L119:
    xdec_ref r3
    goto L7
L120:
    xdec_ref r1
    dec_ref r4
    goto L114
L121:
    xdec_ref r1
    dec_ref r4
    dec_ref r9
    goto L9
L122:
    xdec_ref r1
    dec_ref r4
    dec_ref r9
    goto L114
L123:
    xdec_ref r1
    goto L16
L124:
    dec_ref r4
    goto L114
L125:
    dec_ref r23
    goto L25
L126:
    xdec_ref r1
    dec_ref r4
    goto L20
L127:
    xdec_ref r1
    dec_ref r4
    goto L23
L128:
    xdec_ref r1
    goto L39
L129:
    dec_ref r4
    goto L31
L130:
    xdec_ref r1
    dec_ref r23
    goto L39
L131:
    dec_ref r4
    goto L36
L132:
    dec_ref r22
    goto L39
L133:
    xdec_ref r1
    dec_ref r4
    dec_ref arg
    goto L114
L134:
    xdec_ref r1
    goto L45
L135:
    dec_ref r42
    goto L114
L136:
    xdec_ref r3
    dec_ref r4
    goto L114
L137:
    xdec_ref r3
    dec_ref r4
    dec_ref r44
    goto L53
L138:
    xdec_ref r3
    dec_ref r4
    dec_ref r44
    goto L114
L139:
    xdec_ref r3
    goto L60
L140:
    dec_ref r58
    goto L69
L141:
    xdec_ref r3
    dec_ref r4
    goto L64
L142:
    xdec_ref r3
    dec_ref r4
    goto L67
L143:
    xdec_ref r3
    goto L83
L144:
    dec_ref r4
    goto L75
L145:
    xdec_ref r3
    dec_ref r58
    goto L83
L146:
    dec_ref r4
    goto L80
L147:
    dec_ref r57
    goto L83
L148:
    xdec_ref r3
    dec_ref r4
    dec_ref arg
    goto L114
L149:
    xdec_ref r3
    goto L89
L150:
    dec_ref r4
    dec_ref r76
    goto L114
L151:
    dec_ref r4
    dec_ref r83
    goto L114
L152:
    dec_ref r4
    dec_ref r84
    goto L114
L153:
    dec_ref r4
    dec_ref r90
    goto L114
L154:
    dec_ref r94
    goto L103
L155:
    dec_ref r96
    goto L114
L156:
    dec_ref r5 :: int
    goto L2
L157:
    xdec_ref r3
    dec_ref r5 :: int
    goto L21
L158:
    xdec_ref r1
    goto L111
L159:
    xdec_ref r3
    dec_ref r4
    goto L112

def first_completed_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = first_completed_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def first_completed_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = first_completed_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def first_completed_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def first_completed_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = first_completed_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def first_completed_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def first_completed_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._gather.first_completed_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def first_completed(fs, cancel):
    fs :: tuple
    cancel :: bool
    r0 :: dank_mids.helpers._gather.first_completed_env
    r1, r2 :: bool
    r3 :: dank_mids.helpers._gather.first_completed_gen
    r4, r5 :: bool
    r6 :: object
L0:
    if is_error(cancel) goto L1 else goto L2
L1:
    cancel = 0
L2:
    r0 = first_completed_env()
    if is_error(r0) goto L9 (error at first_completed:74) else goto L3
L3:
    inc_ref fs
    r0.fs = fs; r1 = is_error
    if not r1 goto L10 (error at first_completed:74) else goto L4 :: bool
L4:
    r0.cancel = cancel; r2 = is_error
    if not r2 goto L10 (error at first_completed:74) else goto L5 :: bool
L5:
    r3 = first_completed_gen()
    if is_error(r3) goto L10 (error at first_completed:74) else goto L6
L6:
    inc_ref r0
    r3.__mypyc_env__ = r0; r4 = is_error
    if not r4 goto L11 (error at first_completed:74) else goto L7 :: bool
L7:
    r0.__mypyc_next_label__ = 0; r5 = is_error
    dec_ref r0
    if not r5 goto L12 (error at first_completed:74) else goto L8 :: bool
L8:
    return r3
L9:
    r6 = <error> :: object
    return r6
L10:
    dec_ref r0
    goto L9
L11:
    dec_ref r0
    dec_ref r3
    goto L9
L12:
    dec_ref r3
    goto L9

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18 :: object
    r19 :: object_ptr
    r20 :: object_ptr[1]
    r21 :: c_ptr
    r22 :: native_int[1]
    r23 :: c_ptr
    r24 :: object
    r25 :: dict
    r26, r27 :: str
    r28 :: bit
    r29 :: str
    r30 :: dict
    r31 :: str
    r32 :: object
    r33 :: object[1]
    r34 :: object_ptr
    r35 :: object
    r36 :: dict
    r37 :: str
    r38 :: i32
    r39 :: bit
    r40 :: dict
    r41 :: str
    r42 :: object
    r43 :: str
    r44 :: object
    r45 :: dict
    r46 :: str
    r47 :: i32
    r48 :: bit
    r49 :: dict
    r50 :: str
    r51 :: object
    r52 :: str
    r53 :: object
    r54 :: dict
    r55 :: str
    r56 :: i32
    r57 :: bit
    r58 :: object
    r59 :: str
    r60 :: object
    r61 :: dict
    r62 :: str
    r63 :: i32
    r64 :: bit
    r65 :: object
    r66 :: str
    r67 :: object
    r68 :: dict
    r69 :: str
    r70 :: i32
    r71 :: bit
    r72 :: object
    r73 :: str
    r74 :: object
    r75 :: dict
    r76 :: str
    r77 :: i32
    r78 :: bit
    r79 :: dict
    r80 :: str
    r81 :: object
    r82 :: str
    r83 :: object
    r84 :: str
    r85 :: object
    r86 :: dict
    r87 :: str
    r88 :: i32
    r89 :: bit
    r90 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L26 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address asyncio :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('asyncio', 'asyncio', 'asyncio'),)
    r11 = dank_mids.helpers._gather.globals :: static
    r12 = 'dank_mids\\helpers\\_gather.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L26 else goto L4 :: bool
L4:
    r15 = ('Coroutine', 'Final', 'Iterable', 'Literal', 'Optional', 'Set', 'Tuple', 'TypeVar', 'Union', 'overload')
    r16 = 'typing'
    r17 = dank_mids.helpers._gather.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L26 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = load_address a_sync.asyncio :: module
    r20 = [r19]
    r21 = load_address r20
    r22 = [15]
    r23 = load_address r22
    r24 = (('a_sync.asyncio', 'a_sync', 'a_sync'),)
    r25 = dank_mids.helpers._gather.globals :: static
    r26 = 'dank_mids\\helpers\\_gather.py'
    r27 = '<module>'
    r28 = CPyImport_ImportMany(r24, r21, r25, r26, r27, r23)
    if not r28 goto L26 else goto L6 :: bool
L6:
    r29 = '__T'
    r30 = dank_mids.helpers._gather.globals :: static
    r31 = 'TypeVar'
    r32 = CPyDict_GetItem(r30, r31)
    if is_error(r32) goto L26 (error at <module>:18) else goto L7
L7:
    r33 = [r29]
    r34 = load_address r33
    r35 = _PyObject_Vectorcall(r32, r34, 1, 0)
    dec_ref r32
    if is_error(r35) goto L26 (error at <module>:18) else goto L8
L8:
    r36 = dank_mids.helpers._gather.globals :: static
    r37 = '__T'
    r38 = CPyDict_SetItem(r36, r37, r35)
    dec_ref r35
    r39 = r38 >= 0 :: signed
    if not r39 goto L26 (error at <module>:18) else goto L9 :: bool
L9:
    r40 = dank_mids.helpers._gather.globals :: static
    r41 = 'Set'
    r42 = CPyDict_GetItem(r40, r41)
    if is_error(r42) goto L26 (error at <module>:20) else goto L10
L10:
    r43 = 'asyncio.Future[__T]'
    r44 = PyObject_GetItem(r42, r43)
    dec_ref r42
    if is_error(r44) goto L26 (error at <module>:20) else goto L11
L11:
    r45 = dank_mids.helpers._gather.globals :: static
    r46 = 'FinishedTasks'
    r47 = CPyDict_SetItem(r45, r46, r44)
    dec_ref r44
    r48 = r47 >= 0 :: signed
    if not r48 goto L26 (error at <module>:20) else goto L12 :: bool
L12:
    r49 = dank_mids.helpers._gather.globals :: static
    r50 = 'Set'
    r51 = CPyDict_GetItem(r49, r50)
    if is_error(r51) goto L26 (error at <module>:21) else goto L13
L13:
    r52 = 'asyncio.Future[__T]'
    r53 = PyObject_GetItem(r51, r52)
    dec_ref r51
    if is_error(r53) goto L26 (error at <module>:21) else goto L14
L14:
    r54 = dank_mids.helpers._gather.globals :: static
    r55 = 'PendingTasks'
    r56 = CPyDict_SetItem(r54, r55, r53)
    dec_ref r53
    r57 = r56 >= 0 :: signed
    if not r57 goto L26 (error at <module>:21) else goto L15 :: bool
L15:
    r58 = asyncio :: module
    r59 = 'Task'
    r60 = CPyObject_GetAttr(r58, r59)
    if is_error(r60) goto L26 (error at <module>:25) else goto L16
L16:
    dank_mids.helpers._gather.Task = r60 :: static
    r61 = dank_mids.helpers._gather.globals :: static
    r62 = 'Task'
    r63 = CPyDict_SetItem(r61, r62, r60)
    dec_ref r60
    r64 = r63 >= 0 :: signed
    if not r64 goto L26 (error at <module>:25) else goto L17 :: bool
L17:
    r65 = asyncio :: module
    r66 = 'get_running_loop'
    r67 = CPyObject_GetAttr(r65, r66)
    if is_error(r67) goto L26 (error at <module>:26) else goto L18
L18:
    dank_mids.helpers._gather.get_running_loop = r67 :: static
    r68 = dank_mids.helpers._gather.globals :: static
    r69 = 'get_running_loop'
    r70 = CPyDict_SetItem(r68, r69, r67)
    dec_ref r67
    r71 = r70 >= 0 :: signed
    if not r71 goto L26 (error at <module>:26) else goto L19 :: bool
L19:
    r72 = asyncio :: module
    r73 = 'wait'
    r74 = CPyObject_GetAttr(r72, r73)
    if is_error(r74) goto L26 (error at <module>:27) else goto L20
L20:
    dank_mids.helpers._gather.wait = r74 :: static
    r75 = dank_mids.helpers._gather.globals :: static
    r76 = 'wait'
    r77 = CPyDict_SetItem(r75, r76, r74)
    dec_ref r74
    r78 = r77 >= 0 :: signed
    if not r78 goto L26 (error at <module>:27) else goto L21 :: bool
L21:
    r79 = dank_mids.helpers._gather.globals :: static
    r80 = 'a_sync'
    r81 = CPyDict_GetItem(r79, r80)
    if is_error(r81) goto L26 (error at <module>:30) else goto L22
L22:
    r82 = 'asyncio'
    r83 = CPyObject_GetAttr(r81, r82)
    dec_ref r81
    if is_error(r83) goto L26 (error at <module>:30) else goto L23
L23:
    r84 = 'sleep0'
    r85 = CPyObject_GetAttr(r83, r84)
    dec_ref r83
    if is_error(r85) goto L26 (error at <module>:30) else goto L24
L24:
    dank_mids.helpers._gather.yield_to_loop = r85 :: static
    r86 = dank_mids.helpers._gather.globals :: static
    r87 = 'yield_to_loop'
    r88 = CPyDict_SetItem(r86, r87, r85)
    dec_ref r85
    r89 = r88 >= 0 :: signed
    if not r89 goto L26 (error at <module>:30) else goto L25 :: bool
L25:
    return 1
L26:
    r90 = <error> :: None
    return r90

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: object
    r22 :: dict
    r23 :: str
    r24 :: i32
    r25 :: bit
    r26 :: dict
    r27 :: str
    r28 :: object
    r29 :: i32
    r30 :: bit
    r31 :: dict
    r32 :: str
    r33 :: object
    r34 :: i32
    r35 :: bit
    r36 :: dict
    r37 :: str
    r38 :: object
    r39 :: i32
    r40 :: bit
    r41 :: dict
    r42 :: str
    r43 :: object
    r44 :: i32
    r45 :: bit
    r46 :: dict
    r47 :: str
    r48 :: object
    r49 :: i32
    r50 :: bit
    r51 :: dict
    r52 :: str
    r53 :: object
    r54 :: i32
    r55 :: bit
    r56 :: dict
    r57 :: str
    r58 :: object
    r59 :: i32
    r60 :: bit
    r61 :: dict
    r62 :: str
    r63 :: object
    r64 :: i32
    r65 :: bit
    r66 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L16 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address logging :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('logging', 'logging', 'logging'),)
    r11 = dank_mids._logging.globals :: static
    r12 = 'dank_mids\\_logging.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L16 else goto L4 :: bool
L4:
    r15 = ('Final',)
    r16 = 'typing'
    r17 = dank_mids._logging.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L16 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = logging :: module
    r20 = 'getLogger'
    r21 = CPyObject_GetAttr(r19, r20)
    if is_error(r21) goto L16 (error at <module>:5) else goto L6
L6:
    dank_mids._logging.getLogger = r21 :: static
    r22 = dank_mids._logging.globals :: static
    r23 = 'getLogger'
    r24 = CPyDict_SetItem(r22, r23, r21)
    dec_ref r21
    r25 = r24 >= 0 :: signed
    if not r25 goto L16 (error at <module>:5) else goto L7 :: bool
L7:
    dank_mids._logging.CRITICAL = 100 :: static
    r26 = dank_mids._logging.globals :: static
    r27 = 'CRITICAL'
    r28 = object 50
    r29 = CPyDict_SetItem(r26, r27, r28)
    r30 = r29 >= 0 :: signed
    if not r30 goto L16 (error at <module>:6) else goto L8 :: bool
L8:
    dank_mids._logging.FATAL = 100 :: static
    r31 = dank_mids._logging.globals :: static
    r32 = 'FATAL'
    r33 = object 50
    r34 = CPyDict_SetItem(r31, r32, r33)
    r35 = r34 >= 0 :: signed
    if not r35 goto L16 (error at <module>:7) else goto L9 :: bool
L9:
    dank_mids._logging.ERROR = 80 :: static
    r36 = dank_mids._logging.globals :: static
    r37 = 'ERROR'
    r38 = object 40
    r39 = CPyDict_SetItem(r36, r37, r38)
    r40 = r39 >= 0 :: signed
    if not r40 goto L16 (error at <module>:8) else goto L10 :: bool
L10:
    dank_mids._logging.WARN = 60 :: static
    r41 = dank_mids._logging.globals :: static
    r42 = 'WARN'
    r43 = object 30
    r44 = CPyDict_SetItem(r41, r42, r43)
    r45 = r44 >= 0 :: signed
    if not r45 goto L16 (error at <module>:9) else goto L11 :: bool
L11:
    dank_mids._logging.WARNING = 60 :: static
    r46 = dank_mids._logging.globals :: static
    r47 = 'WARNING'
    r48 = object 30
    r49 = CPyDict_SetItem(r46, r47, r48)
    r50 = r49 >= 0 :: signed
    if not r50 goto L16 (error at <module>:10) else goto L12 :: bool
L12:
    dank_mids._logging.INFO = 40 :: static
    r51 = dank_mids._logging.globals :: static
    r52 = 'INFO'
    r53 = object 20
    r54 = CPyDict_SetItem(r51, r52, r53)
    r55 = r54 >= 0 :: signed
    if not r55 goto L16 (error at <module>:11) else goto L13 :: bool
L13:
    dank_mids._logging.DEBUG = 20 :: static
    r56 = dank_mids._logging.globals :: static
    r57 = 'DEBUG'
    r58 = object 10
    r59 = CPyDict_SetItem(r56, r57, r58)
    r60 = r59 >= 0 :: signed
    if not r60 goto L16 (error at <module>:12) else goto L14 :: bool
L14:
    dank_mids._logging.NOTSET = 0 :: static
    r61 = dank_mids._logging.globals :: static
    r62 = 'NOTSET'
    r63 = object 0
    r64 = CPyDict_SetItem(r61, r62, r63)
    r65 = r64 >= 0 :: signed
    if not r65 goto L16 (error at <module>:13) else goto L15 :: bool
L15:
    return 1
L16:
    r66 = <error> :: None
    return r66

def WeakList.__init__(self, data):
    self :: dank_mids.helpers._weaklist.WeakList
    data :: union[object, None]
    r0 :: object
    r1 :: dict
    r2 :: bool
    r3 :: object
    r4 :: bit
    r5, r6 :: None
L0:
    if is_error(data) goto L1 else goto L8
L1:
    r0 = box(None, 1)
    inc_ref r0
    data = r0
L2:
    r1 = PyDict_New()
    if is_error(r1) goto L9 (error at __init__:18) else goto L3
L3:
    self._refs = r1; r2 = is_error
    if not r2 goto L9 (error at __init__:18) else goto L4 :: bool
L4:
    r3 = load_address _Py_NoneStruct
    r4 = data != r3
    if r4 goto L5 else goto L10 :: bool
L5:
    r5 = self.extend(data)
    dec_ref data
    if is_error(r5) goto L7 (error at __init__:20) else goto L6
L6:
    return 1
L7:
    r6 = <error> :: None
    return r6
L8:
    inc_ref data
    goto L2
L9:
    dec_ref data
    goto L7
L10:
    dec_ref data
    goto L6

def WeakList.__repr__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: object
    r1 :: str
    r2 :: object
    r3, r4, r5 :: str
    r6 :: object
    r7 :: str
    r8, r9 :: object
    r10 :: str
    r11 :: object
    r12 :: object[2]
    r13 :: object_ptr
    r14 :: object
    r15, r16, r17, r18 :: str
L0:
    r0 = PyObject_Type(self)
    r1 = '__name__'
    r2 = CPyObject_GetAttr(r0, r1)
    dec_ref r0
    if is_error(r2) goto L8 (error at __repr__:24) else goto L1
L1:
    r3 = cast(str, r2)
    if is_error(r3) goto L8 (error at __repr__:24) else goto L2
L2:
    r4 = '(['
    r5 = ', '
    r6 = builtins :: module
    r7 = 'repr'
    r8 = CPyObject_GetAttr(r6, r7)
    if is_error(r8) goto L9 (error at __repr__:24) else goto L3
L3:
    r9 = builtins :: module
    r10 = 'map'
    r11 = CPyObject_GetAttr(r9, r10)
    if is_error(r11) goto L10 (error at __repr__:24) else goto L4
L4:
    r12 = [r8, self]
    r13 = load_address r12
    r14 = _PyObject_Vectorcall(r11, r13, 2, 0)
    dec_ref r11
    if is_error(r14) goto L10 (error at __repr__:24) else goto L5
L5:
    dec_ref r8
    r15 = PyUnicode_Join(r5, r14)
    dec_ref r14
    if is_error(r15) goto L9 (error at __repr__:24) else goto L6
L6:
    r16 = '])'
    r17 = CPyStr_Build(4, r3, r4, r15, r16)
    dec_ref r3
    dec_ref r15
    if is_error(r17) goto L8 (error at __repr__:24) else goto L7
L7:
    return r17
L8:
    r18 = <error> :: str
    return r18
L9:
    dec_ref r3
    goto L8
L10:
    dec_ref r3
    dec_ref r8
    goto L8

def WeakList.__len__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: dict
    r1 :: native_int
    r2 :: short_int
    r3 :: int
L0:
    r0 = self._refs
    if is_error(r0) goto L2 (error at __len__:27) else goto L1
L1:
    r1 = PyDict_Size(r0)
    dec_ref r0
    r2 = r1 << 1
    return r2
L2:
    r3 = <error> :: int
    return r3

def WeakList.__bool__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: object
    r1 :: str
    r2 :: object
    r3 :: object[1]
    r4 :: object_ptr
    r5 :: object
    r6, r7 :: bool
L0:
    r0 = builtins :: module
    r1 = 'any'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L4 (error at __bool__:30) else goto L1
L1:
    r3 = [self]
    r4 = load_address r3
    r5 = _PyObject_Vectorcall(r2, r4, 1, 0)
    dec_ref r2
    if is_error(r5) goto L4 (error at __bool__:30) else goto L2
L2:
    r6 = unbox(bool, r5)
    dec_ref r5
    if is_error(r6) goto L4 (error at __bool__:30) else goto L3
L3:
    return r6
L4:
    r7 = <error> :: bool
    return r7

def WeakList.__contains__(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: dict
    r1 :: int
    r2, r3 :: object
    ref :: union[object, None]
    r4 :: object
    r5 :: bit
    r6 :: bool
    r7 :: object
    r8 :: bit
    r9 :: bool
L0:
    r0 = self._refs
    if is_error(r0) goto L7 (error at __contains__:33) else goto L1
L1:
    r1 = CPyTagged_Id(item)
    r2 = box(int, r1)
    r3 = CPyDict_GetWithNone(r0, r2)
    dec_ref r0
    dec_ref r2
    if is_error(r3) goto L7 (error at __contains__:33) else goto L2
L2:
    ref = r3
    r4 = load_address _Py_NoneStruct
    r5 = ref == r4
    if r5 goto L8 else goto L4 :: bool
L3:
    r6 = 0
    goto L6
L4:
    r7 = _PyObject_Vectorcall(ref, 0, 0, 0)
    dec_ref ref
    if is_error(r7) goto L7 (error at __contains__:34) else goto L5
L5:
    r8 = r7 == item
    dec_ref r7
    r6 = r8
L6:
    return r6
L7:
    r9 = <error> :: bool
    return r9
L8:
    dec_ref ref
    goto L3

def __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    type, value, traceback, arg :: object
    r0 :: dank_mids.helpers._weaklist.__iter___WeakList_env
    r1 :: int
    r2 :: object
    r3 :: bit
    r4 :: dank_mids.helpers._weaklist.WeakList
    r5 :: dict
    r6, r7 :: bool
    r8 :: dict
    r9 :: native_int
    r10 :: short_int
    r11 :: bool
    r12 :: object
    r13 :: bool
    r14 :: object
    r15 :: short_int
    r16 :: tuple[bool, short_int, object]
    r17 :: short_int
    r18, r19 :: bool
    r20 :: object
    r21 :: bool
    r22, r23 :: object
    r24 :: bit
    r25, r26 :: object
    r27 :: bool
    r28 :: object[1]
    r29 :: object_ptr
    r30 :: object
    r31 :: bool
    r32 :: union[object, None]
    r33 :: object
    r34 :: bit
    r35 :: union[object, None]
    r36 :: bool
    r37 :: object
    r38 :: bit
    r39 :: dict
    r40 :: short_int
    r41, r42 :: bit
    r43 :: object
    r44 :: bool
    r45, r46 :: bit
    r47 :: bool
    r48 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L45 (error at __iter__:36) else goto L1
L1:
    r1 = r0.__mypyc_next_label__
    if is_error(r1) goto L46 (error at __iter__:36) else goto L41
L2:
    r2 = load_address _Py_NoneStruct
    r3 = type != r2
    if r3 goto L47 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L45 (error at __iter__:36) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = r0.self
    if is_error(r4) goto L46 (error at __iter__:37) else goto L6
L6:
    r5 = r4._refs
    dec_ref r4
    if is_error(r5) goto L46 (error at __iter__:37) else goto L7
L7:
    inc_ref r5
    r0.__mypyc_temp__0 = r5; r6 = is_error
    if not r6 goto L48 (error at __iter__:-1) else goto L8 :: bool
L8:
    r0.__mypyc_temp__1 = 0; r7 = is_error
    if not r7 goto L48 (error at __iter__:-1) else goto L9 :: bool
L9:
    r8 = r0.__mypyc_temp__0
    if is_error(r8) goto L48 (error at __iter__:37) else goto L10
L10:
    r9 = PyDict_Size(r8)
    dec_ref r8
    r10 = r9 << 1
    r0.__mypyc_temp__2 = r10; r11 = is_error
    if not r11 goto L48 (error at __iter__:-1) else goto L11 :: bool
L11:
    r12 = CPyDict_GetValuesIter(r5)
    dec_ref r5
    if is_error(r12) goto L46 (error at __iter__:37) else goto L12
L12:
    r0.__mypyc_temp__3 = r12; r13 = is_error
    if not r13 goto L46 (error at __iter__:-1) else goto L13 :: bool
L13:
    r14 = r0.__mypyc_temp__3
    if is_error(r14) goto L46 (error at __iter__:37) else goto L14
L14:
    r15 = r0.__mypyc_temp__1
    if is_error(r15) goto L49 (error at __iter__:37) else goto L15
L15:
    r16 = CPyDict_NextValue(r14, r15)
    dec_ref r14
    r17 = r16[1]
    r0.__mypyc_temp__1 = r17; r18 = is_error
    if not r18 goto L50 (error at __iter__:37) else goto L16 :: bool
L16:
    r19 = r16[0]
    if r19 goto L17 else goto L51 :: bool
L17:
    r20 = r16[2]
    dec_ref r16
    r0.r = r20; r21 = is_error
    if not r21 goto L46 (error at __iter__:37) else goto L18 :: bool
L18:
    r22 = r0.r
    if is_error(r22) goto L46 (error at __iter__:38) else goto L19
L19:
    r23 = load_address _Py_NoneStruct
    r24 = r22 != r23
    dec_ref r22
    if r24 goto L20 else goto L34 :: bool
L20:
    r25 = r0.r
    if is_error(r25) goto L46 (error at __iter__:39) else goto L21
L21:
    r26 = dank_mids.helpers._weaklist._call_ref :: static
    if is_error(r26) goto L52 else goto L24
L22:
    r27 = raise NameError('value for final name "_call_ref" was not set')
    if not r27 goto L45 (error at __iter__:39) else goto L23 :: bool
L23:
    unreachable
L24:
    r28 = [r25]
    r29 = load_address r28
    r30 = _PyObject_Vectorcall(r26, r29, 1, 0)
    if is_error(r30) goto L53 (error at __iter__:39) else goto L25
L25:
    dec_ref r25
    r0.obj = r30; r31 = is_error
    if not r31 goto L46 (error at __iter__:39) else goto L26 :: bool
L26:
    r32 = r0.obj
    if is_error(r32) goto L46 (error at __iter__:40) else goto L27
L27:
    r33 = load_address _Py_NoneStruct
    r34 = r32 != r33
    dec_ref r32
    if r34 goto L28 else goto L34 :: bool
L28:
    r35 = r0.obj
    if is_error(r35) goto L46 (error at __iter__:41) else goto L29
L29:
    r0.__mypyc_next_label__ = 2; r36 = is_error
    dec_ref r0
    if not r36 goto L54 (error at __iter__:41) else goto L30 :: bool
L30:
    return r35
L31:
    r37 = load_address _Py_NoneStruct
    r38 = type != r37
    if r38 goto L55 else goto L34 :: bool
L32:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L45 (error at __iter__:41) else goto L33 :: bool
L33:
    unreachable
L34:
    r39 = r0.__mypyc_temp__0
    if is_error(r39) goto L46 (error at __iter__:37) else goto L35
L35:
    r40 = r0.__mypyc_temp__2
    if is_error(r40) goto L56 (error at __iter__:37) else goto L36
L36:
    r41 = CPyDict_CheckSize(r39, r40)
    dec_ref r39
    if not r41 goto L46 (error at __iter__:37) else goto L13 :: bool
L37:
    r42 = CPy_NoErrOccurred()
    if not r42 goto L46 (error at __iter__:37) else goto L38 :: bool
L38:
    r43 = box(None, 1)
    r0.__mypyc_next_label__ = -2; r44 = is_error
    dec_ref r0
    if not r44 goto L45 (error at __iter__:36) else goto L39 :: bool
L39:
    CPyGen_SetStopIterationValue(r43)
    if not 0 goto L45 else goto L40 :: bool
L40:
    unreachable
L41:
    r45 = r1 == 0
    if r45 goto L57 else goto L42 :: bool
L42:
    r46 = r1 == 2
    dec_ref r1 :: int
    if r46 goto L31 else goto L58 :: bool
L43:
    r47 = raise StopIteration
    if not r47 goto L45 (error at __iter__:36) else goto L44 :: bool
L44:
    unreachable
L45:
    r48 = <error> :: object
    return r48
L46:
    dec_ref r0
    goto L45
L47:
    dec_ref r0
    goto L3
L48:
    dec_ref r0
    dec_ref r5
    goto L45
L49:
    dec_ref r0
    dec_ref r14
    goto L45
L50:
    dec_ref r0
    dec_ref r16
    goto L45
L51:
    dec_ref r16
    goto L37
L52:
    dec_ref r0
    dec_ref r25
    goto L22
L53:
    dec_ref r0
    dec_ref r25
    goto L45
L54:
    dec_ref r35
    goto L45
L55:
    dec_ref r0
    goto L32
L56:
    dec_ref r0
    dec_ref r39
    goto L45
L57:
    dec_ref r1 :: int
    goto L2
L58:
    dec_ref r0
    goto L43

def __iter___WeakList_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __iter___WeakList_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def __iter___WeakList_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def __iter___WeakList_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = __iter___WeakList_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def __iter___WeakList_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def WeakList.__iter__(self):
    self :: dank_mids.helpers._weaklist.WeakList
    r0 :: dank_mids.helpers._weaklist.__iter___WeakList_env
    r1 :: bool
    r2 :: dank_mids.helpers._weaklist.__iter___WeakList_gen
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = __iter___WeakList_env()
    if is_error(r0) goto L6 (error at __iter__:36) else goto L1
L1:
    inc_ref self
    r0.self = self; r1 = is_error
    if not r1 goto L7 (error at __iter__:36) else goto L2 :: bool
L2:
    r2 = __iter___WeakList_gen()
    if is_error(r2) goto L7 (error at __iter__:36) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L8 (error at __iter__:36) else goto L4 :: bool
L4:
    r0.__mypyc_next_label__ = 0; r4 = is_error
    dec_ref r0
    if not r4 goto L9 (error at __iter__:36) else goto L5 :: bool
L5:
    return r2
L6:
    r5 = <error> :: object
    return r5
L7:
    dec_ref r0
    goto L6
L8:
    dec_ref r0
    dec_ref r2
    goto L6
L9:
    dec_ref r2
    goto L6

def WeakList.append(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: str
    r1, r2 :: object
    r3 :: bool
    r4 :: object[2]
    r5 :: object_ptr
    r6 :: object
    r7 :: dict
    r8 :: int
    r9 :: object
    r10 :: i32
    r11 :: bit
    r12 :: None
L0:
    r0 = '_gc_callback'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L8 (error at append:45) else goto L1
L1:
    r2 = dank_mids.helpers._weaklist.ref :: static
    if is_error(r2) goto L9 else goto L4
L2:
    r3 = raise NameError('value for final name "ref" was not set')
    if not r3 goto L8 (error at append:45) else goto L3 :: bool
L3:
    unreachable
L4:
    r4 = [item, r1]
    r5 = load_address r4
    r6 = _PyObject_Vectorcall(r2, r5, 2, 0)
    if is_error(r6) goto L10 (error at append:45) else goto L5
L5:
    dec_ref r1
    r7 = self._refs
    if is_error(r7) goto L11 (error at append:45) else goto L6
L6:
    r8 = CPyTagged_Id(item)
    r9 = box(int, r8)
    r10 = CPyDict_SetItem(r7, r9, r6)
    dec_ref r7
    dec_ref r9
    dec_ref r6
    r11 = r10 >= 0 :: signed
    if not r11 goto L8 (error at append:45) else goto L7 :: bool
L7:
    return 1
L8:
    r12 = <error> :: None
    return r12
L9:
    dec_ref r1
    goto L2
L10:
    dec_ref r1
    goto L8
L11:
    dec_ref r6
    goto L8

def WeakList.extend(self, items):
    self :: dank_mids.helpers._weaklist.WeakList
    items :: object
    r0 :: str
    r1 :: object
    r2 :: dict
    r3 :: list
    r4, r5 :: object
    r6 :: int
    r7 :: object
    r8 :: bool
    r9 :: object[2]
    r10 :: object_ptr
    r11 :: object
    r12 :: tuple[int, object]
    r13 :: object
    r14 :: i32
    r15, r16 :: bit
    r17 :: i32
    r18 :: bit
    r19 :: None
L0:
    r0 = '_gc_callback'
    r1 = CPyObject_GetAttr(self, r0)
    if is_error(r1) goto L13 (error at extend:48) else goto L1
L1:
    r2 = self._refs
    if is_error(r2) goto L14 (error at extend:49) else goto L2
L2:
    r3 = PyList_New(0)
    if is_error(r3) goto L15 (error at extend:49) else goto L3
L3:
    r4 = PyObject_GetIter(items)
    if is_error(r4) goto L16 (error at extend:49) else goto L4
L4:
    r5 = PyIter_Next(r4)
    if is_error(r5) goto L17 else goto L5
L5:
    r6 = CPyTagged_Id(r5)
    r7 = dank_mids.helpers._weaklist.ref :: static
    if is_error(r7) goto L18 else goto L8
L6:
    r8 = raise NameError('value for final name "ref" was not set')
    if not r8 goto L13 (error at extend:49) else goto L7 :: bool
L7:
    unreachable
L8:
    r9 = [r5, r1]
    r10 = load_address r9
    r11 = _PyObject_Vectorcall(r7, r10, 2, 0)
    if is_error(r11) goto L19 (error at extend:49) else goto L9
L9:
    dec_ref r5
    r12 = (r6, r11)
    r13 = box(tuple[int, object], r12)
    r14 = PyList_Append(r3, r13)
    dec_ref r13
    r15 = r14 >= 0 :: signed
    if not r15 goto L20 (error at extend:49) else goto L4 :: bool
L10:
    r16 = CPy_NoErrOccurred()
    if not r16 goto L21 (error at extend:49) else goto L11 :: bool
L11:
    r17 = CPyDict_UpdateFromAny(r2, r3)
    dec_ref r2
    dec_ref r3
    r18 = r17 >= 0 :: signed
    if not r18 goto L13 (error at extend:49) else goto L12 :: bool
L12:
    return 1
L13:
    r19 = <error> :: None
    return r19
L14:
    dec_ref r1
    goto L13
L15:
    dec_ref r1
    dec_ref r2
    goto L13
L16:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    goto L13
L17:
    dec_ref r1
    dec_ref r4
    goto L10
L18:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    dec_ref r5
    dec_ref r6 :: int
    goto L6
L19:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    dec_ref r5
    dec_ref r6 :: int
    goto L13
L20:
    dec_ref r1
    dec_ref r2
    dec_ref r3
    dec_ref r4
    goto L13
L21:
    dec_ref r2
    dec_ref r3
    goto L13

def WeakList.remove(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: int
    r1 :: dict
    r2, r3 :: object
    ref :: union[object, None]
    r4 :: object
    r5 :: bit
    r6 :: object
    r7, r8 :: bit
    r9 :: str
    r10 :: object
    r11 :: str
    r12 :: object
    r13 :: object[1]
    r14 :: object_ptr
    r15 :: object
    r16 :: dict
    r17 :: object
    r18 :: i32
    r19 :: bit
    r20 :: None
L0:
    r0 = CPyTagged_Id(item)
    r1 = self._refs
    if is_error(r1) goto L13 (error at remove:53) else goto L1
L1:
    inc_ref r0 :: int
    r2 = box(int, r0)
    r3 = CPyDict_GetWithNone(r1, r2)
    dec_ref r1
    dec_ref r2
    if is_error(r3) goto L13 (error at remove:53) else goto L2
L2:
    ref = r3
    r4 = load_address _Py_NoneStruct
    r5 = ref == r4
    if r5 goto L14 else goto L3 :: bool
L3:
    r6 = _PyObject_Vectorcall(ref, 0, 0, 0)
    dec_ref ref
    if is_error(r6) goto L13 (error at remove:54) else goto L4
L4:
    r7 = r6 == item
    dec_ref r6
    r8 = r7 ^ 1
    if r8 goto L15 else goto L9 :: bool
L5:
    r9 = 'list.remove(x): x not in list'
    r10 = builtins :: module
    r11 = 'ValueError'
    r12 = CPyObject_GetAttr(r10, r11)
    if is_error(r12) goto L12 (error at remove:55) else goto L6
L6:
    r13 = [r9]
    r14 = load_address r13
    r15 = _PyObject_Vectorcall(r12, r14, 1, 0)
    dec_ref r12
    if is_error(r15) goto L12 (error at remove:55) else goto L7
L7:
    CPy_Raise(r15)
    dec_ref r15
    if not 0 goto L12 (error at remove:55) else goto L8 :: bool
L8:
    unreachable
L9:
    r16 = self._refs
    if is_error(r16) goto L13 (error at remove:56) else goto L10
L10:
    r17 = box(int, r0)
    r18 = PyObject_DelItem(r16, r17)
    dec_ref r16
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L12 (error at remove:56) else goto L11 :: bool
L11:
    return 1
L12:
    r20 = <error> :: None
    return r20
L13:
    dec_ref r0 :: int
    goto L12
L14:
    dec_ref r0 :: int
    dec_ref ref
    goto L5
L15:
    dec_ref r0 :: int
    goto L5

def WeakList._gc_callback(self, item):
    self :: dank_mids.helpers._weaklist.WeakList
    item :: object
    r0 :: dict
    r1 :: int
    r2 :: str
    r3, r4 :: object
    r5 :: object[3]
    r6 :: object_ptr
    r7 :: object
    r8 :: None
L0:
    r0 = self._refs
    if is_error(r0) goto L3 (error at _gc_callback:60) else goto L1
L1:
    r1 = CPyTagged_Id(item)
    r2 = 'pop'
    r3 = box(int, r1)
    r4 = box(None, 1)
    r5 = [r0, r3, r4]
    r6 = load_address r5
    r7 = PyObject_VectorcallMethod(r2, r6, 9223372036854775811, 0)
    if is_error(r7) goto L4 (error at _gc_callback:60) else goto L5
L2:
    dec_ref r0
    dec_ref r3
    return 1
L3:
    r8 = <error> :: None
    return r8
L4:
    dec_ref r0
    dec_ref r3
    goto L3
L5:
    dec_ref r7
    goto L2

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18 :: object
    r19 :: str
    r20 :: dict
    r21 :: str
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: dict
    r34 :: str
    r35 :: i32
    r36 :: bit
    r37 :: dict
    r38 :: str
    r39 :: object
    r40 :: dict
    r41 :: str
    r42 :: object
    r43 :: list
    r44, r45 :: ptr
    r46 :: object
    r47 :: tuple[list, object]
    r48, r49 :: object
    r50 :: dict
    r51 :: str
    r52 :: i32
    r53 :: bit
    r54 :: object
    r55 :: str
    r56 :: object
    r57 :: dict
    r58 :: str
    r59 :: i32
    r60 :: bit
    r61 :: object
    r62 :: str
    r63 :: object
    r64 :: str
    r65 :: object
    r66 :: dict
    r67 :: str
    r68 :: i32
    r69 :: bit
    r70 :: dict
    r71 :: str
    r72 :: object
    r73 :: dict
    r74 :: str
    r75, r76 :: object
    r77 :: tuple
    r78 :: str
    r79, r80 :: object
    r81 :: bool
    r82, r83, r84 :: str
    r85 :: tuple
    r86 :: i32
    r87 :: bit
    r88 :: dict
    r89 :: str
    r90 :: i32
    r91 :: bit
    r92 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L30 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address weakref :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [1]
    r9 = load_address r8
    r10 = (('weakref', 'weakref', 'weakref'),)
    r11 = dank_mids.helpers._weaklist.globals :: static
    r12 = 'dank_mids\\helpers\\_weaklist.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L30 else goto L4 :: bool
L4:
    r15 = ('Any', 'Callable', 'Dict', 'Final', 'Generic', 'Iterable', 'Iterator', 'Optional', 'TypeVar', 'final')
    r16 = 'typing'
    r17 = dank_mids.helpers._weaklist.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L30 (error at <module>:2) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = '_T'
    r20 = dank_mids.helpers._weaklist.globals :: static
    r21 = 'TypeVar'
    r22 = CPyDict_GetItem(r20, r21)
    if is_error(r22) goto L30 (error at <module>:5) else goto L6
L6:
    r23 = [r19]
    r24 = load_address r23
    r25 = _PyObject_Vectorcall(r22, r24, 1, 0)
    dec_ref r22
    if is_error(r25) goto L30 (error at <module>:5) else goto L7
L7:
    r26 = dank_mids.helpers._weaklist.globals :: static
    r27 = '_T'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L30 (error at <module>:5) else goto L8 :: bool
L8:
    r30 = weakref :: module
    r31 = 'ReferenceType'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L30 (error at <module>:7) else goto L9
L9:
    r33 = dank_mids.helpers._weaklist.globals :: static
    r34 = 'Ref'
    r35 = CPyDict_SetItem(r33, r34, r32)
    dec_ref r32
    r36 = r35 >= 0 :: signed
    if not r36 goto L30 (error at <module>:7) else goto L10 :: bool
L10:
    r37 = dank_mids.helpers._weaklist.globals :: static
    r38 = 'Callable'
    r39 = CPyDict_GetItem(r37, r38)
    if is_error(r39) goto L30 (error at <module>:8) else goto L11
L11:
    r40 = dank_mids.helpers._weaklist.globals :: static
    r41 = 'Any'
    r42 = CPyDict_GetItem(r40, r41)
    if is_error(r42) goto L31 (error at <module>:8) else goto L12
L12:
    r43 = PyList_New(1)
    if is_error(r43) goto L32 (error at <module>:8) else goto L13
L13:
    r44 = get_element_ptr r43 ob_item :: PyListObject
    r45 = load_mem r44 :: ptr*
    set_mem r45, r42 :: builtins.object*
    r46 = box(None, 1)
    inc_ref r46
    r47 = (r43, r46)
    r48 = box(tuple[list, object], r47)
    r49 = PyObject_GetItem(r39, r48)
    dec_ref r39
    dec_ref r48
    if is_error(r49) goto L30 (error at <module>:8) else goto L14
L14:
    r50 = dank_mids.helpers._weaklist.globals :: static
    r51 = 'GCCallback'
    r52 = CPyDict_SetItem(r50, r51, r49)
    dec_ref r49
    r53 = r52 >= 0 :: signed
    if not r53 goto L30 (error at <module>:8) else goto L15 :: bool
L15:
    r54 = weakref :: module
    r55 = 'ref'
    r56 = CPyObject_GetAttr(r54, r55)
    if is_error(r56) goto L30 (error at <module>:10) else goto L16
L16:
    dank_mids.helpers._weaklist.ref = r56 :: static
    r57 = dank_mids.helpers._weaklist.globals :: static
    r58 = 'ref'
    r59 = CPyDict_SetItem(r57, r58, r56)
    dec_ref r56
    r60 = r59 >= 0 :: signed
    if not r60 goto L30 (error at <module>:10) else goto L17 :: bool
L17:
    r61 = weakref :: module
    r62 = 'ref'
    r63 = CPyObject_GetAttr(r61, r62)
    if is_error(r63) goto L30 (error at <module>:11) else goto L18
L18:
    r64 = '__call__'
    r65 = CPyObject_GetAttr(r63, r64)
    dec_ref r63
    if is_error(r65) goto L30 (error at <module>:11) else goto L19
L19:
    dank_mids.helpers._weaklist._call_ref = r65 :: static
    r66 = dank_mids.helpers._weaklist.globals :: static
    r67 = '_call_ref'
    r68 = CPyDict_SetItem(r66, r67, r65)
    dec_ref r65
    r69 = r68 >= 0 :: signed
    if not r69 goto L30 (error at <module>:11) else goto L20 :: bool
L20:
    r70 = dank_mids.helpers._weaklist.globals :: static
    r71 = 'Generic'
    r72 = CPyDict_GetItem(r70, r71)
    if is_error(r72) goto L30 (error at <module>:15) else goto L21
L21:
    r73 = dank_mids.helpers._weaklist.globals :: static
    r74 = '_T'
    r75 = CPyDict_GetItem(r73, r74)
    if is_error(r75) goto L33 (error at <module>:15) else goto L22
L22:
    r76 = PyObject_GetItem(r72, r75)
    dec_ref r72
    dec_ref r75
    if is_error(r76) goto L30 (error at <module>:15) else goto L23
L23:
    r77 = PyTuple_Pack(1, r76)
    dec_ref r76
    if is_error(r77) goto L30 (error at <module>:15) else goto L24
L24:
    r78 = 'dank_mids.helpers._weaklist'
    r79 = dank_mids.helpers._weaklist.WeakList_template :: type
    r80 = CPyType_FromTemplate(r79, r77, r78)
    dec_ref r77
    if is_error(r80) goto L30 (error at <module>:15) else goto L25
L25:
    r81 = WeakList_trait_vtable_setup()
    if is_error(r81) goto L34 (error at <module>:-1) else goto L26
L26:
    r82 = '__mypyc_attrs__'
    r83 = '_refs'
    r84 = '__dict__'
    r85 = PyTuple_Pack(2, r83, r84)
    if is_error(r85) goto L34 (error at <module>:15) else goto L27
L27:
    r86 = PyObject_SetAttr(r80, r82, r85)
    dec_ref r85
    r87 = r86 >= 0 :: signed
    if not r87 goto L34 (error at <module>:15) else goto L28 :: bool
L28:
    dank_mids.helpers._weaklist.WeakList = r80 :: type
    r88 = dank_mids.helpers._weaklist.globals :: static
    r89 = 'WeakList'
    r90 = CPyDict_SetItem(r88, r89, r80)
    dec_ref r80
    r91 = r90 >= 0 :: signed
    if not r91 goto L30 (error at <module>:15) else goto L29 :: bool
L29:
    return 1
L30:
    r92 = <error> :: None
    return r92
L31:
    dec_ref r39
    goto L30
L32:
    dec_ref r39
    dec_ref r42
    goto L30
L33:
    dec_ref r72
    goto L30
L34:
    dec_ref r80
    goto L30

def coroutine__patch_overloaded_method_obj.__get__(__mypyc_self__, instance, owner):
    __mypyc_self__, instance, owner, r0 :: object
    r1 :: bit
    r2, r3 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = instance == r0
    if r1 goto L1 else goto L2 :: bool
L1:
    inc_ref __mypyc_self__
    return __mypyc_self__
L2:
    r2 = PyMethod_New(__mypyc_self__, instance)
    if is_error(r2) goto L4 else goto L3
L3:
    return r2
L4:
    r3 = <error> :: object
    return r3

def coroutine__patch_overloaded_method_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    type, value, traceback, arg, r0, r1 :: object
    r2 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_env
    r3 :: int
    r4 :: dank_mids.brownie_patch.overloaded._patch_overloaded_method_env
    r5 :: object
    r6 :: bit
    r7 :: object
    r8 :: tuple
    r9 :: str
    r10 :: object[2]
    r11 :: object_ptr
    r12 :: object
    r13 :: bool
    r14 :: tuple[object, object, object]
    r15 :: bool
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: bit
    r20 :: object
    r21 :: bool
    r22 :: object
    r23 :: str
    r24 :: bool
    r25 :: str
    r26 :: object
    r27 :: str
    r28 :: object
    r29, r30, r31 :: str
    r32 :: object
    r33 :: str
    r34 :: object
    r35, r36 :: str
    r37 :: tuple[str, str]
    r38, r39 :: bool
    r40 :: tuple[str, str]
    r41, r42 :: object
    r43, r44 :: bool
    r45, r46 :: object
    r47 :: str
    r48 :: bool
    r49, r50 :: str
    r51 :: i32
    r52 :: bit
    r53, r54 :: bool
    r55 :: bit
    r56, r57, r58 :: str
    r59 :: object[2]
    r60 :: object_ptr
    r61 :: object
    r62 :: int
    r63 :: bool
    r64 :: str
    r65 :: int
    r66 :: object
    r67, r68, r69 :: str
    r70 :: int
    r71 :: object
    r72, r73 :: str
    r74 :: object
    r75 :: str
    r76 :: object
    r77 :: object[1]
    r78 :: object_ptr
    r79 :: object
    r80 :: tuple[object, object, object]
    r81 :: bit
    r82 :: str
    r83 :: union[int, str, bytes, None]
    r84 :: str
    r85 :: union[int, None]
    r86 :: str
    r87 :: union[dict, None]
    r88 :: dict
    r89 :: bool
    r90 :: dict
    r91 :: bool
    r92 :: dict
    r93, r94 :: bool
    r95 :: dict
    r96 :: native_int
    r97 :: short_int
    r98 :: bool
    r99 :: object
    r100 :: bool
    r101 :: object
    r102 :: short_int
    r103 :: tuple[bool, short_int, object, object]
    r104 :: short_int
    r105, r106 :: bool
    r107, r108 :: object
    r109 :: str
    r110 :: union[int, str, bytes, None, dict]
    r111, r112 :: bool
    r113 :: union[int, str, bytes, None, dict]
    r114 :: object
    r115 :: bit
    r116 :: str
    r117 :: union[int, str, bytes, None, dict]
    r118 :: union[int, str, bytes, dict]
    r119 :: dict
    r120 :: i32
    r121 :: bit
    r122 :: dict
    r123 :: short_int
    r124, r125 :: bit
    r126 :: dict
    r127 :: bool
    r128 :: object
    r129 :: tuple
    r130 :: dict
    r131 :: str
    r132 :: object
    r133 :: list
    r134 :: object
    r135 :: dict
    r136 :: i32
    r137 :: bit
    r138 :: tuple
    r139, r140 :: object
    r141 :: bool
    r142, r143, r144, r145, r146 :: object
    r147 :: bool
    r148 :: object
    r149 :: bit
    r150 :: tuple[object, object, object]
    r151 :: bool
    r152 :: object_ptr
    r153 :: object
    r154, r155 :: bool
    r156 :: tuple[object, object, object]
    r157 :: bool
    r158, r159 :: tuple[object, object, object]
    r160 :: bit
    r161, r162, r163 :: object
    r164 :: bool
    r165, r166 :: bit
    r167 :: bool
    r168 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = __mypyc_self__.__mypyc_env__
    if is_error(r2) goto L153 (error at coroutine:23) else goto L1
L1:
    r3 = r2.__mypyc_next_label__
    if is_error(r3) goto L154 (error at coroutine:23) else goto L2
L2:
    r4 = r2.__mypyc_env__
    if is_error(r4) goto L155 (error at coroutine:23) else goto L148
L3:
    r5 = load_address _Py_NoneStruct
    r6 = type != r5
    if r6 goto L156 else goto L6 :: bool
L4:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L152 (error at coroutine:23) else goto L5 :: bool
L5:
    unreachable
L6:
    r7 = r2.self
    if is_error(r7) goto L157 (error at coroutine:44) else goto L7
L7:
    r8 = r2.args
    if is_error(r8) goto L158 (error at coroutine:44) else goto L8
L8:
    r9 = '_get_fn_from_args'
    r10 = [r7, r8]
    r11 = load_address r10
    r12 = PyObject_VectorcallMethod(r9, r11, 9223372036854775810, 0)
    if is_error(r12) goto L159 (error at coroutine:44) else goto L9
L9:
    dec_ref r7
    dec_ref r8
    r2.fn = r12; r13 = is_error
    if not r13 goto L157 (error at coroutine:44) else goto L160 :: bool
L10:
    r14 = CPy_CatchError()
    r2.__mypyc_temp__0 = r14; r15 = is_error
    if not r15 goto L161 (error at coroutine:-1) else goto L11 :: bool
L11:
    r16 = builtins :: module
    r17 = 'ValueError'
    r18 = CPyObject_GetAttr(r16, r17)
    if is_error(r18) goto L161 (error at coroutine:45) else goto L12
L12:
    r19 = CPy_ExceptionMatches(r18)
    dec_ref r18
    if r19 goto L13 else goto L162 :: bool
L13:
    r20 = CPy_GetExcValue()
    r2.e = r20; r21 = is_error
    if not r21 goto L161 (error at coroutine:45) else goto L14 :: bool
L14:
    r22 = r2.e
    if is_error(r22) goto L161 (error at coroutine:46) else goto L15
L15:
    r23 = PyObject_Str(r22)
    dec_ref r22
    if is_error(r23) goto L161 (error at coroutine:46) else goto L16
L16:
    r2.exc_str = r23; r24 = is_error
    if not r24 goto L161 (error at coroutine:46) else goto L17 :: bool
L17:
    r25 = "Contract has more than one function '."
    r26 = r4.call
    if is_error(r26) goto L161 (error at coroutine:48) else goto L18
L18:
    r27 = '_name'
    r28 = CPyObject_GetAttr(r26, r27)
    dec_ref r26
    if is_error(r28) goto L161 (error at coroutine:48) else goto L19
L19:
    r29 = PyObject_Str(r28)
    dec_ref r28
    if is_error(r29) goto L161 (error at coroutine:48) else goto L20
L20:
    r30 = CPyStr_Build(2, r25, r29)
    dec_ref r29
    if is_error(r30) goto L161 (error at coroutine:48) else goto L21
L21:
    r31 = 'You must explicitly declare which function you are calling, e.g. .'
    r32 = r4.call
    dec_ref r4
    if is_error(r32) goto L163 (error at coroutine:49) else goto L22
L22:
    r33 = '_name'
    r34 = CPyObject_GetAttr(r32, r33)
    dec_ref r32
    if is_error(r34) goto L163 (error at coroutine:49) else goto L23
L23:
    r35 = PyObject_Str(r34)
    dec_ref r34
    if is_error(r35) goto L163 (error at coroutine:49) else goto L24
L24:
    r36 = CPyStr_Build(2, r31, r35)
    dec_ref r35
    if is_error(r36) goto L163 (error at coroutine:49) else goto L25
L25:
    r37 = (r30, r36)
    r2.match_on = r37; r38 = is_error
    if not r38 goto L62 (error at coroutine:47) else goto L26 :: bool
L26:
    r39 = 1
    r40 = r2.match_on
    if is_error(r40) goto L62 (error at coroutine:51) else goto L27
L27:
    inc_ref r40
    r41 = box(tuple[str, str], r40)
    r42 = PyObject_GetIter(r41)
    dec_ref r41
    if is_error(r42) goto L164 (error at coroutine:51) else goto L28
L28:
    r2.__mypyc_temp__1 = r40; r43 = is_error
    if not r43 goto L165 (error at coroutine:-1) else goto L29 :: bool
L29:
    r2.__mypyc_temp__2 = r42; r44 = is_error
    if not r44 goto L62 (error at coroutine:-1) else goto L30 :: bool
L30:
    r45 = r2.__mypyc_temp__2
    if is_error(r45) goto L62 (error at coroutine:51) else goto L31
L31:
    r46 = PyIter_Next(r45)
    dec_ref r45
    if is_error(r46) goto L39 else goto L32
L32:
    r47 = cast(str, r46)
    if is_error(r47) goto L62 (error at coroutine:51) else goto L33
L33:
    r2.s = r47; r48 = is_error
    if not r48 goto L62 (error at coroutine:51) else goto L34 :: bool
L34:
    r49 = r2.s
    if is_error(r49) goto L62 (error at coroutine:51) else goto L35
L35:
    r50 = r2.exc_str
    if is_error(r50) goto L166 (error at coroutine:51) else goto L36
L36:
    r51 = PySequence_Contains(r50, r49)
    dec_ref r50
    dec_ref r49
    r52 = r51 >= 0 :: signed
    if not r52 goto L62 (error at coroutine:51) else goto L37 :: bool
L37:
    r53 = truncate r51: i32 to builtins.bool
    r54 = r53 ^ 1
    if r54 goto L38 else goto L30 :: bool
L38:
    r39 = 0
    goto L40
L39:
    r55 = CPy_NoErrOccurred()
    if not r55 goto L62 (error at coroutine:51) else goto L40 :: bool
L40:
    if r39 goto L41 else goto L58 :: bool
L41:
    r56 = r2.exc_str
    if is_error(r56) goto L62 (error at coroutine:52) else goto L42
L42:
    r57 = '(*args)'
    r58 = 'find'
    r59 = [r56, r57]
    r60 = load_address r59
    r61 = PyObject_VectorcallMethod(r58, r60, 9223372036854775810, 0)
    if is_error(r61) goto L167 (error at coroutine:52) else goto L43
L43:
    dec_ref r56
    r62 = unbox(int, r61)
    dec_ref r61
    if is_error(r62) goto L62 (error at coroutine:52) else goto L44
L44:
    r2.breakpoint = r62; r63 = is_error
    if not r63 goto L62 (error at coroutine:52) else goto L45 :: bool
L45:
    r64 = r2.exc_str
    if is_error(r64) goto L62 (error at coroutine:53) else goto L46
L46:
    r65 = r2.breakpoint
    if is_error(r65) goto L168 (error at coroutine:53) else goto L47
L47:
    r66 = CPyStr_GetSlice(r64, 0, r65)
    dec_ref r64
    dec_ref r65 :: int
    if is_error(r66) goto L62 (error at coroutine:53) else goto L48
L48:
    r67 = cast(str, r66)
    if is_error(r67) goto L62 (error at coroutine:53) else goto L49
L49:
    r68 = '.coroutine'
    r69 = r2.exc_str
    if is_error(r69) goto L169 (error at coroutine:53) else goto L50
L50:
    r70 = r2.breakpoint
    if is_error(r70) goto L170 (error at coroutine:53) else goto L51
L51:
    r71 = CPyStr_GetSlice(r69, r70, 9223372036854775806)
    dec_ref r69
    dec_ref r70 :: int
    if is_error(r71) goto L169 (error at coroutine:53) else goto L52
L52:
    r72 = cast(str, r71)
    if is_error(r72) goto L169 (error at coroutine:53) else goto L53
L53:
    r73 = CPyStr_Build(3, r67, r68, r72)
    dec_ref r67
    dec_ref r72
    if is_error(r73) goto L62 (error at coroutine:53) else goto L54
L54:
    r74 = builtins :: module
    r75 = 'ValueError'
    r76 = CPyObject_GetAttr(r74, r75)
    if is_error(r76) goto L171 (error at coroutine:53) else goto L55
L55:
    r77 = [r73]
    r78 = load_address r77
    r79 = _PyObject_Vectorcall(r76, r78, 1, 0)
    dec_ref r76
    if is_error(r79) goto L171 (error at coroutine:53) else goto L56
L56:
    dec_ref r73
    CPy_Raise(r79)
    dec_ref r79
    if not 0 goto L62 (error at coroutine:53) else goto L172 :: bool
L57:
    unreachable
L58:
    CPy_Reraise()
    if not 0 goto L62 else goto L173 :: bool
L59:
    unreachable
L60:
    CPy_Reraise()
    if not 0 goto L62 else goto L174 :: bool
L61:
    unreachable
L62:
    r80 = r2.__mypyc_temp__0
    dec_ref r2
    if is_error(r80) goto L152 (error at coroutine:-1) else goto L63
L63:
    CPy_RestoreExcInfo(r80)
    dec_ref r80
    r81 = CPy_KeepPropagating()
    if not r81 goto L152 else goto L64 :: bool
L64:
    unreachable
L65:
    r82 = 'block_identifier'
    r83 = r2.block_identifier
    if is_error(r83) goto L154 (error at coroutine:56) else goto L66
L66:
    r84 = 'decimals'
    r85 = r2.decimals
    if is_error(r85) goto L175 (error at coroutine:56) else goto L67
L67:
    r86 = 'override'
    r87 = r2.override
    if is_error(r87) goto L176 (error at coroutine:56) else goto L68
L68:
    r88 = CPyDict_Build(3, r82, r83, r84, r85, r86, r87)
    dec_ref r83
    dec_ref r85
    dec_ref r87
    if is_error(r88) goto L154 (error at coroutine:56) else goto L69
L69:
    r2.kwargs = r88; r89 = is_error
    if not r89 goto L154 (error at coroutine:56) else goto L70 :: bool
L70:
    r90 = PyDict_New()
    if is_error(r90) goto L154 (error at coroutine:57) else goto L71
L71:
    r2.__mypyc_temp__3 = r90; r91 = is_error
    if not r91 goto L154 (error at coroutine:-1) else goto L72 :: bool
L72:
    r92 = r2.kwargs
    if is_error(r92) goto L154 (error at coroutine:57) else goto L73
L73:
    inc_ref r92
    r2.__mypyc_temp__4 = r92; r93 = is_error
    if not r93 goto L177 (error at coroutine:-1) else goto L74 :: bool
L74:
    r2.__mypyc_temp__5 = 0; r94 = is_error
    if not r94 goto L177 (error at coroutine:-1) else goto L75 :: bool
L75:
    r95 = r2.__mypyc_temp__4
    if is_error(r95) goto L177 (error at coroutine:57) else goto L76
L76:
    r96 = PyDict_Size(r95)
    dec_ref r95
    r97 = r96 << 1
    r2.__mypyc_temp__6 = r97; r98 = is_error
    if not r98 goto L177 (error at coroutine:-1) else goto L77 :: bool
L77:
    r99 = CPyDict_GetItemsIter(r92)
    dec_ref r92
    if is_error(r99) goto L154 (error at coroutine:57) else goto L78
L78:
    r2.__mypyc_temp__7 = r99; r100 = is_error
    if not r100 goto L154 (error at coroutine:-1) else goto L79 :: bool
L79:
    r101 = r2.__mypyc_temp__7
    if is_error(r101) goto L154 (error at coroutine:57) else goto L80
L80:
    r102 = r2.__mypyc_temp__5
    if is_error(r102) goto L178 (error at coroutine:57) else goto L81
L81:
    r103 = CPyDict_NextItem(r101, r102)
    dec_ref r101
    r104 = r103[1]
    r2.__mypyc_temp__5 = r104; r105 = is_error
    if not r105 goto L179 (error at coroutine:57) else goto L82 :: bool
L82:
    r106 = r103[0]
    if r106 goto L83 else goto L180 :: bool
L83:
    r107 = r103[2]
    r108 = r103[3]
    dec_ref r103
    r109 = cast(str, r107)
    if is_error(r109) goto L181 (error at coroutine:57) else goto L84
L84:
    r110 = cast(union[int, str, bytes, None, dict], r108)
    if is_error(r110) goto L182 (error at coroutine:57) else goto L85
L85:
    r2.k = r109; r111 = is_error
    if not r111 goto L183 (error at coroutine:57) else goto L86 :: bool
L86:
    r2.v = r110; r112 = is_error
    if not r112 goto L154 (error at coroutine:57) else goto L87 :: bool
L87:
    r113 = r2.v
    if is_error(r113) goto L154 (error at coroutine:57) else goto L88
L88:
    r114 = load_address _Py_NoneStruct
    r115 = r113 != r114
    dec_ref r113
    if r115 goto L89 else goto L94 :: bool
L89:
    r116 = r2.k
    if is_error(r116) goto L154 (error at coroutine:57) else goto L90
L90:
    r117 = r2.v
    if is_error(r117) goto L184 (error at coroutine:57) else goto L91
L91:
    r118 = cast(union[int, str, bytes, dict], r117)
    if is_error(r118) goto L184 (error at coroutine:57) else goto L92
L92:
    r119 = r2.__mypyc_temp__3
    if is_error(r119) goto L185 (error at coroutine:-1) else goto L93
L93:
    r120 = CPyDict_SetItem(r119, r116, r118)
    dec_ref r119
    dec_ref r116
    dec_ref r118
    r121 = r120 >= 0 :: signed
    if not r121 goto L154 (error at coroutine:57) else goto L94 :: bool
L94:
    r122 = r2.__mypyc_temp__4
    if is_error(r122) goto L154 (error at coroutine:57) else goto L95
L95:
    r123 = r2.__mypyc_temp__6
    if is_error(r123) goto L186 (error at coroutine:57) else goto L96
L96:
    r124 = CPyDict_CheckSize(r122, r123)
    dec_ref r122
    if not r124 goto L154 (error at coroutine:57) else goto L79 :: bool
L97:
    r125 = CPy_NoErrOccurred()
    if not r125 goto L154 (error at coroutine:57) else goto L98 :: bool
L98:
    r126 = r2.__mypyc_temp__3
    if is_error(r126) goto L154 (error at coroutine:-1) else goto L99
L99:
    r2.kwargs = r126; r127 = is_error
    if not r127 goto L154 (error at coroutine:57) else goto L100 :: bool
L100:
    r128 = r2.fn
    if is_error(r128) goto L154 (error at coroutine:58) else goto L101
L101:
    r129 = r2.args
    if is_error(r129) goto L187 (error at coroutine:58) else goto L102
L102:
    r130 = r2.kwargs
    if is_error(r130) goto L188 (error at coroutine:58) else goto L103
L103:
    r131 = 'coroutine'
    r132 = CPyObject_GetAttr(r128, r131)
    dec_ref r128
    if is_error(r132) goto L189 (error at coroutine:58) else goto L104
L104:
    r133 = PyList_New(0)
    if is_error(r133) goto L190 (error at coroutine:58) else goto L105
L105:
    r134 = CPyList_Extend(r133, r129)
    dec_ref r129
    if is_error(r134) goto L191 (error at coroutine:58) else goto L192
L106:
    r135 = PyDict_New()
    if is_error(r135) goto L191 (error at coroutine:58) else goto L107
L107:
    r136 = CPyDict_UpdateInDisplay(r135, r130)
    dec_ref r130
    r137 = r136 >= 0 :: signed
    if not r137 goto L193 (error at coroutine:58) else goto L108 :: bool
L108:
    r138 = PyList_AsTuple(r133)
    dec_ref r133
    if is_error(r138) goto L194 (error at coroutine:58) else goto L109
L109:
    r139 = PyObject_Call(r132, r138, r135)
    dec_ref r132
    dec_ref r138
    dec_ref r135
    if is_error(r139) goto L154 (error at coroutine:58) else goto L110
L110:
    r140 = CPy_GetCoro(r139)
    dec_ref r139
    if is_error(r140) goto L154 (error at coroutine:58) else goto L111
L111:
    r2.__mypyc_temp__8 = r140; r141 = is_error
    if not r141 goto L154 (error at coroutine:-1) else goto L112 :: bool
L112:
    r142 = r2.__mypyc_temp__8
    if is_error(r142) goto L154 (error at coroutine:-1) else goto L113
L113:
    r143 = CPyIter_Next(r142)
    dec_ref r142
    if is_error(r143) goto L195 else goto L116
L114:
    r144 = CPy_FetchStopIterationValue()
    if is_error(r144) goto L196 (error at coroutine:58) else goto L115
L115:
    r145 = r144
    goto L145
L116:
    r146 = r143
L117:
    r2.__mypyc_next_label__ = 2; r147 = is_error
    if not r147 goto L197 (error at coroutine:58) else goto L198 :: bool
L118:
    return r146
L119:
    r148 = load_address _Py_NoneStruct
    r149 = type != r148
    if r149 goto L120 else goto L122 :: bool
L120:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L123 (error at coroutine:58) else goto L199 :: bool
L121:
    unreachable
L122:
    inc_ref arg
    goto L140
L123:
    r150 = CPy_CatchError()
    r2.__mypyc_temp__9 = r150; r151 = is_error
    if not r151 goto L200 (error at coroutine:-1) else goto L124 :: bool
L124:
    r152 = load_address r1
    r153 = r2.__mypyc_temp__8
    if is_error(r153) goto L200 (error at coroutine:-1) else goto L125
L125:
    r154 = CPy_YieldFromErrorHandle(r153, r152)
    dec_ref r153
    if is_error(r154) goto L200 (error at coroutine:58) else goto L126
L126:
    if r154 goto L132 else goto L127 :: bool
L127:
    if is_error(r1) goto L128 else goto L130
L128:
    r155 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r155 goto L137 (error at coroutine:-1) else goto L201 :: bool
L129:
    unreachable
L130:
    inc_ref r1
    r146 = r1
    r156 = r2.__mypyc_temp__9
    if is_error(r156) goto L202 (error at coroutine:-1) else goto L131
L131:
    CPy_RestoreExcInfo(r156)
    dec_ref r156
    goto L117
L132:
    if is_error(r1) goto L133 else goto L135
L133:
    r157 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r157 goto L137 (error at coroutine:-1) else goto L203 :: bool
L134:
    unreachable
L135:
    r145 = r1
    r158 = r2.__mypyc_temp__9
    if is_error(r158) goto L204 (error at coroutine:-1) else goto L136
L136:
    CPy_RestoreExcInfo(r158)
    dec_ref r158
    goto L145
L137:
    r159 = r2.__mypyc_temp__9
    dec_ref r2
    if is_error(r159) goto L152 (error at coroutine:-1) else goto L138
L138:
    CPy_RestoreExcInfo(r159)
    dec_ref r159
    r160 = CPy_KeepPropagating()
    if not r160 goto L152 else goto L139 :: bool
L139:
    unreachable
L140:
    r161 = r2.__mypyc_temp__8
    if is_error(r161) goto L205 (error at coroutine:-1) else goto L141
L141:
    r162 = CPyIter_Send(r161, arg)
    dec_ref r161
    dec_ref arg
    if is_error(r162) goto L206 else goto L142
L142:
    r146 = r162
    goto L117
L143:
    r163 = CPy_FetchStopIterationValue()
    if is_error(r163) goto L196 (error at coroutine:58) else goto L144
L144:
    r145 = r163
L145:
    r2.__mypyc_next_label__ = -2; r164 = is_error
    dec_ref r2
    if not r164 goto L207 (error at coroutine:58) else goto L146 :: bool
L146:
    CPyGen_SetStopIterationValue(r145)
    dec_ref r145
    if not 0 goto L152 else goto L147 :: bool
L147:
    unreachable
L148:
    r165 = r3 == 0
    if r165 goto L208 else goto L209 :: bool
L149:
    r166 = r3 == 2
    dec_ref r3 :: int
    if r166 goto L119 else goto L210 :: bool
L150:
    r167 = raise StopIteration
    if not r167 goto L152 (error at coroutine:23) else goto L151 :: bool
L151:
    unreachable
L152:
    r168 = <error> :: object
    return r168
L153:
    xdec_ref r1
    goto L152
L154:
    xdec_ref r1
    dec_ref r2
    goto L152
L155:
    xdec_ref r1
    dec_ref r2
    dec_ref r3 :: int
    goto L152
L156:
    xdec_ref r1
    dec_ref r2
    dec_ref r4
    goto L4
L157:
    xdec_ref r1
    goto L10
L158:
    xdec_ref r1
    dec_ref r7
    goto L10
L159:
    xdec_ref r1
    dec_ref r7
    dec_ref r8
    goto L10
L160:
    dec_ref r4
    goto L65
L161:
    dec_ref r4
    goto L62
L162:
    dec_ref r4
    goto L60
L163:
    dec_ref r30
    goto L62
L164:
    dec_ref r40
    goto L62
L165:
    dec_ref r42
    goto L62
L166:
    dec_ref r49
    goto L62
L167:
    dec_ref r56
    goto L62
L168:
    dec_ref r64
    goto L62
L169:
    dec_ref r67
    goto L62
L170:
    dec_ref r67
    dec_ref r69
    goto L62
L171:
    dec_ref r73
    goto L62
L172:
    dec_ref r2
    goto L57
L173:
    dec_ref r2
    goto L59
L174:
    dec_ref r2
    goto L61
L175:
    xdec_ref r1
    dec_ref r2
    dec_ref r83
    goto L152
L176:
    xdec_ref r1
    dec_ref r2
    dec_ref r83
    dec_ref r85
    goto L152
L177:
    xdec_ref r1
    dec_ref r2
    dec_ref r92
    goto L152
L178:
    xdec_ref r1
    dec_ref r2
    dec_ref r101
    goto L152
L179:
    xdec_ref r1
    dec_ref r2
    dec_ref r103
    goto L152
L180:
    dec_ref r103
    goto L97
L181:
    xdec_ref r1
    dec_ref r2
    dec_ref r108
    goto L152
L182:
    xdec_ref r1
    dec_ref r2
    dec_ref r109
    goto L152
L183:
    xdec_ref r1
    dec_ref r2
    dec_ref r110
    goto L152
L184:
    xdec_ref r1
    dec_ref r2
    dec_ref r116
    goto L152
L185:
    xdec_ref r1
    dec_ref r2
    dec_ref r116
    dec_ref r118
    goto L152
L186:
    xdec_ref r1
    dec_ref r2
    dec_ref r122
    goto L152
L187:
    xdec_ref r1
    dec_ref r2
    dec_ref r128
    goto L152
L188:
    xdec_ref r1
    dec_ref r2
    dec_ref r128
    dec_ref r129
    goto L152
L189:
    xdec_ref r1
    dec_ref r2
    dec_ref r129
    dec_ref r130
    goto L152
L190:
    xdec_ref r1
    dec_ref r2
    dec_ref r129
    dec_ref r130
    dec_ref r132
    goto L152
L191:
    xdec_ref r1
    dec_ref r2
    dec_ref r130
    dec_ref r132
    dec_ref r133
    goto L152
L192:
    dec_ref r134
    goto L106
L193:
    xdec_ref r1
    dec_ref r2
    dec_ref r132
    dec_ref r133
    dec_ref r135
    goto L152
L194:
    xdec_ref r1
    dec_ref r2
    dec_ref r132
    dec_ref r135
    goto L152
L195:
    xdec_ref r1
    goto L114
L196:
    dec_ref r2
    goto L152
L197:
    dec_ref r146
    goto L123
L198:
    xdec_ref r1
    dec_ref r2
    goto L118
L199:
    xdec_ref r1
    dec_ref r2
    goto L121
L200:
    xdec_ref r1
    goto L137
L201:
    dec_ref r2
    goto L129
L202:
    xdec_ref r1
    dec_ref r146
    goto L137
L203:
    dec_ref r2
    goto L134
L204:
    dec_ref r145
    goto L137
L205:
    xdec_ref r1
    dec_ref r2
    dec_ref arg
    goto L152
L206:
    xdec_ref r1
    goto L143
L207:
    dec_ref r145
    goto L152
L208:
    dec_ref r3 :: int
    goto L3
L209:
    dec_ref r4
    goto L149
L210:
    xdec_ref r1
    dec_ref r2
    goto L150

def coroutine__patch_overloaded_method_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine__patch_overloaded_method_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine__patch_overloaded_method_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutine__patch_overloaded_method_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutine__patch_overloaded_method_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine__patch_overloaded_method_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutine__patch_overloaded_method_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutine__patch_overloaded_method_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def coroutine__patch_overloaded_method_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutine__patch_overloaded_method_obj.__call__(__mypyc_self__, self, args, block_identifier, decimals, override):
    __mypyc_self__ :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_obj
    self :: object
    args :: tuple
    block_identifier :: union[int, str, bytes, None]
    decimals :: union[int, None]
    override :: union[dict, None]
    r0 :: dank_mids.brownie_patch.overloaded._patch_overloaded_method_env
    r1, r2, r3 :: object
    r4 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_env
    r5, r6, r7, r8, r9, r10 :: bool
    r11 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_gen
    r12, r13 :: bool
    r14 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L18 (error at coroutine:23) else goto L1
L1:
    if is_error(block_identifier) goto L2 else goto L19
L2:
    r1 = box(None, 1)
    inc_ref r1
    block_identifier = r1
L3:
    if is_error(decimals) goto L4 else goto L20
L4:
    r2 = box(None, 1)
    inc_ref r2
    decimals = r2
L5:
    if is_error(override) goto L6 else goto L21
L6:
    r3 = box(None, 1)
    inc_ref r3
    override = r3
L7:
    r4 = coroutine__patch_overloaded_method_env()
    if is_error(r4) goto L22 (error at coroutine:23) else goto L8
L8:
    r4.__mypyc_env__ = r0; r5 = is_error
    if not r5 goto L23 (error at coroutine:23) else goto L9 :: bool
L9:
    inc_ref self
    r4.self = self; r6 = is_error
    if not r6 goto L23 (error at coroutine:23) else goto L10 :: bool
L10:
    inc_ref args
    r4.args = args; r7 = is_error
    if not r7 goto L23 (error at coroutine:23) else goto L11 :: bool
L11:
    r4.block_identifier = block_identifier; r8 = is_error
    if not r8 goto L24 (error at coroutine:23) else goto L12 :: bool
L12:
    r4.decimals = decimals; r9 = is_error
    if not r9 goto L25 (error at coroutine:23) else goto L13 :: bool
L13:
    r4.override = override; r10 = is_error
    if not r10 goto L26 (error at coroutine:23) else goto L14 :: bool
L14:
    r11 = coroutine__patch_overloaded_method_gen()
    if is_error(r11) goto L26 (error at coroutine:23) else goto L15
L15:
    inc_ref r4
    r11.__mypyc_env__ = r4; r12 = is_error
    if not r12 goto L27 (error at coroutine:23) else goto L16 :: bool
L16:
    r4.__mypyc_next_label__ = 0; r13 = is_error
    dec_ref r4
    if not r13 goto L28 (error at coroutine:23) else goto L17 :: bool
L17:
    return r11
L18:
    r14 = <error> :: object
    return r14
L19:
    inc_ref block_identifier
    goto L3
L20:
    inc_ref decimals
    goto L5
L21:
    inc_ref override
    goto L7
L22:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r0
    goto L18
L23:
    dec_ref block_identifier
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L18
L24:
    dec_ref decimals
    dec_ref override
    dec_ref r4
    goto L18
L25:
    dec_ref override
    dec_ref r4
    goto L18
L26:
    dec_ref r4
    goto L18
L27:
    dec_ref r4
    dec_ref r11
    goto L18
L28:
    dec_ref r11
    goto L18

def _patch_overloaded_method(call, w3):
    call, w3 :: object
    r0 :: dank_mids.brownie_patch.overloaded._patch_overloaded_method_env
    r1 :: bool
    r2 :: dank_mids.brownie_patch.overloaded.coroutine__patch_overloaded_method_obj
    r3 :: bool
    r4 :: object
    r5 :: dict
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10 :: object
    r11 :: object[1]
    r12 :: object_ptr
    r13 :: object
    r14 :: dict
    r15 :: str
    r16 :: i32
    r17 :: bit
    r18 :: object
    r19 :: str
    r20 :: object
    r21 :: str
    r22 :: object
    r23 :: str
    r24 :: object[1]
    r25 :: object_ptr
    r26, r27, r28 :: object
    r29 :: dict
    r30 :: str
    r31 :: object
    r32 :: dict
    r33 :: str
    r34 :: object
    r35 :: tuple[object, object]
    r36 :: object
    r37 :: i32
    r38 :: bit
    r39 :: bool
    r40 :: str
    r41 :: object
    r42 :: dict
    r43 :: str
    r44 :: object
    r45 :: set
    r46 :: i32
    r47 :: bit
    r48 :: bool
    r49 :: str
    r50 :: object
    r51 :: i32
    r52 :: bit
    r53 :: str
    r54 :: object
    r55 :: str
    r56 :: object
    r57 :: int
    r58 :: dict
    r59 :: str
    r60, r61 :: object
    r62 :: object[2]
    r63 :: object_ptr
    r64 :: object
    r65 :: dict
    r66 :: str
    r67 :: object
    r68 :: object[2]
    r69 :: object_ptr
    r70 :: object
    r71 :: str
    r72 :: i32
    r73, r74 :: bit
    r75 :: object
    r76 :: dict
    r77 :: str
    r78 :: object
    r79 :: object[2]
    r80 :: object_ptr
    r81, r82 :: object
    r83 :: str
    r84 :: i32
    r85 :: bit
    r86 :: None
L0:
    r0 = _patch_overloaded_method_env()
    if is_error(r0) goto L39 (error at _patch_overloaded_method:11) else goto L1
L1:
    inc_ref call
    r0.call = call; r1 = is_error
    if not r1 goto L40 (error at _patch_overloaded_method:11) else goto L2 :: bool
L2:
    r2 = coroutine__patch_overloaded_method_obj()
    if is_error(r2) goto L40 (error at _patch_overloaded_method:23) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L41 (error at _patch_overloaded_method:23) else goto L4 :: bool
L4:
    r4 = r0.call
    if is_error(r4) goto L41 (error at _patch_overloaded_method:22) else goto L5
L5:
    r5 = dank_mids.brownie_patch.overloaded.globals :: static
    r6 = 'wraps'
    r7 = CPyDict_GetItem(r5, r6)
    if is_error(r7) goto L42 (error at _patch_overloaded_method:22) else goto L6
L6:
    r8 = [r4]
    r9 = load_address r8
    r10 = _PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L42 (error at _patch_overloaded_method:22) else goto L7
L7:
    dec_ref r4
    r11 = [r2]
    r12 = load_address r11
    r13 = _PyObject_Vectorcall(r10, r12, 1, 0)
    dec_ref r10
    if is_error(r13) goto L41 (error at _patch_overloaded_method:23) else goto L8
L8:
    dec_ref r2
    inc_ref r13
    r14 = dank_mids.brownie_patch.overloaded.globals :: static
    r15 = 'coroutine'
    r16 = CPyDict_SetItem(r14, r15, r13)
    dec_ref r13
    r17 = r16 >= 0 :: signed
    if not r17 goto L43 (error at _patch_overloaded_method:23) else goto L9 :: bool
L9:
    r18 = r0.call
    if is_error(r18) goto L43 (error at _patch_overloaded_method:60) else goto L10
L10:
    r19 = '__dict__'
    r20 = CPyObject_GetAttr(r18, r19)
    dec_ref r18
    if is_error(r20) goto L43 (error at _patch_overloaded_method:60) else goto L11
L11:
    r21 = 'methods'
    r22 = PyObject_GetItem(r20, r21)
    dec_ref r20
    if is_error(r22) goto L43 (error at _patch_overloaded_method:60) else goto L12
L12:
    r23 = 'values'
    r24 = [r22]
    r25 = load_address r24
    r26 = PyObject_VectorcallMethod(r23, r25, 9223372036854775809, 0)
    if is_error(r26) goto L44 (error at _patch_overloaded_method:60) else goto L13
L13:
    dec_ref r22
    r27 = PyObject_GetIter(r26)
    dec_ref r26
    if is_error(r27) goto L43 (error at _patch_overloaded_method:60) else goto L14
L14:
    r28 = PyIter_Next(r27)
    if is_error(r28) goto L45 else goto L15
L15:
    r29 = dank_mids.brownie_patch.overloaded.globals :: static
    r30 = 'ContractCall'
    r31 = CPyDict_GetItem(r29, r30)
    if is_error(r31) goto L46 (error at _patch_overloaded_method:61) else goto L16
L16:
    r32 = dank_mids.brownie_patch.overloaded.globals :: static
    r33 = 'ContractTx'
    r34 = CPyDict_GetItem(r32, r33)
    if is_error(r34) goto L47 (error at _patch_overloaded_method:61) else goto L17
L17:
    r35 = (r31, r34)
    r36 = box(tuple[object, object], r35)
    r37 = PyObject_IsInstance(r28, r36)
    dec_ref r36
    r38 = r37 >= 0 :: signed
    if not r38 goto L46 (error at _patch_overloaded_method:61) else goto L18 :: bool
L18:
    r39 = truncate r37: i32 to builtins.bool
    if r39 goto L19 else goto L48 :: bool
L19:
    r40 = '_address'
    r41 = CPyObject_GetAttr(r28, r40)
    if is_error(r41) goto L46 (error at _patch_overloaded_method:62) else goto L20
L20:
    r42 = dank_mids.brownie_patch.overloaded.globals :: static
    r43 = '_skip_proc_pool'
    r44 = CPyDict_GetItem(r42, r43)
    if is_error(r44) goto L49 (error at _patch_overloaded_method:62) else goto L21
L21:
    r45 = cast(set, r44)
    if is_error(r45) goto L49 (error at _patch_overloaded_method:62) else goto L22
L22:
    r46 = PySet_Contains(r45, r41)
    dec_ref r45
    dec_ref r41
    r47 = r46 >= 0 :: signed
    if not r47 goto L46 (error at _patch_overloaded_method:62) else goto L23 :: bool
L23:
    r48 = truncate r46: i32 to builtins.bool
    r49 = '_skip_decoder_proc_pool'
    r50 = box(bool, r48)
    r51 = PyObject_SetAttr(r28, r49, r50)
    r52 = r51 >= 0 :: signed
    if not r52 goto L46 (error at _patch_overloaded_method:62) else goto L24 :: bool
L24:
    r53 = 'abi'
    r54 = CPyObject_GetAttr(r28, r53)
    if is_error(r54) goto L46 (error at _patch_overloaded_method:63) else goto L25
L25:
    r55 = 'inputs'
    r56 = PyObject_GetItem(r54, r55)
    dec_ref r54
    if is_error(r56) goto L46 (error at _patch_overloaded_method:63) else goto L26
L26:
    r57 = CPyObject_Size(r56)
    dec_ref r56
    if is_error(r57) goto L46 (error at _patch_overloaded_method:63) else goto L27
L27:
    r58 = dank_mids.brownie_patch.overloaded.globals :: static
    r59 = '_get_coroutine_fn'
    r60 = CPyDict_GetItem(r58, r59)
    if is_error(r60) goto L50 (error at _patch_overloaded_method:63) else goto L28
L28:
    r61 = box(int, r57)
    r62 = [w3, r61]
    r63 = load_address r62
    r64 = _PyObject_Vectorcall(r60, r63, 2, 0)
    dec_ref r60
    if is_error(r64) goto L51 (error at _patch_overloaded_method:63) else goto L29
L29:
    dec_ref r61
    r65 = dank_mids.brownie_patch.overloaded.globals :: static
    r66 = 'MethodType'
    r67 = CPyDict_GetItem(r65, r66)
    if is_error(r67) goto L52 (error at _patch_overloaded_method:63) else goto L30
L30:
    r68 = [r64, r28]
    r69 = load_address r68
    r70 = _PyObject_Vectorcall(r67, r69, 2, 0)
    dec_ref r67
    if is_error(r70) goto L52 (error at _patch_overloaded_method:63) else goto L31
L31:
    dec_ref r64
    r71 = 'coroutine'
    r72 = PyObject_SetAttr(r28, r71, r70)
    dec_ref r28
    dec_ref r70
    r73 = r72 >= 0 :: signed
    if not r73 goto L53 (error at _patch_overloaded_method:63) else goto L14 :: bool
L32:
    r74 = CPy_NoErrOccurred()
    if not r74 goto L43 (error at _patch_overloaded_method:60) else goto L33 :: bool
L33:
    r75 = r0.call
    if is_error(r75) goto L43 (error at _patch_overloaded_method:68) else goto L34
L34:
    r76 = dank_mids.brownie_patch.overloaded.globals :: static
    r77 = 'MethodType'
    r78 = CPyDict_GetItem(r76, r77)
    if is_error(r78) goto L54 (error at _patch_overloaded_method:68) else goto L35
L35:
    r79 = [r13, r75]
    r80 = load_address r79
    r81 = _PyObject_Vectorcall(r78, r80, 2, 0)
    dec_ref r78
    if is_error(r81) goto L54 (error at _patch_overloaded_method:68) else goto L36
L36:
    dec_ref r13
    dec_ref r75
    r82 = r0.call
    dec_ref r0
    if is_error(r82) goto L55 (error at _patch_overloaded_method:68) else goto L37
L37:
    r83 = 'coroutine'
    r84 = PyObject_SetAttr(r82, r83, r81)
    dec_ref r82
    dec_ref r81
    r85 = r84 >= 0 :: signed
    if not r85 goto L39 (error at _patch_overloaded_method:68) else goto L38 :: bool
L38:
    return 1
L39:
    r86 = <error> :: None
    return r86
L40:
    dec_ref r0
    goto L39
L41:
    dec_ref r0
    dec_ref r2
    goto L39
L42:
    dec_ref r0
    dec_ref r2
    dec_ref r4
    goto L39
L43:
    dec_ref r0
    dec_ref r13
    goto L39
L44:
    dec_ref r0
    dec_ref r13
    dec_ref r22
    goto L39
L45:
    dec_ref r27
    goto L32
L46:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    goto L39
L47:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r31
    goto L39
L48:
    dec_ref r28
    goto L14
L49:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r41
    goto L39
L50:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r57 :: int
    goto L39
L51:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r61
    goto L39
L52:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    dec_ref r28
    dec_ref r64
    goto L39
L53:
    dec_ref r0
    dec_ref r13
    dec_ref r27
    goto L39
L54:
    dec_ref r0
    dec_ref r13
    dec_ref r75
    goto L39
L55:
    dec_ref r81
    goto L39

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12, r13 :: object
    r14 :: str
    r15 :: dict
    r16, r17 :: object
    r18 :: str
    r19 :: dict
    r20, r21 :: object
    r22 :: str
    r23 :: dict
    r24, r25 :: object
    r26 :: str
    r27 :: dict
    r28, r29 :: object
    r30 :: str
    r31 :: dict
    r32 :: object
    r33 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L11 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('wraps',)
    r6 = 'functools'
    r7 = dank_mids.brownie_patch.overloaded.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L11 (error at <module>:1) else goto L4
L4:
    functools = r8 :: module
    dec_ref r8
    r9 = ('MethodType',)
    r10 = 'types'
    r11 = dank_mids.brownie_patch.overloaded.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L11 (error at <module>:2) else goto L5
L5:
    types = r12 :: module
    dec_ref r12
    r13 = ('Any', 'Dict', 'Optional', 'Union')
    r14 = 'typing'
    r15 = dank_mids.brownie_patch.overloaded.globals :: static
    r16 = CPyImport_ImportFromMany(r14, r13, r13, r15)
    if is_error(r16) goto L11 (error at <module>:3) else goto L6
L6:
    typing = r16 :: module
    dec_ref r16
    r17 = ('Contract',)
    r18 = 'brownie'
    r19 = dank_mids.brownie_patch.overloaded.globals :: static
    r20 = CPyImport_ImportFromMany(r18, r17, r17, r19)
    if is_error(r20) goto L11 (error at <module>:5) else goto L7
L7:
    brownie = r20 :: module
    dec_ref r20
    r21 = ('ContractCall', 'ContractTx', 'OverloadedMethod')
    r22 = 'brownie.network.contract'
    r23 = dank_mids.brownie_patch.overloaded.globals :: static
    r24 = CPyImport_ImportFromMany(r22, r21, r21, r23)
    if is_error(r24) goto L11 (error at <module>:6) else goto L8
L8:
    brownie.network.contract = r24 :: module
    dec_ref r24
    r25 = ('_get_coroutine_fn', '_skip_proc_pool')
    r26 = 'dank_mids.brownie_patch.call'
    r27 = dank_mids.brownie_patch.overloaded.globals :: static
    r28 = CPyImport_ImportFromMany(r26, r25, r25, r27)
    if is_error(r28) goto L11 (error at <module>:7) else goto L9
L9:
    dank_mids.brownie_patch.call = r28 :: module
    dec_ref r28
    r29 = ('DankWeb3',)
    r30 = 'dank_mids.helpers._helpers'
    r31 = dank_mids.brownie_patch.overloaded.globals :: static
    r32 = CPyImport_ImportFromMany(r30, r29, r29, r31)
    if is_error(r32) goto L11 (error at <module>:8) else goto L10
L10:
    dank_mids.helpers._helpers = r32 :: module
    dec_ref r32
    return 1
L11:
    r33 = <error> :: None
    return r33

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: object
    r9 :: object_ptr
    r10 :: object_ptr[1]
    r11 :: c_ptr
    r12 :: native_int[1]
    r13 :: c_ptr
    r14 :: object
    r15 :: dict
    r16, r17 :: str
    r18 :: bit
    r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: dict
    r26 :: object
    r27, r28, r29, r30 :: str
    r31 :: set
    r32 :: i32
    r33 :: bit
    r34 :: i32
    r35 :: bit
    r36 :: i32
    r37 :: bit
    r38 :: i32
    r39 :: bit
    r40 :: dict
    r41 :: str
    r42 :: i32
    r43 :: bit
    r44, r45, r46, r47, r48, r49 :: str
    r50 :: set
    r51 :: i32
    r52 :: bit
    r53 :: i32
    r54 :: bit
    r55 :: i32
    r56 :: bit
    r57 :: i32
    r58 :: bit
    r59 :: i32
    r60 :: bit
    r61 :: i32
    r62 :: bit
    r63 :: dict
    r64 :: str
    r65 :: i32
    r66 :: bit
    r67 :: dict
    r68 :: str
    r69 :: object
    r70 :: str
    r71 :: object
    r72 :: str
    r73 :: object
    r74 :: dict
    r75 :: str
    r76 :: i32
    r77 :: bit
    r78 :: dict
    r79 :: str
    r80 :: object
    r81 :: str
    r82 :: object
    r83 :: str
    r84 :: object
    r85 :: dict
    r86 :: str
    r87 :: i32
    r88 :: bit
    r89 :: dict
    r90 :: str
    r91 :: object
    r92 :: str
    r93 :: object
    r94 :: str
    r95 :: object
    r96 :: dict
    r97 :: str
    r98 :: i32
    r99 :: bit
    r100 :: tuple[object, object, object]
    r101 :: object
    r102 :: str
    r103 :: object
    r104 :: bit
    r105 :: dict
    r106 :: str
    r107 :: object
    r108 :: str
    r109 :: object
    r110 :: str
    r111 :: object
    r112 :: dict
    r113 :: str
    r114 :: i32
    r115, r116 :: bit
    r117, r118, r119 :: tuple[object, object, object]
    r120 :: dict
    r121 :: str
    r122 :: object
    r123 :: dict
    r124 :: str
    r125 :: i32
    r126, r127 :: bit
    r128 :: dict
    r129 :: str
    r130 :: object
    r131 :: str
    r132 :: object
    r133 :: dict
    r134 :: str
    r135 :: object
    r136 :: str
    r137 :: object
    r138 :: dict
    r139 :: str
    r140 :: object
    r141 :: str
    r142 :: object
    r143 :: dict
    r144 :: str
    r145 :: object
    r146 :: str
    r147, r148, r149, r150, r151 :: object
    r152, r153 :: dict
    r154 :: str
    r155 :: i32
    r156 :: bit
    r157 :: dict
    r158 :: str
    r159 :: object
    r160 :: str
    r161 :: object
    r162 :: dict
    r163 :: str
    r164 :: object
    r165 :: str
    r166 :: object
    r167 :: dict
    r168 :: str
    r169 :: object
    r170 :: str
    r171 :: object
    r172 :: dict
    r173 :: str
    r174 :: object
    r175 :: str
    r176 :: object
    r177 :: dict
    r178 :: str
    r179 :: object
    r180 :: str
    r181, r182, r183, r184, r185, r186 :: object
    r187, r188 :: dict
    r189 :: str
    r190 :: i32
    r191 :: bit
    r192, r193, r194, r195, r196, r197, r198, r199, r200, r201 :: str
    r202 :: tuple[str, str, str, str, str, str, str, str, str, str]
    r203 :: dict
    r204 :: str
    r205 :: object
    r206 :: i32
    r207 :: bit
    r208, r209 :: bytes
    r210 :: tuple[bytes, bytes]
    r211 :: dict
    r212 :: str
    r213 :: object
    r214 :: i32
    r215 :: bit
    r216 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L80 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Dict', 'Final')
    r6 = 'typing'
    r7 = dank_mids.constants.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L80 (error at <module>:2) else goto L4
L4:
    typing = r8 :: module
    dec_ref r8
    r9 = load_address multicall.constants :: module
    r10 = [r9]
    r11 = load_address r10
    r12 = [4]
    r13 = load_address r12
    r14 = (('multicall.constants', 'multicall', 'multicall'),)
    r15 = dank_mids.constants.globals :: static
    r16 = 'dank_mids\\constants.py'
    r17 = '<module>'
    r18 = CPyImport_ImportMany(r14, r11, r15, r16, r17, r13)
    if not r18 goto L80 else goto L5 :: bool
L5:
    r19 = ('BlockNumber',)
    r20 = 'eth_typing'
    r21 = dank_mids.constants.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L80 (error at <module>:5) else goto L6
L6:
    eth_typing = r22 :: module
    dec_ref r22
    r23 = ('Network',)
    r24 = 'multicall.constants'
    r25 = dank_mids.constants.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L80 (error at <module>:6) else goto L7
L7:
    multicall.constants = r26 :: module
    dec_ref r26
    r27 = 'payload too large'
    r28 = 'content length too large'
    r29 = 'request entity too large'
    r30 = 'batch limit exceeded'
    r31 = PySet_New(0)
    if is_error(r31) goto L80 (error at <module>:8) else goto L8
L8:
    r32 = PySet_Add(r31, r27)
    r33 = r32 >= 0 :: signed
    if not r33 goto L81 (error at <module>:8) else goto L9 :: bool
L9:
    r34 = PySet_Add(r31, r28)
    r35 = r34 >= 0 :: signed
    if not r35 goto L81 (error at <module>:8) else goto L10 :: bool
L10:
    r36 = PySet_Add(r31, r29)
    r37 = r36 >= 0 :: signed
    if not r37 goto L81 (error at <module>:8) else goto L11 :: bool
L11:
    r38 = PySet_Add(r31, r30)
    r39 = r38 >= 0 :: signed
    if not r39 goto L81 (error at <module>:8) else goto L12 :: bool
L12:
    dank_mids.constants.TOO_MUCH_DATA_ERRS = r31 :: static
    r40 = dank_mids.constants.globals :: static
    r41 = 'TOO_MUCH_DATA_ERRS'
    r42 = CPyDict_SetItem(r40, r41, r31)
    dec_ref r31
    r43 = r42 >= 0 :: signed
    if not r43 goto L80 (error at <module>:8) else goto L13 :: bool
L13:
    r44 = 'connection reset by peer'
    r45 = 'server disconnected'
    r46 = 'execution aborted (timeout ='
    r47 = 'batch limit exceeded'
    r48 = 'request timed out'
    r49 = 'evm timeout'
    r50 = PySet_New(0)
    if is_error(r50) goto L80 (error at <module>:19) else goto L14
L14:
    r51 = PySet_Add(r50, r44)
    r52 = r51 >= 0 :: signed
    if not r52 goto L82 (error at <module>:19) else goto L15 :: bool
L15:
    r53 = PySet_Add(r50, r45)
    r54 = r53 >= 0 :: signed
    if not r54 goto L82 (error at <module>:19) else goto L16 :: bool
L16:
    r55 = PySet_Add(r50, r46)
    r56 = r55 >= 0 :: signed
    if not r56 goto L82 (error at <module>:19) else goto L17 :: bool
L17:
    r57 = PySet_Add(r50, r47)
    r58 = r57 >= 0 :: signed
    if not r58 goto L82 (error at <module>:19) else goto L18 :: bool
L18:
    r59 = PySet_Add(r50, r48)
    r60 = r59 >= 0 :: signed
    if not r60 goto L82 (error at <module>:19) else goto L19 :: bool
L19:
    r61 = PySet_Add(r50, r49)
    r62 = r61 >= 0 :: signed
    if not r62 goto L82 (error at <module>:19) else goto L20 :: bool
L20:
    dank_mids.constants.RETRY_ERRS = r50 :: static
    r63 = dank_mids.constants.globals :: static
    r64 = 'RETRY_ERRS'
    r65 = CPyDict_SetItem(r63, r64, r50)
    dec_ref r50
    r66 = r65 >= 0 :: signed
    if not r66 goto L80 (error at <module>:19) else goto L21 :: bool
L21:
    r67 = dank_mids.constants.globals :: static
    r68 = 'multicall'
    r69 = CPyDict_GetItem(r67, r68)
    if is_error(r69) goto L80 (error at <module>:32) else goto L22
L22:
    r70 = 'constants'
    r71 = CPyObject_GetAttr(r69, r70)
    dec_ref r69
    if is_error(r71) goto L80 (error at <module>:32) else goto L23
L23:
    r72 = 'GAS_LIMIT'
    r73 = CPyObject_GetAttr(r71, r72)
    dec_ref r71
    if is_error(r73) goto L80 (error at <module>:32) else goto L24
L24:
    dank_mids.constants.GAS_LIMIT = r73 :: static
    r74 = dank_mids.constants.globals :: static
    r75 = 'GAS_LIMIT'
    r76 = CPyDict_SetItem(r74, r75, r73)
    dec_ref r73
    r77 = r76 >= 0 :: signed
    if not r77 goto L80 (error at <module>:32) else goto L25 :: bool
L25:
    r78 = dank_mids.constants.globals :: static
    r79 = 'multicall'
    r80 = CPyDict_GetItem(r78, r79)
    if is_error(r80) goto L80 (error at <module>:38) else goto L26
L26:
    r81 = 'constants'
    r82 = CPyObject_GetAttr(r80, r81)
    dec_ref r80
    if is_error(r82) goto L80 (error at <module>:38) else goto L27
L27:
    r83 = 'MULTICALL2_BYTECODE'
    r84 = CPyObject_GetAttr(r82, r83)
    dec_ref r82
    if is_error(r84) goto L80 (error at <module>:38) else goto L28
L28:
    dank_mids.constants.MULTICALL2_OVERRIDE_CODE = r84 :: static
    r85 = dank_mids.constants.globals :: static
    r86 = 'MULTICALL2_OVERRIDE_CODE'
    r87 = CPyDict_SetItem(r85, r86, r84)
    dec_ref r84
    r88 = r87 >= 0 :: signed
    if not r88 goto L80 (error at <module>:38) else goto L29 :: bool
L29:
    r89 = dank_mids.constants.globals :: static
    r90 = 'multicall'
    r91 = CPyDict_GetItem(r89, r90)
    if is_error(r91) goto L33 (error at <module>:45) else goto L30
L30:
    r92 = 'constants'
    r93 = CPyObject_GetAttr(r91, r92)
    dec_ref r91
    if is_error(r93) goto L33 (error at <module>:45) else goto L31
L31:
    r94 = 'MULTICALL3_BYTECODE'
    r95 = CPyObject_GetAttr(r93, r94)
    dec_ref r93
    if is_error(r95) goto L33 (error at <module>:45) else goto L32
L32:
    r96 = dank_mids.constants.globals :: static
    r97 = '__MULTICALL3_OVERRIDE_CODE'
    r98 = CPyDict_SetItem(r96, r97, r95)
    dec_ref r95
    r99 = r98 >= 0 :: signed
    if not r99 goto L33 (error at <module>:45) else goto L44 :: bool
L33:
    r100 = CPy_CatchError()
    r101 = builtins :: module
    r102 = 'AttributeError'
    r103 = CPyObject_GetAttr(r101, r102)
    if is_error(r103) goto L42 (error at <module>:50) else goto L34
L34:
    r104 = CPy_ExceptionMatches(r103)
    dec_ref r103
    if r104 goto L35 else goto L39 :: bool
L35:
    r105 = dank_mids.constants.globals :: static
    r106 = 'multicall'
    r107 = CPyDict_GetItem(r105, r106)
    if is_error(r107) goto L42 (error at <module>:51) else goto L36
L36:
    r108 = 'constants'
    r109 = CPyObject_GetAttr(r107, r108)
    dec_ref r107
    if is_error(r109) goto L42 (error at <module>:51) else goto L37
L37:
    r110 = 'MULTICALL2_BYTECODE'
    r111 = CPyObject_GetAttr(r109, r110)
    dec_ref r109
    if is_error(r111) goto L42 (error at <module>:51) else goto L38
L38:
    r112 = dank_mids.constants.globals :: static
    r113 = '__MULTICALL3_OVERRIDE_CODE'
    r114 = CPyDict_SetItem(r112, r113, r111)
    dec_ref r111
    r115 = r114 >= 0 :: signed
    if not r115 goto L42 (error at <module>:51) else goto L41 :: bool
L39:
    CPy_Reraise()
    if not 0 goto L42 else goto L83 :: bool
L40:
    unreachable
L41:
    CPy_RestoreExcInfo(r100)
    dec_ref r100
    goto L44
L42:
    CPy_RestoreExcInfo(r100)
    dec_ref r100
    r116 = CPy_KeepPropagating()
    if not r116 goto L45 else goto L43 :: bool
L43:
    unreachable
L44:
    r117 = <error> :: tuple[object, object, object]
    r118 = r117
    goto L46
L45:
    r119 = CPy_CatchError()
    r118 = r119
L46:
    r120 = dank_mids.constants.globals :: static
    r121 = '__MULTICALL3_OVERRIDE_CODE'
    r122 = CPyDict_GetItem(r120, r121)
    if is_error(r122) goto L51 (error at <module>:53) else goto L47
L47:
    dank_mids.constants.MULTICALL3_OVERRIDE_CODE = r122 :: static
    r123 = dank_mids.constants.globals :: static
    r124 = 'MULTICALL3_OVERRIDE_CODE'
    r125 = CPyDict_SetItem(r123, r124, r122)
    dec_ref r122
    r126 = r125 >= 0 :: signed
    if not r126 goto L51 (error at <module>:53) else goto L48 :: bool
L48:
    if is_error(r118) goto L55 else goto L49
L49:
    CPy_Reraise()
    if not 0 goto L51 else goto L84 :: bool
L50:
    unreachable
L51:
    if is_error(r118) goto L53 else goto L52
L52:
    CPy_RestoreExcInfo(r118)
    xdec_ref r118
L53:
    r127 = CPy_KeepPropagating()
    if not r127 goto L80 else goto L54 :: bool
L54:
    unreachable
L55:
    r128 = dank_mids.constants.globals :: static
    r129 = 'Network'
    r130 = CPyDict_GetItem(r128, r129)
    if is_error(r130) goto L80 (error at <module>:56) else goto L56
L56:
    r131 = 'Mainnet'
    r132 = CPyObject_GetAttr(r130, r131)
    dec_ref r130
    if is_error(r132) goto L80 (error at <module>:56) else goto L57
L57:
    r133 = dank_mids.constants.globals :: static
    r134 = 'Network'
    r135 = CPyDict_GetItem(r133, r134)
    if is_error(r135) goto L85 (error at <module>:57) else goto L58
L58:
    r136 = 'Fantom'
    r137 = CPyObject_GetAttr(r135, r136)
    dec_ref r135
    if is_error(r137) goto L85 (error at <module>:57) else goto L59
L59:
    r138 = dank_mids.constants.globals :: static
    r139 = 'Network'
    r140 = CPyDict_GetItem(r138, r139)
    if is_error(r140) goto L86 (error at <module>:58) else goto L60
L60:
    r141 = 'Arbitrum'
    r142 = CPyObject_GetAttr(r140, r141)
    dec_ref r140
    if is_error(r142) goto L86 (error at <module>:58) else goto L61
L61:
    r143 = dank_mids.constants.globals :: static
    r144 = 'Network'
    r145 = CPyDict_GetItem(r143, r144)
    if is_error(r145) goto L87 (error at <module>:59) else goto L62
L62:
    r146 = 'Optimism'
    r147 = CPyObject_GetAttr(r145, r146)
    dec_ref r145
    if is_error(r147) goto L87 (error at <module>:59) else goto L63
L63:
    r148 = object 12336033
    r149 = object 16572242
    r150 = object 821923
    r151 = object 722566
    r152 = CPyDict_Build(4, r132, r148, r137, r149, r142, r150, r147, r151)
    dec_ref r132
    dec_ref r137
    dec_ref r142
    dec_ref r147
    if is_error(r152) goto L80 (error at <module>:55) else goto L64
L64:
    dank_mids.constants.MULTICALL2_DEPLOY_BLOCKS = r152 :: static
    r153 = dank_mids.constants.globals :: static
    r154 = 'MULTICALL2_DEPLOY_BLOCKS'
    r155 = CPyDict_SetItem(r153, r154, r152)
    dec_ref r152
    r156 = r155 >= 0 :: signed
    if not r156 goto L80 (error at <module>:55) else goto L65 :: bool
L65:
    r157 = dank_mids.constants.globals :: static
    r158 = 'Network'
    r159 = CPyDict_GetItem(r157, r158)
    if is_error(r159) goto L80 (error at <module>:64) else goto L66
L66:
    r160 = 'Mainnet'
    r161 = CPyObject_GetAttr(r159, r160)
    dec_ref r159
    if is_error(r161) goto L80 (error at <module>:64) else goto L67
L67:
    r162 = dank_mids.constants.globals :: static
    r163 = 'Network'
    r164 = CPyDict_GetItem(r162, r163)
    if is_error(r164) goto L88 (error at <module>:65) else goto L68
L68:
    r165 = 'Fantom'
    r166 = CPyObject_GetAttr(r164, r165)
    dec_ref r164
    if is_error(r166) goto L88 (error at <module>:65) else goto L69
L69:
    r167 = dank_mids.constants.globals :: static
    r168 = 'Network'
    r169 = CPyDict_GetItem(r167, r168)
    if is_error(r169) goto L89 (error at <module>:66) else goto L70
L70:
    r170 = 'Arbitrum'
    r171 = CPyObject_GetAttr(r169, r170)
    dec_ref r169
    if is_error(r171) goto L89 (error at <module>:66) else goto L71
L71:
    r172 = dank_mids.constants.globals :: static
    r173 = 'Network'
    r174 = CPyDict_GetItem(r172, r173)
    if is_error(r174) goto L90 (error at <module>:67) else goto L72
L72:
    r175 = 'Optimism'
    r176 = CPyObject_GetAttr(r174, r175)
    dec_ref r174
    if is_error(r176) goto L90 (error at <module>:67) else goto L73
L73:
    r177 = dank_mids.constants.globals :: static
    r178 = 'Network'
    r179 = CPyDict_GetItem(r177, r178)
    if is_error(r179) goto L91 (error at <module>:68) else goto L74
L74:
    r180 = 'Base'
    r181 = CPyObject_GetAttr(r179, r180)
    dec_ref r179
    if is_error(r181) goto L91 (error at <module>:68) else goto L75
L75:
    r182 = object 14353601
    r183 = object 33001987
    r184 = object 7654707
    r185 = object 4286263
    r186 = object 5022
    r187 = CPyDict_Build(5, r161, r182, r166, r183, r171, r184, r176, r185, r181, r186)
    dec_ref r161
    dec_ref r166
    dec_ref r171
    dec_ref r176
    dec_ref r181
    if is_error(r187) goto L80 (error at <module>:63) else goto L76
L76:
    dank_mids.constants.MULTICALL3_DEPLOY_BLOCKS = r187 :: static
    r188 = dank_mids.constants.globals :: static
    r189 = 'MULTICALL3_DEPLOY_BLOCKS'
    r190 = CPyDict_SetItem(r188, r189, r187)
    dec_ref r187
    r191 = r190 >= 0 :: signed
    if not r191 goto L80 (error at <module>:63) else goto L77 :: bool
L77:
    r192 = '0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000094e6f206163636573730000000000000000000000000000000000000000000000'
    r193 = '0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e6d696e7420697320706175736564000000000000000000000000000000000000'
    r194 = '0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000016496e76616c6964206574686572207472616e7366657200000000000000000000'
    r195 = '0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e4e4f4e5f454d5054595f44415441000000000000000000000000000000000000'
    r196 = '0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000246d73672e736967206973206e6f742061737369676e656420746f207375626d6f64756c6500000000000000000000000000000000000000000000000000000000'
    r197 = '0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000346f6e6c792077726170706564206e617469766520636f6e747261637420636f756c642073656e64206e617469766520746f6b656e000000000000000000000000'
    r198 = '0x08c379a000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000013434f4e54524f4c4c45525f52454a454354454400000000000000000000000000'
    r199 = '0x08c379a0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000204469616d6f6e643a2046756e6374696f6e20646f6573206e6f74206578697374'
    r200 = '0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001a66756e6374696f6e2073686f756c6420626520616c6c6f776564000000000000'
    r201 = '0x08c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001846756e6374696f6e20646f6573206e6f742065786973742e0000000000000000'
    inc_ref r192
    inc_ref r193
    inc_ref r194
    inc_ref r195
    inc_ref r196
    inc_ref r197
    inc_ref r198
    inc_ref r199
    inc_ref r200
    inc_ref r201
    r202 = (r192, r193, r194, r195, r196, r197, r198, r199, r200, r201)
    dank_mids.constants.BAD_HEXES = r202 :: static
    r203 = dank_mids.constants.globals :: static
    r204 = 'BAD_HEXES'
    r205 = box(tuple[str, str, str, str, str, str, str, str, str, str], r202)
    r206 = CPyDict_SetItem(r203, r204, r205)
    dec_ref r205
    r207 = r206 >= 0 :: signed
    if not r207 goto L80 (error at <module>:75) else goto L78 :: bool
L78:
    r208 = b'\x08\xc3y\xa0'
    r209 = b'4e487b71'
    inc_ref r208
    inc_ref r209
    r210 = (r208, r209)
    dank_mids.constants.REVERT_SELECTORS = r210 :: static
    r211 = dank_mids.constants.globals :: static
    r212 = 'REVERT_SELECTORS'
    r213 = box(tuple[bytes, bytes], r210)
    r214 = CPyDict_SetItem(r211, r212, r213)
    dec_ref r213
    r215 = r214 >= 0 :: signed
    if not r215 goto L80 (error at <module>:101) else goto L79 :: bool
L79:
    return 1
L80:
    r216 = <error> :: None
    return r216
L81:
    dec_ref r31
    goto L80
L82:
    dec_ref r50
    goto L80
L83:
    dec_ref r100
    goto L40
L84:
    xdec_ref r118
    goto L50
L85:
    dec_ref r132
    goto L80
L86:
    dec_ref r132
    dec_ref r137
    goto L80
L87:
    dec_ref r132
    dec_ref r137
    dec_ref r142
    goto L80
L88:
    dec_ref r161
    goto L80
L89:
    dec_ref r161
    dec_ref r166
    goto L80
L90:
    dec_ref r161
    dec_ref r166
    dec_ref r171
    goto L80
L91:
    dec_ref r161
    dec_ref r166
    dec_ref r171
    dec_ref r176
    goto L80

def UIDGenerator.__init__(self):
    self :: dank_mids._uid.UIDGenerator
    r0 :: str
    r1 :: dict
    r2 :: str
    r3 :: object
    r4 :: object[1]
    r5 :: object_ptr
    r6, r7 :: object
    r8 :: None
L0:
    self._value = -2
    r0 = 'uid'
    r1 = dank_mids._uid.globals :: static
    r2 = 'AlertingRLock'
    r3 = CPyDict_GetItem(r1, r2)
    if is_error(r3) goto L3 (error at __init__:24) else goto L1
L1:
    r4 = [r0]
    r5 = load_address r4
    r6 = ('name',)
    r7 = _PyObject_Vectorcall(r3, r5, 0, r6)
    dec_ref r3
    if is_error(r7) goto L3 (error at __init__:24) else goto L2
L2:
    self._lock = r7
    return 1
L3:
    r8 = <error> :: None
    return r8

def UIDGenerator.latest(self):
    self :: dank_mids._uid.UIDGenerator
    r0 :: int
L0:
    r0 = self._value
    return r0

def UIDGenerator.next(self):
    self :: dank_mids._uid.UIDGenerator
    r0, r1 :: object
    r2 :: str
    r3 :: object
    r4 :: str
    r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8 :: object
    r9, r10 :: int
    r11 :: bool
    r12, r13 :: tuple[object, object, object]
    r14 :: object
    r15 :: object[4]
    r16 :: object_ptr
    r17 :: object
    r18 :: bit
    r19 :: int
L0:
    r0 = self._lock
    r1 = PyObject_Type(r0)
    r2 = '__exit__'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L20 (error at next:48) else goto L1
L1:
    r4 = '__enter__'
    r5 = CPyObject_GetAttr(r1, r4)
    dec_ref r1
    if is_error(r5) goto L21 (error at next:48) else goto L2
L2:
    r6 = [r0]
    r7 = load_address r6
    r8 = _PyObject_Vectorcall(r5, r7, 1, 0)
    dec_ref r5
    if is_error(r8) goto L21 (error at next:48) else goto L22
L3:
L4:
    r9 = borrow self._value
    r10 = CPyTagged_Add(r9, 2)
    inc_ref r10 :: int
    self._value = r10
L5:
    r12 = <error> :: tuple[object, object, object]
    r13 = r12
L6:
    if 1 goto L7 else goto L23 :: bool
L7:
    r14 = load_address _Py_NoneStruct
    r15 = [r0, r14, r14, r14]
    r16 = load_address r15
    r17 = _PyObject_Vectorcall(r3, r16, 4, 0)
    dec_ref r3
    if is_error(r17) goto L24 (error at next:48) else goto L25
L8:
    dec_ref r0
L9:
    if is_error(r13) goto L12 else goto L26
L10:
    CPy_Reraise()
    if not 0 goto L14 else goto L27 :: bool
L11:
    unreachable
L12:
    if is_error(r10) goto L18 else goto L13
L13:
    return r10
L14:
    if is_error(r13) goto L16 else goto L15
L15:
    CPy_RestoreExcInfo(r13)
    xdec_ref r13
L16:
    r18 = CPy_KeepPropagating()
    if not r18 goto L19 else goto L17 :: bool
L17:
    unreachable
L18:
    unreachable
L19:
    r19 = <error> :: int
    return r19
L20:
    dec_ref r0
    dec_ref r1
    goto L19
L21:
    dec_ref r0
    dec_ref r3
    goto L19
L22:
    dec_ref r8
    goto L3
L23:
    dec_ref r0
    dec_ref r3
    goto L9
L24:
    dec_ref r0
    xdec_ref r10 :: int
    goto L14
L25:
    dec_ref r17
    goto L8
L26:
    xdec_ref r10 :: int
    goto L10
L27:
    xdec_ref r13
    goto L11

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11, r12 :: object
    r13 :: bool
    r14, r15, r16 :: str
    r17 :: tuple
    r18 :: i32
    r19 :: bit
    r20 :: dict
    r21 :: str
    r22 :: i32
    r23 :: bit
    r24 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L10 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('AlertingRLock',)
    r6 = 'dank_mids.helpers._lock'
    r7 = dank_mids._uid.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L10 (error at <module>:1) else goto L4
L4:
    dank_mids.helpers._lock = r8 :: module
    dec_ref r8
    r9 = <error> :: object
    r10 = 'dank_mids._uid'
    r11 = dank_mids._uid.UIDGenerator_template :: type
    r12 = CPyType_FromTemplate(r11, r9, r10)
    if is_error(r12) goto L10 (error at <module>:4) else goto L5
L5:
    r13 = UIDGenerator_trait_vtable_setup()
    if is_error(r13) goto L11 (error at <module>:-1) else goto L6
L6:
    r14 = '__mypyc_attrs__'
    r15 = '_value'
    r16 = '_lock'
    r17 = PyTuple_Pack(2, r15, r16)
    if is_error(r17) goto L11 (error at <module>:4) else goto L7
L7:
    r18 = PyObject_SetAttr(r12, r14, r17)
    dec_ref r17
    r19 = r18 >= 0 :: signed
    if not r19 goto L11 (error at <module>:4) else goto L8 :: bool
L8:
    dank_mids._uid.UIDGenerator = r12 :: type
    r20 = dank_mids._uid.globals :: static
    r21 = 'UIDGenerator'
    r22 = CPyDict_SetItem(r20, r21, r12)
    dec_ref r12
    r23 = r22 >= 0 :: signed
    if not r23 goto L10 (error at <module>:4) else goto L9 :: bool
L9:
    return 1
L10:
    r24 = <error> :: None
    return r24
L11:
    dec_ref r12
    goto L10

def _create_named_task(awaitable):
    awaitable, r0 :: object
    r1 :: str
    r2 :: object
    r3, r4, r5 :: str
    r6 :: object
    r7 :: bool
    r8 :: object[2]
    r9 :: object_ptr
    r10, r11, r12 :: object
L0:
    r0 = PyObject_Type(awaitable)
    r1 = '__name__'
    r2 = CPyObject_GetAttr(r0, r1)
    dec_ref r0
    if is_error(r2) goto L8 (error at _create_named_task:35) else goto L1
L1:
    r3 = cast(str, r2)
    if is_error(r3) goto L8 (error at _create_named_task:35) else goto L2
L2:
    r4 = ' via DankBatch'
    r5 = CPyStr_Build(2, r3, r4)
    dec_ref r3
    if is_error(r5) goto L8 (error at _create_named_task:35) else goto L3
L3:
    r6 = dank_mids._batch.create_task :: static
    if is_error(r6) goto L9 else goto L6
L4:
    r7 = raise NameError('value for final name "create_task" was not set')
    if not r7 goto L8 (error at _create_named_task:35) else goto L5 :: bool
L5:
    unreachable
L6:
    r8 = [awaitable, r5]
    r9 = load_address r8
    r10 = ('name',)
    r11 = _PyObject_Vectorcall(r6, r9, 1, r10)
    if is_error(r11) goto L10 (error at _create_named_task:35) else goto L7
L7:
    dec_ref r5
    return r11
L8:
    r12 = <error> :: object
    return r12
L9:
    dec_ref r5
    goto L4
L10:
    dec_ref r5
    goto L8

def DankBatch.__init__(self, controller, multicalls, rpc_calls):
    self :: dank_mids._batch.DankBatch
    controller :: object
    multicalls :: dict
    rpc_calls :: object
    r0 :: str
    r1 :: object
    r2 :: str
    r3, r4, r5 :: object
    r6 :: i32
    r7 :: bit
    r8 :: bool
    r9, r10 :: object
    r11 :: None
L0:
    inc_ref controller
    self.controller = controller
    inc_ref multicalls
    self.multicalls = multicalls
    inc_ref rpc_calls
    self.rpc_calls = rpc_calls
    self._awaited = 0
    r0 = 'batcher'
    r1 = CPyObject_GetAttr(controller, r0)
    if is_error(r1) goto L8 (error at __init__:74) else goto L1
L1:
    r2 = 'step'
    r3 = CPyObject_GetAttr(r1, r2)
    dec_ref r1
    if is_error(r3) goto L8 (error at __init__:74) else goto L2
L2:
    r4 = object 0
    r5 = PyObject_RichCompare(r3, r4, 0)
    if is_error(r5) goto L9 (error at __init__:74) else goto L3
L3:
    r6 = PyObject_IsTrue(r5)
    dec_ref r5
    r7 = r6 >= 0 :: signed
    if not r7 goto L9 (error at __init__:74) else goto L4 :: bool
L4:
    r8 = truncate r6: i32 to builtins.bool
    if r8 goto L5 else goto L10 :: bool
L5:
    r9 = r3
    goto L7
L6:
    r10 = object 0
    inc_ref r10
    r9 = r10
L7:
    self._check_len = r9
    return 1
L8:
    r11 = <error> :: None
    return r11
L9:
    dec_ref r3
    goto L8
L10:
    dec_ref r3
    goto L6

def DankBatch.__repr__(self):
    self :: dank_mids._batch.DankBatch
    r0 :: str
    r1 :: int
    r2 :: object
    r3 :: str
    r4, r5 :: object
    r6 :: object[1]
    r7 :: object_ptr
    r8 :: object
    r9, r10, r11, r12 :: str
L0:
    r0 = '<dank_mids.DankBatch object at '
    r1 = CPyTagged_Id(self)
    r2 = builtins :: module
    r3 = 'hex'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L6 (error at __repr__:77) else goto L1
L1:
    r5 = box(int, r1)
    r6 = [r5]
    r7 = load_address r6
    r8 = _PyObject_Vectorcall(r4, r7, 1, 0)
    dec_ref r4
    if is_error(r8) goto L7 (error at __repr__:77) else goto L2
L2:
    dec_ref r5
    r9 = cast(str, r8)
    if is_error(r9) goto L5 (error at __repr__:77) else goto L3
L3:
    r10 = '>'
    r11 = CPyStr_Build(3, r0, r9, r10)
    dec_ref r9
    if is_error(r11) goto L5 (error at __repr__:77) else goto L4
L4:
    return r11
L5:
    r12 = <error> :: str
    return r12
L6:
    dec_ref r1 :: int
    goto L5
L7:
    dec_ref r5
    goto L5

def DankBatch.__await__(self):
    self :: dank_mids._batch.DankBatch
    r0 :: bool
    r1 :: str
    r2 :: object
    r3 :: str
    r4 :: object
    r5 :: object[1]
    r6 :: object_ptr
    r7 :: object
    r8 :: bool
    r9 :: dict
    r10 :: short_int
    r11 :: native_int
    r12 :: short_int
    r13 :: object
    r14 :: tuple[bool, short_int, object]
    r15 :: short_int
    r16 :: bool
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: object[3]
    r21 :: object_ptr
    r22, r23 :: object
    r24, r25 :: bit
    r26, r27, r28 :: object
    r29 :: str
    r30 :: i32
    r31, r32 :: bit
    r33 :: object
    r34 :: str
    r35 :: object[1]
    r36 :: object_ptr
    r37, r38 :: object
L0:
    r0 = self._awaited
    if r0 goto L1 else goto L5 :: bool
L1:
    r1 = 'The batch has already been awaited'
    r2 = builtins :: module
    r3 = 'RuntimeError'
    r4 = CPyObject_GetAttr(r2, r3)
    if is_error(r4) goto L18 (error at __await__:94) else goto L2
L2:
    r5 = [r1]
    r6 = load_address r5
    r7 = _PyObject_Vectorcall(r4, r6, 1, 0)
    dec_ref r4
    if is_error(r7) goto L18 (error at __await__:94) else goto L3
L3:
    CPy_Raise(r7)
    dec_ref r7
    if not 0 goto L18 (error at __await__:94) else goto L4 :: bool
L4:
    unreachable
L5:
    self._awaited = 1
    r9 = self.multicalls
    r10 = 0
    r11 = PyDict_Size(r9)
    r12 = r11 << 1
    r13 = CPyDict_GetValuesIter(r9)
    if is_error(r13) goto L19 (error at __await__:96) else goto L6
L6:
    r14 = CPyDict_NextValue(r13, r10)
    r15 = r14[1]
    r10 = r15
    r16 = r14[0]
    if r16 goto L7 else goto L20 :: bool
L7:
    r17 = r14[2]
    dec_ref r14
    r18 = 'start'
    r19 = box(bool, 0)
    r20 = [r17, self, r19]
    r21 = load_address r20
    r22 = ('cleanup',)
    r23 = PyObject_VectorcallMethod(r18, r21, 9223372036854775810, r22)
    if is_error(r23) goto L21 (error at __await__:97) else goto L22
L8:
    dec_ref r17
L9:
    r24 = CPyDict_CheckSize(r9, r12)
    if not r24 goto L23 (error at __await__:96) else goto L6 :: bool
L10:
    r25 = CPy_NoErrOccurred()
    if not r25 goto L18 (error at __await__:96) else goto L11 :: bool
L11:
    r26 = self.rpc_calls
    r27 = PyObject_GetIter(r26)
    dec_ref r26
    if is_error(r27) goto L18 (error at __await__:98) else goto L12
L12:
    r28 = PyIter_Next(r27)
    if is_error(r28) goto L24 else goto L13
L13:
    r29 = '_batch'
    r30 = PyObject_SetAttr(r28, r29, self)
    dec_ref r28
    r31 = r30 >= 0 :: signed
    if not r31 goto L25 (error at __await__:99) else goto L12 :: bool
L14:
    r32 = CPy_NoErrOccurred()
    if not r32 goto L18 (error at __await__:98) else goto L15 :: bool
L15:
    r33 = self._await()
    if is_error(r33) goto L18 (error at __await__:100) else goto L16
L16:
    r34 = '__await__'
    r35 = [r33]
    r36 = load_address r35
    r37 = PyObject_VectorcallMethod(r34, r36, 9223372036854775809, 0)
    if is_error(r37) goto L26 (error at __await__:100) else goto L17
L17:
    dec_ref r33
    return r37
L18:
    r38 = <error> :: object
    return r38
L19:
    dec_ref r9
    goto L18
L20:
    dec_ref r9
    dec_ref r13
    dec_ref r14
    goto L10
L21:
    dec_ref r9
    dec_ref r13
    dec_ref r17
    goto L18
L22:
    dec_ref r23
    goto L8
L23:
    dec_ref r9
    dec_ref r13
    goto L18
L24:
    dec_ref r27
    goto L14
L25:
    dec_ref r27
    goto L18
L26:
    dec_ref r33
    goto L18

def _await_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    type, value, traceback, arg, r0, r1, r2, r3 :: object
    r4 :: dank_mids._batch._await_DankBatch_env
    r5 :: int
    r6 :: object
    r7 :: bit
    r8 :: dank_mids._batch.DankBatch
    r9 :: object
    r10 :: list
    r11 :: bool
    r12 :: object
    r13 :: bool
    r14 :: list
    r15, r16 :: bool
    r17 :: list
    r18 :: ptr
    r19 :: native_int
    r20 :: list
    r21, r22 :: bool
    r23 :: list
    r24 :: ptr
    r25 :: native_int
    r26, r27 :: short_int
    r28 :: bit
    r29 :: list
    r30 :: short_int
    r31 :: native_int
    r32, r33 :: ptr
    r34 :: native_int
    r35 :: ptr
    r36 :: object
    r37 :: bool
    r38 :: short_int
    r39, r40 :: object
    r41 :: bit
    r42, r43 :: short_int
    r44, r45, r46 :: bool
    r47 :: list
    r48 :: ptr
    r49 :: native_int
    r50, r51 :: short_int
    r52 :: bit
    r53 :: list
    r54 :: ptr
    r55 :: native_int
    r56, r57 :: short_int
    r58 :: bit
    r59 :: list
    r60 :: short_int
    r61 :: native_int
    r62, r63 :: ptr
    r64 :: native_int
    r65 :: ptr
    r66 :: object
    r67 :: bool
    r68 :: list
    r69 :: short_int
    r70 :: native_int
    r71, r72 :: ptr
    r73 :: native_int
    r74 :: ptr
    r75 :: object
    r76 :: bool
    r77, r78 :: object
    r79 :: bool
    r80, r81, r82, r83, r84 :: object
    r85 :: bool
    r86 :: object
    r87 :: bit
    r88 :: tuple[object, object, object]
    r89 :: bool
    r90 :: object_ptr
    r91 :: object
    r92, r93 :: bool
    r94 :: tuple[object, object, object]
    r95 :: bool
    r96, r97 :: tuple[object, object, object]
    r98 :: bit
    r99, r100, r101 :: object
    r102 :: tuple[object, object, object]
    r103 :: bool
    r104 :: object
    r105 :: str
    r106 :: object
    r107 :: bit
    r108 :: object
    r109 :: bool
    r110, r111 :: object
    r112 :: ptr
    r113 :: object
    r114 :: bit
    r115 :: object
    r116 :: bool
    r117, r118 :: object
    r119 :: None
    r120 :: object
    r121 :: bool
    r122, r123 :: tuple[object, object, object]
    r124 :: bit
    r125, r126 :: short_int
    r127 :: bool
    r128, r129 :: short_int
    r130 :: bool
    r131 :: union[object, None]
    r132 :: object
    r133 :: bit
    r134 :: union[object, None]
    r135 :: object
    r136 :: bool
    r137, r138, r139, r140, r141 :: object
    r142 :: bool
    r143 :: object
    r144 :: bit
    r145 :: tuple[object, object, object]
    r146 :: bool
    r147 :: object_ptr
    r148 :: object
    r149, r150 :: bool
    r151 :: tuple[object, object, object]
    r152 :: bool
    r153, r154 :: tuple[object, object, object]
    r155 :: bit
    r156, r157, r158, r159 :: object
    r160 :: bool
    r161, r162, r163 :: bit
    r164 :: bool
    r165 :: object
L0:
    r0 = <error> :: object
    r1 = r0
    r2 = <error> :: object
    r3 = r2
    r4 = __mypyc_self__.__mypyc_env__
    if is_error(r4) goto L151 (error at _await:102) else goto L1
L1:
    r5 = r4.__mypyc_next_label__
    if is_error(r5) goto L152 (error at _await:102) else goto L145
L2:
    r6 = load_address _Py_NoneStruct
    r7 = type != r6
    if r7 goto L153 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L150 (error at _await:102) else goto L4 :: bool
L4:
    unreachable
L5:
    r8 = r4.self
    if is_error(r8) goto L152 (error at _await:114) else goto L6
L6:
    r9 = r8.coroutines
    dec_ref r8
    if is_error(r9) goto L152 (error at _await:114) else goto L7
L7:
    r10 = PySequence_List(r9)
    dec_ref r9
    if is_error(r10) goto L152 (error at _await:114) else goto L8
L8:
    r4.batches = r10; r11 = is_error
    if not r11 goto L152 (error at _await:114) else goto L9 :: bool
L9:
    r12 = box(None, 1)
    inc_ref r12
    r4.last_failure = r12; r13 = is_error
    if not r13 goto L152 (error at _await:116) else goto L10 :: bool
L10:
    r14 = r4.batches
    if is_error(r14) goto L152 (error at _await:117) else goto L11
L11:
    r4.__mypyc_temp__0 = r14; r15 = is_error
    if not r15 goto L152 (error at _await:-1) else goto L12 :: bool
L12:
    r4.__mypyc_temp__1 = 0; r16 = is_error
    if not r16 goto L152 (error at _await:-1) else goto L13 :: bool
L13:
    r17 = r4.batches
    if is_error(r17) goto L152 (error at _await:117) else goto L14
L14:
    r18 = get_element_ptr r17 ob_size :: PyVarObject
    r19 = load_mem r18 :: native_int*
    r20 = PyList_New(r19)
    if is_error(r20) goto L154 (error at _await:117) else goto L15
L15:
    r4.__mypyc_temp__2 = r17; r21 = is_error
    if not r21 goto L155 (error at _await:-1) else goto L16 :: bool
L16:
    r4.__mypyc_temp__3 = 0; r22 = is_error
    if not r22 goto L155 (error at _await:-1) else goto L17 :: bool
L17:
    r23 = r4.__mypyc_temp__2
    if is_error(r23) goto L155 (error at _await:117) else goto L18
L18:
    r24 = get_element_ptr r23 ob_size :: PyVarObject
    r25 = load_mem r24 :: native_int*
    dec_ref r23
    r26 = r25 << 1
    r27 = r4.__mypyc_temp__3
    if is_error(r27) goto L155 (error at _await:117) else goto L19
L19:
    r28 = r27 < r26 :: signed
    if r28 goto L20 else goto L29 :: bool
L20:
    r29 = r4.__mypyc_temp__2
    if is_error(r29) goto L155 (error at _await:117) else goto L21
L21:
    r30 = r4.__mypyc_temp__3
    if is_error(r30) goto L156 (error at _await:117) else goto L22
L22:
    r31 = r30 >> 1
    r32 = get_element_ptr r29 ob_item :: PyListObject
    r33 = load_mem r32 :: ptr*
    r34 = r31 * 8
    r35 = r33 + r34
    r36 = load_mem r35 :: builtins.object*
    inc_ref r36
    dec_ref r29
    r4.coro = r36; r37 = is_error
    if not r37 goto L155 (error at _await:117) else goto L23 :: bool
L23:
    r38 = r4.__mypyc_temp__3
    if is_error(r38) goto L155 (error at _await:-1) else goto L24
L24:
    r39 = r4.coro
    if is_error(r39) goto L155 (error at _await:117) else goto L25
L25:
    r40 = _create_named_task(r39)
    dec_ref r39
    if is_error(r40) goto L155 (error at _await:117) else goto L26
L26:
    r41 = CPyList_SetItemUnsafe(r20, r38, r40)
    if not r41 goto L155 (error at _await:117) else goto L27 :: bool
L27:
    r42 = r4.__mypyc_temp__3
    if is_error(r42) goto L155 (error at _await:117) else goto L28
L28:
    r43 = r42 + 2
    r4.__mypyc_temp__3 = r43; r44 = is_error
    if not r44 goto L155 (error at _await:117) else goto L17 :: bool
L29:
    r4.__mypyc_temp__4 = r20; r45 = is_error
    if not r45 goto L152 (error at _await:-1) else goto L30 :: bool
L30:
    r4.__mypyc_temp__5 = 0; r46 = is_error
    if not r46 goto L152 (error at _await:-1) else goto L31 :: bool
L31:
    r47 = r4.__mypyc_temp__0
    if is_error(r47) goto L152 (error at _await:117) else goto L32
L32:
    r48 = get_element_ptr r47 ob_size :: PyVarObject
    r49 = load_mem r48 :: native_int*
    dec_ref r47
    r50 = r49 << 1
    r51 = r4.__mypyc_temp__1
    if is_error(r51) goto L152 (error at _await:117) else goto L33
L33:
    r52 = r51 < r50 :: signed
    if r52 goto L34 else goto L157 :: bool
L34:
    r53 = r4.__mypyc_temp__4
    if is_error(r53) goto L152 (error at _await:117) else goto L35
L35:
    r54 = get_element_ptr r53 ob_size :: PyVarObject
    r55 = load_mem r54 :: native_int*
    dec_ref r53
    r56 = r55 << 1
    r57 = r4.__mypyc_temp__5
    if is_error(r57) goto L152 (error at _await:117) else goto L36
L36:
    r58 = r57 < r56 :: signed
    if r58 goto L37 else goto L157 :: bool
L37:
    r59 = r4.__mypyc_temp__0
    if is_error(r59) goto L152 (error at _await:117) else goto L38
L38:
    r60 = r4.__mypyc_temp__1
    if is_error(r60) goto L158 (error at _await:117) else goto L39
L39:
    r61 = r60 >> 1
    r62 = get_element_ptr r59 ob_item :: PyListObject
    r63 = load_mem r62 :: ptr*
    r64 = r61 * 8
    r65 = r63 + r64
    r66 = load_mem r65 :: builtins.object*
    inc_ref r66
    dec_ref r59
    r4.batch = r66; r67 = is_error
    if not r67 goto L152 (error at _await:117) else goto L40 :: bool
L40:
    r68 = r4.__mypyc_temp__4
    if is_error(r68) goto L152 (error at _await:117) else goto L41
L41:
    r69 = r4.__mypyc_temp__5
    if is_error(r69) goto L159 (error at _await:117) else goto L42
L42:
    r70 = r69 >> 1
    r71 = get_element_ptr r68 ob_item :: PyListObject
    r72 = load_mem r71 :: ptr*
    r73 = r70 * 8
    r74 = r72 + r73
    r75 = load_mem r74 :: builtins.object*
    inc_ref r75
    dec_ref r68
    r4.task = r75; r76 = is_error
    if not r76 goto L152 (error at _await:117) else goto L43 :: bool
L43:
    r77 = r4.task
    if is_error(r77) goto L79 (error at _await:119) else goto L44
L44:
    r78 = CPy_GetCoro(r77)
    dec_ref r77
    if is_error(r78) goto L79 (error at _await:119) else goto L45
L45:
    r4.__mypyc_temp__6 = r78; r79 = is_error
    if not r79 goto L79 (error at _await:-1) else goto L46 :: bool
L46:
    r80 = r4.__mypyc_temp__6
    if is_error(r80) goto L79 (error at _await:-1) else goto L47
L47:
    r81 = CPyIter_Next(r80)
    dec_ref r80
    if is_error(r81) goto L48 else goto L50
L48:
    r82 = CPy_FetchStopIterationValue()
    if is_error(r82) goto L79 (error at _await:119) else goto L49
L49:
    r83 = r82
    dec_ref r83
    goto L100
L50:
    r84 = r81
L51:
    r4.__mypyc_next_label__ = 2; r85 = is_error
    if not r85 goto L160 (error at _await:119) else goto L161 :: bool
L52:
    return r84
L53:
    r86 = load_address _Py_NoneStruct
    r87 = type != r86
    if r87 goto L54 else goto L56 :: bool
L54:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L57 (error at _await:119) else goto L162 :: bool
L55:
    unreachable
L56:
    inc_ref arg
    goto L74
L57:
    r88 = CPy_CatchError()
    r4.__mypyc_temp__7 = r88; r89 = is_error
    if not r89 goto L71 (error at _await:-1) else goto L58 :: bool
L58:
    r90 = load_address r1
    r91 = r4.__mypyc_temp__6
    if is_error(r91) goto L71 (error at _await:-1) else goto L59
L59:
    r92 = CPy_YieldFromErrorHandle(r91, r90)
    dec_ref r91
    if is_error(r92) goto L71 (error at _await:119) else goto L60
L60:
    if r92 goto L66 else goto L61 :: bool
L61:
    if is_error(r1) goto L62 else goto L64
L62:
    r93 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r93 goto L71 (error at _await:-1) else goto L163 :: bool
L63:
    unreachable
L64:
    inc_ref r1
    r84 = r1
    r94 = r4.__mypyc_temp__7
    if is_error(r94) goto L164 (error at _await:-1) else goto L65
L65:
    CPy_RestoreExcInfo(r94)
    dec_ref r94
    goto L51
L66:
    if is_error(r1) goto L67 else goto L69
L67:
    r95 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r95 goto L71 (error at _await:-1) else goto L165 :: bool
L68:
    unreachable
L69:
    inc_ref r1
    r83 = r1
    dec_ref r83
    r96 = r4.__mypyc_temp__7
    if is_error(r96) goto L71 (error at _await:-1) else goto L70
L70:
    CPy_RestoreExcInfo(r96)
    dec_ref r96
    goto L100
L71:
    r97 = r4.__mypyc_temp__7
    if is_error(r97) goto L79 (error at _await:-1) else goto L72
L72:
    CPy_RestoreExcInfo(r97)
    dec_ref r97
    r98 = CPy_KeepPropagating()
    if not r98 goto L79 else goto L166 :: bool
L73:
    unreachable
L74:
    r99 = r4.__mypyc_temp__6
    if is_error(r99) goto L167 (error at _await:-1) else goto L75
L75:
    r100 = CPyIter_Send(r99, arg)
    dec_ref r99
    dec_ref arg
    if is_error(r100) goto L77 else goto L76
L76:
    r84 = r100
    goto L51
L77:
    r101 = CPy_FetchStopIterationValue()
    if is_error(r101) goto L79 (error at _await:119) else goto L78
L78:
    r83 = r101
    dec_ref r83
    goto L100
L79:
    r102 = CPy_CatchError()
    r4.__mypyc_temp__8 = r102; r103 = is_error
    if not r103 goto L168 (error at _await:-1) else goto L80 :: bool
L80:
    r104 = builtins :: module
    r105 = 'Exception'
    r106 = CPyObject_GetAttr(r104, r105)
    if is_error(r106) goto L168 (error at _await:120) else goto L81
L81:
    r107 = CPy_ExceptionMatches(r106)
    dec_ref r106
    if r107 goto L82 else goto L169 :: bool
L82:
    r108 = CPy_GetExcValue()
    r4.e = r108; r109 = is_error
    if not r109 goto L168 (error at _await:120) else goto L83 :: bool
L83:
    r110 = r4.e
    if is_error(r110) goto L168 (error at _await:122) else goto L84
L84:
    r111 = dank_mids._exceptions.DankMidsInternalError :: type
    r112 = get_element_ptr r110 ob_type :: PyObject
    r113 = load_mem r112 :: builtins.object*
    dec_ref r110
    r114 = r113 == r111
    if r114 goto L91 else goto L85 :: bool
L85:
    r115 = dank_mids._batch.logger :: static
    if is_error(r115) goto L170 else goto L88
L86:
    r116 = raise NameError('value for final name "logger" was not set')
    if not r116 goto L97 (error at _await:123) else goto L171 :: bool
L87:
    unreachable
L88:
    r117 = r4.batch
    if is_error(r117) goto L168 (error at _await:123) else goto L89
L89:
    r118 = r4.e
    if is_error(r118) goto L172 (error at _await:123) else goto L90
L90:
    r119 = log_internal_error(r115, r117, r118)
    dec_ref r117
    dec_ref r118
    if is_error(r119) goto L168 (error at _await:123) else goto L91
L91:
    r120 = r4.task
    if is_error(r120) goto L168 (error at _await:124) else goto L92
L92:
    r4.last_failure = r120; r121 = is_error
    if not r121 goto L168 (error at _await:124) else goto L95 :: bool
L93:
    CPy_Reraise()
    if not 0 goto L97 else goto L173 :: bool
L94:
    unreachable
L95:
    r122 = r4.__mypyc_temp__8
    if is_error(r122) goto L152 (error at _await:-1) else goto L96
L96:
    CPy_RestoreExcInfo(r122)
    dec_ref r122
    goto L100
L97:
    r123 = r4.__mypyc_temp__8
    dec_ref r4
    if is_error(r123) goto L150 (error at _await:-1) else goto L98
L98:
    CPy_RestoreExcInfo(r123)
    dec_ref r123
    r124 = CPy_KeepPropagating()
    if not r124 goto L150 else goto L99 :: bool
L99:
    unreachable
L100:
    r125 = r4.__mypyc_temp__1
    if is_error(r125) goto L152 (error at _await:117) else goto L101
L101:
    r126 = r125 + 2
    r4.__mypyc_temp__1 = r126; r127 = is_error
    if not r127 goto L152 (error at _await:117) else goto L102 :: bool
L102:
    r128 = r4.__mypyc_temp__5
    if is_error(r128) goto L152 (error at _await:117) else goto L103
L103:
    r129 = r128 + 2
    r4.__mypyc_temp__5 = r129; r130 = is_error
    if not r130 goto L152 (error at _await:117) else goto L31 :: bool
L104:
    r131 = r4.last_failure
    if is_error(r131) goto L174 (error at _await:126) else goto L105
L105:
    r132 = load_address _Py_NoneStruct
    r133 = r131 != r132
    dec_ref r131
    if r133 goto L106 else goto L175 :: bool
L106:
    r134 = r4.last_failure
    if is_error(r134) goto L174 (error at _await:128) else goto L107
L107:
    r135 = CPy_GetCoro(r134)
    dec_ref r134
    if is_error(r135) goto L174 (error at _await:128) else goto L108
L108:
    r4.__mypyc_temp__9 = r135; r136 = is_error
    if not r136 goto L174 (error at _await:-1) else goto L109 :: bool
L109:
    r137 = r4.__mypyc_temp__9
    if is_error(r137) goto L174 (error at _await:-1) else goto L110
L110:
    r138 = CPyIter_Next(r137)
    dec_ref r137
    if is_error(r138) goto L176 else goto L113
L111:
    r139 = CPy_FetchStopIterationValue()
    if is_error(r139) goto L177 (error at _await:128) else goto L112
L112:
    r140 = r139
    dec_ref r140
    goto L142
L113:
    r141 = r138
L114:
    r4.__mypyc_next_label__ = 4; r142 = is_error
    if not r142 goto L178 (error at _await:128) else goto L179 :: bool
L115:
    return r141
L116:
    r143 = load_address _Py_NoneStruct
    r144 = type != r143
    if r144 goto L117 else goto L119 :: bool
L117:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L120 (error at _await:128) else goto L180 :: bool
L118:
    unreachable
L119:
    inc_ref arg
    goto L137
L120:
    r145 = CPy_CatchError()
    r4.__mypyc_temp__10 = r145; r146 = is_error
    if not r146 goto L181 (error at _await:-1) else goto L121 :: bool
L121:
    r147 = load_address r3
    r148 = r4.__mypyc_temp__9
    if is_error(r148) goto L181 (error at _await:-1) else goto L122
L122:
    r149 = CPy_YieldFromErrorHandle(r148, r147)
    dec_ref r148
    if is_error(r149) goto L181 (error at _await:128) else goto L123
L123:
    if r149 goto L129 else goto L124 :: bool
L124:
    if is_error(r3) goto L125 else goto L127
L125:
    r150 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r150 goto L134 (error at _await:-1) else goto L182 :: bool
L126:
    unreachable
L127:
    inc_ref r3
    r141 = r3
    r151 = r4.__mypyc_temp__10
    if is_error(r151) goto L183 (error at _await:-1) else goto L128
L128:
    CPy_RestoreExcInfo(r151)
    dec_ref r151
    goto L114
L129:
    if is_error(r3) goto L130 else goto L132
L130:
    r152 = raise UnboundLocalError('local variable "" referenced before assignment')
    if not r152 goto L134 (error at _await:-1) else goto L184 :: bool
L131:
    unreachable
L132:
    r140 = r3
    dec_ref r140
    r153 = r4.__mypyc_temp__10
    if is_error(r153) goto L134 (error at _await:-1) else goto L133
L133:
    CPy_RestoreExcInfo(r153)
    dec_ref r153
    goto L142
L134:
    r154 = r4.__mypyc_temp__10
    dec_ref r4
    if is_error(r154) goto L150 (error at _await:-1) else goto L135
L135:
    CPy_RestoreExcInfo(r154)
    dec_ref r154
    r155 = CPy_KeepPropagating()
    if not r155 goto L150 else goto L136 :: bool
L136:
    unreachable
L137:
    r156 = r4.__mypyc_temp__9
    if is_error(r156) goto L185 (error at _await:-1) else goto L138
L138:
    r157 = CPyIter_Send(r156, arg)
    dec_ref r156
    dec_ref arg
    if is_error(r157) goto L186 else goto L139
L139:
    r141 = r157
    goto L114
L140:
    r158 = CPy_FetchStopIterationValue()
    if is_error(r158) goto L177 (error at _await:128) else goto L141
L141:
    r140 = r158
    dec_ref r140
L142:
    r159 = box(None, 1)
    r4.__mypyc_next_label__ = -2; r160 = is_error
    dec_ref r4
    if not r160 goto L150 (error at _await:102) else goto L143 :: bool
L143:
    CPyGen_SetStopIterationValue(r159)
    if not 0 goto L150 else goto L144 :: bool
L144:
    unreachable
L145:
    r161 = r5 == 0
    if r161 goto L187 else goto L146 :: bool
L146:
    r162 = r5 == 2
    if r162 goto L188 else goto L189 :: bool
L147:
    r163 = r5 == 4
    dec_ref r5 :: int
    if r163 goto L116 else goto L190 :: bool
L148:
    r164 = raise StopIteration
    if not r164 goto L150 (error at _await:102) else goto L149 :: bool
L149:
    unreachable
L150:
    r165 = <error> :: object
    return r165
L151:
    xdec_ref r1
    xdec_ref r3
    goto L150
L152:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L150
L153:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L3
L154:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r17
    goto L150
L155:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r20
    goto L150
L156:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r20
    dec_ref r29
    goto L150
L157:
    xdec_ref r1
    goto L104
L158:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r59
    goto L150
L159:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    dec_ref r68
    goto L150
L160:
    dec_ref r84
    goto L57
L161:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L52
L162:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L55
L163:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L63
L164:
    dec_ref r84
    goto L71
L165:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L68
L166:
    xdec_ref r1
    xdec_ref r3
    dec_ref r4
    goto L73
L167:
    dec_ref arg
    goto L79
L168:
    xdec_ref r1
    xdec_ref r3
    goto L97
L169:
    xdec_ref r1
    xdec_ref r3
    goto L93
L170:
    xdec_ref r1
    xdec_ref r3
    goto L86
L171:
    dec_ref r4
    goto L87
L172:
    xdec_ref r1
    xdec_ref r3
    dec_ref r117
    goto L97
L173:
    dec_ref r4
    goto L94
L174:
    xdec_ref r3
    dec_ref r4
    goto L150
L175:
    xdec_ref r3
    goto L142
L176:
    xdec_ref r3
    goto L111
L177:
    dec_ref r4
    goto L150
L178:
    dec_ref r141
    goto L120
L179:
    xdec_ref r3
    dec_ref r4
    goto L115
L180:
    xdec_ref r3
    dec_ref r4
    goto L118
L181:
    xdec_ref r3
    goto L134
L182:
    dec_ref r4
    goto L126
L183:
    xdec_ref r3
    dec_ref r141
    goto L134
L184:
    dec_ref r4
    goto L131
L185:
    xdec_ref r3
    dec_ref r4
    dec_ref arg
    goto L150
L186:
    xdec_ref r3
    goto L140
L187:
    dec_ref r5 :: int
    goto L2
L188:
    dec_ref r5 :: int
    goto L53
L189:
    xdec_ref r1
    goto L147
L190:
    xdec_ref r3
    dec_ref r4
    goto L148

def _await_DankBatch_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _await_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _await_DankBatch_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = _await_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def _await_DankBatch_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def _await_DankBatch_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = _await_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def _await_DankBatch_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def _await_DankBatch_gen.__await__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch._await_DankBatch_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def DankBatch._await(self):
    self :: dank_mids._batch.DankBatch
    r0 :: dank_mids._batch._await_DankBatch_env
    r1 :: bool
    r2 :: dank_mids._batch._await_DankBatch_gen
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = _await_DankBatch_env()
    if is_error(r0) goto L6 (error at _await:102) else goto L1
L1:
    inc_ref self
    r0.self = self; r1 = is_error
    if not r1 goto L7 (error at _await:102) else goto L2 :: bool
L2:
    r2 = _await_DankBatch_gen()
    if is_error(r2) goto L7 (error at _await:102) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L8 (error at _await:102) else goto L4 :: bool
L4:
    r0.__mypyc_next_label__ = 0; r4 = is_error
    dec_ref r0
    if not r4 goto L9 (error at _await:102) else goto L5 :: bool
L5:
    return r2
L6:
    r5 = <error> :: object
    return r5
L7:
    dec_ref r0
    goto L6
L8:
    dec_ref r0
    dec_ref r2
    goto L6
L9:
    dec_ref r2
    goto L6

def coroutines_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, arg):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    type, value, traceback, arg :: object
    r0 :: dank_mids._batch.coroutines_DankBatch_env
    r1 :: int
    r2 :: object
    r3 :: bit
    r4 :: dank_mids._batch.DankBatch
    r5 :: object
    r6 :: bool
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: bool
    r11 :: dank_mids._batch.DankBatch
    r12 :: object
    r13 :: bool
    r14 :: dank_mids._batch.DankBatch
    r15 :: dict
    r16, r17 :: bool
    r18 :: dict
    r19 :: native_int
    r20 :: short_int
    r21 :: bool
    r22 :: object
    r23 :: bool
    r24 :: object
    r25 :: short_int
    r26 :: tuple[bool, short_int, object]
    r27 :: short_int
    r28, r29 :: bool
    r30 :: object
    r31 :: bool
    r32 :: object
    r33 :: int
    r34, r35, r36 :: object
    r37 :: i32
    r38 :: bit
    r39 :: bool
    r40, r41, r42 :: object
    r43 :: object[2]
    r44 :: object_ptr
    r45, r46, r47, r48 :: object
    r49 :: str
    r50 :: object
    r51 :: object[3]
    r52 :: object_ptr
    r53, r54, r55 :: object
    r56 :: str
    r57 :: object
    r58 :: bool
    r59 :: object
    r60 :: bool
    r61 :: object
    r62 :: bit
    r63 :: dank_mids._batch.DankBatch
    r64 :: object
    r65 :: dict
    r66 :: str
    r67 :: object
    r68 :: object[1]
    r69 :: object_ptr
    r70 :: object
    r71 :: bool
    r72 :: object
    r73 :: str
    r74 :: object
    r75 :: bool
    r76 :: dict
    r77 :: short_int
    r78, r79 :: bit
    r80 :: object
    r81 :: i32
    r82 :: bit
    r83 :: bool
    r84 :: object
    r85 :: int
    r86 :: bit
    r87, r88, r89 :: object
    r90 :: str
    r91 :: object
    r92 :: object[1]
    r93 :: object_ptr
    r94 :: object
    r95 :: bool
    r96 :: object
    r97 :: str
    r98 :: object
    r99 :: str
    r100 :: object[1]
    r101 :: object_ptr
    r102, r103, r104 :: object
    r105 :: dict
    r106 :: str
    r107 :: object
    r108 :: bit
    r109, r110, r111 :: object
    r112 :: str
    r113 :: object[1]
    r114 :: object_ptr
    r115 :: object
    r116 :: bool
    r117 :: object
    r118 :: bit
    r119 :: object
    r120 :: bool
    r121 :: object
    r122 :: bit
    r123 :: object
    r124 :: bool
    r125, r126, r127, r128 :: bit
    r129 :: bool
    r130 :: object
L0:
    r0 = __mypyc_self__.__mypyc_env__
    if is_error(r0) goto L101 (error at coroutines:131) else goto L1
L1:
    r1 = r0.__mypyc_next_label__
    if is_error(r1) goto L102 (error at coroutines:131) else goto L95
L2:
    r2 = load_address _Py_NoneStruct
    r3 = type != r2
    if r3 goto L103 else goto L5 :: bool
L3:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L101 (error at coroutines:131) else goto L4 :: bool
L4:
    unreachable
L5:
    r4 = r0.self
    if is_error(r4) goto L102 (error at coroutines:145) else goto L6
L6:
    r5 = r4.rpc_calls
    dec_ref r4
    r0.working_batch = r5; r6 = is_error
    if not r6 goto L102 (error at coroutines:145) else goto L7 :: bool
L7:
    r7 = r0.working_batch
    if is_error(r7) goto L102 (error at coroutines:148) else goto L8
L8:
    r8 = 'append'
    r9 = CPyObject_GetAttr(r7, r8)
    dec_ref r7
    if is_error(r9) goto L102 (error at coroutines:148) else goto L9
L9:
    r0.batch_append = r9; r10 = is_error
    if not r10 goto L102 (error at coroutines:148) else goto L10 :: bool
L10:
    r11 = r0.self
    if is_error(r11) goto L102 (error at coroutines:151) else goto L11
L11:
    r12 = r11._check_len
    dec_ref r11
    r0.check_len = r12; r13 = is_error
    if not r13 goto L102 (error at coroutines:151) else goto L12 :: bool
L12:
    r14 = r0.self
    if is_error(r14) goto L102 (error at coroutines:152) else goto L13
L13:
    r15 = r14.multicalls
    dec_ref r14
    inc_ref r15
    r0.__mypyc_temp__11 = r15; r16 = is_error
    if not r16 goto L104 (error at coroutines:-1) else goto L14 :: bool
L14:
    r0.__mypyc_temp__12 = 0; r17 = is_error
    if not r17 goto L104 (error at coroutines:-1) else goto L15 :: bool
L15:
    r18 = r0.__mypyc_temp__11
    if is_error(r18) goto L104 (error at coroutines:152) else goto L16
L16:
    r19 = PyDict_Size(r18)
    dec_ref r18
    r20 = r19 << 1
    r0.__mypyc_temp__13 = r20; r21 = is_error
    if not r21 goto L104 (error at coroutines:-1) else goto L17 :: bool
L17:
    r22 = CPyDict_GetValuesIter(r15)
    dec_ref r15
    if is_error(r22) goto L102 (error at coroutines:152) else goto L18
L18:
    r0.__mypyc_temp__14 = r22; r23 = is_error
    if not r23 goto L102 (error at coroutines:-1) else goto L19 :: bool
L19:
    r24 = r0.__mypyc_temp__14
    if is_error(r24) goto L102 (error at coroutines:152) else goto L20
L20:
    r25 = r0.__mypyc_temp__12
    if is_error(r25) goto L105 (error at coroutines:152) else goto L21
L21:
    r26 = CPyDict_NextValue(r24, r25)
    dec_ref r24
    r27 = r26[1]
    r0.__mypyc_temp__12 = r27; r28 = is_error
    if not r28 goto L106 (error at coroutines:152) else goto L22 :: bool
L22:
    r29 = r26[0]
    if r29 goto L23 else goto L107 :: bool
L23:
    r30 = r26[2]
    dec_ref r26
    r0.mcall = r30; r31 = is_error
    if not r31 goto L102 (error at coroutines:152) else goto L24 :: bool
L24:
    r32 = r0.mcall
    if is_error(r32) goto L102 (error at coroutines:153) else goto L25
L25:
    r33 = CPyObject_Size(r32)
    dec_ref r32
    if is_error(r33) goto L102 (error at coroutines:153) else goto L26
L26:
    r34 = r0.check_len
    if is_error(r34) goto L108 (error at coroutines:153) else goto L27
L27:
    r35 = box(int, r33)
    r36 = PyObject_RichCompare(r35, r34, 5)
    dec_ref r35
    dec_ref r34
    if is_error(r36) goto L102 (error at coroutines:153) else goto L28
L28:
    r37 = PyObject_IsTrue(r36)
    dec_ref r36
    r38 = r37 >= 0 :: signed
    if not r38 goto L102 (error at coroutines:153) else goto L29 :: bool
L29:
    r39 = truncate r37: i32 to builtins.bool
    if r39 goto L30 else goto L34 :: bool
L30:
    r40 = r0.mcall
    if is_error(r40) goto L102 (error at coroutines:154) else goto L31
L31:
    r41 = r0.batch_append
    if is_error(r41) goto L109 (error at coroutines:154) else goto L32
L32:
    r42 = box(bool, 1)
    r43 = [r40, r42]
    r44 = load_address r43
    r45 = ('skip_check',)
    r46 = _PyObject_Vectorcall(r41, r44, 1, r45)
    dec_ref r41
    if is_error(r46) goto L109 (error at coroutines:154) else goto L110
L33:
    dec_ref r40
    goto L38
L34:
    r47 = r0.working_batch
    if is_error(r47) goto L102 (error at coroutines:158) else goto L35
L35:
    r48 = r0.mcall
    if is_error(r48) goto L111 (error at coroutines:158) else goto L36
L36:
    r49 = 'extend'
    r50 = box(bool, 1)
    r51 = [r47, r48, r50]
    r52 = load_address r51
    r53 = ('skip_check',)
    r54 = PyObject_VectorcallMethod(r49, r52, 9223372036854775810, r53)
    if is_error(r54) goto L112 (error at coroutines:158) else goto L113
L37:
    dec_ref r47
    dec_ref r48
L38:
    r55 = r0.working_batch
    if is_error(r55) goto L102 (error at coroutines:159) else goto L39
L39:
    r56 = 'is_full'
    r57 = CPyObject_GetAttr(r55, r56)
    dec_ref r55
    if is_error(r57) goto L102 (error at coroutines:159) else goto L40
L40:
    r58 = unbox(bool, r57)
    dec_ref r57
    if is_error(r58) goto L102 (error at coroutines:159) else goto L41
L41:
    if r58 goto L42 else goto L55 :: bool
L42:
    r59 = r0.working_batch
    if is_error(r59) goto L102 (error at coroutines:160) else goto L43
L43:
    r0.__mypyc_next_label__ = 2; r60 = is_error
    dec_ref r0
    if not r60 goto L114 (error at coroutines:160) else goto L44 :: bool
L44:
    return r59
L45:
    r61 = load_address _Py_NoneStruct
    r62 = type != r61
    if r62 goto L115 else goto L48 :: bool
L46:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L101 (error at coroutines:160) else goto L47 :: bool
L47:
    unreachable
L48:
    r63 = r0.self
    if is_error(r63) goto L102 (error at coroutines:161) else goto L49
L49:
    r64 = r63.controller
    dec_ref r63
    r65 = dank_mids._batch.globals :: static
    r66 = 'JSONRPCBatch'
    r67 = CPyDict_GetItem(r65, r66)
    if is_error(r67) goto L116 (error at coroutines:161) else goto L50
L50:
    r68 = [r64]
    r69 = load_address r68
    r70 = _PyObject_Vectorcall(r67, r69, 1, 0)
    dec_ref r67
    if is_error(r70) goto L116 (error at coroutines:161) else goto L51
L51:
    dec_ref r64
    r0.working_batch = r70; r71 = is_error
    if not r71 goto L102 (error at coroutines:161) else goto L52 :: bool
L52:
    r72 = r0.working_batch
    if is_error(r72) goto L102 (error at coroutines:162) else goto L53
L53:
    r73 = 'append'
    r74 = CPyObject_GetAttr(r72, r73)
    dec_ref r72
    if is_error(r74) goto L102 (error at coroutines:162) else goto L54
L54:
    r0.batch_append = r74; r75 = is_error
    if not r75 goto L102 (error at coroutines:162) else goto L55 :: bool
L55:
    r76 = r0.__mypyc_temp__11
    if is_error(r76) goto L102 (error at coroutines:152) else goto L56
L56:
    r77 = r0.__mypyc_temp__13
    if is_error(r77) goto L117 (error at coroutines:152) else goto L57
L57:
    r78 = CPyDict_CheckSize(r76, r77)
    dec_ref r76
    if not r78 goto L102 (error at coroutines:152) else goto L19 :: bool
L58:
    r79 = CPy_NoErrOccurred()
    if not r79 goto L102 (error at coroutines:152) else goto L59 :: bool
L59:
    r80 = r0.working_batch
    if is_error(r80) goto L102 (error at coroutines:164) else goto L60
L60:
    r81 = PyObject_IsTrue(r80)
    dec_ref r80
    r82 = r81 >= 0 :: signed
    if not r82 goto L102 (error at coroutines:164) else goto L61 :: bool
L61:
    r83 = truncate r81: i32 to builtins.bool
    if r83 goto L62 else goto L92 :: bool
L62:
    r84 = r0.working_batch
    if is_error(r84) goto L102 (error at coroutines:165) else goto L63
L63:
    r85 = CPyObject_Size(r84)
    dec_ref r84
    if is_error(r85) goto L102 (error at coroutines:165) else goto L64
L64:
    r86 = r85 == 2
    dec_ref r85 :: int
    if r86 goto L65 else goto L86 :: bool
L65:
    r87 = r0.working_batch
    if is_error(r87) goto L102 (error at coroutines:166) else goto L66
L66:
    r88 = PyObject_GetIter(r87)
    dec_ref r87
    if is_error(r88) goto L102 (error at coroutines:166) else goto L67
L67:
    r89 = builtins :: module
    r90 = 'next'
    r91 = CPyObject_GetAttr(r89, r90)
    if is_error(r91) goto L118 (error at coroutines:166) else goto L68
L68:
    r92 = [r88]
    r93 = load_address r92
    r94 = _PyObject_Vectorcall(r91, r93, 1, 0)
    dec_ref r91
    if is_error(r94) goto L118 (error at coroutines:166) else goto L69
L69:
    dec_ref r88
    r0.call = r94; r95 = is_error
    if not r95 goto L102 (error at coroutines:166) else goto L70 :: bool
L70:
    r96 = r0.working_batch
    if is_error(r96) goto L102 (error at coroutines:168) else goto L71
L71:
    r97 = '_done'
    r98 = CPyObject_GetAttr(r96, r97)
    dec_ref r96
    if is_error(r98) goto L102 (error at coroutines:168) else goto L72
L72:
    r99 = 'set'
    r100 = [r98]
    r101 = load_address r100
    r102 = PyObject_VectorcallMethod(r99, r101, 9223372036854775809, 0)
    if is_error(r102) goto L119 (error at coroutines:168) else goto L120
L73:
    dec_ref r98
    r103 = r0.call
    if is_error(r103) goto L102 (error at coroutines:169) else goto L74
L74:
    r104 = PyObject_Type(r103)
    dec_ref r103
    r105 = dank_mids._batch.globals :: static
    r106 = 'Multicall'
    r107 = CPyDict_GetItem(r105, r106)
    if is_error(r107) goto L121 (error at coroutines:169) else goto L75
L75:
    r108 = r104 == r107
    dec_ref r104
    dec_ref r107
    if r108 goto L76 else goto L78 :: bool
L76:
    r109 = r0.call
    if is_error(r109) goto L102 (error at coroutines:169) else goto L77
L77:
    r110 = r109
    goto L81
L78:
    r111 = r0.call
    if is_error(r111) goto L102 (error at coroutines:169) else goto L79
L79:
    r112 = 'make_request'
    r113 = [r111]
    r114 = load_address r113
    r115 = PyObject_VectorcallMethod(r112, r114, 9223372036854775809, 0)
    if is_error(r115) goto L122 (error at coroutines:169) else goto L80
L80:
    dec_ref r111
    r110 = r115
L81:
    r0.__mypyc_next_label__ = 4; r116 = is_error
    dec_ref r0
    if not r116 goto L123 (error at coroutines:169) else goto L82 :: bool
L82:
    return r110
L83:
    r117 = load_address _Py_NoneStruct
    r118 = type != r117
    if r118 goto L124 else goto L92 :: bool
L84:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L101 (error at coroutines:169) else goto L85 :: bool
L85:
    unreachable
L86:
    r119 = r0.working_batch
    if is_error(r119) goto L102 (error at coroutines:171) else goto L87
L87:
    r0.__mypyc_next_label__ = 6; r120 = is_error
    dec_ref r0
    if not r120 goto L125 (error at coroutines:171) else goto L88 :: bool
L88:
    return r119
L89:
    r121 = load_address _Py_NoneStruct
    r122 = type != r121
    if r122 goto L126 else goto L92 :: bool
L90:
    CPyErr_SetObjectAndTraceback(type, value, traceback)
    if not 0 goto L101 (error at coroutines:171) else goto L91 :: bool
L91:
    unreachable
L92:
    r123 = box(None, 1)
    r0.__mypyc_next_label__ = -2; r124 = is_error
    dec_ref r0
    if not r124 goto L101 (error at coroutines:131) else goto L93 :: bool
L93:
    CPyGen_SetStopIterationValue(r123)
    if not 0 goto L101 else goto L94 :: bool
L94:
    unreachable
L95:
    r125 = r1 == 0
    if r125 goto L127 else goto L96 :: bool
L96:
    r126 = r1 == 2
    if r126 goto L128 else goto L97 :: bool
L97:
    r127 = r1 == 4
    if r127 goto L129 else goto L98 :: bool
L98:
    r128 = r1 == 6
    dec_ref r1 :: int
    if r128 goto L89 else goto L130 :: bool
L99:
    r129 = raise StopIteration
    if not r129 goto L101 (error at coroutines:131) else goto L100 :: bool
L100:
    unreachable
L101:
    r130 = <error> :: object
    return r130
L102:
    dec_ref r0
    goto L101
L103:
    dec_ref r0
    goto L3
L104:
    dec_ref r0
    dec_ref r15
    goto L101
L105:
    dec_ref r0
    dec_ref r24
    goto L101
L106:
    dec_ref r0
    dec_ref r26
    goto L101
L107:
    dec_ref r26
    goto L58
L108:
    dec_ref r0
    dec_ref r33 :: int
    goto L101
L109:
    dec_ref r0
    dec_ref r40
    goto L101
L110:
    dec_ref r46
    goto L33
L111:
    dec_ref r0
    dec_ref r47
    goto L101
L112:
    dec_ref r0
    dec_ref r47
    dec_ref r48
    goto L101
L113:
    dec_ref r54
    goto L37
L114:
    dec_ref r59
    goto L101
L115:
    dec_ref r0
    goto L46
L116:
    dec_ref r0
    dec_ref r64
    goto L101
L117:
    dec_ref r0
    dec_ref r76
    goto L101
L118:
    dec_ref r0
    dec_ref r88
    goto L101
L119:
    dec_ref r0
    dec_ref r98
    goto L101
L120:
    dec_ref r102
    goto L73
L121:
    dec_ref r0
    dec_ref r104
    goto L101
L122:
    dec_ref r0
    dec_ref r111
    goto L101
L123:
    dec_ref r110
    goto L101
L124:
    dec_ref r0
    goto L84
L125:
    dec_ref r119
    goto L101
L126:
    dec_ref r0
    goto L90
L127:
    dec_ref r1 :: int
    goto L2
L128:
    dec_ref r1 :: int
    goto L45
L129:
    dec_ref r1 :: int
    goto L83
L130:
    dec_ref r0
    goto L99

def coroutines_DankBatch_gen.__next__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutines_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, r0)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutines_DankBatch_gen.send(__mypyc_self__, arg):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    arg, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    r1 = coroutines_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, r0, r0, r0, arg)
    if is_error(r1) goto L2 else goto L1
L1:
    return r1
L2:
    r2 = <error> :: object
    return r2

def coroutines_DankBatch_gen.__iter__(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
L0:
    inc_ref __mypyc_self__
    return __mypyc_self__

def coroutines_DankBatch_gen.throw(__mypyc_self__, type, value, traceback):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    type, value, traceback, r0, r1, r2 :: object
L0:
    r0 = load_address _Py_NoneStruct
    if is_error(value) goto L1 else goto L7
L1:
    inc_ref r0
    value = r0
L2:
    if is_error(traceback) goto L3 else goto L8
L3:
    inc_ref r0
    traceback = r0
L4:
    r1 = coroutines_DankBatch_gen.__mypyc_generator_helper__(__mypyc_self__, type, value, traceback, r0)
    dec_ref value
    dec_ref traceback
    if is_error(r1) goto L6 else goto L5
L5:
    return r1
L6:
    r2 = <error> :: object
    return r2
L7:
    inc_ref value
    goto L2
L8:
    inc_ref traceback
    goto L4

def coroutines_DankBatch_gen.close(__mypyc_self__):
    __mypyc_self__ :: dank_mids._batch.coroutines_DankBatch_gen
    r0 :: object
    r1 :: str
    r2, r3, r4, r5 :: object
    r6 :: tuple[object, object, object]
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: tuple[object, object]
    r11 :: object
    r12 :: bit
    r13 :: object
    r14 :: bool
    r15 :: object
L0:
L1:
    r0 = builtins :: module
    r1 = 'GeneratorExit'
    r2 = CPyObject_GetAttr(r0, r1)
    if is_error(r2) goto L3 else goto L2
L2:
    r3 = load_address _Py_NoneStruct
    r4 = load_address _Py_NoneStruct
    r5 = __mypyc_self__.throw(r2, r3, r4)
    if is_error(r5) goto L3 else goto L11
L3:
    r6 = CPy_CatchError()
    r7 = builtins :: module
    r8 = 'StopIteration'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L12 else goto L4
L4:
    r10 = (r2, r9)
    r11 = box(tuple[object, object], r10)
    r12 = CPy_ExceptionMatches(r11)
    dec_ref r11
    if r12 goto L5 else goto L13 :: bool
L5:
    CPy_RestoreExcInfo(r6)
    dec_ref r6
    r13 = load_address _Py_NoneStruct
    inc_ref r13
    return r13
L6:
    CPy_Reraise()
    if not 0 goto L10 else goto L7 :: bool
L7:
    unreachable
L8:
    r14 = raise RuntimeError('generator ignored GeneratorExit')
    if not r14 goto L10 else goto L9 :: bool
L9:
    unreachable
L10:
    r15 = <error> :: object
    return r15
L11:
    dec_ref r2
    dec_ref r5
    goto L8
L12:
    dec_ref r2
    dec_ref r6
    goto L10
L13:
    dec_ref r6
    goto L6

def DankBatch.coroutines(self):
    self :: dank_mids._batch.DankBatch
    r0 :: dank_mids._batch.coroutines_DankBatch_env
    r1 :: bool
    r2 :: dank_mids._batch.coroutines_DankBatch_gen
    r3, r4 :: bool
    r5 :: object
L0:
    r0 = coroutines_DankBatch_env()
    if is_error(r0) goto L6 (error at coroutines:131) else goto L1
L1:
    inc_ref self
    r0.self = self; r1 = is_error
    if not r1 goto L7 (error at coroutines:131) else goto L2 :: bool
L2:
    r2 = coroutines_DankBatch_gen()
    if is_error(r2) goto L7 (error at coroutines:131) else goto L3
L3:
    inc_ref r0
    r2.__mypyc_env__ = r0; r3 = is_error
    if not r3 goto L8 (error at coroutines:131) else goto L4 :: bool
L4:
    r0.__mypyc_next_label__ = 0; r4 = is_error
    dec_ref r0
    if not r4 goto L9 (error at coroutines:131) else goto L5 :: bool
L5:
    return r2
L6:
    r5 = <error> :: object
    return r5
L7:
    dec_ref r0
    goto L6
L8:
    dec_ref r0
    dec_ref r2
    goto L6
L9:
    dec_ref r2
    goto L6

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4, r5 :: object
    r6 :: str
    r7 :: dict
    r8, r9 :: object
    r10 :: str
    r11 :: dict
    r12 :: object
    r13 :: object_ptr
    r14 :: object_ptr[1]
    r15 :: c_ptr
    r16 :: native_int[1]
    r17 :: c_ptr
    r18 :: object
    r19 :: dict
    r20, r21 :: str
    r22 :: bit
    r23 :: object
    r24 :: str
    r25 :: dict
    r26, r27 :: object
    r28 :: str
    r29 :: dict
    r30, r31 :: object
    r32 :: str
    r33 :: dict
    r34, r35 :: object
    r36 :: str
    r37 :: dict
    r38, r39 :: object
    r40 :: str
    r41 :: dict
    r42, r43 :: object
    r44 :: str
    r45 :: dict
    r46 :: object
    r47 :: str
    r48 :: dict
    r49 :: str
    r50 :: object
    r51 :: object[1]
    r52 :: object_ptr
    r53 :: object
    r54 :: dict
    r55 :: str
    r56 :: i32
    r57 :: bit
    r58 :: dict
    r59 :: str
    r60 :: object
    r61 :: dict
    r62 :: str
    r63 :: object
    r64 :: dict
    r65 :: str
    r66 :: object
    r67 :: dict
    r68 :: str
    r69, r70, r71 :: object
    r72 :: tuple[object, object, object]
    r73, r74 :: object
    r75 :: dict
    r76 :: str
    r77 :: i32
    r78 :: bit
    r79 :: dict
    r80 :: str
    r81 :: object
    r82 :: i32
    r83 :: bit
    r84 :: dict
    r85 :: str
    r86 :: object
    r87 :: i32
    r88 :: bit
    r89 :: dict
    r90 :: str
    r91 :: object
    r92 :: str
    r93 :: object
    r94 :: bool
    r95 :: object[1]
    r96 :: object_ptr
    r97 :: object
    r98 :: dict
    r99 :: str
    r100 :: i32
    r101 :: bit
    r102 :: dict
    r103 :: str
    r104 :: object
    r105 :: str
    r106 :: object
    r107 :: dict
    r108 :: str
    r109 :: i32
    r110 :: bit
    r111 :: object
    r112 :: str
    r113, r114 :: object
    r115 :: bool
    r116, r117, r118, r119, r120, r121 :: str
    r122 :: tuple
    r123 :: i32
    r124 :: bit
    r125 :: dict
    r126 :: str
    r127 :: i32
    r128 :: bit
    r129 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L41 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = ('Task',)
    r6 = 'asyncio'
    r7 = dank_mids._batch.globals :: static
    r8 = CPyImport_ImportFromMany(r6, r5, r5, r7)
    if is_error(r8) goto L41 (error at <module>:1) else goto L4
L4:
    asyncio = r8 :: module
    dec_ref r8
    r9 = ('TYPE_CHECKING', 'Any', 'Awaitable', 'Final', 'Generator', 'TypeVar', 'Union', 'final')
    r10 = 'typing'
    r11 = dank_mids._batch.globals :: static
    r12 = CPyImport_ImportFromMany(r10, r9, r9, r11)
    if is_error(r12) goto L41 (error at <module>:2) else goto L5
L5:
    typing = r12 :: module
    dec_ref r12
    r13 = load_address a_sync :: module
    r14 = [r13]
    r15 = load_address r14
    r16 = [4]
    r17 = load_address r16
    r18 = (('a_sync', 'a_sync', 'a_sync'),)
    r19 = dank_mids._batch.globals :: static
    r20 = 'dank_mids\\_batch.py'
    r21 = '<module>'
    r22 = CPyImport_ImportMany(r18, r15, r19, r20, r21, r17)
    if not r22 goto L41 else goto L6 :: bool
L6:
    r23 = ('DankMidsInternalError',)
    r24 = 'dank_mids._exceptions'
    r25 = dank_mids._batch.globals :: static
    r26 = CPyImport_ImportFromMany(r24, r23, r23, r25)
    if is_error(r26) goto L41 (error at <module>:6) else goto L7
L7:
    dank_mids._exceptions = r26 :: module
    dec_ref r26
    r27 = ('getLogger',)
    r28 = 'dank_mids._logging'
    r29 = dank_mids._batch.globals :: static
    r30 = CPyImport_ImportFromMany(r28, r27, r27, r29)
    if is_error(r30) goto L41 (error at <module>:7) else goto L8
L8:
    dank_mids._logging = r30 :: module
    dec_ref r30
    r31 = ('JSONRPCBatch', 'Multicall')
    r32 = 'dank_mids._requests'
    r33 = dank_mids._batch.globals :: static
    r34 = CPyImport_ImportFromMany(r32, r31, r31, r33)
    if is_error(r34) goto L41 (error at <module>:8) else goto L9
L9:
    dank_mids._requests = r34 :: module
    dec_ref r34
    r35 = ('RawResponse',)
    r36 = 'dank_mids.helpers._codec'
    r37 = dank_mids._batch.globals :: static
    r38 = CPyImport_ImportFromMany(r36, r35, r35, r37)
    if is_error(r38) goto L41 (error at <module>:9) else goto L10
L10:
    dank_mids.helpers._codec = r38 :: module
    dec_ref r38
    r39 = ('log_internal_error',)
    r40 = 'dank_mids.helpers._errors'
    r41 = dank_mids._batch.globals :: static
    r42 = CPyImport_ImportFromMany(r40, r39, r39, r41)
    if is_error(r42) goto L41 (error at <module>:10) else goto L11
L11:
    dank_mids.helpers._errors = r42 :: module
    dec_ref r42
    r43 = ('Multicalls',)
    r44 = 'dank_mids.types'
    r45 = dank_mids._batch.globals :: static
    r46 = CPyImport_ImportFromMany(r44, r43, r43, r45)
    if is_error(r46) goto L41 (error at <module>:11) else goto L12
L12:
    dank_mids.types = r46 :: module
    dec_ref r46
    if 0 goto L13 else goto L13 :: bool
L13:
    r47 = '__T'
    r48 = dank_mids._batch.globals :: static
    r49 = 'TypeVar'
    r50 = CPyDict_GetItem(r48, r49)
    if is_error(r50) goto L41 (error at <module>:17) else goto L14
L14:
    r51 = [r47]
    r52 = load_address r51
    r53 = _PyObject_Vectorcall(r50, r52, 1, 0)
    dec_ref r50
    if is_error(r53) goto L41 (error at <module>:17) else goto L15
L15:
    r54 = dank_mids._batch.globals :: static
    r55 = '__T'
    r56 = CPyDict_SetItem(r54, r55, r53)
    dec_ref r53
    r57 = r56 >= 0 :: signed
    if not r57 goto L41 (error at <module>:17) else goto L16 :: bool
L16:
    r58 = dank_mids._batch.globals :: static
    r59 = 'Union'
    r60 = CPyDict_GetItem(r58, r59)
    if is_error(r60) goto L41 (error at <module>:19) else goto L17
L17:
    r61 = dank_mids._batch.globals :: static
    r62 = 'Multicall'
    r63 = CPyDict_GetItem(r61, r62)
    if is_error(r63) goto L42 (error at <module>:19) else goto L18
L18:
    r64 = dank_mids._batch.globals :: static
    r65 = 'JSONRPCBatch'
    r66 = CPyDict_GetItem(r64, r65)
    if is_error(r66) goto L43 (error at <module>:19) else goto L19
L19:
    r67 = dank_mids._batch.globals :: static
    r68 = 'Awaitable'
    r69 = CPyDict_GetItem(r67, r68)
    if is_error(r69) goto L44 (error at <module>:19) else goto L20
L20:
    r70 = dank_mids.helpers._codec.RawResponse :: type
    r71 = PyObject_GetItem(r69, r70)
    dec_ref r69
    if is_error(r71) goto L44 (error at <module>:19) else goto L21
L21:
    r72 = (r63, r66, r71)
    r73 = box(tuple[object, object, object], r72)
    r74 = PyObject_GetItem(r60, r73)
    dec_ref r60
    dec_ref r73
    if is_error(r74) goto L41 (error at <module>:19) else goto L22
L22:
    r75 = dank_mids._batch.globals :: static
    r76 = 'Coro'
    r77 = CPyDict_SetItem(r75, r76, r74)
    dec_ref r74
    r78 = r77 >= 0 :: signed
    if not r78 goto L41 (error at <module>:19) else goto L23 :: bool
L23:
    r79 = dank_mids._batch.globals :: static
    r80 = 'MIN_SIZE'
    r81 = object 1
    r82 = CPyDict_SetItem(r79, r80, r81)
    r83 = r82 >= 0 :: signed
    if not r83 goto L41 (error at <module>:22) else goto L24 :: bool
L24:
    r84 = dank_mids._batch.globals :: static
    r85 = 'CHECK'
    r86 = object 0
    r87 = CPyDict_SetItem(r84, r85, r86)
    r88 = r87 >= 0 :: signed
    if not r88 goto L41 (error at <module>:25) else goto L25 :: bool
L25:
    r89 = dank_mids._batch.globals :: static
    r90 = '__name__'
    r91 = CPyDict_GetItem(r89, r90)
    if is_error(r91) goto L41 (error at <module>:29) else goto L26
L26:
    r92 = cast(str, r91)
    if is_error(r92) goto L41 (error at <module>:29) else goto L27
L27:
    r93 = dank_mids._logging.getLogger :: static
    if is_error(r93) goto L45 else goto L30
L28:
    r94 = raise NameError('value for final name "getLogger" was not set')
    if not r94 goto L41 (error at <module>:29) else goto L29 :: bool
L29:
    unreachable
L30:
    r95 = [r92]
    r96 = load_address r95
    r97 = _PyObject_Vectorcall(r93, r96, 1, 0)
    if is_error(r97) goto L46 (error at <module>:29) else goto L31
L31:
    dec_ref r92
    dank_mids._batch.logger = r97 :: static
    r98 = dank_mids._batch.globals :: static
    r99 = 'logger'
    r100 = CPyDict_SetItem(r98, r99, r97)
    dec_ref r97
    r101 = r100 >= 0 :: signed
    if not r101 goto L41 (error at <module>:29) else goto L32 :: bool
L32:
    r102 = dank_mids._batch.globals :: static
    r103 = 'a_sync'
    r104 = CPyDict_GetItem(r102, r103)
    if is_error(r104) goto L41 (error at <module>:31) else goto L33
L33:
    r105 = 'create_task'
    r106 = CPyObject_GetAttr(r104, r105)
    dec_ref r104
    if is_error(r106) goto L41 (error at <module>:31) else goto L34
L34:
    dank_mids._batch.create_task = r106 :: static
    r107 = dank_mids._batch.globals :: static
    r108 = 'create_task'
    r109 = CPyDict_SetItem(r107, r108, r106)
    dec_ref r106
    r110 = r109 >= 0 :: signed
    if not r110 goto L41 (error at <module>:31) else goto L35 :: bool
L35:
    r111 = <error> :: object
    r112 = 'dank_mids._batch'
    r113 = dank_mids._batch.DankBatch_template :: type
    r114 = CPyType_FromTemplate(r113, r111, r112)
    if is_error(r114) goto L41 (error at <module>:39) else goto L36
L36:
    r115 = DankBatch_trait_vtable_setup()
    if is_error(r115) goto L47 (error at <module>:-1) else goto L37
L37:
    r116 = '__mypyc_attrs__'
    r117 = 'controller'
    r118 = 'multicalls'
    r119 = 'rpc_calls'
    r120 = '_awaited'
    r121 = '_check_len'
    r122 = PyTuple_Pack(5, r117, r118, r119, r120, r121)
    if is_error(r122) goto L47 (error at <module>:39) else goto L38
L38:
    r123 = PyObject_SetAttr(r114, r116, r122)
    dec_ref r122
    r124 = r123 >= 0 :: signed
    if not r124 goto L47 (error at <module>:39) else goto L39 :: bool
L39:
    dank_mids._batch.DankBatch = r114 :: type
    r125 = dank_mids._batch.globals :: static
    r126 = 'DankBatch'
    r127 = CPyDict_SetItem(r125, r126, r114)
    dec_ref r114
    r128 = r127 >= 0 :: signed
    if not r128 goto L41 (error at <module>:39) else goto L40 :: bool
L40:
    return 1
L41:
    r129 = <error> :: None
    return r129
L42:
    dec_ref r60
    goto L41
L43:
    dec_ref r60
    dec_ref r63
    goto L41
L44:
    dec_ref r60
    dec_ref r63
    dec_ref r66
    goto L41
L45:
    dec_ref r92
    goto L28
L46:
    dec_ref r92
    goto L41
L47:
    dec_ref r114
    goto L41

def patch_eth_utils():
    r0 :: dict
    r1, r2 :: object
    r3 :: bit
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: dict
    r8 :: str
    r9 :: object
    r10 :: i32
    r11 :: bit
    r12 :: dict
    r13 :: str
    r14 :: object
    r15 :: dict
    r16 :: str
    r17 :: object
    r18 :: str
    r19 :: object
    r20 :: str
    r21 :: i32
    r22 :: bit
    r23 :: dict
    r24, r25 :: object
    r26 :: bit
    r27 :: str
    r28 :: object
    r29 :: str
    r30 :: dict
    r31 :: str
    r32 :: object
    r33 :: i32
    r34 :: bit
    r35 :: dict
    r36 :: str
    r37 :: object
    r38 :: dict
    r39 :: str
    r40 :: object
    r41 :: str
    r42 :: object
    r43 :: str
    r44 :: i32
    r45 :: bit
    r46 :: dict
    r47 :: str
    r48 :: object
    r49 :: dict
    r50 :: str
    r51 :: object
    r52 :: str
    r53 :: object
    r54 :: str
    r55 :: i32
    r56 :: bit
    r57 :: dict
    r58, r59 :: object
    r60 :: bit
    r61 :: str
    r62 :: object
    r63 :: str
    r64 :: dict
    r65 :: str
    r66 :: object
    r67 :: i32
    r68 :: bit
    r69 :: dict
    r70 :: str
    r71 :: object
    r72 :: dict
    r73 :: str
    r74 :: object
    r75 :: str
    r76 :: object
    r77 :: str
    r78 :: object
    r79 :: str
    r80 :: i32
    r81 :: bit
    r82 :: dict
    r83, r84 :: object
    r85 :: bit
    r86 :: str
    r87 :: object
    r88 :: str
    r89 :: dict
    r90 :: str
    r91 :: object
    r92 :: i32
    r93 :: bit
    r94 :: dict
    r95 :: str
    r96 :: object
    r97 :: dict
    r98 :: str
    r99 :: object
    r100 :: str
    r101 :: object
    r102 :: str
    r103 :: object
    r104 :: str
    r105 :: i32
    r106 :: bit
    r107 :: dict
    r108, r109 :: object
    r110 :: bit
    r111 :: str
    r112 :: object
    r113 :: str
    r114 :: dict
    r115 :: str
    r116 :: object
    r117 :: i32
    r118 :: bit
    r119 :: dict
    r120 :: str
    r121 :: object
    r122 :: dict
    r123 :: str
    r124 :: object
    r125 :: str
    r126 :: object
    r127 :: str
    r128 :: object
    r129 :: str
    r130 :: i32
    r131 :: bit
    r132 :: dict
    r133 :: str
    r134 :: object
    r135 :: dict
    r136 :: str
    r137 :: object
    r138 :: str
    r139 :: object
    r140 :: str
    r141 :: object
    r142 :: str
    r143 :: i32
    r144 :: bit
    r145 :: dict
    r146, r147 :: object
    r148 :: bit
    r149 :: str
    r150 :: object
    r151 :: str
    r152 :: dict
    r153 :: str
    r154 :: object
    r155 :: i32
    r156 :: bit
    r157 :: dict
    r158 :: str
    r159 :: object
    r160 :: dict
    r161 :: str
    r162 :: object
    r163 :: str
    r164 :: object
    r165 :: str
    r166 :: object
    r167 :: str
    r168 :: i32
    r169 :: bit
    r170 :: dict
    r171 :: str
    r172 :: object
    r173 :: dict
    r174 :: str
    r175 :: object
    r176 :: str
    r177 :: object
    r178 :: str
    r179 :: object
    r180 :: str
    r181 :: i32
    r182 :: bit
    r183 :: dict
    r184, r185 :: object
    r186 :: bit
    r187 :: str
    r188 :: object
    r189 :: str
    r190 :: dict
    r191 :: str
    r192 :: object
    r193 :: i32
    r194 :: bit
    r195 :: dict
    r196 :: str
    r197 :: object
    r198 :: dict
    r199 :: str
    r200 :: object
    r201 :: str
    r202 :: object
    r203 :: str
    r204 :: object
    r205 :: str
    r206 :: i32
    r207 :: bit
    r208 :: dict
    r209 :: str
    r210 :: object
    r211 :: dict
    r212 :: str
    r213 :: object
    r214 :: str
    r215 :: object
    r216 :: str
    r217 :: object
    r218 :: str
    r219 :: i32
    r220 :: bit
    r221 :: dict
    r222, r223 :: object
    r224 :: bit
    r225 :: str
    r226 :: object
    r227 :: str
    r228 :: dict
    r229 :: str
    r230 :: object
    r231 :: i32
    r232 :: bit
    r233 :: tuple[object, object, object]
    r234 :: object
    r235 :: str
    r236 :: object
    r237, r238 :: bit
    r239 :: dict
    r240 :: str
    r241 :: object
    r242 :: dict
    r243 :: str
    r244 :: object
    r245 :: str
    r246 :: object
    r247 :: str
    r248 :: object
    r249 :: str
    r250 :: i32
    r251 :: bit
    r252 :: dict
    r253 :: str
    r254 :: object
    r255 :: dict
    r256 :: str
    r257 :: object
    r258 :: str
    r259 :: object
    r260 :: str
    r261 :: object
    r262 :: str
    r263 :: i32
    r264 :: bit
    r265 :: None
L0:
    r0 = dank_mids._eth_utils.globals :: static
    r1 = eth_utils.crypto :: module
    r2 = load_address _Py_NoneStruct
    r3 = r1 != r2
    if r3 goto L3 else goto L1 :: bool
L1:
    r4 = 'eth_utils.crypto'
    r5 = PyImport_Import(r4)
    if is_error(r5) goto L110 (error at patch_eth_utils:25) else goto L2
L2:
    eth_utils.crypto = r5 :: module
    dec_ref r5
L3:
    r6 = 'eth_utils'
    r7 = PyImport_GetModuleDict()
    r8 = 'eth_utils'
    r9 = CPyDict_GetItem(r7, r8)
    if is_error(r9) goto L110 (error at patch_eth_utils:25) else goto L4
L4:
    r10 = CPyDict_SetItem(r0, r6, r9)
    dec_ref r9
    r11 = r10 >= 0 :: signed
    if not r11 goto L110 (error at patch_eth_utils:25) else goto L5 :: bool
L5:
    r12 = dank_mids._eth_utils.globals :: static
    r13 = 'to_bytes'
    r14 = CPyDict_GetItem(r12, r13)
    if is_error(r14) goto L110 (error at patch_eth_utils:27) else goto L6
L6:
    r15 = dank_mids._eth_utils.globals :: static
    r16 = 'eth_utils'
    r17 = CPyDict_GetItem(r15, r16)
    if is_error(r17) goto L111 (error at patch_eth_utils:27) else goto L7
L7:
    r18 = 'crypto'
    r19 = CPyObject_GetAttr(r17, r18)
    dec_ref r17
    if is_error(r19) goto L111 (error at patch_eth_utils:27) else goto L8
L8:
    r20 = 'to_bytes'
    r21 = PyObject_SetAttr(r19, r20, r14)
    dec_ref r19
    dec_ref r14
    r22 = r21 >= 0 :: signed
    if not r22 goto L110 (error at patch_eth_utils:27) else goto L9 :: bool
L9:
    r23 = dank_mids._eth_utils.globals :: static
    r24 = web3.main :: module
    r25 = load_address _Py_NoneStruct
    r26 = r24 != r25
    if r26 goto L12 else goto L10 :: bool
L10:
    r27 = 'web3.main'
    r28 = PyImport_Import(r27)
    if is_error(r28) goto L110 (error at patch_eth_utils:29) else goto L11
L11:
    web3.main = r28 :: module
    dec_ref r28
L12:
    r29 = 'web3'
    r30 = PyImport_GetModuleDict()
    r31 = 'web3'
    r32 = CPyDict_GetItem(r30, r31)
    if is_error(r32) goto L110 (error at patch_eth_utils:29) else goto L13
L13:
    r33 = CPyDict_SetItem(r23, r29, r32)
    dec_ref r32
    r34 = r33 >= 0 :: signed
    if not r34 goto L110 (error at patch_eth_utils:29) else goto L14 :: bool
L14:
    r35 = dank_mids._eth_utils.globals :: static
    r36 = 'to_hex'
    r37 = CPyDict_GetItem(r35, r36)
    if is_error(r37) goto L110 (error at patch_eth_utils:31) else goto L15
L15:
    r38 = dank_mids._eth_utils.globals :: static
    r39 = 'web3'
    r40 = CPyDict_GetItem(r38, r39)
    if is_error(r40) goto L112 (error at patch_eth_utils:31) else goto L16
L16:
    r41 = 'main'
    r42 = CPyObject_GetAttr(r40, r41)
    dec_ref r40
    if is_error(r42) goto L112 (error at patch_eth_utils:31) else goto L17
L17:
    r43 = 'to_hex'
    r44 = PyObject_SetAttr(r42, r43, r37)
    dec_ref r42
    dec_ref r37
    r45 = r44 >= 0 :: signed
    if not r45 goto L110 (error at patch_eth_utils:31) else goto L18 :: bool
L18:
    r46 = dank_mids._eth_utils.globals :: static
    r47 = 'to_bytes'
    r48 = CPyDict_GetItem(r46, r47)
    if is_error(r48) goto L110 (error at patch_eth_utils:32) else goto L19
L19:
    r49 = dank_mids._eth_utils.globals :: static
    r50 = 'web3'
    r51 = CPyDict_GetItem(r49, r50)
    if is_error(r51) goto L113 (error at patch_eth_utils:32) else goto L20
L20:
    r52 = 'main'
    r53 = CPyObject_GetAttr(r51, r52)
    dec_ref r51
    if is_error(r53) goto L113 (error at patch_eth_utils:32) else goto L21
L21:
    r54 = 'to_bytes'
    r55 = PyObject_SetAttr(r53, r54, r48)
    dec_ref r53
    dec_ref r48
    r56 = r55 >= 0 :: signed
    if not r56 goto L110 (error at patch_eth_utils:32) else goto L22 :: bool
L22:
    r57 = dank_mids._eth_utils.globals :: static
    r58 = web3.middleware.filter :: module
    r59 = load_address _Py_NoneStruct
    r60 = r58 != r59
    if r60 goto L25 else goto L23 :: bool
L23:
    r61 = 'web3.middleware.filter'
    r62 = PyImport_Import(r61)
    if is_error(r62) goto L110 (error at patch_eth_utils:34) else goto L24
L24:
    web3.middleware.filter = r62 :: module
    dec_ref r62
L25:
    r63 = 'web3'
    r64 = PyImport_GetModuleDict()
    r65 = 'web3'
    r66 = CPyDict_GetItem(r64, r65)
    if is_error(r66) goto L110 (error at patch_eth_utils:34) else goto L26
L26:
    r67 = CPyDict_SetItem(r57, r63, r66)
    dec_ref r66
    r68 = r67 >= 0 :: signed
    if not r68 goto L110 (error at patch_eth_utils:34) else goto L27 :: bool
L27:
    r69 = dank_mids._eth_utils.globals :: static
    r70 = 'to_hex'
    r71 = CPyDict_GetItem(r69, r70)
    if is_error(r71) goto L110 (error at patch_eth_utils:36) else goto L28
L28:
    r72 = dank_mids._eth_utils.globals :: static
    r73 = 'web3'
    r74 = CPyDict_GetItem(r72, r73)
    if is_error(r74) goto L114 (error at patch_eth_utils:36) else goto L29
L29:
    r75 = 'middleware'
    r76 = CPyObject_GetAttr(r74, r75)
    dec_ref r74
    if is_error(r76) goto L114 (error at patch_eth_utils:36) else goto L30
L30:
    r77 = 'filter'
    r78 = CPyObject_GetAttr(r76, r77)
    dec_ref r76
    if is_error(r78) goto L114 (error at patch_eth_utils:36) else goto L31
L31:
    r79 = 'to_hex'
    r80 = PyObject_SetAttr(r78, r79, r71)
    dec_ref r78
    dec_ref r71
    r81 = r80 >= 0 :: signed
    if not r81 goto L110 (error at patch_eth_utils:36) else goto L32 :: bool
L32:
    r82 = dank_mids._eth_utils.globals :: static
    r83 = web3.providers.base :: module
    r84 = load_address _Py_NoneStruct
    r85 = r83 != r84
    if r85 goto L35 else goto L33 :: bool
L33:
    r86 = 'web3.providers.base'
    r87 = PyImport_Import(r86)
    if is_error(r87) goto L110 (error at patch_eth_utils:38) else goto L34
L34:
    web3.providers.base = r87 :: module
    dec_ref r87
L35:
    r88 = 'web3'
    r89 = PyImport_GetModuleDict()
    r90 = 'web3'
    r91 = CPyDict_GetItem(r89, r90)
    if is_error(r91) goto L110 (error at patch_eth_utils:38) else goto L36
L36:
    r92 = CPyDict_SetItem(r82, r88, r91)
    dec_ref r91
    r93 = r92 >= 0 :: signed
    if not r93 goto L110 (error at patch_eth_utils:38) else goto L37 :: bool
L37:
    r94 = dank_mids._eth_utils.globals :: static
    r95 = 'to_bytes'
    r96 = CPyDict_GetItem(r94, r95)
    if is_error(r96) goto L110 (error at patch_eth_utils:40) else goto L38
L38:
    r97 = dank_mids._eth_utils.globals :: static
    r98 = 'web3'
    r99 = CPyDict_GetItem(r97, r98)
    if is_error(r99) goto L115 (error at patch_eth_utils:40) else goto L39
L39:
    r100 = 'providers'
    r101 = CPyObject_GetAttr(r99, r100)
    dec_ref r99
    if is_error(r101) goto L115 (error at patch_eth_utils:40) else goto L40
L40:
    r102 = 'base'
    r103 = CPyObject_GetAttr(r101, r102)
    dec_ref r101
    if is_error(r103) goto L115 (error at patch_eth_utils:40) else goto L41
L41:
    r104 = 'to_bytes'
    r105 = PyObject_SetAttr(r103, r104, r96)
    dec_ref r103
    dec_ref r96
    r106 = r105 >= 0 :: signed
    if not r106 goto L110 (error at patch_eth_utils:40) else goto L42 :: bool
L42:
    r107 = dank_mids._eth_utils.globals :: static
    r108 = web3._utils.encoding :: module
    r109 = load_address _Py_NoneStruct
    r110 = r108 != r109
    if r110 goto L45 else goto L43 :: bool
L43:
    r111 = 'web3._utils.encoding'
    r112 = PyImport_Import(r111)
    if is_error(r112) goto L110 (error at patch_eth_utils:42) else goto L44
L44:
    web3._utils.encoding = r112 :: module
    dec_ref r112
L45:
    r113 = 'web3'
    r114 = PyImport_GetModuleDict()
    r115 = 'web3'
    r116 = CPyDict_GetItem(r114, r115)
    if is_error(r116) goto L110 (error at patch_eth_utils:42) else goto L46
L46:
    r117 = CPyDict_SetItem(r107, r113, r116)
    dec_ref r116
    r118 = r117 >= 0 :: signed
    if not r118 goto L110 (error at patch_eth_utils:42) else goto L47 :: bool
L47:
    r119 = dank_mids._eth_utils.globals :: static
    r120 = 'to_hex'
    r121 = CPyDict_GetItem(r119, r120)
    if is_error(r121) goto L110 (error at patch_eth_utils:44) else goto L48
L48:
    r122 = dank_mids._eth_utils.globals :: static
    r123 = 'web3'
    r124 = CPyDict_GetItem(r122, r123)
    if is_error(r124) goto L116 (error at patch_eth_utils:44) else goto L49
L49:
    r125 = '_utils'
    r126 = CPyObject_GetAttr(r124, r125)
    dec_ref r124
    if is_error(r126) goto L116 (error at patch_eth_utils:44) else goto L50
L50:
    r127 = 'encoding'
    r128 = CPyObject_GetAttr(r126, r127)
    dec_ref r126
    if is_error(r128) goto L116 (error at patch_eth_utils:44) else goto L51
L51:
    r129 = 'to_hex'
    r130 = PyObject_SetAttr(r128, r129, r121)
    dec_ref r128
    dec_ref r121
    r131 = r130 >= 0 :: signed
    if not r131 goto L110 (error at patch_eth_utils:44) else goto L52 :: bool
L52:
    r132 = dank_mids._eth_utils.globals :: static
    r133 = 'to_bytes'
    r134 = CPyDict_GetItem(r132, r133)
    if is_error(r134) goto L110 (error at patch_eth_utils:45) else goto L53
L53:
    r135 = dank_mids._eth_utils.globals :: static
    r136 = 'web3'
    r137 = CPyDict_GetItem(r135, r136)
    if is_error(r137) goto L117 (error at patch_eth_utils:45) else goto L54
L54:
    r138 = '_utils'
    r139 = CPyObject_GetAttr(r137, r138)
    dec_ref r137
    if is_error(r139) goto L117 (error at patch_eth_utils:45) else goto L55
L55:
    r140 = 'encoding'
    r141 = CPyObject_GetAttr(r139, r140)
    dec_ref r139
    if is_error(r141) goto L117 (error at patch_eth_utils:45) else goto L56
L56:
    r142 = 'to_bytes'
    r143 = PyObject_SetAttr(r141, r142, r134)
    dec_ref r141
    dec_ref r134
    r144 = r143 >= 0 :: signed
    if not r144 goto L110 (error at patch_eth_utils:45) else goto L57 :: bool
L57:
    r145 = dank_mids._eth_utils.globals :: static
    r146 = web3._utils.events :: module
    r147 = load_address _Py_NoneStruct
    r148 = r146 != r147
    if r148 goto L60 else goto L58 :: bool
L58:
    r149 = 'web3._utils.events'
    r150 = PyImport_Import(r149)
    if is_error(r150) goto L110 (error at patch_eth_utils:47) else goto L59
L59:
    web3._utils.events = r150 :: module
    dec_ref r150
L60:
    r151 = 'web3'
    r152 = PyImport_GetModuleDict()
    r153 = 'web3'
    r154 = CPyDict_GetItem(r152, r153)
    if is_error(r154) goto L110 (error at patch_eth_utils:47) else goto L61
L61:
    r155 = CPyDict_SetItem(r145, r151, r154)
    dec_ref r154
    r156 = r155 >= 0 :: signed
    if not r156 goto L110 (error at patch_eth_utils:47) else goto L62 :: bool
L62:
    r157 = dank_mids._eth_utils.globals :: static
    r158 = 'to_hex'
    r159 = CPyDict_GetItem(r157, r158)
    if is_error(r159) goto L110 (error at patch_eth_utils:49) else goto L63
L63:
    r160 = dank_mids._eth_utils.globals :: static
    r161 = 'web3'
    r162 = CPyDict_GetItem(r160, r161)
    if is_error(r162) goto L118 (error at patch_eth_utils:49) else goto L64
L64:
    r163 = '_utils'
    r164 = CPyObject_GetAttr(r162, r163)
    dec_ref r162
    if is_error(r164) goto L118 (error at patch_eth_utils:49) else goto L65
L65:
    r165 = 'events'
    r166 = CPyObject_GetAttr(r164, r165)
    dec_ref r164
    if is_error(r166) goto L118 (error at patch_eth_utils:49) else goto L66
L66:
    r167 = 'to_hex'
    r168 = PyObject_SetAttr(r166, r167, r159)
    dec_ref r166
    dec_ref r159
    r169 = r168 >= 0 :: signed
    if not r169 goto L110 (error at patch_eth_utils:49) else goto L67 :: bool
L67:
    r170 = dank_mids._eth_utils.globals :: static
    r171 = 'to_bytes'
    r172 = CPyDict_GetItem(r170, r171)
    if is_error(r172) goto L110 (error at patch_eth_utils:50) else goto L68
L68:
    r173 = dank_mids._eth_utils.globals :: static
    r174 = 'web3'
    r175 = CPyDict_GetItem(r173, r174)
    if is_error(r175) goto L119 (error at patch_eth_utils:50) else goto L69
L69:
    r176 = '_utils'
    r177 = CPyObject_GetAttr(r175, r176)
    dec_ref r175
    if is_error(r177) goto L119 (error at patch_eth_utils:50) else goto L70
L70:
    r178 = 'events'
    r179 = CPyObject_GetAttr(r177, r178)
    dec_ref r177
    if is_error(r179) goto L119 (error at patch_eth_utils:50) else goto L71
L71:
    r180 = 'to_bytes'
    r181 = PyObject_SetAttr(r179, r180, r172)
    dec_ref r179
    dec_ref r172
    r182 = r181 >= 0 :: signed
    if not r182 goto L110 (error at patch_eth_utils:50) else goto L72 :: bool
L72:
    r183 = dank_mids._eth_utils.globals :: static
    r184 = web3._utils.normalizers :: module
    r185 = load_address _Py_NoneStruct
    r186 = r184 != r185
    if r186 goto L75 else goto L73 :: bool
L73:
    r187 = 'web3._utils.normalizers'
    r188 = PyImport_Import(r187)
    if is_error(r188) goto L110 (error at patch_eth_utils:52) else goto L74
L74:
    web3._utils.normalizers = r188 :: module
    dec_ref r188
L75:
    r189 = 'web3'
    r190 = PyImport_GetModuleDict()
    r191 = 'web3'
    r192 = CPyDict_GetItem(r190, r191)
    if is_error(r192) goto L110 (error at patch_eth_utils:52) else goto L76
L76:
    r193 = CPyDict_SetItem(r183, r189, r192)
    dec_ref r192
    r194 = r193 >= 0 :: signed
    if not r194 goto L110 (error at patch_eth_utils:52) else goto L77 :: bool
L77:
    r195 = dank_mids._eth_utils.globals :: static
    r196 = 'to_hex'
    r197 = CPyDict_GetItem(r195, r196)
    if is_error(r197) goto L110 (error at patch_eth_utils:54) else goto L78
L78:
    r198 = dank_mids._eth_utils.globals :: static
    r199 = 'web3'
    r200 = CPyDict_GetItem(r198, r199)
    if is_error(r200) goto L120 (error at patch_eth_utils:54) else goto L79
L79:
    r201 = '_utils'
    r202 = CPyObject_GetAttr(r200, r201)
    dec_ref r200
    if is_error(r202) goto L120 (error at patch_eth_utils:54) else goto L80
L80:
    r203 = 'normalizers'
    r204 = CPyObject_GetAttr(r202, r203)
    dec_ref r202
    if is_error(r204) goto L120 (error at patch_eth_utils:54) else goto L81
L81:
    r205 = 'to_hex'
    r206 = PyObject_SetAttr(r204, r205, r197)
    dec_ref r204
    dec_ref r197
    r207 = r206 >= 0 :: signed
    if not r207 goto L110 (error at patch_eth_utils:54) else goto L82 :: bool
L82:
    r208 = dank_mids._eth_utils.globals :: static
    r209 = 'to_bytes'
    r210 = CPyDict_GetItem(r208, r209)
    if is_error(r210) goto L110 (error at patch_eth_utils:55) else goto L83
L83:
    r211 = dank_mids._eth_utils.globals :: static
    r212 = 'web3'
    r213 = CPyDict_GetItem(r211, r212)
    if is_error(r213) goto L121 (error at patch_eth_utils:55) else goto L84
L84:
    r214 = '_utils'
    r215 = CPyObject_GetAttr(r213, r214)
    dec_ref r213
    if is_error(r215) goto L121 (error at patch_eth_utils:55) else goto L85
L85:
    r216 = 'normalizers'
    r217 = CPyObject_GetAttr(r215, r216)
    dec_ref r215
    if is_error(r217) goto L121 (error at patch_eth_utils:55) else goto L86
L86:
    r218 = 'to_bytes'
    r219 = PyObject_SetAttr(r217, r218, r210)
    dec_ref r217
    dec_ref r210
    r220 = r219 >= 0 :: signed
    if not r220 goto L110 (error at patch_eth_utils:55) else goto L87 :: bool
L87:
    r221 = dank_mids._eth_utils.globals :: static
    r222 = web3._utils.type_conversion :: module
    r223 = load_address _Py_NoneStruct
    r224 = r222 != r223
    if r224 goto L90 else goto L88 :: bool
L88:
    r225 = 'web3._utils.type_conversion'
    r226 = PyImport_Import(r225)
    if is_error(r226) goto L92 (error at patch_eth_utils:59) else goto L89
L89:
    web3._utils.type_conversion = r226 :: module
    dec_ref r226
L90:
    r227 = 'web3'
    r228 = PyImport_GetModuleDict()
    r229 = 'web3'
    r230 = CPyDict_GetItem(r228, r229)
    if is_error(r230) goto L92 (error at patch_eth_utils:59) else goto L91
L91:
    r231 = CPyDict_SetItem(r221, r227, r230)
    dec_ref r230
    r232 = r231 >= 0 :: signed
    if not r232 goto L92 (error at patch_eth_utils:59) else goto L99 :: bool
L92:
    r233 = CPy_CatchError()
    r234 = builtins :: module
    r235 = 'ModuleNotFoundError'
    r236 = CPyObject_GetAttr(r234, r235)
    if is_error(r236) goto L97 (error at patch_eth_utils:60) else goto L93
L93:
    r237 = CPy_ExceptionMatches(r236)
    dec_ref r236
    if r237 goto L96 else goto L94 :: bool
L94:
    CPy_Reraise()
    if not 0 goto L97 else goto L122 :: bool
L95:
    unreachable
L96:
    CPy_RestoreExcInfo(r233)
    dec_ref r233
    goto L109
L97:
    CPy_RestoreExcInfo(r233)
    dec_ref r233
    r238 = CPy_KeepPropagating()
    if not r238 goto L110 else goto L98 :: bool
L98:
    unreachable
L99:
    r239 = dank_mids._eth_utils.globals :: static
    r240 = 'to_hex'
    r241 = CPyDict_GetItem(r239, r240)
    if is_error(r241) goto L110 (error at patch_eth_utils:63) else goto L100
L100:
    r242 = dank_mids._eth_utils.globals :: static
    r243 = 'web3'
    r244 = CPyDict_GetItem(r242, r243)
    if is_error(r244) goto L123 (error at patch_eth_utils:63) else goto L101
L101:
    r245 = '_utils'
    r246 = CPyObject_GetAttr(r244, r245)
    dec_ref r244
    if is_error(r246) goto L123 (error at patch_eth_utils:63) else goto L102
L102:
    r247 = 'type_conversion'
    r248 = CPyObject_GetAttr(r246, r247)
    dec_ref r246
    if is_error(r248) goto L123 (error at patch_eth_utils:63) else goto L103
L103:
    r249 = 'to_hex'
    r250 = PyObject_SetAttr(r248, r249, r241)
    dec_ref r248
    dec_ref r241
    r251 = r250 >= 0 :: signed
    if not r251 goto L110 (error at patch_eth_utils:63) else goto L104 :: bool
L104:
    r252 = dank_mids._eth_utils.globals :: static
    r253 = 'to_bytes'
    r254 = CPyDict_GetItem(r252, r253)
    if is_error(r254) goto L110 (error at patch_eth_utils:64) else goto L105
L105:
    r255 = dank_mids._eth_utils.globals :: static
    r256 = 'web3'
    r257 = CPyDict_GetItem(r255, r256)
    if is_error(r257) goto L124 (error at patch_eth_utils:64) else goto L106
L106:
    r258 = '_utils'
    r259 = CPyObject_GetAttr(r257, r258)
    dec_ref r257
    if is_error(r259) goto L124 (error at patch_eth_utils:64) else goto L107
L107:
    r260 = 'type_conversion'
    r261 = CPyObject_GetAttr(r259, r260)
    dec_ref r259
    if is_error(r261) goto L124 (error at patch_eth_utils:64) else goto L108
L108:
    r262 = 'to_bytes'
    r263 = PyObject_SetAttr(r261, r262, r254)
    dec_ref r261
    dec_ref r254
    r264 = r263 >= 0 :: signed
    if not r264 goto L110 (error at patch_eth_utils:64) else goto L109 :: bool
L109:
    return 1
L110:
    r265 = <error> :: None
    return r265
L111:
    dec_ref r14
    goto L110
L112:
    dec_ref r37
    goto L110
L113:
    dec_ref r48
    goto L110
L114:
    dec_ref r71
    goto L110
L115:
    dec_ref r96
    goto L110
L116:
    dec_ref r121
    goto L110
L117:
    dec_ref r134
    goto L110
L118:
    dec_ref r159
    goto L110
L119:
    dec_ref r172
    goto L110
L120:
    dec_ref r197
    goto L110
L121:
    dec_ref r210
    goto L110
L122:
    dec_ref r233
    goto L95
L123:
    dec_ref r241
    goto L110
L124:
    dec_ref r254
    goto L110

def to_hex(primitive, hexstr, text):
    primitive, hexstr :: union[object, None]
    text :: union[str, None]
    r0, r1, r2, r3 :: object
    r4 :: bit
    r5 :: object
    r6 :: str
    r7 :: object[1]
    r8 :: object_ptr
    r9, r10, r11 :: object
    r12 :: bit
    r13 :: str
    r14 :: bytes
    r15, r16 :: object
    r17 :: i32
    r18 :: bit
    r19, r20 :: bool
    r21, r22, r23 :: str
    r24, r25 :: object
    r26 :: str
    r27 :: object
    r28 :: tuple[object, object]
    r29 :: object
    r30 :: i32
    r31 :: bit
    r32 :: bool
    r33, r34 :: object
    r35 :: str
    r36 :: object
    r37 :: i32
    r38 :: bit
    r39 :: bool
    r40 :: object
    r41 :: object[1]
    r42 :: object_ptr
    r43 :: object
    r44 :: bytes
    r45, r46 :: object
    r47 :: i32
    r48 :: bit
    r49 :: bool
    r50 :: str
    r51 :: object
    r52 :: str
    r53 :: object
    r54 :: object[1]
    r55 :: object_ptr
    r56, r57 :: object
    r58 :: i32
    r59 :: bit
    r60 :: bool
    r61 :: int
    r62 :: object
    r63 :: str
    r64, r65 :: object
    r66 :: object[1]
    r67 :: object_ptr
    r68 :: object
    r69, r70 :: str
    r71, r72 :: object
    r73 :: str
    r74 :: object
    r75 :: object[1]
    r76 :: object_ptr
    r77 :: object
    r78, r79, r80 :: str
    r81 :: object
    r82 :: str
    r83 :: object
    r84 :: object[1]
    r85 :: object_ptr
    r86, r87 :: object
L0:
    if is_error(primitive) goto L1 else goto L57
L1:
    r0 = box(None, 1)
    inc_ref r0
    primitive = r0
L2:
    if is_error(hexstr) goto L3 else goto L58
L3:
    r1 = box(None, 1)
    inc_ref r1
    hexstr = r1
L4:
    if is_error(text) goto L5 else goto L59
L5:
    r2 = box(None, 1)
    inc_ref r2
    text = r2
L6:
    r3 = load_address _Py_NoneStruct
    r4 = hexstr != r3
    if r4 goto L60 else goto L61 :: bool
L7:
    r5 = hexstr
    r6 = 'lower'
    r7 = [r5]
    r8 = load_address r7
    r9 = PyObject_VectorcallMethod(r6, r8, 9223372036854775809, 0)
    if is_error(r9) goto L62 (error at to_hex:78) else goto L8
L8:
    dec_ref r5
L9:
    r10 = add_0x_prefix(r9)
    dec_ref r9
    if is_error(r10) goto L56 (error at to_hex:78) else goto L10
L10:
    return r10
L11:
    r11 = load_address _Py_NoneStruct
    r12 = text != r11
    if r12 goto L63 else goto L64 :: bool
L12:
    r13 = cast(str, text)
    if is_error(r13) goto L56 (error at to_hex:81) else goto L13
L13:
    r14 = PyUnicode_AsUTF8String(r13)
    dec_ref r13
    if is_error(r14) goto L56 (error at to_hex:81) else goto L14
L14:
    r15 = encode_hex(r14)
    dec_ref r14
    if is_error(r15) goto L56 (error at to_hex:81) else goto L15
L15:
    return r15
L16:
    r16 = load_address PyBool_Type
    r17 = PyObject_IsInstance(primitive, r16)
    r18 = r17 >= 0 :: signed
    if not r18 goto L65 (error at to_hex:83) else goto L17 :: bool
L17:
    r19 = truncate r17: i32 to builtins.bool
    if r19 goto L18 else goto L23 :: bool
L18:
    r20 = unbox(bool, primitive)
    dec_ref primitive
    if is_error(r20) goto L56 (error at to_hex:84) else goto L19
L19:
    if r20 goto L20 else goto L21 :: bool
L20:
    r21 = '0x1'
    inc_ref r21
    r22 = r21
    goto L22
L21:
    r23 = '0x0'
    inc_ref r23
    r22 = r23
L22:
    return r22
L23:
    r24 = load_address PyBytes_Type
    r25 = builtins :: module
    r26 = 'bytearray'
    r27 = CPyObject_GetAttr(r25, r26)
    if is_error(r27) goto L65 (error at to_hex:86) else goto L24
L24:
    inc_ref r24
    r28 = (r24, r27)
    r29 = box(tuple[object, object], r28)
    r30 = PyObject_IsInstance(primitive, r29)
    dec_ref r29
    r31 = r30 >= 0 :: signed
    if not r31 goto L65 (error at to_hex:86) else goto L25 :: bool
L25:
    r32 = truncate r30: i32 to builtins.bool
    if r32 goto L26 else goto L28 :: bool
L26:
    r33 = encode_hex(primitive)
    dec_ref primitive
    if is_error(r33) goto L56 (error at to_hex:87) else goto L27
L27:
    return r33
L28:
    r34 = builtins :: module
    r35 = 'memoryview'
    r36 = CPyObject_GetAttr(r34, r35)
    if is_error(r36) goto L65 (error at to_hex:89) else goto L29
L29:
    r37 = PyObject_IsInstance(primitive, r36)
    dec_ref r36
    r38 = r37 >= 0 :: signed
    if not r38 goto L65 (error at to_hex:89) else goto L30 :: bool
L30:
    r39 = truncate r37: i32 to builtins.bool
    if r39 goto L31 else goto L35 :: bool
L31:
    r40 = load_address PyBytes_Type
    r41 = [primitive]
    r42 = load_address r41
    r43 = _PyObject_Vectorcall(r40, r42, 1, 0)
    if is_error(r43) goto L65 (error at to_hex:90) else goto L32
L32:
    dec_ref primitive
    r44 = cast(bytes, r43)
    if is_error(r44) goto L56 (error at to_hex:90) else goto L33
L33:
    r45 = encode_hex(r44)
    dec_ref r44
    if is_error(r45) goto L56 (error at to_hex:90) else goto L34
L34:
    return r45
L35:
    r46 = load_address PyUnicode_Type
    r47 = PyObject_IsInstance(primitive, r46)
    r48 = r47 >= 0 :: signed
    if not r48 goto L65 (error at to_hex:92) else goto L36 :: bool
L36:
    r49 = truncate r47: i32 to builtins.bool
    if r49 goto L66 else goto L41 :: bool
L37:
    r50 = 'Unsupported type: The primitive argument must be one of: bytes,bytearray, int or bool and not str'
    r51 = builtins :: module
    r52 = 'TypeError'
    r53 = CPyObject_GetAttr(r51, r52)
    if is_error(r53) goto L56 (error at to_hex:93) else goto L38
L38:
    r54 = [r50]
    r55 = load_address r54
    r56 = _PyObject_Vectorcall(r53, r55, 1, 0)
    dec_ref r53
    if is_error(r56) goto L56 (error at to_hex:93) else goto L39
L39:
    CPy_Raise(r56)
    dec_ref r56
    if not 0 goto L56 (error at to_hex:93) else goto L40 :: bool
L40:
    unreachable
L41:
    r57 = load_address PyLong_Type
    r58 = PyObject_IsInstance(primitive, r57)
    r59 = r58 >= 0 :: signed
    if not r59 goto L65 (error at to_hex:98) else goto L42 :: bool
L42:
    r60 = truncate r58: i32 to builtins.bool
    if r60 goto L43 else goto L48 :: bool
L43:
    r61 = unbox(int, primitive)
    dec_ref primitive
    if is_error(r61) goto L56 (error at to_hex:99) else goto L44
L44:
    r62 = builtins :: module
    r63 = 'hex'
    r64 = CPyObject_GetAttr(r62, r63)
    if is_error(r64) goto L67 (error at to_hex:99) else goto L45
L45:
    r65 = box(int, r61)
    r66 = [r65]
    r67 = load_address r66
    r68 = _PyObject_Vectorcall(r64, r67, 1, 0)
    dec_ref r64
    if is_error(r68) goto L68 (error at to_hex:99) else goto L46
L46:
    dec_ref r65
    r69 = cast(str, r68)
    if is_error(r69) goto L56 (error at to_hex:99) else goto L47
L47:
    return r69
L48:
    r70 = "Unsupported type: '"
    r71 = PyObject_Type(primitive)
    dec_ref primitive
    r72 = builtins :: module
    r73 = 'repr'
    r74 = CPyObject_GetAttr(r72, r73)
    if is_error(r74) goto L69 (error at to_hex:102) else goto L49
L49:
    r75 = [r71]
    r76 = load_address r75
    r77 = _PyObject_Vectorcall(r74, r76, 1, 0)
    dec_ref r74
    if is_error(r77) goto L69 (error at to_hex:102) else goto L50
L50:
    dec_ref r71
    r78 = cast(str, r77)
    if is_error(r78) goto L56 (error at to_hex:102) else goto L51
L51:
    r79 = "'. Must be one of: bool, str, bytes, bytearray or int."
    r80 = CPyStr_Build(3, r70, r78, r79)
    dec_ref r78
    if is_error(r80) goto L56 (error at to_hex:102) else goto L52
L52:
    r81 = builtins :: module
    r82 = 'TypeError'
    r83 = CPyObject_GetAttr(r81, r82)
    if is_error(r83) goto L70 (error at to_hex:101) else goto L53
L53:
    r84 = [r80]
    r85 = load_address r84
    r86 = _PyObject_Vectorcall(r83, r85, 1, 0)
    dec_ref r83
    if is_error(r86) goto L70 (error at to_hex:101) else goto L54
L54:
    dec_ref r80
    CPy_Raise(r86)
    dec_ref r86
    if not 0 goto L56 (error at to_hex:101) else goto L55 :: bool
L55:
    unreachable
L56:
    r87 = <error> :: object
    return r87
L57:
    inc_ref primitive
    goto L2
L58:
    inc_ref hexstr
    goto L4
L59:
    inc_ref text
    goto L6
L60:
    dec_ref primitive
    dec_ref text
    goto L7
L61:
    dec_ref hexstr
    goto L11
L62:
    dec_ref r5
    goto L56
L63:
    dec_ref primitive
    goto L12
L64:
    dec_ref text
    goto L16
L65:
    dec_ref primitive
    goto L56
L66:
    dec_ref primitive
    goto L37
L67:
    dec_ref r61 :: int
    goto L56
L68:
    dec_ref r65
    goto L56
L69:
    dec_ref r71
    goto L56
L70:
    dec_ref r80
    goto L56

def to_bytes(primitive, hexstr, text):
    primitive, hexstr :: union[object, None]
    text :: union[str, None]
    r0, r1, r2, r3 :: object
    r4 :: i32
    r5 :: bit
    r6, r7 :: bool
    r8, r9, r10 :: bytes
    r11 :: object
    r12 :: str
    r13, r14 :: object
    r15 :: str
    r16 :: object
    r17 :: tuple[object, object]
    r18 :: object
    r19 :: i32
    r20 :: bit
    r21 :: bool
    r22 :: object
    r23 :: object[1]
    r24 :: object_ptr
    r25 :: object
    r26 :: bytes
    r27 :: object
    r28 :: i32
    r29 :: bit
    r30 :: bool
    r31 :: bytes
    r32 :: object
    r33 :: i32
    r34 :: bit
    r35 :: bool
    r36 :: int
    r37 :: object
    r38 :: union[object, None]
    r39 :: union[str, None]
    r40 :: object
    r41 :: union[object, None]
    r42 :: union[str, None]
    r43 :: bytes
    r44 :: object
    r45 :: bit
    r46, r47 :: int
    r48 :: bit
    r49 :: str
    r50 :: object
    r51, r52 :: str
    r53 :: union[str, object]
    r54 :: str
    r55 :: bytes
    r56 :: object
    r57 :: bit
    r58 :: str
    r59 :: bytes
    r60 :: str
    r61 :: object
    r62 :: str
    r63 :: object
    r64 :: object[1]
    r65 :: object_ptr
    r66 :: object
    r67 :: bytes
L0:
    if is_error(primitive) goto L1 else goto L51
L1:
    r0 = box(None, 1)
    inc_ref r0
    primitive = r0
L2:
    if is_error(hexstr) goto L3 else goto L52
L3:
    r1 = box(None, 1)
    inc_ref r1
    hexstr = r1
L4:
    if is_error(text) goto L5 else goto L53
L5:
    r2 = box(None, 1)
    inc_ref r2
    text = r2
L6:
    r3 = load_address PyBool_Type
    r4 = PyObject_IsInstance(primitive, r3)
    r5 = r4 >= 0 :: signed
    if not r5 goto L54 (error at to_bytes:112) else goto L7 :: bool
L7:
    r6 = truncate r4: i32 to builtins.bool
    if r6 goto L55 else goto L13 :: bool
L8:
    r7 = unbox(bool, primitive)
    dec_ref primitive
    if is_error(r7) goto L50 (error at to_bytes:113) else goto L9
L9:
    if r7 goto L10 else goto L11 :: bool
L10:
    r8 = b'\x01'
    inc_ref r8
    r9 = r8
    goto L12
L11:
    r10 = b'\x00'
    inc_ref r10
    r9 = r10
L12:
    return r9
L13:
    r11 = builtins :: module
    r12 = 'bytearray'
    r13 = CPyObject_GetAttr(r11, r12)
    if is_error(r13) goto L54 (error at to_bytes:114) else goto L14
L14:
    r14 = builtins :: module
    r15 = 'memoryview'
    r16 = CPyObject_GetAttr(r14, r15)
    if is_error(r16) goto L56 (error at to_bytes:114) else goto L15
L15:
    r17 = (r13, r16)
    r18 = box(tuple[object, object], r17)
    r19 = PyObject_IsInstance(primitive, r18)
    dec_ref r18
    r20 = r19 >= 0 :: signed
    if not r20 goto L54 (error at to_bytes:114) else goto L16 :: bool
L16:
    r21 = truncate r19: i32 to builtins.bool
    if r21 goto L57 else goto L20 :: bool
L17:
    r22 = load_address PyBytes_Type
    r23 = [primitive]
    r24 = load_address r23
    r25 = _PyObject_Vectorcall(r22, r24, 1, 0)
    if is_error(r25) goto L58 (error at to_bytes:115) else goto L18
L18:
    dec_ref primitive
    r26 = cast(bytes, r25)
    if is_error(r26) goto L50 (error at to_bytes:115) else goto L19
L19:
    return r26
L20:
    r27 = load_address PyBytes_Type
    r28 = PyObject_IsInstance(primitive, r27)
    r29 = r28 >= 0 :: signed
    if not r29 goto L54 (error at to_bytes:116) else goto L21 :: bool
L21:
    r30 = truncate r28: i32 to builtins.bool
    if r30 goto L59 else goto L24 :: bool
L22:
    r31 = cast(bytes, primitive)
    if is_error(r31) goto L50 (error at to_bytes:117) else goto L23
L23:
    return r31
L24:
    r32 = load_address PyLong_Type
    r33 = PyObject_IsInstance(primitive, r32)
    r34 = r33 >= 0 :: signed
    if not r34 goto L54 (error at to_bytes:118) else goto L25 :: bool
L25:
    r35 = truncate r33: i32 to builtins.bool
    if r35 goto L60 else goto L61 :: bool
L26:
    r36 = unbox(int, primitive)
    dec_ref primitive
    if is_error(r36) goto L50 (error at to_bytes:119) else goto L27
L27:
    r37 = box(int, r36)
    r38 = <error> :: union[object, None]
    r39 = <error> :: union[str, None]
    r40 = to_hex(r37, r38, r39)
    dec_ref r37
    if is_error(r40) goto L50 (error at to_bytes:119) else goto L28
L28:
    r41 = <error> :: union[object, None]
    r42 = <error> :: union[str, None]
    r43 = to_bytes(r41, r40, r42)
    dec_ref r40
    if is_error(r43) goto L50 (error at to_bytes:119) else goto L29
L29:
    return r43
L30:
    r44 = load_address _Py_NoneStruct
    r45 = hexstr != r44
    if r45 goto L62 else goto L63 :: bool
L31:
    r46 = CPyObject_Size(hexstr)
    if is_error(r46) goto L64 (error at to_bytes:121) else goto L32
L32:
    r47 = CPyTagged_Remainder(r46, 4)
    dec_ref r46 :: int
    if is_error(r47) goto L64 (error at to_bytes:121) else goto L33
L33:
    r48 = r47 != 0
    dec_ref r47 :: int
    if r48 goto L34 else goto L38 :: bool
L34:
    r49 = '0x0'
    r50 = remove_0x_prefix(hexstr)
    dec_ref hexstr
    if is_error(r50) goto L50 (error at to_bytes:121) else goto L35
L35:
    r51 = PyObject_Str(r50)
    dec_ref r50
    if is_error(r51) goto L50 (error at to_bytes:121) else goto L36
L36:
    r52 = CPyStr_Build(2, r49, r51)
    dec_ref r51
    if is_error(r52) goto L50 (error at to_bytes:121) else goto L37
L37:
    r53 = r52
    goto L39
L38:
    r53 = hexstr
L39:
    r54 = cast(str, r53)
    if is_error(r54) goto L50 (error at to_bytes:121) else goto L40
L40:
    r55 = decode_hex(r54)
    dec_ref r54
    if is_error(r55) goto L50 (error at to_bytes:121) else goto L41
L41:
    return r55
L42:
    r56 = load_address _Py_NoneStruct
    r57 = text != r56
    if r57 goto L43 else goto L65 :: bool
L43:
    r58 = cast(str, text)
    if is_error(r58) goto L50 (error at to_bytes:123) else goto L44
L44:
    r59 = PyUnicode_AsUTF8String(r58)
    dec_ref r58
    if is_error(r59) goto L50 (error at to_bytes:123) else goto L45
L45:
    return r59
L46:
    r60 = 'expected a bool, int, byte or bytearray in first arg, or keyword of hexstr or text'
    r61 = builtins :: module
    r62 = 'TypeError'
    r63 = CPyObject_GetAttr(r61, r62)
    if is_error(r63) goto L50 (error at to_bytes:124) else goto L47
L47:
    r64 = [r60]
    r65 = load_address r64
    r66 = _PyObject_Vectorcall(r63, r65, 1, 0)
    dec_ref r63
    if is_error(r66) goto L50 (error at to_bytes:124) else goto L48
L48:
    CPy_Raise(r66)
    dec_ref r66
    if not 0 goto L50 (error at to_bytes:124) else goto L49 :: bool
L49:
    unreachable
L50:
    r67 = <error> :: bytes
    return r67
L51:
    inc_ref primitive
    goto L2
L52:
    inc_ref hexstr
    goto L4
L53:
    inc_ref text
    goto L6
L54:
    dec_ref primitive
    dec_ref hexstr
    dec_ref text
    goto L50
L55:
    dec_ref hexstr
    dec_ref text
    goto L8
L56:
    dec_ref primitive
    dec_ref hexstr
    dec_ref text
    dec_ref r13
    goto L50
L57:
    dec_ref hexstr
    dec_ref text
    goto L17
L58:
    dec_ref primitive
    goto L50
L59:
    dec_ref hexstr
    dec_ref text
    goto L22
L60:
    dec_ref hexstr
    dec_ref text
    goto L26
L61:
    dec_ref primitive
    goto L30
L62:
    dec_ref text
    goto L31
L63:
    dec_ref hexstr
    goto L42
L64:
    dec_ref hexstr
    goto L50
L65:
    dec_ref text
    goto L46

def decode_hex(value):
    value :: str
    r0 :: object
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4 :: str
    r5 :: object
    r6 :: str
    r7 :: object
    r8 :: object[1]
    r9 :: object_ptr
    r10, r11 :: object
    r12, r13 :: str
    r14 :: object[2]
    r15 :: object_ptr
    r16, r17 :: object
    r18 :: bool
    r19 :: object[1]
    r20 :: object_ptr
    r21 :: object
    r22, r23 :: bytes
L0:
    r0 = load_address PyUnicode_Type
    r1 = PyObject_IsInstance(value, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L14 (error at decode_hex:130) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L6 else goto L2 :: bool
L2:
    r4 = 'Value must be an instance of str'
    r5 = builtins :: module
    r6 = 'TypeError'
    r7 = CPyObject_GetAttr(r5, r6)
    if is_error(r7) goto L14 (error at decode_hex:131) else goto L3
L3:
    r8 = [r4]
    r9 = load_address r8
    r10 = _PyObject_Vectorcall(r7, r9, 1, 0)
    dec_ref r7
    if is_error(r10) goto L14 (error at decode_hex:131) else goto L4
L4:
    CPy_Raise(r10)
    dec_ref r10
    if not 0 goto L14 (error at decode_hex:131) else goto L5 :: bool
L5:
    unreachable
L6:
    r11 = remove_0x_prefix(value)
    if is_error(r11) goto L14 (error at decode_hex:132) else goto L7
L7:
    r12 = 'ascii'
    r13 = 'encode'
    r14 = [r11, r12]
    r15 = load_address r14
    r16 = PyObject_VectorcallMethod(r13, r15, 9223372036854775810, 0)
    if is_error(r16) goto L15 (error at decode_hex:134) else goto L8
L8:
    dec_ref r11
    r17 = dank_mids._eth_utils.unhexlify :: static
    if is_error(r17) goto L16 else goto L11
L9:
    r18 = raise NameError('value for final name "unhexlify" was not set')
    if not r18 goto L14 (error at decode_hex:135) else goto L10 :: bool
L10:
    unreachable
L11:
    r19 = [r16]
    r20 = load_address r19
    r21 = _PyObject_Vectorcall(r17, r20, 1, 0)
    if is_error(r21) goto L17 (error at decode_hex:135) else goto L12
L12:
    dec_ref r16
    r22 = cast(bytes, r21)
    if is_error(r22) goto L14 (error at decode_hex:135) else goto L13
L13:
    return r22
L14:
    r23 = <error> :: bytes
    return r23
L15:
    dec_ref r11
    goto L14
L16:
    dec_ref r16
    goto L9
L17:
    dec_ref r16
    goto L14

def encode_hex(value):
    value, r0, r1 :: object
    r2 :: str
    r3 :: object
    r4 :: tuple[object, object]
    r5 :: object
    r6 :: i32
    r7 :: bit
    r8 :: bool
    ascii_bytes :: union[bytes, object]
    r9 :: object
    r10 :: i32
    r11 :: bit
    r12 :: bool
    r13 :: str
    r14 :: bytes
    r15 :: str
    r16 :: object
    r17 :: str
    r18 :: object
    r19 :: object[1]
    r20 :: object_ptr
    r21, r22 :: object
    r23 :: bool
    r24 :: object[1]
    r25 :: object_ptr
    r26 :: object
    r27 :: bytes
    r28, r29 :: str
    r30, r31 :: object
L0:
    r0 = load_address PyBytes_Type
    r1 = builtins :: module
    r2 = 'bytearray'
    r3 = CPyObject_GetAttr(r1, r2)
    if is_error(r3) goto L21 (error at encode_hex:139) else goto L1
L1:
    inc_ref r0
    r4 = (r0, r3)
    r5 = box(tuple[object, object], r4)
    r6 = PyObject_IsInstance(value, r5)
    dec_ref r5
    r7 = r6 >= 0 :: signed
    if not r7 goto L21 (error at encode_hex:139) else goto L2 :: bool
L2:
    r8 = truncate r6: i32 to builtins.bool
    if r8 goto L3 else goto L4 :: bool
L3:
    inc_ref value
    ascii_bytes = value
    goto L13
L4:
    r9 = load_address PyUnicode_Type
    r10 = PyObject_IsInstance(value, r9)
    r11 = r10 >= 0 :: signed
    if not r11 goto L21 (error at encode_hex:141) else goto L5 :: bool
L5:
    r12 = truncate r10: i32 to builtins.bool
    if r12 goto L6 else goto L9 :: bool
L6:
    inc_ref value
    r13 = cast(str, value)
    if is_error(r13) goto L21 (error at encode_hex:142) else goto L7
L7:
    r14 = PyUnicode_AsASCIIString(r13)
    dec_ref r13
    if is_error(r14) goto L21 (error at encode_hex:142) else goto L8
L8:
    ascii_bytes = r14
    goto L13
L9:
    r15 = 'Value must be an instance of str or unicode'
    r16 = builtins :: module
    r17 = 'TypeError'
    r18 = CPyObject_GetAttr(r16, r17)
    if is_error(r18) goto L21 (error at encode_hex:144) else goto L10
L10:
    r19 = [r15]
    r20 = load_address r19
    r21 = _PyObject_Vectorcall(r18, r20, 1, 0)
    dec_ref r18
    if is_error(r21) goto L21 (error at encode_hex:144) else goto L11
L11:
    CPy_Raise(r21)
    dec_ref r21
    if not 0 goto L21 (error at encode_hex:144) else goto L12 :: bool
L12:
    unreachable
L13:
    r22 = dank_mids._eth_utils.hexlify :: static
    if is_error(r22) goto L22 else goto L16
L14:
    r23 = raise NameError('value for final name "hexlify" was not set')
    if not r23 goto L21 (error at encode_hex:145) else goto L15 :: bool
L15:
    unreachable
L16:
    r24 = [ascii_bytes]
    r25 = load_address r24
    r26 = _PyObject_Vectorcall(r22, r25, 1, 0)
    if is_error(r26) goto L23 (error at encode_hex:145) else goto L17
L17:
    dec_ref ascii_bytes
    r27 = cast(bytes, r26)
    if is_error(r27) goto L21 (error at encode_hex:145) else goto L18
L18:
    r28 = 'ascii'
    r29 = CPy_Decode(r27, r28, 0)
    dec_ref r27
    if is_error(r29) goto L21 (error at encode_hex:145) else goto L19
L19:
    r30 = add_0x_prefix(r29)
    dec_ref r29
    if is_error(r30) goto L21 (error at encode_hex:146) else goto L20
L20:
    return r30
L21:
    r31 = <error> :: object
    return r31
L22:
    dec_ref ascii_bytes
    goto L14
L23:
    dec_ref ascii_bytes
    goto L21

def is_0x_prefixed(value):
    value :: str
    r0 :: object
    r1 :: i32
    r2 :: bit
    r3 :: bool
    r4, r5, r6 :: str
    r7 :: object
    r8 :: str
    r9 :: object
    r10 :: object[1]
    r11 :: object_ptr
    r12 :: object
    r13, r14 :: str
    r15 :: object[3]
    r16 :: object_ptr
    r17 :: object
    r18 :: list
    r19, r20, r21 :: ptr
    r22 :: str
    r23 :: object
    r24 :: str
    r25 :: object
    r26 :: object[1]
    r27 :: object_ptr
    r28 :: object
    r29, r30 :: str
    r31 :: tuple[str, str]
    r32 :: str
    r33 :: object
    r34 :: object[2]
    r35 :: object_ptr
    r36 :: object
    r37, r38 :: bool
L0:
    r0 = load_address PyUnicode_Type
    r1 = PyObject_IsInstance(value, r0)
    r2 = r1 >= 0 :: signed
    if not r2 goto L14 (error at is_0x_prefixed:150) else goto L1 :: bool
L1:
    r3 = truncate r1: i32 to builtins.bool
    if r3 goto L11 else goto L2 :: bool
L2:
    r4 = ''
    r5 = 'is_0x_prefixed requires text typed arguments. Got: '
    r6 = '{:{}}'
    r7 = builtins :: module
    r8 = 'repr'
    r9 = CPyObject_GetAttr(r7, r8)
    if is_error(r9) goto L14 (error at is_0x_prefixed:151) else goto L3
L3:
    r10 = [value]
    r11 = load_address r10
    r12 = _PyObject_Vectorcall(r9, r11, 1, 0)
    dec_ref r9
    if is_error(r12) goto L14 (error at is_0x_prefixed:151) else goto L4
L4:
    r13 = ''
    r14 = 'format'
    r15 = [r6, r12, r13]
    r16 = load_address r15
    r17 = PyObject_VectorcallMethod(r14, r16, 9223372036854775811, 0)
    if is_error(r17) goto L15 (error at is_0x_prefixed:151) else goto L5
L5:
    dec_ref r12
    r18 = PyList_New(2)
    if is_error(r18) goto L16 (error at is_0x_prefixed:151) else goto L6
L6:
    r19 = get_element_ptr r18 ob_item :: PyListObject
    r20 = load_mem r19 :: ptr*
    inc_ref r5
    set_mem r20, r5 :: builtins.object*
    r21 = r20 + 8
    set_mem r21, r17 :: builtins.object*
    r22 = PyUnicode_Join(r4, r18)
    dec_ref r18
    if is_error(r22) goto L14 (error at is_0x_prefixed:151) else goto L7
L7:
    r23 = builtins :: module
    r24 = 'TypeError'
    r25 = CPyObject_GetAttr(r23, r24)
    if is_error(r25) goto L17 (error at is_0x_prefixed:151) else goto L8
L8:
    r26 = [r22]
    r27 = load_address r26
    r28 = _PyObject_Vectorcall(r25, r27, 1, 0)
    dec_ref r25
    if is_error(r28) goto L17 (error at is_0x_prefixed:151) else goto L9
L9:
    dec_ref r22
    CPy_Raise(r28)
    dec_ref r28
    if not 0 goto L14 (error at is_0x_prefixed:151) else goto L10 :: bool
L10:
    unreachable
L11:
    r29 = '0x'
    r30 = '0X'
    inc_ref r29
    inc_ref r30
    r31 = (r29, r30)
    r32 = 'startswith'
    r33 = box(tuple[str, str], r31)
    r34 = [value, r33]
    r35 = load_address r34
    r36 = PyObject_VectorcallMethod(r32, r35, 9223372036854775810, 0)
    if is_error(r36) goto L18 (error at is_0x_prefixed:152) else goto L12
L12:
    dec_ref r33
    r37 = unbox(bool, r36)
    dec_ref r36
    if is_error(r37) goto L14 (error at is_0x_prefixed:152) else goto L13
L13:
    return r37
L14:
    r38 = <error> :: bool
    return r38
L15:
    dec_ref r12
    goto L14
L16:
    dec_ref r17
    goto L14
L17:
    dec_ref r22
    goto L14
L18:
    dec_ref r33
    goto L14

def remove_0x_prefix(value):
    value :: object
    r0 :: str
    r1 :: bool
    r2, r3, r4, r5, r6, r7 :: object
L0:
    inc_ref value
    r0 = cast(str, value)
    if is_error(r0) goto L7 (error at remove_0x_prefix:157) else goto L1
L1:
    r1 = is_0x_prefixed(r0)
    dec_ref r0
    if is_error(r1) goto L7 (error at remove_0x_prefix:157) else goto L2
L2:
    if r1 goto L3 else goto L6 :: bool
L3:
    r2 = load_address _Py_NoneStruct
    r3 = load_address _Py_NoneStruct
    r4 = object 2
    r5 = PySlice_New(r4, r2, r3)
    if is_error(r5) goto L7 (error at remove_0x_prefix:158) else goto L4
L4:
    r6 = PyObject_GetItem(value, r5)
    dec_ref r5
    if is_error(r6) goto L7 (error at remove_0x_prefix:158) else goto L5
L5:
    return r6
L6:
    inc_ref value
    return value
L7:
    r7 = <error> :: object
    return r7

def add_0x_prefix(value):
    value :: object
    r0 :: str
    r1 :: bool
    r2, r3, r4 :: str
    r5 :: object
L0:
    inc_ref value
    r0 = cast(str, value)
    if is_error(r0) goto L7 (error at add_0x_prefix:164) else goto L1
L1:
    r1 = is_0x_prefixed(r0)
    dec_ref r0
    if is_error(r1) goto L7 (error at add_0x_prefix:164) else goto L2
L2:
    if r1 goto L3 else goto L4 :: bool
L3:
    inc_ref value
    return value
L4:
    r2 = '0x'
    r3 = PyObject_Str(value)
    if is_error(r3) goto L7 (error at add_0x_prefix:166) else goto L5
L5:
    r4 = CPyStr_Build(2, r2, r3)
    dec_ref r3
    if is_error(r4) goto L7 (error at add_0x_prefix:166) else goto L6
L6:
    return r4
L7:
    r5 = <error> :: object
    return r5

def __top_level__():
    r0, r1 :: object
    r2 :: bit
    r3 :: str
    r4 :: object
    r5 :: object_ptr
    r6 :: object_ptr[1]
    r7 :: c_ptr
    r8 :: native_int[1]
    r9 :: c_ptr
    r10 :: object
    r11 :: dict
    r12, r13 :: str
    r14 :: bit
    r15 :: object
    r16 :: str
    r17 :: dict
    r18, r19 :: object
    r20 :: str
    r21 :: dict
    r22, r23 :: object
    r24 :: str
    r25 :: object
    r26 :: dict
    r27 :: str
    r28 :: i32
    r29 :: bit
    r30 :: object
    r31 :: str
    r32 :: object
    r33 :: dict
    r34 :: str
    r35 :: i32
    r36 :: bit
    r37 :: None
L0:
    r0 = builtins :: module
    r1 = load_address _Py_NoneStruct
    r2 = r0 != r1
    if r2 goto L3 else goto L1 :: bool
L1:
    r3 = 'builtins'
    r4 = PyImport_Import(r3)
    if is_error(r4) goto L11 (error at <module>:-1) else goto L2
L2:
    builtins = r4 :: module
    dec_ref r4
L3:
    r5 = load_address binascii :: module
    r6 = [r5]
    r7 = load_address r6
    r8 = [8]
    r9 = load_address r8
    r10 = (('binascii', 'binascii', 'binascii'),)
    r11 = dank_mids._eth_utils.globals :: static
    r12 = 'dank_mids\\_eth_utils.py'
    r13 = '<module>'
    r14 = CPyImport_ImportMany(r10, r7, r11, r12, r13, r9)
    if not r14 goto L11 else goto L4 :: bool
L4:
    r15 = ('Any', 'AnyStr', 'Final', 'Optional')
    r16 = 'typing'
    r17 = dank_mids._eth_utils.globals :: static
    r18 = CPyImport_ImportFromMany(r16, r15, r15, r17)
    if is_error(r18) goto L11 (error at <module>:9) else goto L5
L5:
    typing = r18 :: module
    dec_ref r18
    r19 = ('HexStr',)
    r20 = 'eth_typing'
    r21 = dank_mids._eth_utils.globals :: static
    r22 = CPyImport_ImportFromMany(r20, r19, r19, r21)
    if is_error(r22) goto L11 (error at <module>:11) else goto L6
L6:
    eth_typing = r22 :: module
    dec_ref r22
    r23 = binascii :: module
    r24 = 'hexlify'
    r25 = CPyObject_GetAttr(r23, r24)
    if is_error(r25) goto L11 (error at <module>:14) else goto L7
L7:
    dank_mids._eth_utils.hexlify = r25 :: static
    r26 = dank_mids._eth_utils.globals :: static
    r27 = 'hexlify'
    r28 = CPyDict_SetItem(r26, r27, r25)
    dec_ref r25
    r29 = r28 >= 0 :: signed
    if not r29 goto L11 (error at <module>:14) else goto L8 :: bool
L8:
    r30 = binascii :: module
    r31 = 'unhexlify'
    r32 = CPyObject_GetAttr(r30, r31)
    if is_error(r32) goto L11 (error at <module>:15) else goto L9
L9:
    dank_mids._eth_utils.unhexlify = r32 :: static
    r33 = dank_mids._eth_utils.globals :: static
    r34 = 'unhexlify'
    r35 = CPyDict_SetItem(r33, r34, r32)
    dec_ref r32
    r36 = r35 >= 0 :: signed
    if not r36 goto L11 (error at <module>:15) else goto L10 :: bool
L10:
    return 1
L11:
    r37 = <error> :: None
    return r37
